<!DOCTYPE html>
<html>
<head>
  <meta name="baidu-site-verification" content="cns0EghbIQ" />
  <meta charset="utf-8">
  
  <title>设计模式 | 学海无涯</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言设计模式简介设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。  设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码">
<meta name="keywords" content="Singleton Pattern,Factory Pattern,Proxy Pattern,MVC Pattern,Intercepting Filter Pattern,Iterator Pattern">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="https://jet-han.gitee.io/2017/08/08/设计模式/index.html">
<meta property="og:site_name" content="学海无涯">
<meta property="og:description" content="前言设计模式简介设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。  设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/java.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/design-patterns.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/factory_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/abstractfactory_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/singleton_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/builder_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/prototype_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/adapter_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/bridge_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/filter_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/composite_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/decorator_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/facade_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/flyweight_pattern_uml_diagram-1.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/proxy_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/chain_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/command_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/interpreter_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/iterator_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/mediator_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/memento_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/observer_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/state_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/null_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/strategy_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/template_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/visitor_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/mvc_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/business_delegate_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/compositeentity_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/dao_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/frontcontroller_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/interceptingfilter_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/servicelocator_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/transferobject_pattern_uml_diagram.jpg">
<meta property="og:updated_time" content="2017-08-08T06:34:34.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="设计模式">
<meta name="twitter:description" content="前言设计模式简介设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。  设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码">
<meta name="twitter:image" content="https://jet-han.gitee.io/2017/08/08/设计模式/java.jpg">
  
    <link rel="alternative" href="/atom.xml" title="学海无涯" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
if ((!window.location.host.startsWith("localhost")) && (!window.location.host.startsWith("192.168.40")) && (window.location.protocol != "https:"))
        window.location = window.location.toString().replace(/^http:/, "https:");
  </script>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script src="https://cdn.jsdelivr.net/npm/echarts@4.7.0/dist/echarts.common.min.js"></script>
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay">
<a href="https://github.com/jethan/blog" style="cursor: hand;z-index: 9999999!important" rel="external nofollow noopener noreferrer" target="_blank">
         <img style="position: absolute; top: 0; border: 0; transform: rotate(-90deg);" src="https://jet-han.gitee.io/img/icons/fork.png"
         alt="Fork me on GitHub">
</a>
</div>
<div class="intrude-less">
    <header id="header" class="inner">  
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/ali.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/" title="Hi Mate">Jet</a></h1>
        </hgroup>

        
        <p class="header-subtitle">技术博客</p>
        
        
        
        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=225 height=86 src="//music.163.com/outchain/player?type=2&id=482792397&auto=0&height=66"></iframe>
        

        
            <form>
                <input type="text" class="st-default-search-input search" id="search" placeholder=" Search...">
            </form>
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">首页</a></li>
                        
                            <li><a href="/archives">归档</a></li>
                        
                            <li><a href="/photos">相册</a></li>
                        
                            <li><a href="http://markdown.xiaoshujiang.com/">编辑器</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl github" target="_blank" href="https://github.com/jethan" title="github">github</a>
                            
                                <a class="fl zhihu" target="_blank" href="https://www.zhihu.com/people/jet-77-36" title="zhihu">zhihu</a>
                            
                                <a class="fl weibo" target="_blank" href="http://weibo.com/2146269010/profile?topnav=1&wvr=6&is_all=1" title="weibo">weibo</a>
                            
                                <a class="fl oschina" target="_blank" href="http://git.oschina.net/jet-han" title="oschina">oschina</a>
                            
                                <a class="fl twitter" target="_blank" href="https://twitter.com/fajie_han" title="twitter">twitter</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/" style="font-size: 20px;">==</a> <a href="/tags/AOF/" style="font-size: 10px;">AOF</a> <a href="/tags/AOP/" style="font-size: 10px;">AOP</a> <a href="/tags/ArrayList/" style="font-size: 10px;">ArrayList</a> <a href="/tags/Arrays/" style="font-size: 10px;">Arrays</a> <a href="/tags/B-Tree索引/" style="font-size: 10px;">B-Tree索引</a> <a href="/tags/Bean的作用域/" style="font-size: 10px;">Bean的作用域</a> <a href="/tags/Bean的生命周期/" style="font-size: 10px;">Bean的生命周期</a> <a href="/tags/Collection/" style="font-size: 10px;">Collection</a> <a href="/tags/Collections/" style="font-size: 10px;">Collections</a> <a href="/tags/CountDownLatch/" style="font-size: 10px;">CountDownLatch</a> <a href="/tags/CyclicBarrier/" style="font-size: 10px;">CyclicBarrier</a> <a href="/tags/Factory-Pattern/" style="font-size: 10px;">Factory Pattern</a> <a href="/tags/Generics/" style="font-size: 10px;">Generics</a> <a href="/tags/HEAP/" style="font-size: 10px;">HEAP</a> <a href="/tags/HashMap/" style="font-size: 10px;">HashMap</a> <a href="/tags/HashSet/" style="font-size: 10px;">HashSet</a> <a href="/tags/HashTable/" style="font-size: 10px;">HashTable</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/IOC/" style="font-size: 10px;">IOC</a> <a href="/tags/ISAM/" style="font-size: 10px;">ISAM</a> <a href="/tags/Innodb/" style="font-size: 10px;">Innodb</a> <a href="/tags/Intercepting-Filter-Pattern/" style="font-size: 10px;">Intercepting Filter Pattern</a> <a href="/tags/Iterator-Pattern/" style="font-size: 10px;">Iterator Pattern</a> <a href="/tags/LinkedHashMap/" style="font-size: 10px;">LinkedHashMap</a> <a href="/tags/LinkedList/" style="font-size: 10px;">LinkedList</a> <a href="/tags/MVC-Pattern/" style="font-size: 10px;">MVC Pattern</a> <a href="/tags/Map/" style="font-size: 10px;">Map</a> <a href="/tags/MapperScannerConfigurer/" style="font-size: 10px;">MapperScannerConfigurer</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/MyIsam/" style="font-size: 10px;">MyIsam</a> <a href="/tags/Proxy-Pattern/" style="font-size: 10px;">Proxy Pattern</a> <a href="/tags/RDB/" style="font-size: 10px;">RDB</a> <a href="/tags/ReentrantLock/" style="font-size: 10px;">ReentrantLock</a> <a href="/tags/Semaphore/" style="font-size: 10px;">Semaphore</a> <a href="/tags/Singleton-Pattern/" style="font-size: 10px;">Singleton Pattern</a> <a href="/tags/String/" style="font-size: 10px;">String</a> <a href="/tags/StringBuffer/" style="font-size: 10px;">StringBuffer</a> <a href="/tags/StringBuilder/" style="font-size: 10px;">StringBuilder</a> <a href="/tags/ThreadPoolExecutor/" style="font-size: 10px;">ThreadPoolExecutor</a> <a href="/tags/TreeMap/" style="font-size: 10px;">TreeMap</a> <a href="/tags/TreeSet/" style="font-size: 10px;">TreeSet</a> <a href="/tags/Vector/" style="font-size: 10px;">Vector</a> <a href="/tags/WeakHashMap/" style="font-size: 10px;">WeakHashMap</a> <a href="/tags/Wildcard/" style="font-size: 10px;">Wildcard</a> <a href="/tags/ambari/" style="font-size: 10px;">ambari</a> <a href="/tags/await/" style="font-size: 10px;">await</a> <a href="/tags/binlog/" style="font-size: 10px;">binlog</a> <a href="/tags/crontab/" style="font-size: 10px;">crontab</a> <a href="/tags/equals/" style="font-size: 20px;">equals</a> <a href="/tags/explain/" style="font-size: 10px;">explain</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/hashCode/" style="font-size: 10px;">hashCode</a> <a href="/tags/hashmap/" style="font-size: 10px;">hashmap</a> <a href="/tags/index/" style="font-size: 10px;">index</a> <a href="/tags/jdk8/" style="font-size: 10px;">jdk8</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/my-cnf配置详解/" style="font-size: 10px;">my.cnf配置详解</a> <a href="/tags/mysqldump/" style="font-size: 10px;">mysqldump</a> <a href="/tags/mysqldumpslow/" style="font-size: 10px;">mysqldumpslow</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/nosql/" style="font-size: 10px;">nosql</a> <a href="/tags/notify/" style="font-size: 10px;">notify</a> <a href="/tags/notifyAll/" style="font-size: 10px;">notifyAll</a> <a href="/tags/quartz/" style="font-size: 10px;">quartz</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/runnable/" style="font-size: 10px;">runnable</a> <a href="/tags/signal/" style="font-size: 10px;">signal</a> <a href="/tags/signalAll/" style="font-size: 10px;">signalAll</a> <a href="/tags/solr/" style="font-size: 10px;">solr</a> <a href="/tags/sort/" style="font-size: 10px;">sort</a> <a href="/tags/spring单例模式/" style="font-size: 10px;">spring单例模式</a> <a href="/tags/spring线程安全/" style="font-size: 10px;">spring线程安全</a> <a href="/tags/string/" style="font-size: 10px;">string</a> <a href="/tags/synchronized/" style="font-size: 10px;">synchronized</a> <a href="/tags/thread/" style="font-size: 10px;">thread</a> <a href="/tags/volatile/" style="font-size: 10px;">volatile</a> <a href="/tags/vpn/" style="font-size: 10px;">vpn</a> <a href="/tags/wait/" style="font-size: 10px;">wait</a> <a href="/tags/web-xml加载顺序/" style="font-size: 10px;">web.xml加载顺序</a> <a href="/tags/主从/" style="font-size: 10px;">主从</a> <a href="/tags/主从备份/" style="font-size: 10px;">主从备份</a> <a href="/tags/乐观锁/" style="font-size: 10px;">乐观锁</a> <a href="/tags/事务传播属性/" style="font-size: 10px;">事务传播属性</a> <a href="/tags/事务隔离级别/" style="font-size: 10px;">事务隔离级别</a> <a href="/tags/二分/" style="font-size: 10px;">二分</a> <a href="/tags/冒泡/" style="font-size: 10px;">冒泡</a> <a href="/tags/堆/" style="font-size: 10px;">堆</a> <a href="/tags/容器/" style="font-size: 10px;">容器</a> <a href="/tags/希尔/" style="font-size: 10px;">希尔</a> <a href="/tags/常量池/" style="font-size: 10px;">常量池</a> <a href="/tags/快速/" style="font-size: 10px;">快速</a> <a href="/tags/性能调优/" style="font-size: 10px;">性能调优</a> <a href="/tags/悲观锁/" style="font-size: 10px;">悲观锁</a> <a href="/tags/持久化/" style="font-size: 10px;">持久化</a> <a href="/tags/插入/" style="font-size: 10px;">插入</a> <a href="/tags/方法区/" style="font-size: 10px;">方法区</a> <a href="/tags/本地方法栈/" style="font-size: 10px;">本地方法栈</a> <a href="/tags/泛型/" style="font-size: 10px;">泛型</a> <a href="/tags/程序计数器/" style="font-size: 10px;">程序计数器</a> <a href="/tags/线程池/" style="font-size: 10px;">线程池</a> <a href="/tags/虚拟机栈/" style="font-size: 10px;">虚拟机栈</a> <a href="/tags/语句执行/" style="font-size: 10px;">语句执行</a> <a href="/tags/迭代/" style="font-size: 10px;">迭代</a> <a href="/tags/选择/" style="font-size: 10px;">选择</a> <a href="/tags/递归/" style="font-size: 10px;">递归</a> <a href="/tags/隔离级别/" style="font-size: 10px;">隔离级别</a> <a href="/tags/面试技巧/" style="font-size: 10px;">面试技巧</a> <a href="/tags/面试题/" style="font-size: 10px;">面试题</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://jethan.bid/">学海无涯</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">纯海迷、爱运动、爱交友、爱旅行、喜欢接触新鲜事物、迎接新的挑战，更爱游离于错综复杂的编码与逻辑中</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">Jet</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/ali.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">Jet</a></h1>
            </hgroup>
            
            <p class="header-subtitle">技术博客</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">首页</a></li>
                
                    <li><a href="/archives">归档</a></li>
                
                    <li><a href="/photos">相册</a></li>
                
                    <li><a href="http://markdown.xiaoshujiang.com/">编辑器</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="github" target="_blank" href="https://github.com/jethan" title="github">github</a>
                    
                        <a class="zhihu" target="_blank" href="https://www.zhihu.com/people/jet-77-36" title="zhihu">zhihu</a>
                    
                        <a class="weibo" target="_blank" href="http://weibo.com/2146269010/profile?topnav=1&wvr=6&is_all=1" title="weibo">weibo</a>
                    
                        <a class="oschina" target="_blank" href="http://git.oschina.net/jet-han" title="oschina">oschina</a>
                    
                        <a class="twitter" target="_blank" href="https://twitter.com/fajie_han" title="twitter">twitter</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-设计模式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/08/08/设计模式/" class="article-date">
      <time datetime="2017-08-08T06:34:34.000Z" itemprop="datePublished">2017-08-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      设计模式
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/java/">java</a><a class="article-category-link" href="/categories/java/设计模式/">设计模式</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Factory-Pattern/">Factory Pattern</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Intercepting-Filter-Pattern/">Intercepting Filter Pattern</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Iterator-Pattern/">Iterator Pattern</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MVC-Pattern/">MVC Pattern</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Proxy-Pattern/">Proxy Pattern</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Singleton-Pattern/">Singleton Pattern</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><img src="/2017/08/08/设计模式/java.jpg" alt="java" title="java"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>设计模式简介</strong><br>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 </p>
<p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。<br><a id="more"></a><br><strong>什么是 GOF（四人帮，全拼 Gang of Four）？</strong><br>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。<br>四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。<br>对接口编程而不是对实现编程。<br>优先使用对象组合而不是继承。<br><strong>设计模式的使用</strong><br>设计模式在软件开发中的两个主要用途。<br><strong>开发人员的共同平台</strong><br>设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。<br><strong>最佳的实践</strong><br>设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。<br><strong>设计模式的类型</strong><br>根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th>模式&amp;描述</th>
<th>包含</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td><strong>创建型模式</strong><br>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑<br>的方式，而不是使用 new 运算符直接实例化对象。这<br>使得程序在判断针对某个给定实例需要创建哪些对象时<br>更加灵活。</td>
<td>工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td><strong>结构型模式</strong><br>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td>
<td>适配器模式（Adapter Pattern）<br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td><strong>行为型模式</strong><br>这些设计模式特别关注对象之间的通信。</td>
<td>责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td><strong>J2EE 模式</strong><br>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</td>
<td>MVC 模式（MVC Pattern）<br>业务代表模式（Business Delegate Pattern）<br>组合实体模式（Composite Entity Pattern）<br>数据访问对象模式（Data Access Object Pattern）<br>前端控制器模式（Front Controller Pattern）<br>拦截过滤器模式（Intercepting Filter Pattern）<br>服务定位器模式（Service Locator Pattern）<br>传输对象模式（Transfer Object Pattern）</td>
</tr>
</tbody>
</table>
</div>
<p>下面用一个图片来整体描述一下设计模式之间的关系：<br><img src="/2017/08/08/设计模式/design-patterns.jpg" alt="design-patterns" title="design-patterns"></p>
<p><strong>设计模式的六大原则</strong>  </p>
<ol>
<li><strong>开闭原则（Open Close Principle）</strong><br>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。  </li>
<li><strong>里氏代换原则（Liskov Substitution Principle）</strong><br>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。  </li>
<li><strong>依赖倒转原则（Dependence Inversion Principle）</strong><br>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。  </li>
<li><strong>接口隔离原则（Interface Segregation Principle）</strong><br>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。  </li>
<li><strong>迪米特法则，又称最少知道原则（Demeter Principle）</strong><br>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</li>
<li><strong>合成复用原则（Composite Reuse Principle）</strong><br>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</li>
</ol>
<h2 id="java常用设计模式"><a href="#java常用设计模式" class="headerlink" title="java常用设计模式"></a>java常用设计模式</h2><p>通俗一点讲就是：<br>一个程序员对设计模式的理解:<br>“不懂”为什么要把很简单的东西搞得那么复杂。后来随着软件开发经验的增加才开始明白我所看到的“复杂”恰恰就是设计模式的精髓所在，我所理解的“简单”就是一把钥匙开一把锁的模式，目的仅仅是着眼于解决现在的问题，而设计模式的“复杂”就在于它是要构造一个“万能钥匙”，目的是提出一种对所有锁的开锁方案。在真正理解设计模式之前我一直在编写“简单”的代码.<br>这个“简单”不是功能的简单，而是设计的简单。简单的设计意味着缺少灵活性，代码很钢硬，只在这个项目里有用，拿到其它的项目中就是垃圾，我将其称之为“一次性代码”。</p>
<p>要使代码可被反复使用,请用’设计模式’对你的代码进行设计。 </p>
<p>很多我所认识的程序员在接触到设计模式之后，都有一种相见恨晚的感觉，有人形容学习了设计模式之后感觉自己好像已经脱胎换骨，达到了新的境界，还有人甚至把是否了解设计模式作为程序员划分水平的标准。<br>我们也不能陷入模式的陷阱，为了使用模式而去套模式，那样会陷入形式主义。我们在使用模式的时候，一定要注意模式的意图（intent），而不要过多的去关注模式的实现细节，因为这些实现细节在特定情况下，可能会发生一些改变。不要顽固地认为设计模式一书中的类图或实现代码就代表了模式本身。  </p>
<p>设计原则：(重要)</p>
<ol>
<li>逻辑代码独立到单独的方法中，注重封装性—易读，易复用。<br>不要在一个方法中，写下上百行的逻辑代码。把各小逻辑代码独立出来，写于其它方法中，易读其可重复调用。</li>
<li>写类，写方法，写功能时，应考虑其移植性，复用性：防止一次性代码！<br>是否可以拿到其它同类事物中应该？是否可以拿到其它系统中应该？</li>
<li>熟练运用继承的思想：<br>找出应用中相同之处，且不容易发生变化的东西，把它们抽取到抽象类中，让子类去继承它们；<br>继承的思想，也方便将自己的逻辑建立于别人的成果之上。如ImageField extends JTextField；<br>熟练运用接口的思想：<br>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li>
</ol>
<p><strong>把很简单的东西搞得那么复杂，一次性代码，设计模式优势的实例说明：（策略模式）</strong><br>说明：<br>模拟鸭子游戏的应用程序，要求：游戏中会出现各种颜色外形的鸭子，一边游泳戏水，一边呱呱叫。<br><strong>1、 一次性代码 </strong><br>直接编写出各种鸭子的类：MallardDuck//野鸭，RedheadDuck//红头鸭，各类有三个方法：<br>quack()：叫的方法<br>swim()：游水的方法<br>display()：外形的方法<br><strong>2、运用继承的特性，将其中共同的部分提升出来，避免重复编程。</strong><br>即：设计一个鸭子的超类（Superclass）,并让各种鸭子继承这个超类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Duck&#123;</div><div class="line">     public void quack()&#123;  //呱呱叫</div><div class="line">              System.out.println(&quot;呱呱叫&quot;);</div><div class="line">      &#125;</div><div class="line">     public void swim()&#123;   //游泳</div><div class="line">            System.out.println(&quot; 游泳&quot;);</div><div class="line">      &#125;    </div><div class="line">     public  abstratact void display(); /*因为外观不一样，让子类自己去决定了。*/</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于它的子类只需简单的继承就可以了，并实现自己的display()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//野鸭</div><div class="line"> public class MallardDuck extends Duck&#123;</div><div class="line">     public void display()&#123;</div><div class="line">          System.out.println(&quot;野鸭的颜色...&quot;);</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line">//红头鸭</div><div class="line"> public class RedheadDuck extends Duck&#123;</div><div class="line">     public void display()&#123;</div><div class="line">          System.out.println(&quot;红头鸭的颜色...&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不幸的是，现在客户又提出了新的需求，想让鸭子飞起来。这个对于我们OO程序员，在简单不过了，在超类中在加一个方法就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Duck&#123;</div><div class="line">   public void quack()&#123;  //呱呱叫</div><div class="line">      System.out.println(&quot;呱呱叫&quot;);</div><div class="line">     &#125;</div><div class="line">   public void swim()&#123;   //游泳</div><div class="line">      System.out.println(&quot; 游泳&quot;);</div><div class="line">   &#125;    </div><div class="line">   public  abstract void display(); /*因为外观不一样，让子类自己去决定了。*/</div><div class="line">   public void fly()&#123;</div><div class="line">      System.out.println(&quot;飞吧！鸭子&quot;); </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于不能飞的鸭子，在子类中只需简单的覆盖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//残废鸭</div><div class="line"> public class DisabledDuck extends Duck&#123;</div><div class="line">    public void display()&#123;</div><div class="line">       System.out.println(&quot;残废鸭的颜色...&quot;);</div><div class="line">   &#125;</div><div class="line">   public void fly()&#123;</div><div class="line">    //覆盖，变成什么事都不做。 </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其它会飞的鸭子不用覆盖。<br>这样所有的继承这个超类的鸭子都会fly了。但是问题又出来了，客户又提出有的鸭子会飞，有的不能飞。</p>
<p><strong>对于上面的设计，你可能发现一些弊端，如果超类有新的特性，子类都必须变动，这是我们开发最不喜欢看到的，一个类变让另一个类也跟着变，这有点不符合OO设计了。这样很显然的耦合了一起。利用继承—&gt;耦合度太高了.</strong></p>
<p><strong>3、用接口改进</strong><br>我们把容易引起变化的部分提取出来并封装之，来应付以后的变法。虽然代码量加大了，但可用性提高了，耦合度也降低了。<br>我们把Duck中的fly方法和quack提取出来。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> public interface Flyable&#123;</div><div class="line">    public void fly(); </div><div class="line">&#125;</div><div class="line"> public interface Quackable&#123;</div><div class="line">   public void quack();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  最后Duck的设计成为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class Duck&#123;</div><div class="line">     public void swim()&#123;   //游泳</div><div class="line">            System.out.println(&quot; 游泳&quot;);</div><div class="line">    &#125;    </div><div class="line">    public  abstract void display(); /*因为外观不一样，让子类自 己去决定了。*/</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 而MallardDuck,RedheadDuck,DisabledDuck 就可以写成为：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">//野鸭</div><div class="line"> public class MallardDuck extends Duck implements Flyable,Quackable&#123;</div><div class="line">     public void display()&#123;</div><div class="line">          System.out.println(&quot;野鸭的颜色...&quot;);</div><div class="line">   &#125;</div><div class="line">   public void fly()&#123;</div><div class="line">    //实现该方法</div><div class="line">  &#125;</div><div class="line">   public void quack()&#123;</div><div class="line">    //实现该方法</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line">//红头鸭</div><div class="line"> public class RedheadDuck extends Duck implements Flyable,Quackable&#123;</div><div class="line">     public void display()&#123;</div><div class="line">          System.out.println(&quot;红头鸭的颜色...&quot;);</div><div class="line">   &#125;</div><div class="line">   public void fly()&#123;</div><div class="line">    //实现该方法</div><div class="line">  &#125;</div><div class="line">   public void quack()&#123;</div><div class="line">    //实现该方法</div><div class="line">  &#125;</div><div class="line">&#125; </div><div class="line">//残废鸭 只实现Quackable（能叫不能飞）</div><div class="line"> public class DisabledDuck extends Duck implements Quackable&#123;</div><div class="line">     public void display()&#123;</div><div class="line">          System.out.println(&quot;残废鸭的颜色...&quot;);</div><div class="line">   &#125;</div><div class="line">   public void quack()&#123;</div><div class="line">    //实现该方法</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好处:<br>这样已设计，我们的程序就降低了它们之间的耦合。<br>不足:<br>Flyable和 Quackable接口一开始似乎还挺不错的，解决了问题（只有会飞到鸭子才实现 Flyable），但是Java接口不具有实现代码，所以<strong>实现接口无法达到代码的复用</strong>。</p>
<p><strong>继承的好处:</strong>让共同部分,可以复用.避免重复编程.<br><strong>继承的不好:</strong>耦合性高.一旦超类添加一个新方法,子类都继承,拥有此方法,若子类相当部分不实现此方法,则要进行大批量修改.继承时,子类就不可继承其它类了.<br><strong>接口的好处:</strong>解决了继承耦合性高的问题,且可让实现类,继承或实现其它类或接口.<br><strong>接口的不好:</strong>不能真正实现代码的复用.可用以下的策略模式来解决.</p>
<h2 id="strategy-策略模式"><a href="#strategy-策略模式" class="headerlink" title="strategy(策略模式)"></a>strategy(策略模式)</h2><p>我们有一个设计原则：<br>找出应用中相同之处，且不容易发生变化的东西，把它们抽取到抽象类中，让子类去继承它们；<br>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。   </p>
<p>现在，为了要分开“变化和不变化的部分”，我们准备建立两组类（完全远离Duck类），一个是”fly”相关的，另一个是“quack”相关的，每一组类将实现各自的动作。比方说，我们可能有一个类实现“呱呱叫”，另一个类实现“吱吱叫”，还有一个类实现“安静”。<br>首先写两个接口。<br>FlyBehavior(飞行行为)和QuackBehavior（叫的行为）.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public interface FlyBehavior&#123;</div><div class="line">   public void fly();     </div><div class="line">&#125;</div><div class="line">public interface QuackBehavior&#123;</div><div class="line">   public void quack();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在定义一些针对FlyBehavior的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class FlyWithWings implements FlyBehavior&#123;</div><div class="line">   public void  fly()&#123;</div><div class="line">     //实现了所有有翅膀的鸭子飞行行为。</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line">public class FlyNoWay implements FlyBehavior&#123;</div><div class="line">   public void  fly()&#123;</div><div class="line">      //什么都不做，不会飞</div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>针对QuackBehavior的几种具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Quack implements QuackBehavior&#123;</div><div class="line">   public void quack()&#123;</div><div class="line">      //实现呱呱叫的鸭子</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public class Squeak implements QuackBehavior&#123;</div><div class="line">   public void quack()&#123;</div><div class="line">      //实现吱吱叫的鸭子 </div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public class MuteQuack implements QuackBehavior&#123;</div><div class="line">   public void quack()&#123;</div><div class="line">      //什么都不做，不会叫</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>点评一:<br>这样的设计，可以让飞行和呱呱叫的动作被其他的对象复用，因为这些行为已经与鸭子类无关了。而我们增加一些新的行为，不会影响到既有的行为类，也不会影响“使用”到飞行行为的鸭子类。<br>最后我们看看Duck 如何设计。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Duck&#123;        ---------&gt;在抽象类中,声明各接口,定义各接口对应的方法.</div><div class="line">   FlyBehavior flyBehavior;//接口</div><div class="line">   QuackBehavior quackBehavior;//接口</div><div class="line">   public Duck()&#123;&#125;</div><div class="line">   public abstract void display();</div><div class="line">   public void swim()&#123;</div><div class="line">     //实现游泳的行为</div><div class="line">   &#125;</div><div class="line">   public void performFly()&#123;</div><div class="line">      flyBehavior.fly();  --&gt;由于是接口,会根据继承类实现的方式,而调用相应的方法.</div><div class="line">   &#125;</div><div class="line">   public void performQuack()&#123;</div><div class="line">      quackBehavior.quack();();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看看MallardDuck如何实现<br>通过构造方法,生成’飞’,’叫’具体实现类的实例,从而指定’飞’,’叫’的具体属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class MallardDuck extends Duck&#123;</div><div class="line">   public MallardDuck &#123;       </div><div class="line">      flyBehavior = new FlyWithWings ();</div><div class="line">      quackBehavior = new Quack(); </div><div class="line">     //因为MallardDuck 继承了Duck，所有具有flyBehavior 与quackBehavior 实例变量</div><div class="line">  &#125;</div><div class="line">   public void display()&#123;</div><div class="line">    //实现</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就满足了即可以飞，又可以叫，同时展现自己的颜色了。<br>这样的设计我们可以看到是把flyBehavior ，quackBehavior 的实例化写在子类了。我们还可以动态的来决定。<br>我们只需在Duck中加上两个方法。</p>
<p>在构造方法中对属性进行赋值与用属性的setter的区别：<br><strong>构造方法中对属性进行赋值：固定，不可变；<br>用属性的setter，可以在实例化对象后，动态的变化，比较灵活。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Duck&#123;</div><div class="line">   FlyBehavior flyBehavior;//接口</div><div class="line">   QuackBehavior quackBehavior;//接口</div><div class="line">   public void setFlyBehavior(FlyBehavior flyBehavior)&#123;</div><div class="line">      this.flyBehavior = flyBehavior;</div><div class="line">   &#125;</div><div class="line">   public void setQuackBehavior(QuackBehavior quackBehavior  &#123;</div><div class="line">      this.quackBehavior= quackBehavior;</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。<br><strong>意图：</strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。<br><strong>主要解决：</strong>主要解决接口选择的问题。<br><strong>何时使用：</strong>我们明确地计划不同条件下创建不同实例时。<br><strong>如何解决：</strong>让其子类实现工厂接口，返回的也是一个抽象的产品。<br><strong>关键代码：</strong>创建过程在其子类执行。<br><strong>应用实例：</strong> 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。<br><strong>优点：</strong> 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。<br><strong>缺点：</strong>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。<br><strong>注意事项：</strong>作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。<br><strong>实现</strong><br>我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。<br>FactoryPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。<br><img src="/2017/08/08/设计模式/factory_pattern_uml_diagram.jpg" alt="factory_pattern" title="factory_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口:</p>
<p>Shape.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Shape &#123;</div><div class="line">   void draw();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类:  </p>
<p>Rectangle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Rectangle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Square.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Square implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Square::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Circle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Circle::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建一个工厂，生成基于给定信息的实体类的对象:</p>
<p>ShapeFactory.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class ShapeFactory &#123;</div><div class="line">	</div><div class="line">   //使用 getShape 方法获取形状类型的对象</div><div class="line">   public Shape getShape(String shapeType)&#123;</div><div class="line">      if(shapeType == null)&#123;</div><div class="line">         return null;</div><div class="line">      &#125;		</div><div class="line">      if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123;</div><div class="line">         return new Circle();</div><div class="line">      &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123;</div><div class="line">         return new Rectangle();</div><div class="line">      &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123;</div><div class="line">         return new Square();</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用该工厂，通过传递类型信息来获取实体类的对象:</p>
<p>FactoryPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class FactoryPatternDemo &#123;</div><div class="line"></div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      ShapeFactory shapeFactory = new ShapeFactory();</div><div class="line"></div><div class="line">      //获取 Circle 的对象，并调用它的 draw 方法</div><div class="line">      Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);</div><div class="line"></div><div class="line">      //调用 Circle 的 draw 方法</div><div class="line">      shape1.draw();</div><div class="line"></div><div class="line">      //获取 Rectangle 的对象，并调用它的 draw 方法</div><div class="line">      Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);</div><div class="line"></div><div class="line">      //调用 Rectangle 的 draw 方法</div><div class="line">      shape2.draw();</div><div class="line"></div><div class="line">      //获取 Square 的对象，并调用它的 draw 方法</div><div class="line">      Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);</div><div class="line"></div><div class="line">      //调用 Square 的 draw 方法</div><div class="line">      shape3.draw();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Inside Circle::draw() method.</div><div class="line">Inside Rectangle::draw() method.</div><div class="line">Inside Square::draw() method.</div></pre></td></tr></table></figure>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。<br>介绍<br>意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br>主要解决：主要解决接口选择的问题。<br>何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。<br>如何解决：在一个产品族里面，定义多个产品。<br>关键代码：在一个工厂里聚合多个同类产品。<br>应用实例：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。<br>优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。<br>缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。<br>使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。<br>注意事项：产品族难扩展，产品等级易扩展。<br>实现<br>我们将创建 Shape 和 Color 接口和实现这些接口的实体类。下一步是创建抽象工厂类 AbstractFactory。接着定义工厂类 ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory。然后创建一个工厂创造器/生成器类 FactoryProducer。<br>AbstractFactoryPatternDemo，我们的演示类使用 FactoryProducer 来获取 AbstractFactory 对象。它将向 AbstractFactory 传递形状信息 Shape（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。同时它还向 AbstractFactory 传递颜色信息 Color（RED / GREEN / BLUE），以便获取它所需对象的类型。<br><img src="/2017/08/08/设计模式/abstractfactory_pattern_uml_diagram.jpg" alt="abstractfactory_pattern" title="abstractfactory_pattern"></p>
<p><strong>步骤 1</strong> </p>
<p>为形状创建一个接口。</p>
<p>Shape.java</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Shape &#123;</div><div class="line">   void draw();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>Rectangle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Rectangle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Square.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Square implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Square::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Circle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Circle::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>为颜色创建一个接口。</p>
<p>Color.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Color &#123;</div><div class="line">   void fill();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤4</strong> </p>
<p>创建实现接口的实体类。  </p>
<p>Red.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Red implements Color &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void fill() &#123;</div><div class="line">      System.out.println(&quot;Inside Red::fill() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Green.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Green implements Color &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void fill() &#123;</div><div class="line">      System.out.println(&quot;Inside Green::fill() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Blue.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Blue implements Color &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void fill() &#123;</div><div class="line">      System.out.println(&quot;Inside Blue::fill() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong>  </p>
<p>为 Color 和 Shape 对象创建抽象类来获取工厂。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">AbstractFactory.java</div><div class="line">public abstract class AbstractFactory &#123;</div><div class="line">   abstract Color getColor(String color);</div><div class="line">   abstract Shape getShape(String shape) ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。</p>
<p>ShapeFactory.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class ShapeFactory extends AbstractFactory &#123;</div><div class="line">	</div><div class="line">   @Override</div><div class="line">   public Shape getShape(String shapeType)&#123;</div><div class="line">      if(shapeType == null)&#123;</div><div class="line">         return null;</div><div class="line">      &#125;		</div><div class="line">      if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123;</div><div class="line">         return new Circle();</div><div class="line">      &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123;</div><div class="line">         return new Rectangle();</div><div class="line">      &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123;</div><div class="line">         return new Square();</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @Override</div><div class="line">   Color getColor(String color) &#123;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ColorFactory.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class ColorFactory extends AbstractFactory &#123;</div><div class="line">	</div><div class="line">   @Override</div><div class="line">   public Shape getShape(String shapeType)&#123;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @Override</div><div class="line">   Color getColor(String color) &#123;</div><div class="line">      if(color == null)&#123;</div><div class="line">         return null;</div><div class="line">      &#125;		</div><div class="line">      if(color.equalsIgnoreCase(&quot;RED&quot;))&#123;</div><div class="line">         return new Red();</div><div class="line">      &#125; else if(color.equalsIgnoreCase(&quot;GREEN&quot;))&#123;</div><div class="line">         return new Green();</div><div class="line">      &#125; else if(color.equalsIgnoreCase(&quot;BLUE&quot;))&#123;</div><div class="line">         return new Blue();</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 7</strong>  </p>
<p>创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。</p>
<p>FactoryProducer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class FactoryProducer &#123;</div><div class="line">   public static AbstractFactory getFactory(String choice)&#123;</div><div class="line">      if(choice.equalsIgnoreCase(&quot;SHAPE&quot;))&#123;</div><div class="line">         return new ShapeFactory();</div><div class="line">      &#125; else if(choice.equalsIgnoreCase(&quot;COLOR&quot;))&#123;</div><div class="line">         return new ColorFactory();</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 8</strong></p>
<p>使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。  </p>
<p>AbstractFactoryPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class AbstractFactoryPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      //获取形状工厂</div><div class="line">      AbstractFactory shapeFactory = FactoryProducer.getFactory(&quot;SHAPE&quot;);</div><div class="line"></div><div class="line">      //获取形状为 Circle 的对象</div><div class="line">      Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);</div><div class="line"></div><div class="line">      //调用 Circle 的 draw 方法</div><div class="line">      shape1.draw();</div><div class="line"></div><div class="line">      //获取形状为 Rectangle 的对象</div><div class="line">      Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);</div><div class="line"></div><div class="line">      //调用 Rectangle 的 draw 方法</div><div class="line">      shape2.draw();</div><div class="line">      </div><div class="line">      //获取形状为 Square 的对象</div><div class="line">      Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);</div><div class="line"></div><div class="line">      //调用 Square 的 draw 方法</div><div class="line">      shape3.draw();</div><div class="line"></div><div class="line">      //获取颜色工厂</div><div class="line">      AbstractFactory colorFactory = FactoryProducer.getFactory(&quot;COLOR&quot;);</div><div class="line"></div><div class="line">      //获取颜色为 Red 的对象</div><div class="line">      Color color1 = colorFactory.getColor(&quot;RED&quot;);</div><div class="line"></div><div class="line">      //调用 Red 的 fill 方法</div><div class="line">      color1.fill();</div><div class="line"></div><div class="line">      //获取颜色为 Green 的对象</div><div class="line">      Color color2 = colorFactory.getColor(&quot;Green&quot;);</div><div class="line"></div><div class="line">      //调用 Green 的 fill 方法</div><div class="line">      color2.fill();</div><div class="line"></div><div class="line">      //获取颜色为 Blue 的对象</div><div class="line">      Color color3 = colorFactory.getColor(&quot;BLUE&quot;);</div><div class="line"></div><div class="line">      //调用 Blue 的 fill 方法</div><div class="line">      color3.fill();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 9</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Inside Circle::draw() method.</div><div class="line">Inside Rectangle::draw() method.</div><div class="line">Inside Square::draw() method.</div><div class="line">Inside Red::fill() method.</div><div class="line">Inside Green::fill() method.</div><div class="line">Inside Blue::fill() method.</div></pre></td></tr></table></figure>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。<br>注意：<br>1、单例类只能有一个实例。<br>2、单例类必须自己创建自己的唯一实例。<br>3、单例类必须给所有其他对象提供这一实例。<br><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。<br><strong>何时使用：</strong>当您想控制实例数目，节省系统资源的时候。<br><strong>如何解决：</strong>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。<br><strong>关键代码：</strong>构造函数是私有的。<br><strong>优点： </strong>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。<br><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。<br><strong>使用场景：</strong> 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。<br><strong>注意事项：</strong>getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。<br><strong>实现</strong><br>我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。<br>SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。<br><img src="/2017/08/08/设计模式/singleton_pattern_uml_diagram.jpg" alt="singleton_pattern" title="singleton_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个 Singleton 类。</p>
<p>SingleObject.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class SingleObject &#123;</div><div class="line"></div><div class="line">   //创建 SingleObject 的一个对象</div><div class="line">   private static SingleObject instance = new SingleObject();</div><div class="line"></div><div class="line">   //让构造函数为 private，这样该类就不会被实例化</div><div class="line">   private SingleObject()&#123;&#125;</div><div class="line"></div><div class="line">   //获取唯一可用的对象</div><div class="line">   public static SingleObject getInstance()&#123;</div><div class="line">      return instance;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void showMessage()&#123;</div><div class="line">      System.out.println(&quot;Hello World!&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>从 singleton 类获取唯一的对象。</p>
<p>SingletonPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class SingletonPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      //不合法的构造函数</div><div class="line">      //编译时错误：构造函数 SingleObject() 是不可见的</div><div class="line">      //SingleObject object = new SingleObject();</div><div class="line"></div><div class="line">      //获取唯一可用的对象</div><div class="line">      SingleObject object = SingleObject.getInstance();</div><div class="line"></div><div class="line">      //显示消息</div><div class="line">      object.showMessage();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello World!</div></pre></td></tr></table></figure>
<p><strong>单例模式的几种实现方式</strong><br>单例模式的实现有多种方式，如下所示：<br><strong>1、懒汉式，线程不安全</strong><br><strong>是否 Lazy 初始化</strong>：是<br><strong>是否多线程安全：</strong>否<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。<br>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。<br><strong>代码实例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">    private static Singleton instance;  </div><div class="line">    private Singleton ()&#123;&#125;  </div><div class="line">  </div><div class="line">    public static Singleton getInstance() &#123;  </div><div class="line">    if (instance == null) &#123;  </div><div class="line">        instance = new Singleton();  </div><div class="line">    &#125;  </div><div class="line">    return instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。  </p>
<p><strong>2、懒汉式，线程安全</strong><br><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。<br><strong>优点：</strong>第一次调用才初始化，避免内存浪费。<br><strong>缺点：</strong>必须加锁 synchronized 才能保证单例，但加锁会影响效率。<br>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。<br><strong>代码实例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">    private static Singleton instance;  </div><div class="line">    private Singleton ()&#123;&#125;  </div><div class="line">    public static synchronized Singleton getInstance() &#123;  </div><div class="line">    if (instance == null) &#123;  </div><div class="line">        instance = new Singleton();  </div><div class="line">    &#125;  </div><div class="line">    return instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>3、饿汉式</strong><br><strong>是否 Lazy 初始化：</strong>否<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种方式比较常用，但容易产生垃圾对象。<br><strong>优点：</strong>没有加锁，执行效率会提高。<br><strong>缺点：</strong>类加载时就初始化，浪费内存。<br>它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。<br><strong>代码实例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">    private static Singleton instance = new Singleton();  </div><div class="line">    private Singleton ()&#123;&#125;  </div><div class="line">    public static Singleton getInstance() &#123;  </div><div class="line">    return instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>4、双检锁/双重校验锁（DCL，即 double-checked locking）</strong><br><strong>JDK 版本：</strong>JDK1.5 起<br><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>较复杂<br><strong>描述：</strong>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance() 的性能对应用程序很关键。<br><strong>代码实例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">    private volatile static Singleton singleton;  </div><div class="line">    private Singleton ()&#123;&#125;  </div><div class="line">    public static Singleton getSingleton() &#123;  </div><div class="line">    if (singleton == null) &#123;  </div><div class="line">        synchronized (Singleton.class) &#123;  </div><div class="line">        if (singleton == null) &#123;  </div><div class="line">            singleton = new Singleton();  </div><div class="line">        &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    return singleton;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>5、登记式/静态内部类</strong><br><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全</strong>：是<br><strong>实现难度：</strong>一般<br><strong>描述：</strong>这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<br>这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有显示通过调用 getInstance 方法时，才会显示装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。<br><strong>代码实例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">    private static class SingletonHolder &#123;  </div><div class="line">    private static final Singleton INSTANCE = new Singleton();  </div><div class="line">    &#125;  </div><div class="line">    private Singleton ()&#123;&#125;  </div><div class="line">    public static final Singleton getInstance() &#123;  </div><div class="line">    return SingletonHolder.INSTANCE;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>6、枚举</strong><br><strong>JDK 版本：</strong>JDK1.5 起<br><strong>是否 Lazy 初始化：</strong>否<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。<br>不能通过 reflection attack 来调用私有构造方法。<br><strong>代码实例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public enum Singleton &#123;  </div><div class="line">    INSTANCE;  </div><div class="line">    public void whateverMethod() &#123;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>经验之谈：</strong>一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。   </p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。<br>意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br><strong>主要解决：</strong>主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。<br><strong>何时使用：</strong>一些基本部件不会变，而其组合经常变化的时候。<br><strong>如何解决：</strong>将变与不变分离开。<br><strong>关键代码：</strong>建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。<br><strong>应用实例：</strong> 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。 2、JAVA 中的 StringBuilder。<br><strong>优点：</strong> 1、建造者独立，易扩展。 2、便于控制细节风险。<br><strong>缺点：</strong> 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。<br><strong>使用场景：</strong> 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。<br><strong>注意事项：</strong>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。<br><strong>实现</strong><br>我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。<br>我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。<br>然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo，我们的演示类使用 MealBuilder 来创建一个 Meal。<br><img src="/2017/08/08/设计模式/builder_pattern_uml_diagram.jpg" alt="builder_pattern" title="builder_pattern"></p>
<p><strong>步骤 1</strong>  </p>
<p>创建一个表示食物条目和食物包装的接口。</p>
<p>Item.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface Item &#123;</div><div class="line">   public String name();</div><div class="line">   public Packing packing();</div><div class="line">   public float price();	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Packing.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Packing &#123;</div><div class="line">   public String pack();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现 Packing 接口的实体类。</p>
<p>Wrapper.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Wrapper implements Packing &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String pack() &#123;</div><div class="line">      return &quot;Wrapper&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Bottle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Bottle implements Packing &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String pack() &#123;</div><div class="line">      return &quot;Bottle&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实现 Item 接口的抽象类，该类提供了默认的功能。</p>
<p>Burger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public abstract class Burger implements Item &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public Packing packing() &#123;</div><div class="line">      return new Wrapper();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public abstract float price();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ColdDrink.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public abstract class ColdDrink implements Item &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Packing packing() &#123;</div><div class="line">       return new Bottle();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public abstract float price();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建扩展了 Burger 和 ColdDrink 的实体类。</p>
<p>VegBurger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class VegBurger extends Burger &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public float price() &#123;</div><div class="line">      return 25.0f;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String name() &#123;</div><div class="line">      return &quot;Veg Burger&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ChickenBurger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class ChickenBurger extends Burger &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public float price() &#123;</div><div class="line">      return 50.5f;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String name() &#123;</div><div class="line">      return &quot;Chicken Burger&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Coke.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Coke extends ColdDrink &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public float price() &#123;</div><div class="line">      return 30.0f;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String name() &#123;</div><div class="line">      return &quot;Coke&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Pepsi.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Pepsi extends ColdDrink &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public float price() &#123;</div><div class="line">      return 35.0f;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String name() &#123;</div><div class="line">      return &quot;Pepsi&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>创建一个 Meal 类，带有上面定义的 Item 对象。</p>
<p>Meal.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class Meal &#123;</div><div class="line">   private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;();	</div><div class="line"></div><div class="line">   public void addItem(Item item)&#123;</div><div class="line">      items.add(item);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public float getCost()&#123;</div><div class="line">      float cost = 0.0f;</div><div class="line">      for (Item item : items) &#123;</div><div class="line">         cost += item.price();</div><div class="line">      &#125;		</div><div class="line">      return cost;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void showItems()&#123;</div><div class="line">      for (Item item : items) &#123;</div><div class="line">         System.out.print(&quot;Item : &quot;+item.name());</div><div class="line">         System.out.print(&quot;, Packing : &quot;+item.packing().pack());</div><div class="line">         System.out.println(&quot;, Price : &quot;+item.price());</div><div class="line">      &#125;		</div><div class="line">   &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。</p>
<p>MealBuilder.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class MealBuilder &#123;</div><div class="line"></div><div class="line">   public Meal prepareVegMeal ()&#123;</div><div class="line">      Meal meal = new Meal();</div><div class="line">      meal.addItem(new VegBurger());</div><div class="line">      meal.addItem(new Coke());</div><div class="line">      return meal;</div><div class="line">   &#125;   </div><div class="line"></div><div class="line">   public Meal prepareNonVegMeal ()&#123;</div><div class="line">      Meal meal = new Meal();</div><div class="line">      meal.addItem(new ChickenBurger());</div><div class="line">      meal.addItem(new Pepsi());</div><div class="line">      return meal;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 7</strong></p>
<p>BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern）。</p>
<p>BuilderPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class BuilderPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      MealBuilder mealBuilder = new MealBuilder();</div><div class="line"></div><div class="line">      Meal vegMeal = mealBuilder.prepareVegMeal();</div><div class="line">      System.out.println(&quot;Veg Meal&quot;);</div><div class="line">      vegMeal.showItems();</div><div class="line">      System.out.println(&quot;Total Cost: &quot; +vegMeal.getCost());</div><div class="line"></div><div class="line">      Meal nonVegMeal = mealBuilder.prepareNonVegMeal();</div><div class="line">      System.out.println(&quot;\n\nNon-Veg Meal&quot;);</div><div class="line">      nonVegMeal.showItems();</div><div class="line">      System.out.println(&quot;Total Cost: &quot; +nonVegMeal.getCost());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 8</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Veg Meal</div><div class="line">Item : Veg Burger, Packing : Wrapper, Price : 25.0</div><div class="line">Item : Coke, Packing : Bottle, Price : 30.0</div><div class="line">Total Cost: 55.0</div><div class="line"></div><div class="line">Non-Veg Meal</div><div class="line">Item : Chicken Burger, Packing : Wrapper, Price : 50.5</div><div class="line">Item : Pepsi, Packing : Bottle, Price : 35.0</div><div class="line">Total Cost: 85.5</div></pre></td></tr></table></figure>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。<br><strong>意图：</strong>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br><strong>主要解决：</strong>在运行期建立和删除原型。<br><strong>何时使用：</strong> 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。<br><strong>如何解决：</strong>利用已有的一个原型对象，快速地生成和原型对象一样的实例。<br><strong>关键代码：</strong> 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口。<br><strong>应用实例：</strong> 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。<br><strong>优点：</strong> 1、性能提高。 2、逃避构造函数的约束。<br><strong>缺点：</strong> 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。 3、逃避构造函数的约束。<br><strong>使用场景：</strong> 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。   5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。<br>注意事项：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。<br><strong>实现 </strong><br>我们将创建一个抽象类 Shape 和扩展了 Shape 类的实体类。下一步是定义类 ShapeCache，该类把 shape 对象存储在一个 Hashtable 中，并在请求的时候返回它们的克隆。<br>PrototypPatternDemo，我们的演示类使用 ShapeCache 类来获取 Shape 对象<br><img src="/2017/08/08/设计模式/prototype_pattern_uml_diagram.jpg" alt="prototype_pattern" title="prototype_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个实现了 Clonable 接口的抽象类。</p>
<p>Shape.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public abstract class Shape implements Cloneable &#123;</div><div class="line">   </div><div class="line">   private String id;</div><div class="line">   protected String type;</div><div class="line">   </div><div class="line">   abstract void draw();</div><div class="line">   </div><div class="line">   public String getType()&#123;</div><div class="line">      return type;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   public String getId() &#123;</div><div class="line">      return id;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   public void setId(String id) &#123;</div><div class="line">      this.id = id;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   public Object clone() &#123;</div><div class="line">      Object clone = null;</div><div class="line">      try &#123;</div><div class="line">         clone = super.clone();</div><div class="line">      &#125; catch (CloneNotSupportedException e) &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">      return clone;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建扩展了上面抽象类的实体类。</p>
<p>Rectangle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Rectangle extends Shape &#123;</div><div class="line"></div><div class="line">   public Rectangle()&#123;</div><div class="line">     type = &quot;Rectangle&quot;;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Square.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Square extends Shape &#123;</div><div class="line"></div><div class="line">   public Square()&#123;</div><div class="line">     type = &quot;Square&quot;;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Square::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Circle extends Shape &#123;</div><div class="line"></div><div class="line">   public Circle()&#123;</div><div class="line">     type = &quot;Circle&quot;;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Circle::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建一个类，从数据库获取实体类，并把它们存储在一个 Hashtable 中。</p>
<p>ShapeCache.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">import java.util.Hashtable;</div><div class="line"></div><div class="line">public class ShapeCache &#123;</div><div class="line">	</div><div class="line">   private static Hashtable&lt;String, Shape&gt; shapeMap </div><div class="line">      = new Hashtable&lt;String, Shape&gt;();</div><div class="line"></div><div class="line">   public static Shape getShape(String shapeId) &#123;</div><div class="line">      Shape cachedShape = shapeMap.get(shapeId);</div><div class="line">      return (Shape) cachedShape.clone();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // 对每种形状都运行数据库查询，并创建该形状</div><div class="line">   // shapeMap.put(shapeKey, shape);</div><div class="line">   // 例如，我们要添加三种形状</div><div class="line">   public static void loadCache() &#123;</div><div class="line">      Circle circle = new Circle();</div><div class="line">      circle.setId(&quot;1&quot;);</div><div class="line">      shapeMap.put(circle.getId(),circle);</div><div class="line"></div><div class="line">      Square square = new Square();</div><div class="line">      square.setId(&quot;2&quot;);</div><div class="line">      shapeMap.put(square.getId(),square);</div><div class="line"></div><div class="line">      Rectangle rectangle = new Rectangle();</div><div class="line">      rectangle.setId(&quot;3&quot;);</div><div class="line">      shapeMap.put(rectangle.getId(),rectangle);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>PrototypePatternDemo 使用 ShapeCache 类来获取存储在 Hashtable 中的形状的克隆。</p>
<p>PrototypePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class PrototypePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      ShapeCache.loadCache();</div><div class="line"></div><div class="line">      Shape clonedShape = (Shape) ShapeCache.getShape(&quot;1&quot;);</div><div class="line">      System.out.println(&quot;Shape : &quot; + clonedShape.getType());		</div><div class="line"></div><div class="line">      Shape clonedShape2 = (Shape) ShapeCache.getShape(&quot;2&quot;);</div><div class="line">      System.out.println(&quot;Shape : &quot; + clonedShape2.getType());		</div><div class="line"></div><div class="line">      Shape clonedShape3 = (Shape) ShapeCache.getShape(&quot;3&quot;);</div><div class="line">      System.out.println(&quot;Shape : &quot; + clonedShape3.getType());		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Shape : Circle</div><div class="line">Shape : Square</div><div class="line">Shape : Rectangle</div></pre></td></tr></table></figure>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。<br>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。<br>我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。<br><strong>意图：</strong>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>主要解决：主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。<br><strong>何时使用：</strong> 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）<br><strong>如何解决：</strong>继承或依赖（推荐）。<br><strong>关键代码：</strong>适配器继承或依赖已有的对象，实现想要的目标接口。<br><strong>应用实例：</strong> 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。<br><strong>优点：</strong> 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。<br><strong>缺点：</strong> 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。<br><strong>使用场景：</strong>有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。<br><strong>注意事项：</strong>适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。<br><strong>实现</strong><br>我们有一个 MediaPlayer 接口和一个实现了 MediaPlayer 接口的实体类 AudioPlayer。默认情况下，AudioPlayer 可以播放 mp3 格式的音频文件。<br>我们还有另一个接口 AdvancedMediaPlayer 和实现了 AdvancedMediaPlayer 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。<br>我们想要让 AudioPlayer 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 MediaPlayer 接口的适配器类 MediaAdapter，并使用 AdvancedMediaPlayer 对象来播放所需的格式。<br>AudioPlayer 使用适配器类 MediaAdapter 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。AdapterPatternDemo，我们的演示类使用 AudioPlayer 类来播放各种格式。<br><img src="/2017/08/08/设计模式/adapter_pattern_uml_diagram.jpg" alt="adapter_pattern" title="adapter_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>为媒体播放器和更高级的媒体播放器创建接口。</p>
<p>MediaPlayer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public interface MediaPlayer &#123;</div><div class="line">   public void play(String audioType, String fileName);</div><div class="line">&#125;</div><div class="line">AdvancedMediaPlayer.java</div><div class="line">public interface AdvancedMediaPlayer &#123;	</div><div class="line">   public void playVlc(String fileName);</div><div class="line">   public void playMp4(String fileName);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现了 AdvancedMediaPlayer 接口的实体类。</p>
<p>VlcPlayer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class VlcPlayer implements AdvancedMediaPlayer&#123;</div><div class="line">   @Override</div><div class="line">   public void playVlc(String fileName) &#123;</div><div class="line">      System.out.println(&quot;Playing vlc file. Name: &quot;+ fileName);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void playMp4(String fileName) &#123;</div><div class="line">      //什么也不做</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Mp4Player.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Mp4Player implements AdvancedMediaPlayer&#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void playVlc(String fileName) &#123;</div><div class="line">      //什么也不做</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void playMp4(String fileName) &#123;</div><div class="line">      System.out.println(&quot;Playing mp4 file. Name: &quot;+ fileName);		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实现了 MediaPlayer 接口的适配器类。</p>
<p>MediaAdapter.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class MediaAdapter implements MediaPlayer &#123;</div><div class="line"></div><div class="line">   AdvancedMediaPlayer advancedMusicPlayer;</div><div class="line"></div><div class="line">   public MediaAdapter(String audioType)&#123;</div><div class="line">      if(audioType.equalsIgnoreCase(&quot;vlc&quot;) )&#123;</div><div class="line">         advancedMusicPlayer = new VlcPlayer();			</div><div class="line">      &#125; else if (audioType.equalsIgnoreCase(&quot;mp4&quot;))&#123;</div><div class="line">         advancedMusicPlayer = new Mp4Player();</div><div class="line">      &#125;	</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void play(String audioType, String fileName) &#123;</div><div class="line">      if(audioType.equalsIgnoreCase(&quot;vlc&quot;))&#123;</div><div class="line">         advancedMusicPlayer.playVlc(fileName);</div><div class="line">      &#125;else if(audioType.equalsIgnoreCase(&quot;mp4&quot;))&#123;</div><div class="line">         advancedMusicPlayer.playMp4(fileName);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建实现了 MediaPlayer 接口的实体类。</p>
<p>AudioPlayer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class AudioPlayer implements MediaPlayer &#123;</div><div class="line">   MediaAdapter mediaAdapter; </div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void play(String audioType, String fileName) &#123;		</div><div class="line"></div><div class="line">      //播放 mp3 音乐文件的内置支持</div><div class="line">      if(audioType.equalsIgnoreCase(&quot;mp3&quot;))&#123;</div><div class="line">         System.out.println(&quot;Playing mp3 file. Name: &quot;+ fileName);			</div><div class="line">      &#125; </div><div class="line">      //mediaAdapter 提供了播放其他文件格式的支持</div><div class="line">      else if(audioType.equalsIgnoreCase(&quot;vlc&quot;) </div><div class="line">         || audioType.equalsIgnoreCase(&quot;mp4&quot;))&#123;</div><div class="line">         mediaAdapter = new MediaAdapter(audioType);</div><div class="line">         mediaAdapter.play(audioType, fileName);</div><div class="line">      &#125;</div><div class="line">      else&#123;</div><div class="line">         System.out.println(&quot;Invalid media. &quot;+</div><div class="line">            audioType + &quot; format not supported&quot;);</div><div class="line">      &#125;</div><div class="line">   &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>使用 AudioPlayer 来播放不同类型的音频格式。</p>
<p>AdapterPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class AdapterPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      AudioPlayer audioPlayer = new AudioPlayer();</div><div class="line"></div><div class="line">      audioPlayer.play(&quot;mp3&quot;, &quot;beyond the horizon.mp3&quot;);</div><div class="line">      audioPlayer.play(&quot;mp4&quot;, &quot;alone.mp4&quot;);</div><div class="line">      audioPlayer.play(&quot;vlc&quot;, &quot;far far away.vlc&quot;);</div><div class="line">      audioPlayer.play(&quot;avi&quot;, &quot;mind me.avi&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Playing mp3 file. Name: beyond the horizon.mp3</div><div class="line">Playing mp4 file. Name: alone.mp4</div><div class="line">Playing vlc file. Name: far far away.vlc</div><div class="line">Invalid media. avi format not supported</div></pre></td></tr></table></figure>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。<br>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。<br>我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。<br><strong>意图：</strong>将抽象部分与实现部分分离，使它们都可以独立的变化。<br><strong>主要解决：</strong>在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。<br><strong>何时使用：</strong>实现系统可能有多个角度分类，每一种角度都可能变化。<br><strong>如何解决：</strong>把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。<br><strong>关键代码：</strong>抽象类依赖实现类。<br><strong>应用实例：</strong> 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。<br><strong>优点：</strong> 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。<br><strong>缺点：</strong>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。<br><strong>使用场景：</strong> 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。<br><strong>注意事项：</strong>对于两个独立变化的维度，使用桥接模式再适合不过了。<br><strong>实现 </strong><br>我们有一个作为桥接实现的 DrawAPI 接口和实现了 DrawAPI 接口的实体类 RedCircle、GreenCircle。Shape 是一个抽象类，将使用 DrawAPI 的对象。BridgePatternDemo，我们的演示类使用 Shape 类来画出不同颜色的圆。<br><img src="/2017/08/08/设计模式/bridge_pattern_uml_diagram.jpg" alt="bridge_pattern" title="bridge_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建桥接实现接口。</p>
<p>DrawAPI.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface DrawAPI &#123;</div><div class="line">   public void drawCircle(int radius, int x, int y);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现了 DrawAPI 接口的实体桥接实现类。</p>
<p>RedCircle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class RedCircle implements DrawAPI &#123;</div><div class="line">   @Override</div><div class="line">   public void drawCircle(int radius, int x, int y) &#123;</div><div class="line">      System.out.println(&quot;Drawing Circle[ color: red, radius: &quot;</div><div class="line">         + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>GreenCircle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class GreenCircle implements DrawAPI &#123;</div><div class="line">   @Override</div><div class="line">   public void drawCircle(int radius, int x, int y) &#123;</div><div class="line">      System.out.println(&quot;Drawing Circle[ color: green, radius: &quot;</div><div class="line">         + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>使用 DrawAPI 接口创建抽象类 Shape。</p>
<p>Shape.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public abstract class Shape &#123;</div><div class="line">   protected DrawAPI drawAPI;</div><div class="line">   protected Shape(DrawAPI drawAPI)&#123;</div><div class="line">      this.drawAPI = drawAPI;</div><div class="line">   &#125;</div><div class="line">   public abstract void draw();	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建实现了 Shape 接口的实体类。</p>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Circle extends Shape &#123;</div><div class="line">   private int x, y, radius;</div><div class="line"></div><div class="line">   public Circle(int x, int y, int radius, DrawAPI drawAPI) &#123;</div><div class="line">      super(drawAPI);</div><div class="line">      this.x = x;  </div><div class="line">      this.y = y;  </div><div class="line">      this.radius = radius;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void draw() &#123;</div><div class="line">      drawAPI.drawCircle(radius,x,y);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>使用 Shape 和 DrawAPI 类画出不同颜色的圆。</p>
<p>BridgePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class BridgePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Shape redCircle = new Circle(100,100, 10, new RedCircle());</div><div class="line">      Shape greenCircle = new Circle(100,100, 10, new GreenCircle());</div><div class="line"></div><div class="line">      redCircle.draw();</div><div class="line">      greenCircle.draw();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Drawing Circle[ color: red, radius: 10, x: 100, 100]</div><div class="line">Drawing Circle[  color: green, radius: 10, x: 100, 100]</div></pre></td></tr></table></figure>
<h2 id="过滤器模式"><a href="#过滤器模式" class="headerlink" title="过滤器模式"></a>过滤器模式</h2><p>过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。<br><strong>实现</strong><br>我们将创建一个 Person 对象、Criteria 接口和实现了该接口的实体类，来过滤 Person 对象的列表。CriteriaPatternDemo，我们的演示类使用 Criteria 对象，基于各种标准和它们的结合来过滤 Person 对象的列表。<br><img src="/2017/08/08/设计模式/filter_pattern_uml_diagram.jpg" alt="filter_pattern" title="filter_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个类，在该类上应用标准。</p>
<p>Person.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Person &#123;</div><div class="line">	</div><div class="line">   private String name;</div><div class="line">   private String gender;</div><div class="line">   private String maritalStatus;</div><div class="line"></div><div class="line">   public Person(String name,String gender,String maritalStatus)&#123;</div><div class="line">      this.name = name;</div><div class="line">      this.gender = gender;</div><div class="line">      this.maritalStatus = maritalStatus;		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getName() &#123;</div><div class="line">      return name;</div><div class="line">   &#125;</div><div class="line">   public String getGender() &#123;</div><div class="line">      return gender;</div><div class="line">   &#125;</div><div class="line">   public String getMaritalStatus() &#123;</div><div class="line">      return maritalStatus;</div><div class="line">   &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>为标准（Criteria）创建一个接口。</p>
<p>Criteria.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public interface Criteria &#123;</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实现了 Criteria 接口的实体类。</p>
<p>CriteriaMale.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class CriteriaMale implements Criteria &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123;</div><div class="line">      List&lt;Person&gt; malePersons = new ArrayList&lt;Person&gt;(); </div><div class="line">      for (Person person : persons) &#123;</div><div class="line">         if(person.getGender().equalsIgnoreCase(&quot;MALE&quot;))&#123;</div><div class="line">            malePersons.add(person);</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      return malePersons;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CriteriaFemale.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class CriteriaFemale implements Criteria &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123;</div><div class="line">      List&lt;Person&gt; femalePersons = new ArrayList&lt;Person&gt;(); </div><div class="line">      for (Person person : persons) &#123;</div><div class="line">         if(person.getGender().equalsIgnoreCase(&quot;FEMALE&quot;))&#123;</div><div class="line">            femalePersons.add(person);</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      return femalePersons;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CriteriaSingle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class CriteriaSingle implements Criteria &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123;</div><div class="line">      List&lt;Person&gt; singlePersons = new ArrayList&lt;Person&gt;(); </div><div class="line">      for (Person person : persons) &#123;</div><div class="line">         if(person.getMaritalStatus().equalsIgnoreCase(&quot;SINGLE&quot;))&#123;</div><div class="line">            singlePersons.add(person);</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      return singlePersons;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AndCriteria.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class AndCriteria implements Criteria &#123;</div><div class="line"></div><div class="line">   private Criteria criteria;</div><div class="line">   private Criteria otherCriteria;</div><div class="line"></div><div class="line">   public AndCriteria(Criteria criteria, Criteria otherCriteria) &#123;</div><div class="line">      this.criteria = criteria;</div><div class="line">      this.otherCriteria = otherCriteria; </div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123;</div><div class="line">      List&lt;Person&gt; firstCriteriaPersons = criteria.meetCriteria(persons);		</div><div class="line">      return otherCriteria.meetCriteria(firstCriteriaPersons);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OrCriteria.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class OrCriteria implements Criteria &#123;</div><div class="line"></div><div class="line">   private Criteria criteria;</div><div class="line">   private Criteria otherCriteria;</div><div class="line"></div><div class="line">   public OrCriteria(Criteria criteria, Criteria otherCriteria) &#123;</div><div class="line">      this.criteria = criteria;</div><div class="line">      this.otherCriteria = otherCriteria; </div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123;</div><div class="line">      List&lt;Person&gt; firstCriteriaItems = criteria.meetCriteria(persons);</div><div class="line">      List&lt;Person&gt; otherCriteriaItems = otherCriteria.meetCriteria(persons);</div><div class="line"></div><div class="line">      for (Person person : otherCriteriaItems) &#123;</div><div class="line">         if(!firstCriteriaItems.contains(person))&#123;</div><div class="line">	        firstCriteriaItems.add(person);</div><div class="line">         &#125;</div><div class="line">      &#125;	</div><div class="line">      return firstCriteriaItems;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤4</strong></p>
<p>使用不同的标准（Criteria）和它们的结合来过滤 Person 对象的列表。</p>
<p>CriteriaPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList; </div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class CriteriaPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;();</div><div class="line"></div><div class="line">      persons.add(new Person(&quot;Robert&quot;,&quot;Male&quot;, &quot;Single&quot;));</div><div class="line">      persons.add(new Person(&quot;John&quot;,&quot;Male&quot;, &quot;Married&quot;));</div><div class="line">      persons.add(new Person(&quot;Laura&quot;,&quot;Female&quot;, &quot;Married&quot;));</div><div class="line">      persons.add(new Person(&quot;Diana&quot;,&quot;Female&quot;, &quot;Single&quot;));</div><div class="line">      persons.add(new Person(&quot;Mike&quot;,&quot;Male&quot;, &quot;Single&quot;));</div><div class="line">      persons.add(new Person(&quot;Bobby&quot;,&quot;Male&quot;, &quot;Single&quot;));</div><div class="line"></div><div class="line">      Criteria male = new CriteriaMale();</div><div class="line">      Criteria female = new CriteriaFemale();</div><div class="line">      Criteria single = new CriteriaSingle();</div><div class="line">      Criteria singleMale = new AndCriteria(single, male);</div><div class="line">      Criteria singleOrFemale = new OrCriteria(single, female);</div><div class="line"></div><div class="line">      System.out.println(&quot;Males: &quot;);</div><div class="line">      printPersons(male.meetCriteria(persons));</div><div class="line"></div><div class="line">      System.out.println(&quot;\nFemales: &quot;);</div><div class="line">      printPersons(female.meetCriteria(persons));</div><div class="line"></div><div class="line">      System.out.println(&quot;\nSingle Males: &quot;);</div><div class="line">      printPersons(singleMale.meetCriteria(persons));</div><div class="line"></div><div class="line">      System.out.println(&quot;\nSingle Or Females: &quot;);</div><div class="line">      printPersons(singleOrFemale.meetCriteria(persons));</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public static void printPersons(List&lt;Person&gt; persons)&#123;</div><div class="line">      for (Person person : persons) &#123;</div><div class="line">         System.out.println(&quot;Person : [ Name : &quot; + person.getName() </div><div class="line">            +&quot;, Gender : &quot; + person.getGender() </div><div class="line">            +&quot;, Marital Status : &quot; + person.getMaritalStatus()</div><div class="line">            +&quot; ]&quot;);</div><div class="line">      &#125;</div><div class="line">   &#125;      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Males: </div><div class="line">Person : [ Name : Robert, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : John, Gender : Male, Marital Status : Married ]</div><div class="line">Person : [ Name : Mike, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]</div><div class="line"></div><div class="line">Females: </div><div class="line">Person : [ Name : Laura, Gender : Female, Marital Status : Married ]</div><div class="line">Person : [ Name : Diana, Gender : Female, Marital Status : Single ]</div><div class="line"></div><div class="line">Single Males: </div><div class="line">Person : [ Name : Robert, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Mike, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]</div><div class="line"></div><div class="line">Single Or Females: </div><div class="line">Person : [ Name : Robert, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Diana, Gender : Female, Marital Status : Single ]</div><div class="line">Person : [ Name : Mike, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Laura, Gender : Female, Marital Status : Married ]</div></pre></td></tr></table></figure>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。<br>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。<br>我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。<br>意图：将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。<br><strong>主要解决：</strong>它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。<br><strong>何时使用：</strong> 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。<br><strong>如何解决：</strong>树枝和叶子实现统一接口，树枝内部组合该接口。<br>关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。<br><strong>应用实例：</strong> 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作树、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。<br><strong>优点：</strong> 1、高层模块调用简单。 2、节点自由增加。<br><strong>缺点：</strong>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。<br><strong>使用场景：</strong>部分、整体场景，如树形菜单，文件、文件夹的管理。<br><strong>注意事项：</strong>定义时为具体类。<br><strong>实现</strong><br>我们有一个类 Employee，该类被当作组合模型类。CompositePatternDemo，我们的演示类使用 Employee 类来添加部门层次结构，并打印所有员工。<br><img src="/2017/08/08/设计模式/composite_pattern_uml_diagram.jpg" alt="composite_pattern" title="composite_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建 Employee 类，该类带有 Employee 对象的列表。</p>
<p>Employee.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class Employee &#123;</div><div class="line">   private String name;</div><div class="line">   private String dept;</div><div class="line">   private int salary;</div><div class="line">   private List&lt;Employee&gt; subordinates;</div><div class="line"></div><div class="line">   //构造函数</div><div class="line">   public Employee(String name,String dept, int sal) &#123;</div><div class="line">      this.name = name;</div><div class="line">      this.dept = dept;</div><div class="line">      this.salary = sal;</div><div class="line">      subordinates = new ArrayList&lt;Employee&gt;();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void add(Employee e) &#123;</div><div class="line">      subordinates.add(e);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void remove(Employee e) &#123;</div><div class="line">      subordinates.remove(e);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public List&lt;Employee&gt; getSubordinates()&#123;</div><div class="line">     return subordinates;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String toString()&#123;</div><div class="line">      return (&quot;Employee :[ Name : &quot;+ name </div><div class="line">      +&quot;, dept : &quot;+ dept + &quot;, salary :&quot;</div><div class="line">      + salary+&quot; ]&quot;);</div><div class="line">   &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>使用 Employee 类来创建和打印员工的层次结构。</p>
<p>CompositePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class CompositePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Employee CEO = new Employee(&quot;John&quot;,&quot;CEO&quot;, 30000);</div><div class="line"></div><div class="line">      Employee headSales = new Employee(&quot;Robert&quot;,&quot;Head Sales&quot;, 20000);</div><div class="line"></div><div class="line">      Employee headMarketing = new Employee(&quot;Michel&quot;,&quot;Head Marketing&quot;, 20000);</div><div class="line"></div><div class="line">      Employee clerk1 = new Employee(&quot;Laura&quot;,&quot;Marketing&quot;, 10000);</div><div class="line">      Employee clerk2 = new Employee(&quot;Bob&quot;,&quot;Marketing&quot;, 10000);</div><div class="line"></div><div class="line">      Employee salesExecutive1 = new Employee(&quot;Richard&quot;,&quot;Sales&quot;, 10000);</div><div class="line">      Employee salesExecutive2 = new Employee(&quot;Rob&quot;,&quot;Sales&quot;, 10000);</div><div class="line"></div><div class="line">      CEO.add(headSales);</div><div class="line">      CEO.add(headMarketing);</div><div class="line"></div><div class="line">      headSales.add(salesExecutive1);</div><div class="line">      headSales.add(salesExecutive2);</div><div class="line"></div><div class="line">      headMarketing.add(clerk1);</div><div class="line">      headMarketing.add(clerk2);</div><div class="line"></div><div class="line">      //打印该组织的所有员工</div><div class="line">      System.out.println(CEO); </div><div class="line">      for (Employee headEmployee : CEO.getSubordinates()) &#123;</div><div class="line">         System.out.println(headEmployee);</div><div class="line">         for (Employee employee : headEmployee.getSubordinates()) &#123;</div><div class="line">            System.out.println(employee);</div><div class="line">         &#125;</div><div class="line">      &#125;		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Employee :[ Name : John, dept : CEO, salary :30000 ]</div><div class="line">Employee :[ Name : Robert, dept : Head Sales, salary :20000 ]</div><div class="line">Employee :[ Name : Richard, dept : Sales, salary :10000 ]</div><div class="line">Employee :[ Name : Rob, dept : Sales, salary :10000 ]</div><div class="line">Employee :[ Name : Michel, dept : Head Marketing, salary :20000 ]</div><div class="line">Employee :[ Name : Laura, dept : Marketing, salary :10000 ]</div><div class="line">Employee :[ Name : Bob, dept : Marketing, salary :10000 ]</div></pre></td></tr></table></figure>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。<br>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。<br>我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。<br><strong>意图：</strong>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。<br>主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。<br><strong>何时使用：</strong>在不想增加很多子类的情况下扩展类。<br><strong>如何解决：</strong>将具体功能职责划分，同时继承装饰者模式。<br><strong>关键代码：</strong> 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。<br><strong>应用实例：</strong> 1、孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。<br><strong>优点：</strong>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。<br><strong>缺点：</strong>多层装饰比较复杂。<br><strong>使用场景：</strong> 1、扩展一个类的功能。 2、动态增加功能，动态撤销。<br><strong>注意事项：</strong>可代替继承。<br><strong>实现</strong><br>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。<br>RedShapeDecorator 是实现了 ShapeDecorator 的实体类。<br>DecoratorPatternDemo，我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象<br><img src="/2017/08/08/设计模式/decorator_pattern_uml_diagram.jpg" alt="decorator_pattern" title="decorator_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口。</p>
<p>Shape.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Shape &#123;</div><div class="line">   void draw();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>Rectangle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Rectangle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Shape: Rectangle&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Circle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Shape: Circle&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实现了 Shape 接口的抽象装饰类。</p>
<p>ShapeDecorator.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public abstract class ShapeDecorator implements Shape &#123;</div><div class="line">   protected Shape decoratedShape;</div><div class="line"></div><div class="line">   public ShapeDecorator(Shape decoratedShape)&#123;</div><div class="line">      this.decoratedShape = decoratedShape;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void draw()&#123;</div><div class="line">      decoratedShape.draw();</div><div class="line">   &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建扩展了 ShapeDecorator 类的实体装饰类。</p>
<p>RedShapeDecorator.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class RedShapeDecorator extends ShapeDecorator &#123;</div><div class="line"></div><div class="line">   public RedShapeDecorator(Shape decoratedShape) &#123;</div><div class="line">      super(decoratedShape);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      decoratedShape.draw();	       </div><div class="line">      setRedBorder(decoratedShape);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private void setRedBorder(Shape decoratedShape)&#123;</div><div class="line">      System.out.println(&quot;Border Color: Red&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>使用 RedShapeDecorator 来装饰 Shape 对象。</p>
<p>DecoratorPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class DecoratorPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      Shape circle = new Circle();</div><div class="line"></div><div class="line">      Shape redCircle = new RedShapeDecorator(new Circle());</div><div class="line"></div><div class="line">      Shape redRectangle = new RedShapeDecorator(new Rectangle());</div><div class="line">      System.out.println(&quot;Circle with normal border&quot;);</div><div class="line">      circle.draw();</div><div class="line"></div><div class="line">      System.out.println(&quot;\nCircle of red border&quot;);</div><div class="line">      redCircle.draw();</div><div class="line"></div><div class="line">      System.out.println(&quot;\nRectangle of red border&quot;);</div><div class="line">      redRectangle.draw();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Circle with normal border</div><div class="line">Shape: Circle</div><div class="line"></div><div class="line">Circle of red border</div><div class="line">Shape: Circle</div><div class="line">Border Color: Red</div><div class="line"></div><div class="line">Rectangle of red border</div><div class="line">Shape: Rectangle</div><div class="line">Border Color: Red</div></pre></td></tr></table></figure>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。<br>这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。<br><strong>意图：</strong>为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br><strong>主要解决：</strong>降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。<br><strong>何时使用：</strong> 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。 2、定义系统的入口。<br><strong>如何解决：</strong>客户端不与系统耦合，外观类与系统耦合。<br><strong>关键代码：</strong>在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。<br><strong>应用实例：</strong> 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、JAVA 的三层开发模式。<br><strong>优点：</strong> 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。<br><strong>缺点：</strong>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。<br><strong>使用场景： </strong>1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。<br><strong>注意事项：</strong>在层次化结构中，可以使用外观模式定义系统中每一层的入口。<br><strong>实现</strong><br>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。下一步是定义一个外观类 ShapeMaker。<br>ShapeMaker 类使用实体类来代表用户对这些类的调用。FacadePatternDemo，我们的演示类使用 ShapeMaker 类来显示结果。<br><img src="/2017/08/08/设计模式/facade_pattern_uml_diagram.jpg" alt="facade_pattern" title="facade_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口。</p>
<p>Shape.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Shape &#123;</div><div class="line">   void draw();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>Rectangle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Rectangle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Rectangle::draw()&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Square.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Square implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Square::draw()&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Circle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Circle::draw()&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建一个外观类。</p>
<p>ShapeMaker.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class ShapeMaker &#123;</div><div class="line">   private Shape circle;</div><div class="line">   private Shape rectangle;</div><div class="line">   private Shape square;</div><div class="line"></div><div class="line">   public ShapeMaker() &#123;</div><div class="line">      circle = new Circle();</div><div class="line">      rectangle = new Rectangle();</div><div class="line">      square = new Square();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void drawCircle()&#123;</div><div class="line">      circle.draw();</div><div class="line">   &#125;</div><div class="line">   public void drawRectangle()&#123;</div><div class="line">      rectangle.draw();</div><div class="line">   &#125;</div><div class="line">   public void drawSquare()&#123;</div><div class="line">      square.draw();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用该外观类画出各种类型的形状。</p>
<p>FacadePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class FacadePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      ShapeMaker shapeMaker = new ShapeMaker();</div><div class="line"></div><div class="line">      shapeMaker.drawCircle();</div><div class="line">      shapeMaker.drawRectangle();</div><div class="line">      shapeMaker.drawSquare();		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Circle::draw()</div><div class="line">Rectangle::draw()</div><div class="line">Square::draw()</div></pre></td></tr></table></figure>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。<br>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对象。<br><strong>意图：</strong>运用共享技术有效地支持大量细粒度的对象。<br>主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。<br><strong>何时使用：</strong> 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。<br><strong>如何解决：</strong>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。<br><strong>关键代码：</strong>用 HashMap 存储这些对象。<br><strong>应用实例：</strong> 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。<br><strong>优点：</strong>大大减少对象的创建，降低系统的内存，使效率提高。<br><strong>缺点：</strong>提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。<br><strong>使用场景：</strong> 1、系统有大量相似对象。 2、需要缓冲池的场景。<br><strong>注意事项：</strong> 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。<br><strong>实现</strong><br>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类 Circle。下一步是定义工厂类 ShapeFactory。<br>ShapeFactory 有一个 Circle 的 HashMap，其中键名为 Circle 对象的颜色。无论何时接收到请求，都会创建一个特定颜色的圆。ShapeFactory 检查它的 HashMap 中的 circle 对象，如果找到 Circle 对象，则返回该对象，否则将创建一个存储在 hashmap 中以备后续使用的新对象，并把该对象返回到客户端。<br>FlyWeightPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（red / green / blue/ black / white），以便获取它所需对象的颜色。<br><img src="/2017/08/08/设计模式/flyweight_pattern_uml_diagram-1.jpg" alt="flyweight_pattern" title="flyweight_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口。</p>
<p>Shape.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Shape &#123;</div><div class="line">   void draw();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class Circle implements Shape &#123;</div><div class="line">   private String color;</div><div class="line">   private int x;</div><div class="line">   private int y;</div><div class="line">   private int radius;</div><div class="line"></div><div class="line">   public Circle(String color)&#123;</div><div class="line">      this.color = color;		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setX(int x) &#123;</div><div class="line">      this.x = x;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setY(int y) &#123;</div><div class="line">      this.y = y;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setRadius(int radius) &#123;</div><div class="line">      this.radius = radius;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Circle: Draw() [Color : &quot; + color </div><div class="line">         +&quot;, x : &quot; + x +&quot;, y :&quot; + y +&quot;, radius :&quot; + radius);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建一个工厂，生成基于给定信息的实体类的对象。</p>
<p>ShapeFactory.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import java.util.HashMap;</div><div class="line"></div><div class="line">public class ShapeFactory &#123;</div><div class="line">   private static final HashMap&lt;String, Shape&gt; circleMap = new HashMap();</div><div class="line"></div><div class="line">   public static Shape getCircle(String color) &#123;</div><div class="line">      Circle circle = (Circle)circleMap.get(color);</div><div class="line"></div><div class="line">      if(circle == null) &#123;</div><div class="line">         circle = new Circle(color);</div><div class="line">         circleMap.put(color, circle);</div><div class="line">         System.out.println(&quot;Creating circle of color : &quot; + color);</div><div class="line">      &#125;</div><div class="line">      return circle;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用该工厂，通过传递颜色信息来获取实体类的对象。</p>
<p>FlyweightPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class FlyweightPatternDemo &#123;</div><div class="line">   private static final String colors[] = </div><div class="line">      &#123; &quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot;, &quot;White&quot;, &quot;Black&quot; &#125;;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      for(int i=0; i &lt; 20; ++i) &#123;</div><div class="line">         Circle circle = </div><div class="line">            (Circle)ShapeFactory.getCircle(getRandomColor());</div><div class="line">         circle.setX(getRandomX());</div><div class="line">         circle.setY(getRandomY());</div><div class="line">         circle.setRadius(100);</div><div class="line">         circle.draw();</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">   private static String getRandomColor() &#123;</div><div class="line">      return colors[(int)(Math.random()*colors.length)];</div><div class="line">   &#125;</div><div class="line">   private static int getRandomX() &#123;</div><div class="line">      return (int)(Math.random()*100 );</div><div class="line">   &#125;</div><div class="line">   private static int getRandomY() &#123;</div><div class="line">      return (int)(Math.random()*100);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Creating circle of color : Black</div><div class="line">Circle: Draw() [Color : Black, x : 36, y :71, radius :100</div><div class="line">Creating circle of color : Green</div><div class="line">Circle: Draw() [Color : Green, x : 27, y :27, radius :100</div><div class="line">Creating circle of color : White</div><div class="line">Circle: Draw() [Color : White, x : 64, y :10, radius :100</div><div class="line">Creating circle of color : Red</div><div class="line">Circle: Draw() [Color : Red, x : 15, y :44, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 19, y :10, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 94, y :32, radius :100</div><div class="line">Circle: Draw() [Color : White, x : 69, y :98, radius :100</div><div class="line">Creating circle of color : Blue</div><div class="line">Circle: Draw() [Color : Blue, x : 13, y :4, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 21, y :21, radius :100</div><div class="line">Circle: Draw() [Color : Blue, x : 55, y :86, radius :100</div><div class="line">Circle: Draw() [Color : White, x : 90, y :70, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 78, y :3, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 64, y :89, radius :100</div><div class="line">Circle: Draw() [Color : Blue, x : 3, y :91, radius :100</div><div class="line">Circle: Draw() [Color : Blue, x : 62, y :82, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 97, y :61, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 86, y :12, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 38, y :93, radius :100</div><div class="line">Circle: Draw() [Color : Red, x : 76, y :82, radius :100</div><div class="line">Circle: Draw() [Color : Blue, x : 95, y :82, radius :100</div></pre></td></tr></table></figure>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。<br>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。<br><strong>意图：</strong>为其他对象提供一种代理以控制对这个对象的访问。<br><strong>主要解决：</strong>在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。<br><strong>何时使用：</strong>想在访问一个类时做一些控制。<br><strong>如何解决：</strong>增加中间层。<br>关键代码：实现与被代理类组合。<br><strong>应用实例：</strong> 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。<br><strong>优点：</strong> 1、职责清晰。 2、高扩展性。 3、智能化。<br><strong>缺点：</strong> 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。<br><strong>使用场景：</strong>按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。<br><strong>注意事项：</strong> 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。<br><strong>实现</strong><br>我们将创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。<br>ProxyPatternDemo，我们的演示类使用 ProxyImage 来获取要加载的 Image 对象，并按照需求进行显示。<br><img src="/2017/08/08/设计模式/proxy_pattern_uml_diagram.jpg" alt="proxy_pattern" title="proxy_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口。</p>
<p>Image.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Image &#123;</div><div class="line">   void display();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>RealImage.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class RealImage implements Image &#123;</div><div class="line"></div><div class="line">   private String fileName;</div><div class="line"></div><div class="line">   public RealImage(String fileName)&#123;</div><div class="line">      this.fileName = fileName;</div><div class="line">      loadFromDisk(fileName);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void display() &#123;</div><div class="line">      System.out.println(&quot;Displaying &quot; + fileName);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private void loadFromDisk(String fileName)&#123;</div><div class="line">      System.out.println(&quot;Loading &quot; + fileName);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ProxyImage.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class ProxyImage implements Image&#123;</div><div class="line"></div><div class="line">   private RealImage realImage;</div><div class="line">   private String fileName;</div><div class="line"></div><div class="line">   public ProxyImage(String fileName)&#123;</div><div class="line">      this.fileName = fileName;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void display() &#123;</div><div class="line">      if(realImage == null)&#123;</div><div class="line">         realImage = new RealImage(fileName);</div><div class="line">      &#125;</div><div class="line">      realImage.display();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>当被请求时，使用 ProxyImage 来获取 RealImage 类的对象。</p>
<p>ProxyPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class ProxyPatternDemo &#123;</div><div class="line">	</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Image image = new ProxyImage(&quot;test_10mb.jpg&quot;);</div><div class="line"></div><div class="line">      //图像将从磁盘加载</div><div class="line">      image.display(); </div><div class="line">      System.out.println(&quot;&quot;);</div><div class="line">      //图像将无法从磁盘加载</div><div class="line">      image.display(); 	</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Loading test_10mb.jpg</div><div class="line">Displaying test_10mb.jpg</div><div class="line"></div><div class="line">Displaying test_10mb.jpg</div></pre></td></tr></table></figure>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。<br>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。<br><strong>意图：</strong>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。<br><strong>主要解决：</strong>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。<br><strong>何时使用：</strong>在处理消息的时候以过滤很多道。<br><strong>如何解决：</strong>拦截的类都实现统一接口。<br><strong>关键代码：</strong>Handler 里面聚合它自己，在 HanleRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。<br><strong>应用实例：</strong> 1、红楼梦中的”击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。<br><strong>优点：</strong> 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。<br><strong>缺点：</strong> 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。<br><strong>使用场景：</strong> 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。<br>注意事项：在 JAVA WEB 中遇到很多应用。<br><strong>实现 </strong><br>我们创建抽象类 AbstractLogger，带有详细的日志记录级别。然后我们创建三种类型的记录器，都扩展了 AbstractLogger。每个记录器消息的级别是否属于自己的级别，如果是则相应地打印出来，否则将不打印并把消息传给下一个记录器。<br><img src="/2017/08/08/设计模式/chain_pattern_uml_diagram.jpg" alt="chain_pattern" title="chain_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建抽象的记录器类。</p>
<p>AbstractLogger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public abstract class AbstractLogger &#123;</div><div class="line">   public static int INFO = 1;</div><div class="line">   public static int DEBUG = 2;</div><div class="line">   public static int ERROR = 3;</div><div class="line"></div><div class="line">   protected int level;</div><div class="line"></div><div class="line">   //责任链中的下一个元素</div><div class="line">   protected AbstractLogger nextLogger;</div><div class="line"></div><div class="line">   public void setNextLogger(AbstractLogger nextLogger)&#123;</div><div class="line">      this.nextLogger = nextLogger;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void logMessage(int level, String message)&#123;</div><div class="line">      if(this.level &lt;= level)&#123;</div><div class="line">         write(message);</div><div class="line">      &#125;</div><div class="line">      if(nextLogger !=null)&#123;</div><div class="line">         nextLogger.logMessage(level, message);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   abstract protected void write(String message);</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建扩展了该记录器类的实体类。</p>
<p>ConsoleLogger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class ConsoleLogger extends AbstractLogger &#123;</div><div class="line"></div><div class="line">   public ConsoleLogger(int level)&#123;</div><div class="line">      this.level = level;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   protected void write(String message) &#123;		</div><div class="line">      System.out.println(&quot;Standard Console::Logger: &quot; + message);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ErrorLogger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class ErrorLogger extends AbstractLogger &#123;</div><div class="line"></div><div class="line">   public ErrorLogger(int level)&#123;</div><div class="line">      this.level = level;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   protected void write(String message) &#123;		</div><div class="line">      System.out.println(&quot;Error Console::Logger: &quot; + message);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>FileLogger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class FileLogger extends AbstractLogger &#123;</div><div class="line"></div><div class="line">   public FileLogger(int level)&#123;</div><div class="line">      this.level = level;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   protected void write(String message) &#123;		</div><div class="line">      System.out.println(&quot;File::Logger: &quot; + message);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建不同类型的记录器。赋予它们不同的错误级别，并在每个记录器中设置下一个记录器。每个记录器中的下一个记录器代表的是链的一部分。</p>
<p>ChainPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class ChainPatternDemo &#123;</div><div class="line">	</div><div class="line">   private static AbstractLogger getChainOfLoggers()&#123;</div><div class="line"></div><div class="line">      AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR);</div><div class="line">      AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG);</div><div class="line">      AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO);</div><div class="line"></div><div class="line">      errorLogger.setNextLogger(fileLogger);</div><div class="line">      fileLogger.setNextLogger(consoleLogger);</div><div class="line"></div><div class="line">      return errorLogger;	</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      AbstractLogger loggerChain = getChainOfLoggers();</div><div class="line"></div><div class="line">      loggerChain.logMessage(AbstractLogger.INFO, </div><div class="line">         &quot;This is an information.&quot;);</div><div class="line"></div><div class="line">      loggerChain.logMessage(AbstractLogger.DEBUG, </div><div class="line">         &quot;This is an debug level information.&quot;);</div><div class="line"></div><div class="line">      loggerChain.logMessage(AbstractLogger.ERROR, </div><div class="line">         &quot;This is an error information.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Standard Console::Logger: This is an information.</div><div class="line">File::Logger: This is an debug level information.</div><div class="line">Standard Console::Logger: This is an debug level information.</div><div class="line">Error Console::Logger: This is an error information.</div><div class="line">File::Logger: This is an error information.</div><div class="line">Standard Console::Logger: This is an error information.</div></pre></td></tr></table></figure>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。<br><strong>意图：</strong>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。<br><strong>主要解决：</strong>在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。<br><strong>何时使用：</strong>在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。<br><strong>如何解决：</strong>通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。<br><strong>关键代码：</strong>定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口<br><strong>应用实例：</strong>struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。<br><strong>优点：</strong> 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。<br><strong>缺点：</strong>使用命令模式可能会导致某些系统有过多的具体命令类。<br><strong>使用场景：</strong>认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。<br><strong>注意事项：</strong>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。<br><strong>实现</strong><br>我们首先创建作为命令的接口 Order，然后创建作为请求的 Stock 类。实体命令类 BuyStock 和 SellStock，实现了 Order 接口，将执行实际的命令处理。创建作为调用对象的类 Broker，它接受订单并能下订单。<br>Broker 对象使用命令模式，基于命令的类型确定哪个对象执行哪个命令。CommandPatternDemo，我们的演示类使用 Broker 类来演示命令模式。<br><img src="/2017/08/08/设计模式/command_pattern_uml_diagram.jpg" alt="command_pattern" title="command_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个命令接口。</p>
<p>Order.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Order &#123;</div><div class="line">   void execute();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建一个请求类。</p>
<p>Stock.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Stock &#123;</div><div class="line">	</div><div class="line">   private String name = &quot;ABC&quot;;</div><div class="line">   private int quantity = 10;</div><div class="line"></div><div class="line">   public void buy()&#123;</div><div class="line">      System.out.println(&quot;Stock [ Name: &quot;+name+&quot;, </div><div class="line">         Quantity: &quot; + quantity +&quot; ] bought&quot;);</div><div class="line">   &#125;</div><div class="line">   public void sell()&#123;</div><div class="line">      System.out.println(&quot;Stock [ Name: &quot;+name+&quot;, </div><div class="line">         Quantity: &quot; + quantity +&quot; ] sold&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实现了 Order 接口的实体类。</p>
<p>BuyStock.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class BuyStock implements Order &#123;</div><div class="line">   private Stock abcStock;</div><div class="line"></div><div class="line">   public BuyStock(Stock abcStock)&#123;</div><div class="line">      this.abcStock = abcStock;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void execute() &#123;</div><div class="line">      abcStock.buy();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SellStock.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class SellStock implements Order &#123;</div><div class="line">   private Stock abcStock;</div><div class="line"></div><div class="line">   public SellStock(Stock abcStock)&#123;</div><div class="line">      this.abcStock = abcStock;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void execute() &#123;</div><div class="line">      abcStock.sell();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建命令调用类。</p>
<p>Broker.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">   public class Broker &#123;</div><div class="line">   private List&lt;Order&gt; orderList = new ArrayList&lt;Order&gt;(); </div><div class="line"></div><div class="line">   public void takeOrder(Order order)&#123;</div><div class="line">      orderList.add(order);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void placeOrders()&#123;</div><div class="line">      for (Order order : orderList) &#123;</div><div class="line">         order.execute();</div><div class="line">      &#125;</div><div class="line">      orderList.clear();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>使用 Broker 类来接受并执行命令。</p>
<p>CommandPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class CommandPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Stock abcStock = new Stock();</div><div class="line"></div><div class="line">      BuyStock buyStockOrder = new BuyStock(abcStock);</div><div class="line">      SellStock sellStockOrder = new SellStock(abcStock);</div><div class="line"></div><div class="line">      Broker broker = new Broker();</div><div class="line">      broker.takeOrder(buyStockOrder);</div><div class="line">      broker.takeOrder(sellStockOrder);</div><div class="line"></div><div class="line">      broker.placeOrders();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Stock [ Name: ABC, Quantity: 10 ] bought</div><div class="line">Stock [ Name: ABC, Quantity: 10 ] sold</div></pre></td></tr></table></figure>
<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。<br>意图：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。<br><strong>主要解决：</strong>对于一些固定文法构建一个解释句子的解释器。<br><strong>何时使用：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。  
</strong>如何解决：<strong>构件语法树，定义终结符与非终结符。  
</strong>关键代码：<strong>构件环境类，包含解释器之外的一些全局信息，一般是 HashMap。  
</strong>应用实例：<strong>编译器、运算表达式计算。  
</strong>优点：<strong> 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。  
</strong>缺点：<strong> 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。  
</strong>使用场景：<strong> 1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 2、一些重复出现的问题可以用一种简单的语言来进行表达。 3、一个简单语法需要解释的场景。<br>注意事项：可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。  
</strong>实现 **<br>我们将创建一个接口 Expression 和实现了 Expression 接口的实体类。定义作为上下文中主要解释器的 TerminalExpression 类。其他的类 OrExpression、AndExpression 用于创建组合式表达式。<br>InterpreterPatternDemo，我们的演示类使用 Expression 类创建规则和演示表达式的解析。<br><img src="/2017/08/08/设计模式/interpreter_pattern_uml_diagram.jpg" alt="interpreter_pattern" title="interpreter_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个表达式接口。</p>
<p>Expression.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Expression &#123;</div><div class="line">   public boolean interpret(String context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现了上述接口的实体类。</p>
<p>TerminalExpression.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class TerminalExpression implements Expression &#123;</div><div class="line">	</div><div class="line">   private String data;</div><div class="line"></div><div class="line">   public TerminalExpression(String data)&#123;</div><div class="line">      this.data = data; </div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public boolean interpret(String context) &#123;</div><div class="line">      if(context.contains(data))&#123;</div><div class="line">         return true;</div><div class="line">      &#125;</div><div class="line">      return false;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OrExpression.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class OrExpression implements Expression &#123;</div><div class="line">	 </div><div class="line">   private Expression expr1 = null;</div><div class="line">   private Expression expr2 = null;</div><div class="line"></div><div class="line">   public OrExpression(Expression expr1, Expression expr2) &#123; </div><div class="line">      this.expr1 = expr1;</div><div class="line">      this.expr2 = expr2;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public boolean interpret(String context) &#123;		</div><div class="line">      return expr1.interpret(context) || expr2.interpret(context);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AndExpression.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class AndExpression implements Expression &#123;</div><div class="line">	 </div><div class="line">   private Expression expr1 = null;</div><div class="line">   private Expression expr2 = null;</div><div class="line"></div><div class="line">   public AndExpression(Expression expr1, Expression expr2) &#123; </div><div class="line">      this.expr1 = expr1;</div><div class="line">      this.expr2 = expr2;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public boolean interpret(String context) &#123;		</div><div class="line">      return expr1.interpret(context) &amp;&amp; expr2.interpret(context);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong><br>InterpreterPatternDemo 使用 Expression 类来创建规则，并解析它们。</p>
<p>InterpreterPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class InterpreterPatternDemo &#123;</div><div class="line"></div><div class="line">   //规则：Robert 和 John 是男性</div><div class="line">   public static Expression getMaleExpression()&#123;</div><div class="line">      Expression robert = new TerminalExpression(&quot;Robert&quot;);</div><div class="line">      Expression john = new TerminalExpression(&quot;John&quot;);</div><div class="line">      return new OrExpression(robert, john);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //规则：Julie 是一个已婚的女性</div><div class="line">   public static Expression getMarriedWomanExpression()&#123;</div><div class="line">      Expression julie = new TerminalExpression(&quot;Julie&quot;);</div><div class="line">      Expression married = new TerminalExpression(&quot;Married&quot;);</div><div class="line">      return new AndExpression(julie, married);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Expression isMale = getMaleExpression();</div><div class="line">      Expression isMarriedWoman = getMarriedWomanExpression();</div><div class="line"></div><div class="line">      System.out.println(&quot;John is male? &quot; + isMale.interpret(&quot;John&quot;));</div><div class="line">      System.out.println(&quot;Julie is a married women? &quot; </div><div class="line">      + isMarriedWoman.interpret(&quot;Married Julie&quot;));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">John is male? true</div><div class="line">Julie is a married women? true</div></pre></td></tr></table></figure>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。<br>迭代器模式属于行为型模式。<br><strong>意图：</strong>提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。<br><strong>主要解决：</strong>不同的方式来遍历整个整合对象。<br><strong>何时使用：</strong>遍历一个聚合对象。<br><strong>如何解决：</strong>把在元素之间游走的责任交给迭代器，而不是聚合对象。<br><strong>关键代码：</strong>定义接口：hasNext, next。<br><strong>应用实例：</strong>JAVA 中的 iterator。<br><strong>优点：</strong> 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。<br><strong>缺点：</strong>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。<br>使用场景： 1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口。<br><strong>注意事项：</strong>迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。<br><strong>实现</strong><br>我们将创建一个叙述导航方法的 Iterator 接口和一个返回迭代器的 Container 接口。实现了 Container 接口的实体类将负责实现 Iterator 接口。<br>IteratorPatternDemo，我们的演示类使用实体类 NamesRepository 来打印 NamesRepository 中存储为集合的 Names。<br><img src="/2017/08/08/设计模式/iterator_pattern_uml_diagram.jpg" alt="iterator_pattern" title="iterator_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建接口。</p>
<p>Iterator.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface Iterator &#123;</div><div class="line">   public boolean hasNext();</div><div class="line">   public Object next();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Container.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Container &#123;</div><div class="line">   public Iterator getIterator();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现了 Container 接口的实体类。该类有实现了 Iterator 接口的内部类 NameIterator。</p>
<p>NameRepository.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class NameRepository implements Container &#123;</div><div class="line">   public String names[] = &#123;&quot;Robert&quot; , &quot;John&quot; ,&quot;Julie&quot; , &quot;Lora&quot;&#125;;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public Iterator getIterator() &#123;</div><div class="line">      return new NameIterator();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private class NameIterator implements Iterator &#123;</div><div class="line"></div><div class="line">      int index;</div><div class="line"></div><div class="line">      @Override</div><div class="line">      public boolean hasNext() &#123;</div><div class="line">         if(index &lt; names.length)&#123;</div><div class="line">            return true;</div><div class="line">         &#125;</div><div class="line">         return false;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      @Override</div><div class="line">      public Object next() &#123;</div><div class="line">         if(this.hasNext())&#123;</div><div class="line">            return names[index++];</div><div class="line">         &#125;</div><div class="line">         return null;</div><div class="line">      &#125;		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>使用 NameRepository 来获取迭代器，并打印名字。</p>
<p>IteratorPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class IteratorPatternDemo &#123;</div><div class="line">	</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      NameRepository namesRepository = new NameRepository();</div><div class="line"></div><div class="line">      for(Iterator iter = namesRepository.getIterator(); iter.hasNext();)&#123;</div><div class="line">         String name = (String)iter.next();</div><div class="line">         System.out.println(&quot;Name : &quot; + name);</div><div class="line">      &#125; 	</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Name : Robert</div><div class="line">Name : John</div><div class="line">Name : Julie</div><div class="line">Name : Lora</div></pre></td></tr></table></figure>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。<br><strong>意图：</strong>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br><strong>主要解决：</strong>对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。<br><strong>何时使用：</strong>多个类相互耦合，形成了网状结构。<br><strong>如何解决：</strong>将上述网状结构分离为星型结构。<br><strong>关键代码：</strong>对象 Colleague 之间的通信封装到一个类中单独处理。<br><strong>应用实例：</strong> 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。<br><strong>优点：</strong> 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。<br><strong>缺点：</strong>中介者会庞大，变得复杂难以维护。<br>使用场景： 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。<br>注意事项：不应当在职责混乱的时候使用。<br><strong>实现</strong><br>我们通过聊天室实例来演示中介者模式。实例中，多个用户可以向聊天室发送消息，聊天室向所有的用户显示消息。我们将创建两个类 ChatRoom 和 User。User 对象使用 ChatRoom 方法来分享他们的消息。<br>MediatorPatternDemo，我们的演示类使用 User 对象来显示他们之间的通信。<br><img src="/2017/08/08/设计模式/mediator_pattern_uml_diagram.jpg" alt="mediator_pattern" title="mediator_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建中介类。</p>
<p>ChatRoom.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import java.util.Date;</div><div class="line"></div><div class="line">public class ChatRoom &#123;</div><div class="line">   public static void showMessage(User user, String message)&#123;</div><div class="line">      System.out.println(new Date().toString()</div><div class="line">         + &quot; [&quot; + user.getName() +&quot;] : &quot; + message);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建 user 类。</p>
<p>User.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class User &#123;</div><div class="line">   private String name;</div><div class="line"></div><div class="line">   public String getName() &#123;</div><div class="line">      return name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setName(String name) &#123;</div><div class="line">      this.name = name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public User(String name)&#123;</div><div class="line">      this.name  = name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void sendMessage(String message)&#123;</div><div class="line">      ChatRoom.showMessage(this,message);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>使用 User 对象来显示他们之间的通信。</p>
<p>MediatorPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class MediatorPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      User robert = new User(&quot;Robert&quot;);</div><div class="line">      User john = new User(&quot;John&quot;);</div><div class="line"></div><div class="line">      robert.sendMessage(&quot;Hi! John!&quot;);</div><div class="line">      john.sendMessage(&quot;Hello! Robert!&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Thu Jan 31 16:05:46 IST 2013 [Robert] : Hi! John!</div><div class="line">Thu Jan 31 16:05:46 IST 2013 [John] : Hello! Robert!</div></pre></td></tr></table></figure>
<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。<br><strong>意图：</strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。<br><strong>主要解决：</strong>所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。<br><strong>何时使用：</strong>很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。<br><strong>如何解决：</strong>通过一个备忘录类专门存储对象状态。<br><strong>关键代码：</strong>客户不与备忘录类耦合，与备忘录管理类耦合。<br><strong>应用实例：</strong> 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、IE 中的后退。 4、数据库的事务管理。<br><strong>优点：</strong> 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。<br><strong>缺点：</strong>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。<br><strong>使用场景：</strong> 1、需要保存/恢复数据的相关状态场景。 2、提供一个可回滚的操作。<br><strong>注意事项：</strong> 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。<br><strong>实现</strong><br>备忘录模式使用三个类 Memento、Originator 和 CareTaker。Memento 包含了要被恢复的对象的状态。  Originator 创建并在 Memento 对象中存储状态。Caretaker 对象负责从 Memento 中恢复对象的状态。<br>MementoPatternDemo，我们的演示类使用 CareTaker 和 Originator 对象来显示对象的状态恢复。<br><img src="/2017/08/08/设计模式/memento_pattern_uml_diagram.jpg" alt="memento_pattern" title="memento_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建 Memento 类。</p>
<p>Memento.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Memento &#123;</div><div class="line">   private String state;</div><div class="line"></div><div class="line">   public Memento(String state)&#123;</div><div class="line">      this.state = state;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getState()&#123;</div><div class="line">      return state;</div><div class="line">   &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建 Originator 类。</p>
<p>Originator.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Originator &#123;</div><div class="line">   private String state;</div><div class="line"></div><div class="line">   public void setState(String state)&#123;</div><div class="line">      this.state = state;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getState()&#123;</div><div class="line">      return state;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public Memento saveStateToMemento()&#123;</div><div class="line">      return new Memento(state);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void getStateFromMemento(Memento Memento)&#123;</div><div class="line">      state = Memento.getState();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建 CareTaker 类。</p>
<p>CareTaker.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class CareTaker &#123;</div><div class="line">   private List&lt;Memento&gt; mementoList = new ArrayList&lt;Memento&gt;();</div><div class="line"></div><div class="line">   public void add(Memento state)&#123;</div><div class="line">      mementoList.add(state);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public Memento get(int index)&#123;</div><div class="line">      return mementoList.get(index);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 CareTaker 和 Originator 对象。</p>
<p>MementoPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class MementoPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Originator originator = new Originator();</div><div class="line">      CareTaker careTaker = new CareTaker();</div><div class="line">      originator.setState(&quot;State #1&quot;);</div><div class="line">      originator.setState(&quot;State #2&quot;);</div><div class="line">      careTaker.add(originator.saveStateToMemento());</div><div class="line">      originator.setState(&quot;State #3&quot;);</div><div class="line">      careTaker.add(originator.saveStateToMemento());</div><div class="line">      originator.setState(&quot;State #4&quot;);</div><div class="line"></div><div class="line">      System.out.println(&quot;Current State: &quot; + originator.getState());		</div><div class="line">      originator.getStateFromMemento(careTaker.get(0));</div><div class="line">      System.out.println(&quot;First saved State: &quot; + originator.getState());</div><div class="line">      originator.getStateFromMemento(careTaker.get(1));</div><div class="line">      System.out.println(&quot;Second saved State: &quot; + originator.getState());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Current State: State #4</div><div class="line">First saved State: State #2</div><div class="line">Second saved State: State #3</div></pre></td></tr></table></figure>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。<br>意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。<br><strong>主要解决：</strong>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。<br><strong>何时使用：</strong>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。<br><strong>如何解决：</strong>使用面向对象技术，可以将这种依赖关系弱化。<br><strong>关键代码：</strong>在抽象类里有一个 ArrayList 存放观察者们。<br><strong>应用实例：</strong> 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。<br><strong>优点：</strong> 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。<br><strong>缺点：</strong> 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。<br><strong>使用场景：</strong> 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。<br><strong>注意事项：</strong> 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。<br><strong>实现</strong><br>观察者模式使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。我们创建 Subject 类、Observer 抽象类和扩展了抽象类 Observer 的实体类。<br>ObserverPatternDemo，我们的演示类使用 Subject 和实体类对象来演示观察者模式。<br><img src="/2017/08/08/设计模式/observer_pattern_uml_diagram.jpg" alt="observer_pattern" title="observer_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建 Subject 类。</p>
<p>Subject.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class Subject &#123;</div><div class="line">	</div><div class="line">   private List&lt;Observer&gt; observers </div><div class="line">      = new ArrayList&lt;Observer&gt;();</div><div class="line">   private int state;</div><div class="line"></div><div class="line">   public int getState() &#123;</div><div class="line">      return state;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setState(int state) &#123;</div><div class="line">      this.state = state;</div><div class="line">      notifyAllObservers();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void attach(Observer observer)&#123;</div><div class="line">      observers.add(observer);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void notifyAllObservers()&#123;</div><div class="line">      for (Observer observer : observers) &#123;</div><div class="line">         observer.update();</div><div class="line">      &#125;</div><div class="line">   &#125; 	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建 Observer 类。</p>
<p>Observer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public abstract class Observer &#123;</div><div class="line">   protected Subject subject;</div><div class="line">   public abstract void update();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实体观察者类。</p>
<p>BinaryObserver.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class BinaryObserver extends Observer&#123;</div><div class="line"></div><div class="line">   public BinaryObserver(Subject subject)&#123;</div><div class="line">      this.subject = subject;</div><div class="line">      this.subject.attach(this);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void update() &#123;</div><div class="line">      System.out.println( &quot;Binary String: &quot; </div><div class="line">      + Integer.toBinaryString( subject.getState() ) ); </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OctalObserver.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class OctalObserver extends Observer&#123;</div><div class="line"></div><div class="line">   public OctalObserver(Subject subject)&#123;</div><div class="line">      this.subject = subject;</div><div class="line">      this.subject.attach(this);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void update() &#123;</div><div class="line">     System.out.println( &quot;Octal String: &quot; </div><div class="line">     + Integer.toOctalString( subject.getState() ) ); </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>HexaObserver.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class HexaObserver extends Observer&#123;</div><div class="line"></div><div class="line">   public HexaObserver(Subject subject)&#123;</div><div class="line">      this.subject = subject;</div><div class="line">      this.subject.attach(this);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void update() &#123;</div><div class="line">      System.out.println( &quot;Hex String: &quot; </div><div class="line">      + Integer.toHexString( subject.getState() ).toUpperCase() ); </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 Subject 和实体观察者对象。</p>
<p>ObserverPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class ObserverPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Subject subject = new Subject();</div><div class="line"></div><div class="line">      new HexaObserver(subject);</div><div class="line">      new OctalObserver(subject);</div><div class="line">      new BinaryObserver(subject);</div><div class="line"></div><div class="line">      System.out.println(&quot;First state change: 15&quot;);	</div><div class="line">      subject.setState(15);</div><div class="line">      System.out.println(&quot;Second state change: 10&quot;);	</div><div class="line">      subject.setState(10);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">First state change: 15</div><div class="line">Hex String: F</div><div class="line">Octal String: 17</div><div class="line">Binary String: 1111</div><div class="line">Second state change: 10</div><div class="line">Hex String: A</div><div class="line">Octal String: 12</div><div class="line">Binary String: 1010</div></pre></td></tr></table></figure>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。<br>在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。<br>介绍<br><strong>意图：</strong>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。<br><strong>主要解决：</strong>对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。<br><strong>何时使用：</strong>代码中包含大量与对象状态有关的条件语句。<br><strong>如何解决：</strong>将各种具体的状态类抽象出来。<br><strong>关键代码：</strong>通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。<br><strong>应用实例：</strong> 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。<br><strong>优点：</strong> 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。<br><strong>缺点：</strong> 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。<br><strong>使用场景：</strong> 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。<br><strong>注意事项：</strong>在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。<br><strong>实现</strong><br>我们将创建一个 State 接口和实现了 State 接口的实体状态类。Context 是一个带有某个状态的类。<br>StatePatternDemo，我们的演示类使用 Context 和状态对象来演示 Context 在状态改变时的行为变化。<br><img src="/2017/08/08/设计模式/state_pattern_uml_diagram.jpg" alt="state_pattern" title="state_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口。</p>
<p>State.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface State &#123;</div><div class="line">   public void doAction(Context context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>StartState.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class StartState implements State &#123;</div><div class="line"></div><div class="line">   public void doAction(Context context) &#123;</div><div class="line">      System.out.println(&quot;Player is in start state&quot;);</div><div class="line">      context.setState(this);	</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String toString()&#123;</div><div class="line">      return &quot;Start State&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>StopState.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class StopState implements State &#123;</div><div class="line"></div><div class="line">   public void doAction(Context context) &#123;</div><div class="line">      System.out.println(&quot;Player is in stop state&quot;);</div><div class="line">      context.setState(this);	</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String toString()&#123;</div><div class="line">      return &quot;Stop State&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建 Context 类。</p>
<p>Context.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Context &#123;</div><div class="line">   private State state;</div><div class="line"></div><div class="line">   public Context()&#123;</div><div class="line">      state = null;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setState(State state)&#123;</div><div class="line">      this.state = state;		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public State getState()&#123;</div><div class="line">      return state;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 Context 来查看当状态 State 改变时的行为变化。</p>
<p>StatePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class StatePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Context context = new Context();</div><div class="line"></div><div class="line">      StartState startState = new StartState();</div><div class="line">      startState.doAction(context);</div><div class="line"></div><div class="line">      System.out.println(context.getState().toString());</div><div class="line"></div><div class="line">      StopState stopState = new StopState();</div><div class="line">      stopState.doAction(context);</div><div class="line"></div><div class="line">      System.out.println(context.getState().toString());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Player is in start state</div><div class="line">Start State</div><div class="line">Player is in stop state</div><div class="line">Stop State</div></pre></td></tr></table></figure>
<h2 id="空对象模式"><a href="#空对象模式" class="headerlink" title="空对象模式"></a>空对象模式</h2><p>在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。<br>在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。<br><strong>实现</strong><br>我们将创建一个定义操作（在这里，是客户的名称）的 AbstractCustomer 抽象类，和扩展了 AbstractCustomer 类的实体类。工厂类 CustomerFactory 基于客户传递的名字来返回 RealCustomer 或 NullCustomer 对象。<br>NullPatternDemo，我们的演示类使用 CustomerFactory 来演示空对象模式的用法。<br><img src="/2017/08/08/设计模式/null_pattern_uml_diagram.jpg" alt="null_pattern" title="null_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个抽象类。</p>
<p>AbstractCustomer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public abstract class AbstractCustomer &#123;</div><div class="line">   protected String name;</div><div class="line">   public abstract boolean isNil();</div><div class="line">   public abstract String getName();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建扩展了上述类的实体类。</p>
<p>RealCustomer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class RealCustomer extends AbstractCustomer &#123;</div><div class="line"></div><div class="line">   public RealCustomer(String name) &#123;</div><div class="line">      this.name = name;		</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @Override</div><div class="line">   public String getName() &#123;</div><div class="line">      return name;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @Override</div><div class="line">   public boolean isNil() &#123;</div><div class="line">      return false;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>NullCustomer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class NullCustomer extends AbstractCustomer &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String getName() &#123;</div><div class="line">      return &quot;Not Available in Customer Database&quot;;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public boolean isNil() &#123;</div><div class="line">      return true;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建 CustomerFactory 类。</p>
<p>CustomerFactory.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class CustomerFactory &#123;</div><div class="line">	</div><div class="line">   public static final String[] names = &#123;&quot;Rob&quot;, &quot;Joe&quot;, &quot;Julie&quot;&#125;;</div><div class="line"></div><div class="line">   public static AbstractCustomer getCustomer(String name)&#123;</div><div class="line">      for (int i = 0; i &lt; names.length; i++) &#123;</div><div class="line">         if (names[i].equalsIgnoreCase(name))&#123;</div><div class="line">            return new RealCustomer(name);</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      return new NullCustomer();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 CustomerFactory，基于客户传递的名字，来获取 RealCustomer 或 NullCustomer 对象。</p>
<p>NullPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class NullPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      AbstractCustomer customer1 = CustomerFactory.getCustomer(&quot;Rob&quot;);</div><div class="line">      AbstractCustomer customer2 = CustomerFactory.getCustomer(&quot;Bob&quot;);</div><div class="line">      AbstractCustomer customer3 = CustomerFactory.getCustomer(&quot;Julie&quot;);</div><div class="line">      AbstractCustomer customer4 = CustomerFactory.getCustomer(&quot;Laura&quot;);</div><div class="line"></div><div class="line">      System.out.println(&quot;Customers&quot;);</div><div class="line">      System.out.println(customer1.getName());</div><div class="line">      System.out.println(customer2.getName());</div><div class="line">      System.out.println(customer3.getName());</div><div class="line">      System.out.println(customer4.getName());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Customers</div><div class="line">Rob</div><div class="line">Not Available in Customer Database</div><div class="line">Julie</div><div class="line">Not Available in Customer Database</div></pre></td></tr></table></figure>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。<br>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。<br><strong>意图：</strong>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。<br><strong>主要解决：</strong>在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。<br><strong>何时使用：</strong>一个系统有许多许多类，而区分它们的只是他们直接的行为。<br><strong>如何解决：</strong>将这些算法封装成一个一个的类，任意地替换。<br><strong>关键代码：</strong>实现同一个接口。<br><strong>应用实例：</strong> 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。<br><strong>优点：</strong> 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。<br><strong>缺点：</strong> 1、策略类会增多。 2、所有策略类都需要对外暴露。<br><strong>使用场景：</strong> 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。<br>注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。<br><strong>实现 </strong><br>我们将创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。<br>StrategyPatternDemo，我们的演示类使用 Context 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。<br><img src="/2017/08/08/设计模式/strategy_pattern_uml_diagram.jpg" alt="strategy_pattern" title="strategy_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口。</p>
<p>Strategy.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Strategy &#123;</div><div class="line">   public int doOperation(int num1, int num2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>OperationAdd.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class OperationAdd implements Strategy&#123;</div><div class="line">   @Override</div><div class="line">   public int doOperation(int num1, int num2) &#123;</div><div class="line">      return num1 + num2;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OperationSubstract.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class OperationSubstract implements Strategy&#123;</div><div class="line">   @Override</div><div class="line">   public int doOperation(int num1, int num2) &#123;</div><div class="line">      return num1 - num2;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OperationMultiply.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class OperationMultiply implements Strategy&#123;</div><div class="line">   @Override</div><div class="line">   public int doOperation(int num1, int num2) &#123;</div><div class="line">      return num1 * num2;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建 Context 类。</p>
<p>Context.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Context &#123;</div><div class="line">   private Strategy strategy;</div><div class="line"></div><div class="line">   public Context(Strategy strategy)&#123;</div><div class="line">      this.strategy = strategy;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public int executeStrategy(int num1, int num2)&#123;</div><div class="line">      return strategy.doOperation(num1, num2);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 Context 来查看当它改变策略 Strategy 时的行为变化。</p>
<p>StrategyPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class StrategyPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Context context = new Context(new OperationAdd());		</div><div class="line">      System.out.println(&quot;10 + 5 = &quot; + context.executeStrategy(10, 5));</div><div class="line"></div><div class="line">      context = new Context(new OperationSubstract());		</div><div class="line">      System.out.println(&quot;10 - 5 = &quot; + context.executeStrategy(10, 5));</div><div class="line"></div><div class="line">      context = new Context(new OperationMultiply());		</div><div class="line">      System.out.println(&quot;10 * 5 = &quot; + context.executeStrategy(10, 5));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">10 + 5 = 15</div><div class="line">10 - 5 = 5</div><div class="line">10 * 5 = 50</div></pre></td></tr></table></figure>
<h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。<br>意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br><strong>主要解决：</strong>一些方法通用，却在每一个子类都重新写了这一方法。<br><strong>何时使用：</strong>有一些通用的方法。<br><strong>如何解决：</strong>将这些通用算法抽象出来。<br><strong>关键代码：</strong>在抽象类实现，其他步骤在子类实现。<br><strong>应用实例：</strong> 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。<br><strong>优点：</strong> 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。<br><strong>缺点：</strong>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。<br><strong>使用场景：</strong> 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。<br><strong>注意事项：</strong>为防止恶意操作，一般模板方法都加上 final 关键词。<br><strong>实现</strong><br>我们将创建一个定义操作的 Game 抽象类，其中，模板方法设置为 final，这样它就不会被重写。Cricket 和 Football 是扩展了 Game 的实体类，它们重写了抽象类的方法。<br>TemplatePatternDemo，我们的演示类使用 Game 来演示模板模式的用法。<br><img src="/2017/08/08/设计模式/template_pattern_uml_diagram.jpg" alt="template_pattern" title="template_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个抽象类，它的模板方法被设置为 final。</p>
<p>Game.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public abstract class Game &#123;</div><div class="line">   abstract void initialize();</div><div class="line">   abstract void startPlay();</div><div class="line">   abstract void endPlay();</div><div class="line"></div><div class="line">   //模板</div><div class="line">   public final void play()&#123;</div><div class="line"></div><div class="line">      //初始化游戏</div><div class="line">      initialize();</div><div class="line"></div><div class="line">      //开始游戏</div><div class="line">      startPlay();</div><div class="line"></div><div class="line">      //结束游戏</div><div class="line">      endPlay();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建扩展了上述类的实体类。</p>
<p>Cricket.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Cricket extends Game &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   void endPlay() &#123;</div><div class="line">      System.out.println(&quot;Cricket Game Finished!&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   void initialize() &#123;</div><div class="line">      System.out.println(&quot;Cricket Game Initialized! Start playing.&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   void startPlay() &#123;</div><div class="line">      System.out.println(&quot;Cricket Game Started. Enjoy the game!&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Football.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Football extends Game &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   void endPlay() &#123;</div><div class="line">      System.out.println(&quot;Football Game Finished!&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   void initialize() &#123;</div><div class="line">      System.out.println(&quot;Football Game Initialized! Start playing.&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   void startPlay() &#123;</div><div class="line">      System.out.println(&quot;Football Game Started. Enjoy the game!&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>使用 Game 的模板方法 play() 来演示游戏的定义方式。</p>
<p>TemplatePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class TemplatePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      Game game = new Cricket();</div><div class="line">      game.play();</div><div class="line">      System.out.println();</div><div class="line">      game = new Football();</div><div class="line">      game.play();		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Cricket Game Initialized! Start playing.</div><div class="line">Cricket Game Started. Enjoy the game!</div><div class="line">Cricket Game Finished!</div><div class="line"></div><div class="line">Football Game Initialized! Start playing.</div><div class="line">Football Game Started. Enjoy the game!</div><div class="line">Football Game Finished!</div></pre></td></tr></table></figure>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。<br>意图：主要将数据结构与数据操作分离。<br><strong> 主要解决：</strong> 稳定的数据结构和易变的操作耦合问题。<br><strong> 何时使用：</strong> 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。<br><strong> 如何解决：</strong> 在被访问的类里面加一个对外提供接待访问者的接口。<br><strong> 关键代码：</strong> 在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。<br><strong> 应用实例：</strong> 您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。<br><strong> 优点：</strong>  1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。<br><strong> 缺点：</strong>  1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。<br><strong> 使用场景：</strong>  1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。<br><strong> 注意事项：</strong> 访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。<br><strong> 实现</strong><br>我们将创建一个定义接受操作的 ComputerPart 接口。Keyboard、Mouse、Monitor 和 Computer 是实现了 ComputerPart 接口的实体类。我们将定义另一个接口 ComputerPartVisitor，它定义了访问者类的操作。Computer 使用实体访问者来执行相应的动作。<br>VisitorPatternDemo，我们的演示类使用 Computer、ComputerPartVisitor 类来演示访问者模式的用法。<br><img src="/2017/08/08/设计模式/visitor_pattern_uml_diagram.jpg" alt="visitor_pattern" title="visitor_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>定义一个表示元素的接口。</p>
<p>ComputerPart.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface ComputerPart &#123;</div><div class="line">   public void accept(ComputerPartVisitor computerPartVisitor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建扩展了上述类的实体类。</p>
<p>Keyboard.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Keyboard  implements ComputerPart &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void accept(ComputerPartVisitor computerPartVisitor) &#123;</div><div class="line">      computerPartVisitor.visit(this);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Monitor.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Monitor  implements ComputerPart &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void accept(ComputerPartVisitor computerPartVisitor) &#123;</div><div class="line">      computerPartVisitor.visit(this);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Mouse.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Mouse  implements ComputerPart &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void accept(ComputerPartVisitor computerPartVisitor) &#123;</div><div class="line">      computerPartVisitor.visit(this);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Computer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Computer implements ComputerPart &#123;</div><div class="line">	</div><div class="line">   ComputerPart[] parts;</div><div class="line"></div><div class="line">   public Computer()&#123;</div><div class="line">      parts = new ComputerPart[] &#123;new Mouse(), new Keyboard(), new Monitor()&#125;;		</div><div class="line">   &#125; </div><div class="line"></div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void accept(ComputerPartVisitor computerPartVisitor) &#123;</div><div class="line">      for (int i = 0; i &lt; parts.length; i++) &#123;</div><div class="line">         parts[i].accept(computerPartVisitor);</div><div class="line">      &#125;</div><div class="line">      computerPartVisitor.visit(this);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>定义一个表示访问者的接口。</p>
<p>ComputerPartVisitor.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public interface ComputerPartVisitor &#123;</div><div class="line">	public void visit(Computer computer);</div><div class="line">	public void visit(Mouse mouse);</div><div class="line">	public void visit(Keyboard keyboard);</div><div class="line">	public void visit(Monitor monitor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建实现了上述类的实体访问者。</p>
<p>ComputerPartDisplayVisitor.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class ComputerPartDisplayVisitor implements ComputerPartVisitor &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void visit(Computer computer) &#123;</div><div class="line">      System.out.println(&quot;Displaying Computer.&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void visit(Mouse mouse) &#123;</div><div class="line">      System.out.println(&quot;Displaying Mouse.&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void visit(Keyboard keyboard) &#123;</div><div class="line">      System.out.println(&quot;Displaying Keyboard.&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void visit(Monitor monitor) &#123;</div><div class="line">      System.out.println(&quot;Displaying Monitor.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>使用 ComputerPartDisplayVisitor 来显示 Computer 的组成部分。</p>
<p>VisitorPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class VisitorPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      ComputerPart computer = new Computer();</div><div class="line">      computer.accept(new ComputerPartDisplayVisitor());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Displaying Mouse.</div><div class="line">Displaying Keyboard.</div><div class="line">Displaying Monitor.</div><div class="line">Displaying Computer.</div></pre></td></tr></table></figure>
<h2 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC 模式"></a>MVC 模式</h2><p>MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。<br><strong>Model（模型）</strong> - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。<br><strong>View（视图） </strong>- 视图代表模型包含的数据的可视化。<br><strong>Controller（控制器）</strong> - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。<br><strong>实现</strong><br>我们将创建一个作为模型的 Student 对象。StudentView 是一个把学生详细信息输出到控制台的视图类，StudentController 是负责存储数据到 Student 对象中的控制器类，并相应地更新视图 StudentView。<br>MVCPatternDemo，我们的演示类使用 StudentController 来演示 MVC 模式的用法。</p>
<p><img src="/2017/08/08/设计模式/mvc_pattern_uml_diagram.jpg" alt="mvc_pattern" title="mvc_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建模型。</p>
<p>Student.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Student &#123;</div><div class="line">   private String rollNo;</div><div class="line">   private String name;</div><div class="line">   public String getRollNo() &#123;</div><div class="line">      return rollNo;</div><div class="line">   &#125;</div><div class="line">   public void setRollNo(String rollNo) &#123;</div><div class="line">      this.rollNo = rollNo;</div><div class="line">   &#125;</div><div class="line">   public String getName() &#123;</div><div class="line">      return name;</div><div class="line">   &#125;</div><div class="line">   public void setName(String name) &#123;</div><div class="line">      this.name = name;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建视图。</p>
<p>StudentView.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class StudentView &#123;</div><div class="line">   public void printStudentDetails(String studentName, String studentRollNo)&#123;</div><div class="line">      System.out.println(&quot;Student: &quot;);</div><div class="line">      System.out.println(&quot;Name: &quot; + studentName);</div><div class="line">      System.out.println(&quot;Roll No: &quot; + studentRollNo);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建控制器。</p>
<p>StudentController.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class StudentController &#123;</div><div class="line">   private Student model;</div><div class="line">   private StudentView view;</div><div class="line"></div><div class="line">   public StudentController(Student model, StudentView view)&#123;</div><div class="line">      this.model = model;</div><div class="line">      this.view = view;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setStudentName(String name)&#123;</div><div class="line">      model.setName(name);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getStudentName()&#123;</div><div class="line">      return model.getName();		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setStudentRollNo(String rollNo)&#123;</div><div class="line">      model.setRollNo(rollNo);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getStudentRollNo()&#123;</div><div class="line">      return model.getRollNo();		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void updateView()&#123;				</div><div class="line">      view.printStudentDetails(model.getName(), model.getRollNo());</div><div class="line">   &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 StudentController 方法来演示 MVC 设计模式的用法。</p>
<p>MVCPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class MVCPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      //从数据可获取学生记录</div><div class="line">      Student model  = retriveStudentFromDatabase();</div><div class="line"></div><div class="line">      //创建一个视图：把学生详细信息输出到控制台</div><div class="line">      StudentView view = new StudentView();</div><div class="line"></div><div class="line">      StudentController controller = new StudentController(model, view);</div><div class="line"></div><div class="line">      controller.updateView();</div><div class="line"></div><div class="line">      //更新模型数据</div><div class="line">      controller.setStudentName(&quot;John&quot;);</div><div class="line"></div><div class="line">      controller.updateView();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private static Student retriveStudentFromDatabase()&#123;</div><div class="line">      Student student = new Student();</div><div class="line">      student.setName(&quot;Robert&quot;);</div><div class="line">      student.setRollNo(&quot;10&quot;);</div><div class="line">      return student;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Student: </div><div class="line">Name: Robert</div><div class="line">Roll No: 10</div><div class="line">Student: </div><div class="line">Name: John</div><div class="line">Roll No: 10</div></pre></td></tr></table></figure>
<h2 id="业务代表模式"><a href="#业务代表模式" class="headerlink" title="业务代表模式"></a>业务代表模式</h2><p>业务代表模式（Business Delegate Pattern）用于对表示层和业务层解耦。它基本上是用来减少通信或对表示层代码中的业务层代码的远程查询功能。在业务层中我们有以下实体。<br><strong>客户端（Client）</strong> - 表示层代码可以是 JSP、servlet 或 UI java 代码。<br><strong>业务代表（Business Delegate）</strong> - 一个为客户端实体提供的入口类，它提供了对业务服务方法的访问。<br><strong>查询服务（LookUp Service）</strong> - 查找服务对象负责获取相关的业务实现，并提供业务对象对业务代表对象的访问。<br><strong>业务服务（Business Service）</strong> - 业务服务接口。实现了该业务服务的实体类，提供了实际的业务实现逻辑。<br><strong>实现</strong><br>我们将创建 Client、BusinessDelegate、BusinessService、LookUpService、JMSService 和 EJBService 来表示业务代表模式中的各种实体。<br>BusinessDelegatePatternDemo，我们的演示类使用 BusinessDelegate 和 Client 来演示业务代表模式的用法。<br><img src="/2017/08/08/设计模式/business_delegate_pattern_uml_diagram.jpg" alt="business_delegate_pattern" title="business_delegate_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建 BusinessService 接口。</p>
<p>BusinessService.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface BusinessService &#123;</div><div class="line">   public void doProcessing();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实体服务类。</p>
<p>EJBService.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class EJBService implements BusinessService &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void doProcessing() &#123;</div><div class="line">      System.out.println(&quot;Processing task by invoking EJB Service&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JMSService.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class JMSService implements BusinessService &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void doProcessing() &#123;</div><div class="line">      System.out.println(&quot;Processing task by invoking JMS Service&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建业务查询服务。</p>
<p>BusinessLookUp.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class BusinessLookUp &#123;</div><div class="line">   public BusinessService getBusinessService(String serviceType)&#123;</div><div class="line">      if(serviceType.equalsIgnoreCase(&quot;EJB&quot;))&#123;</div><div class="line">         return new EJBService();</div><div class="line">      &#125;else &#123;</div><div class="line">         return new JMSService();</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建业务代表。</p>
<p>BusinessDelegate.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class BusinessDelegate &#123;</div><div class="line">   private BusinessLookUp lookupService = new BusinessLookUp();</div><div class="line">   private BusinessService businessService;</div><div class="line">   private String serviceType;</div><div class="line"></div><div class="line">   public void setServiceType(String serviceType)&#123;</div><div class="line">      this.serviceType = serviceType;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void doTask()&#123;</div><div class="line">      businessService = lookupService.getBusinessService(serviceType);</div><div class="line">      businessService.doProcessing();		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>创建客户端。</p>
<p>Client.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">	</div><div class="line">   BusinessDelegate businessService;</div><div class="line"></div><div class="line">   public Client(BusinessDelegate businessService)&#123;</div><div class="line">      this.businessService  = businessService;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void doTask()&#123;		</div><div class="line">      businessService.doTask();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>使用 BusinessDelegate 和 Client 类来演示业务代表模式。</p>
<p>BusinessDelegatePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class BusinessDelegatePatternDemo &#123;</div><div class="line">	</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      BusinessDelegate businessDelegate = new BusinessDelegate();</div><div class="line">      businessDelegate.setServiceType(&quot;EJB&quot;);</div><div class="line"></div><div class="line">      Client client = new Client(businessDelegate);</div><div class="line">      client.doTask();</div><div class="line"></div><div class="line">      businessDelegate.setServiceType(&quot;JMS&quot;);</div><div class="line">      client.doTask();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 7</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Processing task by invoking EJB Service</div><div class="line">Processing task by invoking JMS Service</div></pre></td></tr></table></figure>
<h2 id="组合实体模式"><a href="#组合实体模式" class="headerlink" title="组合实体模式"></a>组合实体模式</h2><p>组合实体模式（Composite Entity Pattern）用在 EJB 持久化机制中。一个组合实体是一个 EJB 实体 bean，代表了对象的图解。当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean 管理的。以下是组合实体 bean 的参与者。<br><strong>组合实体（Composite Entity）</strong> - 它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期。<br><strong>粗粒度对象（Coarse-Grained Object）</strong> - 该对象包含依赖对象。它有自己的生命周期，也能管理依赖对象的生命周期。<br><strong>依赖对象（Dependent Object）</strong> - 依赖对象是一个持续生命周期依赖于粗粒度对象的对象。<br><strong>策略（Strategies）</strong> - 策略表示如何实现组合实体。<br><strong>实现</strong><br>我们将创建作为组合实体的 CompositeEntity 对象。CoarseGrainedObject 是一个包含依赖对象的类。<br>CompositeEntityPatternDemo，我们的演示类使用 Client 类来演示组合实体模式的用法。<br><img src="/2017/08/08/设计模式/compositeentity_pattern_uml_diagram.jpg" alt="compositeentity_pattern" title="compositeentity_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建依赖对象。</p>
<p>DependentObject1.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class DependentObject1 &#123;</div><div class="line">	</div><div class="line">   private String data;</div><div class="line"></div><div class="line">   public void setData(String data)&#123;</div><div class="line">      this.data = data; </div><div class="line">   &#125; </div><div class="line"></div><div class="line">   public String getData()&#123;</div><div class="line">      return data;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DependentObject2.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class DependentObject2 &#123;</div><div class="line">	</div><div class="line">   private String data;</div><div class="line"></div><div class="line">   public void setData(String data)&#123;</div><div class="line">      this.data = data; </div><div class="line">   &#125; </div><div class="line"></div><div class="line">   public String getData()&#123;</div><div class="line">      return data;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建粗粒度对象。</p>
<p>CoarseGrainedObject.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class CoarseGrainedObject &#123;</div><div class="line">   DependentObject1 do1 = new DependentObject1();</div><div class="line">   DependentObject2 do2 = new DependentObject2();</div><div class="line"></div><div class="line">   public void setData(String data1, String data2)&#123;</div><div class="line">      do1.setData(data1);</div><div class="line">      do2.setData(data2);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String[] getData()&#123;</div><div class="line">      return new String[] &#123;do1.getData(),do2.getData()&#125;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建组合实体。</p>
<p>CompositeEntity.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class CompositeEntity &#123;</div><div class="line">   private CoarseGrainedObject cgo = new CoarseGrainedObject();</div><div class="line"></div><div class="line">   public void setData(String data1, String data2)&#123;</div><div class="line">      cgo.setData(data1, data2);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String[] getData()&#123;</div><div class="line">      return cgo.getData();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建使用组合实体的客户端类。</p>
<p>Client.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">   private CompositeEntity compositeEntity = new CompositeEntity();</div><div class="line"></div><div class="line">   public void printData()&#123;</div><div class="line">      for (int i = 0; i &lt; compositeEntity.getData().length; i++) &#123;</div><div class="line">         System.out.println(&quot;Data: &quot; + compositeEntity.getData()[i]);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setData(String data1, String data2)&#123;</div><div class="line">      compositeEntity.setData(data1, data2);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>使用 Client 来演示组合实体设计模式的用法。</p>
<p>CompositeEntityPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class CompositeEntityPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">       Client client = new Client();</div><div class="line">       client.setData(&quot;Test&quot;, &quot;Data&quot;);</div><div class="line">       client.printData();</div><div class="line">       client.setData(&quot;Second Test&quot;, &quot;Data1&quot;);</div><div class="line">       client.printData();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Data: Test</div><div class="line">Data: Data</div><div class="line">Data: Second Test</div><div class="line">Data: Data1</div></pre></td></tr></table></figure>
<h2 id="数据访问对象模式"><a href="#数据访问对象模式" class="headerlink" title="数据访问对象模式"></a>数据访问对象模式</h2><p>数据访问对象模式（Data Access Object Pattern）或 DAO 模式用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者。<br><strong>数据访问对象接口（Data Access Object Interface）</strong> - 该接口定义了在一个模型对象上要执行的标准操作。<br><strong>数据访问对象实体类（Data Access Object concrete class）</strong> - 该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。<br><strong>模型对象/数值对象（Model Object/Value Object）</strong> - 该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据。<br><strong>实现 </strong><br>我们将创建一个作为模型对象或数值对象的 Student 对象。StudentDao 是数据访问对象接口。StudentDaoImpl 是实现了数据访问对象接口的实体类。DaoPatternDemo，我们的演示类使用 StudentDao 来演示数据访问对象模式的用法。<br><img src="/2017/08/08/设计模式/dao_pattern_uml_diagram.jpg" alt="dao_pattern" title="dao_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建数值对象。</p>
<p>Student.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class Student &#123;</div><div class="line">   private String name;</div><div class="line">   private int rollNo;</div><div class="line"></div><div class="line">   Student(String name, int rollNo)&#123;</div><div class="line">      this.name = name;</div><div class="line">      this.rollNo = rollNo;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getName() &#123;</div><div class="line">      return name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setName(String name) &#123;</div><div class="line">      this.name = name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public int getRollNo() &#123;</div><div class="line">      return rollNo;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setRollNo(int rollNo) &#123;</div><div class="line">      this.rollNo = rollNo;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建数据访问对象接口。</p>
<p>StudentDao.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public interface StudentDao &#123;</div><div class="line">   public List&lt;Student&gt; getAllStudents();</div><div class="line">   public Student getStudent(int rollNo);</div><div class="line">   public void updateStudent(Student student);</div><div class="line">   public void deleteStudent(Student student);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实现了上述接口的实体类。</p>
<p>StudentDaoImpl.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class StudentDaoImpl implements StudentDao &#123;</div><div class="line">	</div><div class="line">   //列表是当作一个数据库</div><div class="line">   List&lt;Student&gt; students;</div><div class="line"></div><div class="line">   public StudentDaoImpl()&#123;</div><div class="line">      students = new ArrayList&lt;Student&gt;();</div><div class="line">      Student student1 = new Student(&quot;Robert&quot;,0);</div><div class="line">      Student student2 = new Student(&quot;John&quot;,1);</div><div class="line">      students.add(student1);</div><div class="line">      students.add(student2);		</div><div class="line">   &#125;</div><div class="line">   @Override</div><div class="line">   public void deleteStudent(Student student) &#123;</div><div class="line">      students.remove(student.getRollNo());</div><div class="line">      System.out.println(&quot;Student: Roll No &quot; + student.getRollNo() </div><div class="line">         +&quot;, deleted from database&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //从数据库中检索学生名单</div><div class="line">   @Override</div><div class="line">   public List&lt;Student&gt; getAllStudents() &#123;</div><div class="line">      return students;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public Student getStudent(int rollNo) &#123;</div><div class="line">      return students.get(rollNo);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void updateStudent(Student student) &#123;</div><div class="line">      students.get(student.getRollNo()).setName(student.getName());</div><div class="line">      System.out.println(&quot;Student: Roll No &quot; + student.getRollNo() </div><div class="line">         +&quot;, updated in the database&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 StudentDao 来演示数据访问对象模式的用法。</p>
<p>CompositeEntityPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class DaoPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      StudentDao studentDao = new StudentDaoImpl();</div><div class="line"></div><div class="line">      //输出所有的学生</div><div class="line">      for (Student student : studentDao.getAllStudents()) &#123;</div><div class="line">         System.out.println(&quot;Student: [RollNo : &quot;</div><div class="line">            +student.getRollNo()+&quot;, Name : &quot;+student.getName()+&quot; ]&quot;);</div><div class="line">      &#125;</div><div class="line"></div><div class="line"></div><div class="line">      //更新学生</div><div class="line">      Student student =studentDao.getAllStudents().get(0);</div><div class="line">      student.setName(&quot;Michael&quot;);</div><div class="line">      studentDao.updateStudent(student);</div><div class="line"></div><div class="line">      //获取学生</div><div class="line">      studentDao.getStudent(0);</div><div class="line">      System.out.println(&quot;Student: [RollNo : &quot;</div><div class="line">         +student.getRollNo()+&quot;, Name : &quot;+student.getName()+&quot; ]&quot;);		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Student: [RollNo : 0, Name : Robert ]</div><div class="line">Student: [RollNo : 1, Name : John ]</div><div class="line">Student: Roll No 0, updated in the database</div><div class="line">Student: [RollNo : 0, Name : Michael ]</div></pre></td></tr></table></figure>
<h2 id="前端控制器模式"><a href="#前端控制器模式" class="headerlink" title="前端控制器模式"></a>前端控制器模式</h2><p>前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。<br><strong>前端控制器（Front Controller）</strong> - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。<br><strong>调度器（Dispatcher）</strong> - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。<br><strong>视图（View）</strong> - 视图是为请求而创建的对象。<br><strong>实现 </strong><br>我们将创建 FrontController、Dispatcher 分别当作前端控制器和调度器。HomeView 和 StudentView 表示各种为前端控制器接收到的请求而创建的视图。<br>FrontControllerPatternDemo，我们的演示类使用 FrontController 来演示前端控制器设计模式。<br><img src="/2017/08/08/设计模式/frontcontroller_pattern_uml_diagram.jpg" alt="frontcontroller_pattern" title="frontcontroller_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建视图。</p>
<p>HomeView.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class HomeView &#123;</div><div class="line">   public void show()&#123;</div><div class="line">      System.out.println(&quot;Displaying Home Page&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>StudentView.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class StudentView &#123;</div><div class="line">   public void show()&#123;</div><div class="line">      System.out.println(&quot;Displaying Student Page&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建调度器 Dispatcher。</p>
<p>Dispatcher.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Dispatcher &#123;</div><div class="line">   private StudentView studentView;</div><div class="line">   private HomeView homeView;</div><div class="line">   public Dispatcher()&#123;</div><div class="line">      studentView = new StudentView();</div><div class="line">      homeView = new HomeView();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void dispatch(String request)&#123;</div><div class="line">      if(request.equalsIgnoreCase(&quot;STUDENT&quot;))&#123;</div><div class="line">         studentView.show();</div><div class="line">      &#125;else&#123;</div><div class="line">         homeView.show();</div><div class="line">      &#125;	</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建前端控制器 FrontController。</p>
<p>Context.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class FrontController &#123;</div><div class="line">	</div><div class="line">   private Dispatcher dispatcher;</div><div class="line"></div><div class="line">   public FrontController()&#123;</div><div class="line">      dispatcher = new Dispatcher();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private boolean isAuthenticUser()&#123;</div><div class="line">      System.out.println(&quot;User is authenticated successfully.&quot;);</div><div class="line">      return true;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private void trackRequest(String request)&#123;</div><div class="line">      System.out.println(&quot;Page requested: &quot; + request);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void dispatchRequest(String request)&#123;</div><div class="line">      //记录每一个请求</div><div class="line">      trackRequest(request);</div><div class="line">      //对用户进行身份验证</div><div class="line">      if(isAuthenticUser())&#123;</div><div class="line">         dispatcher.dispatch(request);</div><div class="line">      &#125;	</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 FrontController 来演示前端控制器设计模式。</p>
<p>FrontControllerPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class FrontControllerPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      FrontController frontController = new FrontController();</div><div class="line">      frontController.dispatchRequest(&quot;HOME&quot;);</div><div class="line">      frontController.dispatchRequest(&quot;STUDENT&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Page requested: HOME</div><div class="line">User is authenticated successfully.</div><div class="line">Displaying Home Page</div><div class="line">Page requested: STUDENT</div><div class="line">User is authenticated successfully.</div><div class="line">Displaying Student Page</div></pre></td></tr></table></figure>
<h2 id="拦截过滤器模式"><a href="#拦截过滤器模式" class="headerlink" title="拦截过滤器模式"></a>拦截过滤器模式</h2><p>拦截过滤器模式（Intercepting Filter Pattern）用于对应用程序的请求或响应做一些预处理/后处理。定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上。过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。<br><strong>过滤器（Filter）</strong> - 过滤器在请求处理程序执行请求之前或之后，执行某些任务。<br><strong>过滤器链（Filter Chain）</strong> - 过滤器链带有多个过滤器，并在 Target 上按照定义的顺序执行这些过滤器。<br><strong>Target </strong>- Target 对象是请求处理程序。<br><strong>过滤管理器（Filter Manager）</strong> - 过滤管理器管理过滤器和过滤器链。<br><strong>客户端（Client）</strong> - Client 是向 Target 对象发送请求的对象。<br><strong>实现</strong><br>我们将创建 FilterChain、FilterManager、Target、Client 作为表示实体的各种对象。AuthenticationFilter 和 DebugFilter 表示实体过滤器。<br>InterceptingFilterDemo，我们的演示类使用 Client 来演示拦截过滤器设计模式。<br><img src="/2017/08/08/设计模式/interceptingfilter_pattern_uml_diagram.jpg" alt="interceptingfilter_pattern" title="interceptingfilter_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建过滤器接口 Filter。</p>
<p>Filter.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Filter &#123;</div><div class="line">   public void execute(String request);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实体过滤器。</p>
<p>AuthenticationFilter.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class AuthenticationFilter implements Filter &#123;</div><div class="line">   public void execute(String request)&#123;</div><div class="line">      System.out.println(&quot;Authenticating request: &quot; + request);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DebugFilter.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class DebugFilter implements Filter &#123;</div><div class="line">   public void execute(String request)&#123;</div><div class="line">      System.out.println(&quot;request log: &quot; + request);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建 Target。</p>
<p>Target.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class Target &#123;</div><div class="line">   public void execute(String request)&#123;</div><div class="line">      System.out.println(&quot;Executing request: &quot; + request);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建过滤器链。</p>
<p>FilterChain.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class FilterChain &#123;</div><div class="line">   private List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;();</div><div class="line">   private Target target;</div><div class="line"></div><div class="line">   public void addFilter(Filter filter)&#123;</div><div class="line">      filters.add(filter);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void execute(String request)&#123;</div><div class="line">      for (Filter filter : filters) &#123;</div><div class="line">         filter.execute(request);</div><div class="line">      &#125;</div><div class="line">      target.execute(request);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setTarget(Target target)&#123;</div><div class="line">      this.target = target;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>创建过滤管理器。</p>
<p>FilterManager.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class FilterManager &#123;</div><div class="line">   FilterChain filterChain;</div><div class="line"></div><div class="line">   public FilterManager(Target target)&#123;</div><div class="line">      filterChain = new FilterChain();</div><div class="line">      filterChain.setTarget(target);</div><div class="line">   &#125;</div><div class="line">   public void setFilter(Filter filter)&#123;</div><div class="line">      filterChain.addFilter(filter);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void filterRequest(String request)&#123;</div><div class="line">      filterChain.execute(request);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>创建客户端 Client。</p>
<p>Client.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">   FilterManager filterManager;</div><div class="line"></div><div class="line">   public void setFilterManager(FilterManager filterManager)&#123;</div><div class="line">      this.filterManager = filterManager;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void sendRequest(String request)&#123;</div><div class="line">      filterManager.filterRequest(request);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 7</strong></p>
<p>使用 Client 来演示拦截过滤器设计模式。</p>
<p>FrontControllerPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class InterceptingFilterDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      FilterManager filterManager = new FilterManager(new Target());</div><div class="line">      filterManager.setFilter(new AuthenticationFilter());</div><div class="line">      filterManager.setFilter(new DebugFilter());</div><div class="line"></div><div class="line">      Client client = new Client();</div><div class="line">      client.setFilterManager(filterManager);</div><div class="line">      client.sendRequest(&quot;HOME&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 8</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Authenticating request: HOME</div><div class="line">request log: HOME</div><div class="line">Executing request: HOME</div></pre></td></tr></table></figure>
<h2 id="服务定位器模式"><a href="#服务定位器模式" class="headerlink" title="服务定位器模式"></a>服务定位器模式</h2><p>服务定位器模式（Service Locator Pattern）用在我们想使用 JNDI 查询定位各种服务的时候。考虑到为某个服务查找 JNDI 的代价很高，服务定位器模式充分利用了缓存技术。在首次请求某个服务时，服务定位器在 JNDI 中查找服务，并缓存该服务对象。当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能。以下是这种设计模式的实体。<br><strong>服务（Service）</strong> - 实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到。<br><strong>Context / 初始的 Context</strong> - JNDI Context 带有对要查找的服务的引用。<br><strong>服务定位器（Service Locator）</strong> - 服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触。<br><strong>缓存（Cache）</strong> - 缓存存储服务的引用，以便复用它们。<br><strong>客户端（Client）</strong> - Client 是通过 ServiceLocator 调用服务的对象。<br><strong>实现</strong><br>我们将创建 ServiceLocator、InitialContext、Cache、Service 作为表示实体的各种对象。Service1 和 Service2 表示实体服务。<br>ServiceLocatorPatternDemo，我们的演示类在这里是作为一个客户端，将使用 ServiceLocator 来演示服务定位器设计模式。<br><img src="/2017/08/08/设计模式/servicelocator_pattern_uml_diagram.jpg" alt="servicelocator_pattern" title="servicelocator_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建服务接口 Service。</p>
<p>Service.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface Service &#123;</div><div class="line">   public String getName();</div><div class="line">   public void execute();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实体服务。</p>
<p>Service1.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Service1 implements Service &#123;</div><div class="line">   public void execute()&#123;</div><div class="line">      System.out.println(&quot;Executing Service1&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String getName() &#123;</div><div class="line">      return &quot;Service1&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Service2.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Service2 implements Service &#123;</div><div class="line">   public void execute()&#123;</div><div class="line">      System.out.println(&quot;Executing Service2&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String getName() &#123;</div><div class="line">      return &quot;Service2&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>为 JNDI 查询创建 InitialContext。</p>
<p>InitialContext.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class InitialContext &#123;</div><div class="line">   public Object lookup(String jndiName)&#123;</div><div class="line">      if(jndiName.equalsIgnoreCase(&quot;SERVICE1&quot;))&#123;</div><div class="line">         System.out.println(&quot;Looking up and creating a new Service1 object&quot;);</div><div class="line">         return new Service1();</div><div class="line">      &#125;else if (jndiName.equalsIgnoreCase(&quot;SERVICE2&quot;))&#123;</div><div class="line">         System.out.println(&quot;Looking up and creating a new Service2 object&quot;);</div><div class="line">         return new Service2();</div><div class="line">      &#125;</div><div class="line">      return null;		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建缓存 Cache。</p>
<p>Cache.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class Cache &#123;</div><div class="line"></div><div class="line">   private List&lt;Service&gt; services;</div><div class="line"></div><div class="line">   public Cache()&#123;</div><div class="line">      services = new ArrayList&lt;Service&gt;();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public Service getService(String serviceName)&#123;</div><div class="line">      for (Service service : services) &#123;</div><div class="line">         if(service.getName().equalsIgnoreCase(serviceName))&#123;</div><div class="line">            System.out.println(&quot;Returning cached  &quot;+serviceName+&quot; object&quot;);</div><div class="line">            return service;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void addService(Service newService)&#123;</div><div class="line">      boolean exists = false;</div><div class="line">      for (Service service : services) &#123;</div><div class="line">         if(service.getName().equalsIgnoreCase(newService.getName()))&#123;</div><div class="line">            exists = true;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      if(!exists)&#123;</div><div class="line">         services.add(newService);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>创建服务定位器。</p>
<p>ServiceLocator.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class ServiceLocator &#123;</div><div class="line">   private static Cache cache;</div><div class="line"></div><div class="line">   static &#123;</div><div class="line">      cache = new Cache();		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public static Service getService(String jndiName)&#123;</div><div class="line"></div><div class="line">      Service service = cache.getService(jndiName);</div><div class="line"></div><div class="line">      if(service != null)&#123;</div><div class="line">         return service;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      InitialContext context = new InitialContext();</div><div class="line">      Service service1 = (Service)context.lookup(jndiName);</div><div class="line">      cache.addService(service1);</div><div class="line">      return service1;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>使用 ServiceLocator 来演示服务定位器设计模式。</p>
<p>ServiceLocatorPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class ServiceLocatorPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Service service = ServiceLocator.getService(&quot;Service1&quot;);</div><div class="line">      service.execute();</div><div class="line">      service = ServiceLocator.getService(&quot;Service2&quot;);</div><div class="line">      service.execute();</div><div class="line">      service = ServiceLocator.getService(&quot;Service1&quot;);</div><div class="line">      service.execute();</div><div class="line">      service = ServiceLocator.getService(&quot;Service2&quot;);</div><div class="line">      service.execute();		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 7</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Looking up and creating a new Service1 object</div><div class="line">Executing Service1</div><div class="line">Looking up and creating a new Service2 object</div><div class="line">Executing Service2</div><div class="line">Returning cached  Service1 object</div><div class="line">Executing Service1</div><div class="line">Returning cached  Service2 object</div><div class="line">Executing Service2</div></pre></td></tr></table></figure>
<h2 id="传输对象模式"><a href="#传输对象模式" class="headerlink" title="传输对象模式"></a>传输对象模式</h2><p>传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。传输对象也被称为数值对象。传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输。它没有任何的行为。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。<br><strong>业务对象（Business Object）</strong> - 为传输对象填充数据的业务服务。<br><strong>传输对象（Transfer Object）</strong> - 简单的 POJO，只有设置/获取属性的方法。<br><strong>客户端（Client）</strong> - 客户端可以发送请求或者发送传输对象到业务对象。<br><strong>实现</strong><br>我们将创建一个作为业务对象的 StudentBO 和作为传输对象的 StudentVO，它们都代表了我们的实体。<br>TransferObjectPatternDemo，我们的演示类在这里是作为一个客户端，将使用 StudentBO 和 Student 来演示传输对象设计模式。<br><img src="/2017/08/08/设计模式/transferobject_pattern_uml_diagram.jpg" alt="transferobject_pattern" title="transferobject_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建传输对象。</p>
<p>StudentVO.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class StudentVO &#123;</div><div class="line">   private String name;</div><div class="line">   private int rollNo;</div><div class="line"></div><div class="line">   StudentVO(String name, int rollNo)&#123;</div><div class="line">      this.name = name;</div><div class="line">      this.rollNo = rollNo;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getName() &#123;</div><div class="line">      return name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setName(String name) &#123;</div><div class="line">      this.name = name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public int getRollNo() &#123;</div><div class="line">      return rollNo;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setRollNo(int rollNo) &#123;</div><div class="line">      this.rollNo = rollNo;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建业务对象。</p>
<p>StudentBO.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class StudentBO &#123;</div><div class="line">	</div><div class="line">   //列表是当作一个数据库</div><div class="line">   List&lt;StudentVO&gt; students;</div><div class="line"></div><div class="line">   public StudentBO()&#123;</div><div class="line">      students = new ArrayList&lt;StudentVO&gt;();</div><div class="line">      StudentVO student1 = new StudentVO(&quot;Robert&quot;,0);</div><div class="line">      StudentVO student2 = new StudentVO(&quot;John&quot;,1);</div><div class="line">      students.add(student1);</div><div class="line">      students.add(student2);		</div><div class="line">   &#125;</div><div class="line">   public void deleteStudent(StudentVO student) &#123;</div><div class="line">      students.remove(student.getRollNo());</div><div class="line">      System.out.println(&quot;Student: Roll No &quot; </div><div class="line">      + student.getRollNo() +&quot;, deleted from database&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //从数据库中检索学生名单</div><div class="line">   public List&lt;StudentVO&gt; getAllStudents() &#123;</div><div class="line">      return students;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public StudentVO getStudent(int rollNo) &#123;</div><div class="line">      return students.get(rollNo);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void updateStudent(StudentVO student) &#123;</div><div class="line">      students.get(student.getRollNo()).setName(student.getName());</div><div class="line">      System.out.println(&quot;Student: Roll No &quot; </div><div class="line">      + student.getRollNo() +&quot;, updated in the database&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>使用 StudentBO 来演示传输对象设计模式。</p>
<p>TransferObjectPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class TransferObjectPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      StudentBO studentBusinessObject = new StudentBO();</div><div class="line"></div><div class="line">      //输出所有的学生</div><div class="line">      for (StudentVO student : studentBusinessObject.getAllStudents()) &#123;</div><div class="line">         System.out.println(&quot;Student: [RollNo : &quot;</div><div class="line">         +student.getRollNo()+&quot;, Name : &quot;+student.getName()+&quot; ]&quot;);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      //更新学生</div><div class="line">      StudentVO student =studentBusinessObject.getAllStudents().get(0);</div><div class="line">      student.setName(&quot;Michael&quot;);</div><div class="line">      studentBusinessObject.updateStudent(student);</div><div class="line"></div><div class="line">      //获取学生</div><div class="line">      studentBusinessObject.getStudent(0);</div><div class="line">      System.out.println(&quot;Student: [RollNo : &quot;</div><div class="line">      +student.getRollNo()+&quot;, Name : &quot;+student.getName()+&quot; ]&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Student: [RollNo : 0, Name : Robert ]</div><div class="line">Student: [RollNo : 1, Name : John ]</div><div class="line">Student: Roll No 0, updated in the database</div><div class="line">Student: [RollNo : 0, Name : Michael ]</div></pre></td></tr></table></figure>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p>本章列出了设计模式相关的网站、书籍和文章。</p>
<p><strong>设计模式相关的网站</strong></p>
<p><a href="http://en.wikipedia.org/wiki/Design_pattern_(computer_science" target="_blank" rel="external"><font color="#0366d6">Wiki Page for Design Patterns</font></a>) - 以一种非常通用的方式检查设计模式。<br><a href="http://en.wikibooks.org/wiki/Java_Programming/Design_Patterns" target="_blank" rel="external"><font color="#0366d6">Java Programming/Design Patterns</font></a> - 一篇关于设计模式的好文章。<br><a href="http://java.sun.com/docs/books/tutorial/index.html" target="_blank" rel="external"><font color="#0366d6">The JavaTM Tutorials</font></a> - 该 Java 教程是为那些想用 Java 编程语言创建应用程序的编程人员提供的实用指南。<br><a href="http://java.sun.com/j2se/1.4.2/docs/index.html" target="_blank" rel="external"><font color="#0366d6">JavaTM 2 SDK, Standard Edition</font></a> - JavaTM 2 SDK, Standard Edition 的官网。<br><a href="http://exciton.cs.rice.edu/javaresources/DesignPatterns/" target="_blank" rel="external"><font color="#0366d6">Java DesignPatterns</font></a> - 关于设计模式的短文。</p>
<p><strong>Java 设计模式有用的书籍</strong><br>Java Design Patterns<br>Head First Design Patterns<br>Java Design Pattern Essentials<br>Design Patterns: Elements of Reusable Object-Oriented Software<br>Design Patterns in Java(TM)<br>Design Patterns Java Workbook </p>
<p><a href="http://www.runoob.com/design-pattern/design-pattern-tutorial.html" target="_blank" rel="external"><font color="#0366d6">原文地址</font></a></p>

      
      
        <div class="page-reward">
          <p><a href="javascript:void(0)" onclick="dashangToggle()" class="dashang">赏</a></p>
          <div class="hide_box"></div>
          <div class="shang_box">
            <a class="shang_close" href="javascript:void(0)" onclick="dashangToggle()">×</a>
            <div class="shang_tit">
              <p>如果文章对您有用请随意打赏！</p>
            </div>
            <div class="shang_payimg">
              <img src="/img/alipayimg.jpg" alt="扫码支持" title="扫一扫" />
            </div>
              <div class="pay_explain">谢谢支持！</div>
            <div class="shang_payselect">
              
                <div class="pay_item checked" data-id="alipay">
                  <span class="radiobox"></span>
                  <span class="pay_logo"><img src="/img/alipay.jpg" alt="支付宝" /></span>
                </div>
              
              
                <div class="pay_item" data-id="wechat">
                  <span class="radiobox"></span>
                  <span class="pay_logo"><img src="/img/weChat.jpg" alt="微信" /></span>
                </div>
              
            </div>
            <div class="shang_info">
              <p>打开<span id="shang_pay_txt">支付宝</span>扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
        </div>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
        <script type="text/javascript">
          $(".pay_item").click(function(){
            $(this).addClass('checked').siblings('.pay_item').removeClass('checked');
            var dataid=$(this).attr('data-id');
            $(".shang_payimg img").attr("src","/img/"+dataid+"img.jpg");
            $("#shang_pay_txt").text(dataid=="alipay"?"支付宝":"微信");
          });
          function dashangToggle(){
            
            $(".hide_box").fadeToggle();
            $(".shang_box").fadeToggle();
          }
        </script>
      
    </div>
    
  </div>
  
    
<div style="text-align:center;color: #ccc;font-size:14px;">
------ 本文结束 ------</div>
<br/>
<div style="border: 1px solid black">
<div style="margin-left:10px">
<span style="font-weight:blod">版权声明</span>
<img src="http://jet-han.gitee.io/img/copyright.png" >
<br/>
<p style="font-size: 10px;line-height: 30px"><a href="http://jet-han.gitee.io/" style="color:#258FC6">Jet's Blog</a> by <a href="http://jet-han.gitee.io/" style="color:#258FC6">Jet Han</a> is licensed under a <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" style="color:#258FC6">Creative Commons BY-NC-ND 4.0 International License</a>.<br/>
由<a href="http://jet-han.gitee.io" style="color:#258FC6"> jet han </a>创作并维护的<a href="http://jet-han.gitee.io" style="color:#258FC6"> jet </a>的博客采用<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" style="color:#258FC6">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br/>
本文首发于<a href="http://jet-han.gitee.io/" style="color:#258FC6">Jet</a> 的博客（ <a href="http://jet-han.gitee.io/" style="color:#258FC6">http://jet-han.oschina.io/</a> ），版权所有，侵权必究。</p>
</div>

    <div class="copyright">
        <p><span>本文标题:</span><a href="/2017/08/08/设计模式/">设计模式</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 Jet 的个人博客">Jet</a></p>
        <p><span>发布时间:</span>2017年08月08日 - 14时34分</p>
        <p><span>最后更新:</span>2017年08月08日 - 14时34分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2017/08/08/设计模式/" title="设计模式">https://jet-han.gitee.io/2017/08/08/设计模式/</a>
            <span class="copy-path" data-clipboard-text="原文: https://jet-han.gitee.io/2017/08/08/设计模式/　　作者: Jet" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
    <a href="/2017/09/13/Spring中bean的生命周期/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Spring中bean的生命周期
        
      </div>
    </a>
  
  
    <a href="/2017/08/06/mysql数据库引擎/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">mysql数据库引擎</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

</div>


  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java常用设计模式"><span class="toc-number">2.</span> <span class="toc-text">java常用设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#strategy-策略模式"><span class="toc-number">3.</span> <span class="toc-text">strategy(策略模式)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工厂模式"><span class="toc-number">4.</span> <span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#抽象工厂模式"><span class="toc-number">5.</span> <span class="toc-text">抽象工厂模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单例模式"><span class="toc-number">6.</span> <span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建造者模式"><span class="toc-number">7.</span> <span class="toc-text">建造者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型模式"><span class="toc-number">8.</span> <span class="toc-text">原型模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#适配器模式"><span class="toc-number">9.</span> <span class="toc-text">适配器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#桥接模式"><span class="toc-number">10.</span> <span class="toc-text">桥接模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#过滤器模式"><span class="toc-number">11.</span> <span class="toc-text">过滤器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组合模式"><span class="toc-number">12.</span> <span class="toc-text">组合模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#装饰器模式"><span class="toc-number">13.</span> <span class="toc-text">装饰器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#外观模式"><span class="toc-number">14.</span> <span class="toc-text">外观模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#享元模式"><span class="toc-number">15.</span> <span class="toc-text">享元模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代理模式"><span class="toc-number">16.</span> <span class="toc-text">代理模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#责任链模式"><span class="toc-number">17.</span> <span class="toc-text">责任链模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#命令模式"><span class="toc-number">18.</span> <span class="toc-text">命令模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解释器模式"><span class="toc-number">19.</span> <span class="toc-text">解释器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#迭代器模式"><span class="toc-number">20.</span> <span class="toc-text">迭代器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中介者模式"><span class="toc-number">21.</span> <span class="toc-text">中介者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#备忘录模式"><span class="toc-number">22.</span> <span class="toc-text">备忘录模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#观察者模式"><span class="toc-number">23.</span> <span class="toc-text">观察者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#状态模式"><span class="toc-number">24.</span> <span class="toc-text">状态模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#空对象模式"><span class="toc-number">25.</span> <span class="toc-text">空对象模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#策略模式"><span class="toc-number">26.</span> <span class="toc-text">策略模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模板模式"><span class="toc-number">27.</span> <span class="toc-text">模板模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问者模式"><span class="toc-number">28.</span> <span class="toc-text">访问者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVC-模式"><span class="toc-number">29.</span> <span class="toc-text">MVC 模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#业务代表模式"><span class="toc-number">30.</span> <span class="toc-text">业务代表模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组合实体模式"><span class="toc-number">31.</span> <span class="toc-text">组合实体模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据访问对象模式"><span class="toc-number">32.</span> <span class="toc-text">数据访问对象模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#前端控制器模式"><span class="toc-number">33.</span> <span class="toc-text">前端控制器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拦截过滤器模式"><span class="toc-number">34.</span> <span class="toc-text">拦截过滤器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#服务定位器模式"><span class="toc-number">35.</span> <span class="toc-text">服务定位器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#传输对象模式"><span class="toc-number">36.</span> <span class="toc-text">传输对象模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#相关资料"><span class="toc-number">37.</span> <span class="toc-text">相关资料</span></a></li></ol>
</div>
<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
    }
</script>





<div class="bdsharebuttonbox">
	<a href="#" class="fx fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="fx fa-weixin bds_weixin" data-cmd="weixin" title="分享到微信"></a>
	<a href="#" class="fx fa-qq bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
	<a href="#" class="fx fa-facebook-official bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
	<a href="#" class="fx fa-twitter bds_twi" data-cmd="twi" title="分享到Twitter"></a>
	<a href="#" class="fx fa-linkedin bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
	<a href="#" class="fx fa-files-o bds_copy" data-cmd="copy" title="分享到复制网址"></a>
</div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>




    
        <!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" style="width:90%;margin:5% auto 0 auto;background: #fff;padding: 0 12px;border-radius: 5px;" data-uid="MTAyMC8yOTg3NS82NDQw">
	<script type="text/javascript">
   window.livereOptions = {
        refer: 'jet-han.oschina.io' + location.pathname
   };
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;
console.log('jet-han.gitee.io' + location.pathname);
       e.parentNode.insertBefore(j, e);
   })(document, 'script');
	</script>
<noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->

  



    <div class="scroll" id="post-nav-button">
        
            <a href="/2017/09/13/Spring中bean的生命周期/" title="上一篇: Spring中bean的生命周期">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/2017/08/06/mysql数据库引擎/" title="下一篇: mysql数据库引擎">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/12/17/并发编程之synchronized与加锁机制/">并发编程之synchronized与加锁机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/12/jdk8💗特性/">jdk8💗特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/05/Cron/">Cron</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/30/Mybatis-MapperScannerConfigurer/">Mybatis-MapperScannerConfigurer</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/28/Mysql-SQL语句执行/">Mysql-SQL语句执行</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/28/Mysql-B-Tree索引/">Mysql-B-Tree索引</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/18/并发编程之CountDownLatch、CyclicBarrier和Semaphore/">并发编程之CountDownLatch、CyclicBarrier和Semaphore</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/14/Docker/">Docker</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/13/Spring中bean的生命周期/">Spring中bean的生命周期</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/08/设计模式/">设计模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/06/mysql数据库引擎/">mysql数据库引擎</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/06/并发编程之线程池ThreadPoolExecutor/">并发编程之线程池ThreadPoolExecutor</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/05/线程的实现方式/">线程的实现方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/05/jvm调优/">jvm调优</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/05/web-xml加载顺序/">web.xml加载顺序</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/05/sping之IOC，AOP/">sping之IOC，AOP</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/05/spring事务的传播属性和隔离级别/">spring事务的传播属性和隔离级别</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/05/乐观锁与悲观锁及应用举例/">乐观锁与悲观锁及应用举例</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/04/mysql事务隔离级别/">mysql事务隔离级别</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/01/equals、-和hashCode/">equals、==和hashCode</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/28/HashMap工作原理/">HashMap工作原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/28/volatile用法/">volatile用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/28/java常量池/">java常量池</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/28/string比较之‘’equals‘’和‘’==‘’/">string比较之‘’equals‘’和‘’==‘’</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/26/spring Bean的作用域/">spring Bean的作用域</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/20/jvm内存模型/">jvm内存模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/18/并发编程-线程间协作/">并发编程-线程间协作</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/17/nginx安装与使用/">nginx安装与使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/16/solr安装与使用/">solr安装与使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/16/crontab安装及使用/">crontab安装及使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/15/大数据平台-ambari/">大数据平台-ambari</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/10/mysql配置详解/">mysql配置详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/09/google-cloud搭建vpn/">google-cloud搭建vpn</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/08/java-IO/">java-IO</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/02/github搭建个人maven仓库/">github搭建个人maven仓库</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/24/git/">git</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/19/linux常用操作命令/">linux常用操作命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/17/redis安装及使用/">redis安装及使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/15/mysql主从备份/">mysql主从备份</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/12/Java Generics/">Java Generics</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/30/Markdown-语法说明/">Markdown-语法说明</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/30/java常见排序算法/">java常见排序算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/29/mysql索引及查询优化/">mysql索引及查询优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/28/java常用集合/">java常用集合/容器</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/27/递归和迭代/">递归和迭代</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/27/StringBuilder和StringBuffer/">StringBuilder和StringBuffer</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/27/Hexo-NexT主题搭建个人博客/">Hexo-NexT主题搭建个人博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/07/java后端开发面试/">java后端开发面试</a></li></ul>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
            }
        })
    </script>



    <script>
        
    </script>

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2020 学海无涯
            </div>
            <div class="footer-right">
                <span class="author" itemprop="copyrightHolder">Powered By - Jet</span>
            </div>
        </div>
        

      <div class="total_count">
          本站共 <span id="busuanzi_value_site_pv"></span><span id="site_pv">次访问</span>
          您是第 <span id="busuanzi_value_site_uv"></span><span id="site_uv">个小伙伴</span>
          本页累计 <span id="busuanzi_value_page_pv"></span><span id="page_pv">次阅读</span>
          已运行 <span id="showDays"></span><span id="show_days">天</span>
      </div>
      <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
      </script>
      <script>
        var birthDay = new Date('05/24/2017');
        var now = new Date();
        var duration = now.getTime() - birthDay.getTime();
        var total= Math.floor(duration / (1000 * 60 * 60 * 24));
        document.getElementById('showDays').innerHTML=total;
      </script>
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>
<!-- 优效ssp<script src="http://s.6travel.com/titi126.js"></script>-->

    <script>
        $(document).ready(function() {
            var backgroundnum 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>







  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("{{theme.leancloud_visitors.app_id}}", "{{theme.leancloud_visitors.app_key}}");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


    <script type="text/javascript">
      window.onload = function(){
        document.getElementById("search").onclick = function(){
            console.log("search")
            search();
        }
      }
      function search(){
        (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
        (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
        e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
        })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

        _st('install','A1Pz-LKMXbrzcFg2FWi6','2.0.0');
      }
    </script>


    <script type="text/javascript">
   document.oncontextmenu = function(){
     return false;
   }
   document.onkeydown = function(){
    if (event.ctrlKey && window.event.keyCode==67){
    return false;
    }
    if ((window.event.altKey)&& 
     ((window.event.keyCode==37)||   
      (window.event.keyCode==39))){alert("请访问主页"); 
    event.returnValue=false; 
    } 
if ((event.keyCode==8)||(event.keyCode==116)){//屏蔽 F5 刷新键 
    event.keyCode=0; 
    event.returnValue=false; 
    } 
if ((event.ctrlKey)&&(event.keyCode==78)){   //屏蔽 Ctrl+n 
    event.returnValue=false; 
    } 
if ((event.shiftKey)&&(event.keyCode==121)){ //屏蔽 shift+F10 
    event.returnValue=false; 
    }
if (event.keyCode==123){ //屏蔽 F12 
    event.returnValue=false;
    }
   }
  document.body.oncopy = function (){
   return false;
  }
  //不建议连选中文本都不行
  document.onselectstart = function(){
  //return false;
  }
    </script>


  </div>
</body>
</html>