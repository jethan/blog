<!DOCTYPE html>
<html>
<head>
  <meta name="baidu-site-verification" content="cns0EghbIQ" />
  <meta charset="utf-8">
  
  <title>java后端开发面试 | 学海无涯</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="在IT圈，跳槽是一件很平常的事情，干的不爽、钱没给到位、工作反复无趣没有提升等等因素。所以这里有必要说说面试，有些小型的创业公司可能没有那么多流程，面试官的差不多都是与你同级的，只是入职时间比你早而已。标准其实不复杂：第一能干活，第二Java基础要好，第三最好熟悉些分布式框架，我相信其它公司招初级开发时，应该也照着这个标准来面的。   我也知道，不少候选人能力其实不差，但面试时没准备或不会说，这">
<meta name="keywords" content="面试题,面试技巧">
<meta property="og:type" content="article">
<meta property="og:title" content="java后端开发面试">
<meta property="og:url" content="https://jet-han.gitee.io/2017/05/07/java后端开发面试/index.html">
<meta property="og:site_name" content="学海无涯">
<meta property="og:description" content="在IT圈，跳槽是一件很平常的事情，干的不爽、钱没给到位、工作反复无趣没有提升等等因素。所以这里有必要说说面试，有些小型的创业公司可能没有那么多流程，面试官的差不多都是与你同级的，只是入职时间比你早而已。标准其实不复杂：第一能干活，第二Java基础要好，第三最好熟悉些分布式框架，我相信其它公司招初级开发时，应该也照着这个标准来面的。   我也知道，不少候选人能力其实不差，但面试时没准备或不会说，这">
<meta property="og:image" content="https://jet-han.gitee.io/2017/05/07/java后端开发面试/interview1.png">
<meta property="og:updated_time" content="2017-05-07T05:44:59.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java后端开发面试">
<meta name="twitter:description" content="在IT圈，跳槽是一件很平常的事情，干的不爽、钱没给到位、工作反复无趣没有提升等等因素。所以这里有必要说说面试，有些小型的创业公司可能没有那么多流程，面试官的差不多都是与你同级的，只是入职时间比你早而已。标准其实不复杂：第一能干活，第二Java基础要好，第三最好熟悉些分布式框架，我相信其它公司招初级开发时，应该也照着这个标准来面的。   我也知道，不少候选人能力其实不差，但面试时没准备或不会说，这">
<meta name="twitter:image" content="https://jet-han.gitee.io/2017/05/07/java后端开发面试/interview1.png">
  
    <link rel="alternative" href="/atom.xml" title="学海无涯" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
if ((!window.location.host.startsWith("localhost")) && (!window.location.host.startsWith("192.168.40")) && (window.location.protocol != "https:"))
        window.location = window.location.toString().replace(/^http:/, "https:");
  </script>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script src="https://cdn.jsdelivr.net/npm/echarts@4.7.0/dist/echarts.common.min.js"></script>
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay">
<a href="https://github.com/jethan/blog" style="cursor: hand;z-index: 9999999!important" rel="external nofollow noopener noreferrer" target="_blank">
         <img style="position: absolute; top: 0; border: 0; transform: rotate(-90deg);" src="https://jet-han.gitee.io/img/icons/fork.png"
         alt="Fork me on GitHub">
</a>
</div>
<div class="intrude-less">
    <header id="header" class="inner">  
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/ali.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/" title="Hi Mate">Jet</a></h1>
        </hgroup>

        
        <p class="header-subtitle">技术博客</p>
        
        
        
        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=225 height=86 src="//music.163.com/outchain/player?type=2&id=482792397&auto=0&height=66"></iframe>
        

        
            <form>
                <input type="text" class="st-default-search-input search" id="search" placeholder=" Search...">
            </form>
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">首页</a></li>
                        
                            <li><a href="/archives">归档</a></li>
                        
                            <li><a href="/photos">相册</a></li>
                        
                            <li><a href="http://markdown.xiaoshujiang.com/">编辑器</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl github" target="_blank" href="https://github.com/jethan" title="github">github</a>
                            
                                <a class="fl zhihu" target="_blank" href="https://www.zhihu.com/people/jet-77-36" title="zhihu">zhihu</a>
                            
                                <a class="fl weibo" target="_blank" href="http://weibo.com/2146269010/profile?topnav=1&wvr=6&is_all=1" title="weibo">weibo</a>
                            
                                <a class="fl oschina" target="_blank" href="http://git.oschina.net/jet-han" title="oschina">oschina</a>
                            
                                <a class="fl twitter" target="_blank" href="https://twitter.com/fajie_han" title="twitter">twitter</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/" style="font-size: 20px;">==</a> <a href="/tags/AOF/" style="font-size: 10px;">AOF</a> <a href="/tags/AOP/" style="font-size: 10px;">AOP</a> <a href="/tags/ArrayList/" style="font-size: 10px;">ArrayList</a> <a href="/tags/Arrays/" style="font-size: 10px;">Arrays</a> <a href="/tags/B-Tree索引/" style="font-size: 10px;">B-Tree索引</a> <a href="/tags/Bean的作用域/" style="font-size: 10px;">Bean的作用域</a> <a href="/tags/Bean的生命周期/" style="font-size: 10px;">Bean的生命周期</a> <a href="/tags/Collection/" style="font-size: 10px;">Collection</a> <a href="/tags/Collections/" style="font-size: 10px;">Collections</a> <a href="/tags/CountDownLatch/" style="font-size: 10px;">CountDownLatch</a> <a href="/tags/CyclicBarrier/" style="font-size: 10px;">CyclicBarrier</a> <a href="/tags/Factory-Pattern/" style="font-size: 10px;">Factory Pattern</a> <a href="/tags/Generics/" style="font-size: 10px;">Generics</a> <a href="/tags/HEAP/" style="font-size: 10px;">HEAP</a> <a href="/tags/HashMap/" style="font-size: 10px;">HashMap</a> <a href="/tags/HashSet/" style="font-size: 10px;">HashSet</a> <a href="/tags/HashTable/" style="font-size: 10px;">HashTable</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/IOC/" style="font-size: 10px;">IOC</a> <a href="/tags/ISAM/" style="font-size: 10px;">ISAM</a> <a href="/tags/Innodb/" style="font-size: 10px;">Innodb</a> <a href="/tags/Intercepting-Filter-Pattern/" style="font-size: 10px;">Intercepting Filter Pattern</a> <a href="/tags/Iterator-Pattern/" style="font-size: 10px;">Iterator Pattern</a> <a href="/tags/LinkedHashMap/" style="font-size: 10px;">LinkedHashMap</a> <a href="/tags/LinkedList/" style="font-size: 10px;">LinkedList</a> <a href="/tags/MVC-Pattern/" style="font-size: 10px;">MVC Pattern</a> <a href="/tags/Map/" style="font-size: 10px;">Map</a> <a href="/tags/MapperScannerConfigurer/" style="font-size: 10px;">MapperScannerConfigurer</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/MyIsam/" style="font-size: 10px;">MyIsam</a> <a href="/tags/Proxy-Pattern/" style="font-size: 10px;">Proxy Pattern</a> <a href="/tags/RDB/" style="font-size: 10px;">RDB</a> <a href="/tags/ReentrantLock/" style="font-size: 10px;">ReentrantLock</a> <a href="/tags/Semaphore/" style="font-size: 10px;">Semaphore</a> <a href="/tags/Singleton-Pattern/" style="font-size: 10px;">Singleton Pattern</a> <a href="/tags/String/" style="font-size: 10px;">String</a> <a href="/tags/StringBuffer/" style="font-size: 10px;">StringBuffer</a> <a href="/tags/StringBuilder/" style="font-size: 10px;">StringBuilder</a> <a href="/tags/ThreadPoolExecutor/" style="font-size: 10px;">ThreadPoolExecutor</a> <a href="/tags/TreeMap/" style="font-size: 10px;">TreeMap</a> <a href="/tags/TreeSet/" style="font-size: 10px;">TreeSet</a> <a href="/tags/Vector/" style="font-size: 10px;">Vector</a> <a href="/tags/WeakHashMap/" style="font-size: 10px;">WeakHashMap</a> <a href="/tags/Wildcard/" style="font-size: 10px;">Wildcard</a> <a href="/tags/ambari/" style="font-size: 10px;">ambari</a> <a href="/tags/await/" style="font-size: 10px;">await</a> <a href="/tags/binlog/" style="font-size: 10px;">binlog</a> <a href="/tags/crontab/" style="font-size: 10px;">crontab</a> <a href="/tags/equals/" style="font-size: 20px;">equals</a> <a href="/tags/explain/" style="font-size: 10px;">explain</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/hashCode/" style="font-size: 10px;">hashCode</a> <a href="/tags/hashmap/" style="font-size: 10px;">hashmap</a> <a href="/tags/index/" style="font-size: 10px;">index</a> <a href="/tags/jdk8/" style="font-size: 10px;">jdk8</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/my-cnf配置详解/" style="font-size: 10px;">my.cnf配置详解</a> <a href="/tags/mysqldump/" style="font-size: 10px;">mysqldump</a> <a href="/tags/mysqldumpslow/" style="font-size: 10px;">mysqldumpslow</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/nosql/" style="font-size: 10px;">nosql</a> <a href="/tags/notify/" style="font-size: 10px;">notify</a> <a href="/tags/notifyAll/" style="font-size: 10px;">notifyAll</a> <a href="/tags/quartz/" style="font-size: 10px;">quartz</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/runnable/" style="font-size: 10px;">runnable</a> <a href="/tags/signal/" style="font-size: 10px;">signal</a> <a href="/tags/signalAll/" style="font-size: 10px;">signalAll</a> <a href="/tags/solr/" style="font-size: 10px;">solr</a> <a href="/tags/sort/" style="font-size: 10px;">sort</a> <a href="/tags/spring单例模式/" style="font-size: 10px;">spring单例模式</a> <a href="/tags/spring线程安全/" style="font-size: 10px;">spring线程安全</a> <a href="/tags/string/" style="font-size: 10px;">string</a> <a href="/tags/synchronized/" style="font-size: 10px;">synchronized</a> <a href="/tags/thread/" style="font-size: 10px;">thread</a> <a href="/tags/volatile/" style="font-size: 10px;">volatile</a> <a href="/tags/vpn/" style="font-size: 10px;">vpn</a> <a href="/tags/wait/" style="font-size: 10px;">wait</a> <a href="/tags/web-xml加载顺序/" style="font-size: 10px;">web.xml加载顺序</a> <a href="/tags/主从/" style="font-size: 10px;">主从</a> <a href="/tags/主从备份/" style="font-size: 10px;">主从备份</a> <a href="/tags/乐观锁/" style="font-size: 10px;">乐观锁</a> <a href="/tags/事务传播属性/" style="font-size: 10px;">事务传播属性</a> <a href="/tags/事务隔离级别/" style="font-size: 10px;">事务隔离级别</a> <a href="/tags/二分/" style="font-size: 10px;">二分</a> <a href="/tags/冒泡/" style="font-size: 10px;">冒泡</a> <a href="/tags/堆/" style="font-size: 10px;">堆</a> <a href="/tags/容器/" style="font-size: 10px;">容器</a> <a href="/tags/希尔/" style="font-size: 10px;">希尔</a> <a href="/tags/常量池/" style="font-size: 10px;">常量池</a> <a href="/tags/快速/" style="font-size: 10px;">快速</a> <a href="/tags/性能调优/" style="font-size: 10px;">性能调优</a> <a href="/tags/悲观锁/" style="font-size: 10px;">悲观锁</a> <a href="/tags/持久化/" style="font-size: 10px;">持久化</a> <a href="/tags/插入/" style="font-size: 10px;">插入</a> <a href="/tags/方法区/" style="font-size: 10px;">方法区</a> <a href="/tags/本地方法栈/" style="font-size: 10px;">本地方法栈</a> <a href="/tags/泛型/" style="font-size: 10px;">泛型</a> <a href="/tags/程序计数器/" style="font-size: 10px;">程序计数器</a> <a href="/tags/线程池/" style="font-size: 10px;">线程池</a> <a href="/tags/虚拟机栈/" style="font-size: 10px;">虚拟机栈</a> <a href="/tags/语句执行/" style="font-size: 10px;">语句执行</a> <a href="/tags/迭代/" style="font-size: 10px;">迭代</a> <a href="/tags/选择/" style="font-size: 10px;">选择</a> <a href="/tags/递归/" style="font-size: 10px;">递归</a> <a href="/tags/隔离级别/" style="font-size: 10px;">隔离级别</a> <a href="/tags/面试技巧/" style="font-size: 10px;">面试技巧</a> <a href="/tags/面试题/" style="font-size: 10px;">面试题</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://jethan.bid/">学海无涯</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">纯海迷、爱运动、爱交友、爱旅行、喜欢接触新鲜事物、迎接新的挑战，更爱游离于错综复杂的编码与逻辑中</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">Jet</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/ali.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">Jet</a></h1>
            </hgroup>
            
            <p class="header-subtitle">技术博客</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">首页</a></li>
                
                    <li><a href="/archives">归档</a></li>
                
                    <li><a href="/photos">相册</a></li>
                
                    <li><a href="http://markdown.xiaoshujiang.com/">编辑器</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="github" target="_blank" href="https://github.com/jethan" title="github">github</a>
                    
                        <a class="zhihu" target="_blank" href="https://www.zhihu.com/people/jet-77-36" title="zhihu">zhihu</a>
                    
                        <a class="weibo" target="_blank" href="http://weibo.com/2146269010/profile?topnav=1&wvr=6&is_all=1" title="weibo">weibo</a>
                    
                        <a class="oschina" target="_blank" href="http://git.oschina.net/jet-han" title="oschina">oschina</a>
                    
                        <a class="twitter" target="_blank" href="https://twitter.com/fajie_han" title="twitter">twitter</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-java后端开发面试" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/07/java后端开发面试/" class="article-date">
      <time datetime="2017-05-07T05:44:59.000Z" itemprop="datePublished">2017-05-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      java后端开发面试
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/java/">java</a><a class="article-category-link" href="/categories/java/interview/">interview</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试技巧/">面试技巧</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试题/">面试题</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><img src="/2017/05/07/java后端开发面试/interview1.png" alt="interview" title="interview"></p>
<p>在IT圈，跳槽是一件很平常的事情，干的不爽、钱没给到位、工作反复无趣没有提升等等因素。所以这里有必要说说面试，有些小型的创业公司可能没有那么多流程，面试官的差不多都是与你同级的，只是入职时间比你早而已。标准其实不复杂：第一能干活，第二Java基础要好，第三最好熟悉些分布式框架，我相信其它公司招初级开发时，应该也照着这个标准来面的。  </p>
<p>我也知道，不少候选人能力其实不差，但面试时没准备或不会说，这样的人可能在进团队干活后确实能达到期望，但可能就无法通过面试，但面试官总是只根据面试情况来判断。  </p>
<p>但现实情况是，大多数人可能面试前没准备，或准备方法不得当。要知道，我们平时干活更偏重于业务，不可能大量接触到算法，数据结构，底层代码这类面试必问的问题点，换句话说，面试准备点和平时工作要点匹配度很小。  </p>
<p>本文里，将通过一些常用的问题来介绍面试的准备技巧。大家在看后一定会感叹：只要方法得当，准备面试第一不难，第二用的时间也不会太多。  </p>
<a id="more"></a>
<h2 id="框架是重点，但别让人感觉你只会山寨别人的代码"><a href="#框架是重点，但别让人感觉你只会山寨别人的代码" class="headerlink" title="框架是重点，但别让人感觉你只会山寨别人的代码"></a>框架是重点，但别让人感觉你只会山寨别人的代码</h2><p>在面试前，我会阅读简历以查看候选人在框架方面的项目经验，在候选人的项目介绍的环节，我也会着重关注候选人最近的框架经验，目前比较热门的是SSM。<br>不过，一般工作在5年内的候选人，大多仅仅是能“山寨”别人的代码，也就是说能在现有框架的基础上，照着别人写的流程，扩展出新的功能模块。比如要写个股票挂单的功能模块，是会模仿现有的下单流程，然后从前端到后端再到数据库，依样画葫芦写一遍，最多把功能相关的代码点改掉。<br>其实我们每个人都这样过来的，但在面试时，如果你仅仅表现出这样的能力，就和大多数人的水平差不多了，在这点就没法体现出你的优势了。<br>我们知道，如果单纯使用SSM框架，大多数项目都会有痛点。比如数据库性能差，或者业务模块比较复杂，并发量比较高，用Spring MVC里的Controller无法满足跳转的需求。所以我一般还会主动问：你除了依照现有框架写业务代码时，还做了哪些改动？<br>我听到的回答有：增加了Redis缓存，以避免频繁调用一些不变的数据。或者，在MyBitas的xml里，select语句where条件有isnull，即这个值有就增加一个where条件，对此，会对任何一个where增加一个不带isnull的查询条件，以免该语句当传入参数都是null时，做全表扫描。或者，干脆说，后端异步返回的数据量很大，时间很长，我在项目里就调大了异步返回的最大时间，或者对返回信息做了压缩处理，以增加网络传输性能。<br>对于这个问题，我不在乎听到什么回答，我只关心回答符不符逻辑。一般只要答对，我就会给出“在框架层面有自己的体会，有一定的了解”，否则，我就只会给出“只能在项目经理带领下编写框架代码，对框架本身了解不多”。<br>其实，在准备面试时，归纳框架里的要点并不难，我就不信所有人在做项目时一点积累也没，只要你说出来，可以说，这方面你就碾压了将近7成的竞争者。 </p>
<h2 id="别单纯看单机版的框架，适当了解些分布式"><a href="#别单纯看单机版的框架，适当了解些分布式" class="headerlink" title="别单纯看单机版的框架，适当了解些分布式"></a>别单纯看单机版的框架，适当了解些分布式</h2><p>此外，在描述项目里框架技术时，最好你再带些分布式的技术。下面我列些大家可以准备的分布式技术。  </p>
<ul>
<li>反向代理方面，nginx的基本配置，比如如何通过lua语言设置规则，如何设置session粘滞。如果可以，再看些nginx的底层，比如协议，集群设置，失效转移等。</li>
<li>远程调用dubbo方面，可以看下dubbo和zookeeper整合的知识点，再深一步，了解下dubbo底层的传输协议和序列化方式。</li>
<li>消息队列方面，可以看下kafka或任意一种组件的使用方式，简单点可以看下配置，工作组的设置，再深入点，可以看下Kafka集群，持久化的方式，以及发送消息是用长连接还是短拦截。</li>
</ul>
<p>以上仅仅是用3个组件举例，大家还可以看下Redis缓存，日志框架，MyCAT分库分表等。准备的方式有两大类，第一是要会说怎么用，这比较简单，能通过配置文件搭建成一个功能模块即可，第二是可以适当读些底层代码，以此了解下协议，集群和失效转移之类的高级知识点。   </p>
<p>如果能在面试中侃侃而谈分布式组件的底层，那么得到的评价就会比较好了，比如“深入了解框架底层”，或“框架经验丰富”，这样就算去面试架构师也行了，更何况是高级开发。  </p>
<h2 id="数据库方面，别就知道增删改查，得了解性能优化"><a href="#数据库方面，别就知道增删改查，得了解性能优化" class="headerlink" title="数据库方面，别就知道增删改查，得了解性能优化"></a>数据库方面，别就知道增删改查，得了解性能优化</h2><p>在实际项目里，大多数程序员用到的可能仅仅是增删改查，当我们用Mybatis时，这个情况更普遍。不过如果你面试时也这样表现，估计你的能力就和其它竞争者差不多了。  </p>
<p>这方面，你可以准备如下的技能。  </p>
<ul>
<li>SQL高级方面，比如group by, having，左连接，子查询（带in），行转列等高级用法。</li>
<li>建表方面，你可以考虑下，你项目是用三范式还是反范式，理由是什么？</li>
<li>尤其是优化，你可以准备下如何通过执行计划查看SQL语句改进点的方式，或者其它能改善SQL性能的方式（比如建索引等）。</li>
<li>如果你感觉有能力，还可以准备些MySQL集群，MyCAT分库分表的技能。比如通过LVS+Keepalived实现MySQL负载均衡，MyCAT的配置方式。同样，如果可以，也看些相关的底层代码。</li>
</ul>
<p>哪怕你在前三点表现一般，那么至少也能超越将近一般的候选人，尤其当你在SQL优化方面表现非常好，那么你在面试高级开发时，数据库层面一定是达标的，如果你连第四点也回答非常好，那么恭喜你，你在数据库方面的能力甚至达到了初级架构的级别。  </p>
<h2 id="Java核心方面，围绕数据结构和性能优化准备面试题"><a href="#Java核心方面，围绕数据结构和性能优化准备面试题" class="headerlink" title="Java核心方面，围绕数据结构和性能优化准备面试题"></a>Java核心方面，围绕数据结构和性能优化准备面试题</h2><p>Java核心这块，网上的面试题很多，不过在此之外，大家还应当着重关注集合（即数据结构）和多线程并发这两块，在此基础上，大家可以准备些设计模式和虚拟机的说辞。  </p>
<p>下面列些我一般会问的部分问题：  </p>
<ul>
<li>String a = “123”; String b = “123”; a==b的结果是什么？ 这包含了内存，String存储方式等诸多知识点。</li>
<li>HashMap里的hashcode方法和equal方法什么时候需要重写？如果不重写会有什么后果？对此大家可以进一步了解HashMap（甚至ConcurrentHashMap）的底层实现。</li>
<li>ArrayList和LinkedList底层实现有什么差别？它们各自适用于哪些场合？对此大家也可以了解下相关底层代码。</li>
<li>volatile关键字有什么作用？由此展开，大家可以了解下线程内存和堆内存的差别。</li>
<li>CompletableFuture，这个是JDK1.8里的新特性，通过它怎么实现多线程并发控制？</li>
<li>JVM里，new出来的对象是在哪个区？再深入一下，问下如何查看和优化JVM虚拟机内存。</li>
<li>Java的静态代理和动态代理有什么差别？最好结合底层代码来说。</li>
</ul>
<p>通过上述的问题点，我其实不仅仅停留在“会用”级别，比如我不会问如何在ArrayList里放元素。大家可以看到，上述问题包含了“多线程并发”，“JVM优化”，“数据结构对象底层代码”等细节，大家也可以举一反三，通过看一些高级知识，多准备些其它类似面试题。  </p>
<p>我们知道，目前Java开发是以Web框架为主，那么为什么还要问Java核心知识点呢？我这个是有切身体会的。  </p>
<p>之前在我团队里，我见过两个人，一个是就会干活，具体表现是会用Java核心基本的API，而且也没有深入了解的意愿（估计不知道该怎么深入了解），另一位平时专门会看些Java并发，虚拟机等的高级知识。过了半年以后，后者的能力快速升级到高级开发，由于对JAVA核心知识点了解很透彻，所以看一些分布式组件的底层实现没什么大问题。 而前者，一直在重复劳动，能力也只一直停留在“会干活”的层面。   </p>
<p>而在现实的面试中，如果不熟悉Java核心知识点，估计升高级开发都难，更别说是面试架构师级别的岗位了。   </p>
<h2 id="Linux方面，至少了解如何看日志排查问题"><a href="#Linux方面，至少了解如何看日志排查问题" class="headerlink" title="Linux方面，至少了解如何看日志排查问题"></a>Linux方面，至少了解如何看日志排查问题</h2><p>如果候选人能证明自己有“排查问题”和“解决问题”的能力，这绝对是个加分项，但怎么证明？  </p>
<p>目前大多数的互联网项目，都是部署在Linux上，也就是说，日志都是在Linux，下面归纳些实际的Linux操作。  </p>
<ul>
<li>能通过less命令打开文件，通过Shift+G到达文件底部，再通过?+关键字的方式来根据关键来搜索信息。</li>
<li>能通过grep的方式查关键字，具体用法是, grep 关键字 文件名，如果要两次在结果里查找的话，就用grep 关键字1 文件名 | 关键字2 —color。最后—color是高亮关键字。</li>
<li>能通过vi来编辑文件。</li>
<li>能通过chmod来设置文件的权限。</li>
</ul>
<p>当然，还有更多更实用的Linux命令，但在实际面试过程中，不少候选人连一条linux命令也不知道。还是这句话，你哪怕知道些很基本的，也比一般人强了。 </p>
<h2 id="通读一段底层代码，作为加分项"><a href="#通读一段底层代码，作为加分项" class="headerlink" title="通读一段底层代码，作为加分项"></a>通读一段底层代码，作为加分项</h2><p>如何证明自己对一个知识点非常了解?莫过于能通过底层代码来说明。我在和不少工作经验在5年之内的程序员沟通时，不少人认为这很难？确实，如果要通过阅读底层代码了解分布式组件，那难度不小，但如果如下部分的底层代码，并不难懂。  </p>
<ul>
<li>ArrayList,LinkedList的底层代码里，包含着基于数组和链表的实现方式，如果大家能以此讲清楚扩容，“通过枚举器遍历“等方式，绝对能证明自己。 </li>
<li>HashMap直接对应着Hash表这个数据结构，在HashMap的底层代码里，包含着hashcode的put，get等的操作，甚至在ConcurrentHashMap里，还包含着Lock的逻辑。我相信，如果大家在面试中，看看而言ConcurrentHashMap，再结合在纸上边说边画，那一定能征服面试官。  </li>
<li>可以看下静态代理和动态代理的实现方式，再深入一下，可以看下Spring AOP里的实现代码。  </li>
<li>或许Spirng IOC和MVC的底层实现代码比较难看懂，但大家可以说些关键的类，根据关键流程说下它们的实现方式。   </li>
</ul>
<p>其实准备的底层代码未必要多，而且也不限于在哪个方面，比如集合里基于红黑树的TreeSet，基于NIO的开源框架，甚至分布式组件的Dubbo，都可以准备。而且准备时未必要背出所有的底层（事实上很难做到），你只要能结合一些重要的类和方法，讲清楚思路即可（比如讲清楚HashMap如何通过hashCode快速定位）。<br>那么在面试时，如何找到个好机会说出你准备好的上述底层代码？在面试时，总会被问到集合，Spring MVC框架等相关知识点，你在回答时，顺便说一句，“我还了解这块的底层实现”，那么面试官一定会追问，那么你就可以说出来了。<br>不要小看这个对候选人的帮助，一旦你讲了，只要意思到位，那么最少能得到个“肯积极专业“的评价，如果描述很清楚，那么评价就会升级到“熟悉Java核心技能（或Spring MVC），且基本功扎实”。要知道，面试中，很少有人能讲清楚底层代码，所以你抛出了这个话题，哪怕最后没达到预期效果，面试官也不会由此对你降低评价。所以说，准备这块绝对是“有百利而无一害”的挣钱买卖。  </p>
<h2 id="一切的一切，把上述技能嵌入到你做过的项目里"><a href="#一切的一切，把上述技能嵌入到你做过的项目里" class="headerlink" title="一切的一切，把上述技能嵌入到你做过的项目里"></a>一切的一切，把上述技能嵌入到你做过的项目里</h2><p>在面试过程中，我经常会听到一些比较遗憾的回答，比如候选人对SQL优化技能讲得头头是道，但最后得知，这是他平时自学时掌握的，并没用在实际项目里。  </p>
<p>当然这总比不说要好，所以我会写下“在平时自学过SQL优化技能”，但如果在项目里实践过，那么我就会写下“有实际数据库SQL优化的技能”。大家可以对比下两者的差别，一个是偏重理论，一个是直接能干活了。其实，很多场景里，我就不信在实际项目里一定没有实践过SQL优化技能。  </p>
<p>从这个案例中，我想告诉大家的是，你之前费了千辛万苦（其实方法方向得到，也不用费太大精力）准备的很多技能和说辞，最后应该落实到你的实际项目里。  </p>
<p>比如你有过在Linux日志里查询关键字排查问题的经验，在描述时你可以带一句，在之前的项目里我就这样干的。又如，你通过看底层代码，了解了TreeSet和HashSet的差别以及它们的适用范围，那么你就可以回想下你之前做的项目，是否有个场景仅仅适用于TreeSet？如果有，那么你就可以适当描述下项目的需求，然后说，通过读底层代码，我了解了两者的差别，而且在这个实际需求里，我就用了TreeSet，而且我还专门做了对比性试验，发现用TreeSet比HashSet要高xx个百分点。  </p>
<p>请记得，“实践经验”一定比“理论经验”值钱，而且大多数你知道的理论上的经验，一定在你的项目里用过。所以，如果你仅仅让面试官感觉你只有“理论经验”，那就太亏了。  </p>
<h2 id="小结：前文更多讲述的准备面试的方法"><a href="#小结：前文更多讲述的准备面试的方法" class="headerlink" title="小结：前文更多讲述的准备面试的方法"></a>小结：前文更多讲述的准备面试的方法</h2><p>前文给出的面试题并不多，大家更多看到的是面试官发现的诸多候选人的痛点。  </p>
<p>前文的用意是让大家别再重蹈别人的覆辙，这还不算，本文还给出了不少准备面试的方法。你的能力或许比别人出众，但如果你准备面试的方式和别人差不多，或者就拿你在项目里干的活来说事，而没有归纳出你在项目中的亮点，那么面试官还真的会看扁你。</p>
<h2 id="JAVA多线程和并发基础面试问答"><a href="#JAVA多线程和并发基础面试问答" class="headerlink" title="JAVA多线程和并发基础面试问答"></a>JAVA多线程和并发基础面试问答</h2><p>多线程和并发问题是Java技术面试中面试官比较喜欢问的问题之一。在这里，从面试的角度列出了大部分重要的问题，但是你仍然应该牢固的掌握Java多线程基础知识来对应日后碰到的问题。</p>
<h3 id="Java多线程面试问题"><a href="#Java多线程面试问题" class="headerlink" title="Java多线程面试问题"></a>Java多线程面试问题</h3><h2 id="JAVA多线程和并发基础面试问答-1"><a href="#JAVA多线程和并发基础面试问答-1" class="headerlink" title="JAVA多线程和并发基础面试问答"></a>JAVA多线程和并发基础面试问答</h2><p>多线程和并发问题是Java技术面试中面试官比较喜欢问的问题之一。在这里，从面试的角度列出了大部分重要的问题，但是你仍然应该牢固的掌握Java多线程基础知识来对应日后碰到的问题。</p>
<h3 id="Java多线程面试问题-1"><a href="#Java多线程面试问题-1" class="headerlink" title="Java多线程面试问题"></a>Java多线程面试问题</h3><h4 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h4><p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成该任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。欲了解更多详细信息请<a href="http://java67.blogspot.com/2014/01/10-points-about-thread-and-javalangthread-in-java.html" target="_blank" rel="external">点击这里</a>。</p>
<h4 id="进程和线程之间有什么不同？"><a href="#进程和线程之间有什么不同？" class="headerlink" title="进程和线程之间有什么不同？"></a>进程和线程之间有什么不同？</h4><p>一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。Java运行环境是一个包含了不同的类和程序的单一进程。线程可以被称为轻量级进程。线程需要较少的资源来创建和驻留在进程中，并且可以共享进程中的资源。<br>线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。更多详细信息请<a href="http://java67.blogspot.com/2012/12/what-is-difference-between-thread-vs-process-java.html" target="_blank" rel="external">点击这里</a>。</p>
<h4 id="有哪些不同的线程生命周期？"><a href="#有哪些不同的线程生命周期？" class="headerlink" title="有哪些不同的线程生命周期？"></a>有哪些不同的线程生命周期？</h4><p>当我们在Java程序中新建一个线程时，它的状态是New。当我们调用线程的start()方法时，状态被改变为Runnable。线程调度器会为Runnable线程池中的线程分配CPU时间并且将它们的状态改变为Running。其他的线程状态还有Waiting，Blocked 和Dead。读这篇文章可以了解更多关于<a href="https://www.journaldev.com/1044/thread-life-cycle-in-java-thread-states-in-java" target="_blank" rel="external">线程生命周期</a>的知识。</p>
<h4 id="多线程编程的好处是什么？"><a href="#多线程编程的好处是什么？" class="headerlink" title="多线程编程的好处是什么？"></a>多线程编程的好处是什么？</h4><p>在多线程程序中，多个线程被并发的执行以提高程序的效率，CPU不会因为某个线程需要等待资源而进入空闲状态。多个线程共享堆内存(heap memory)，因此创建多个线程去执行一些任务会比创建多个进程更好。举个例子，Servlets比CGI更好，是因为Servlets支持多线程而CGI不支持。</p>
<h4 id="用户线程和守护线程有什么区别？"><a href="#用户线程和守护线程有什么区别？" class="headerlink" title="用户线程和守护线程有什么区别？"></a>用户线程和守护线程有什么区别？</h4><p>当我们在Java程序中创建一个线程，它就被称为用户线程。一个守护线程是在后台执行并且不会阻止JVM终止的线程。当没有用户线程在运行的时候，JVM关闭程序并且退出。一个守护线程创建的子线程依然是守护线程。</p>
<h4 id="我们如何创建一个线程？"><a href="#我们如何创建一个线程？" class="headerlink" title="我们如何创建一个线程？"></a>我们如何创建一个线程？</h4><p>有两种创建线程的方法：一是实现Runnable接口，然后将它传递给Thread的构造函数，创建一个Thread对象；二是直接继承Thread类。若想了解更多可以阅读这篇关于如何在<a href="https://www.journaldev.com/1016/java-thread-example" target="_blank" rel="external">Java中创建线程</a>的文章。</p>
<h4 id="用Runnable还是Thread？"><a href="#用Runnable还是Thread？" class="headerlink" title="用Runnable还是Thread？"></a>用Runnable还是Thread？</h4><p>　　这个问题是上题的后续，大家都知道我们可以通过继承Thread类或者调用Runnable接口来实现线程，问题是，那个方法更好呢？什么情况下使用它？这个问题很容易回答，如果你知道Java不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他类，当然是调用Runnable接口好了。更多详细信息请<a href="http://javarevisited.blogspot.sg/2012/01/difference-thread-vs-runnable-interface.html" target="_blank" rel="external">点击这里</a>。</p>
<h4 id="Thread-类中的start-和-run-方法有什么区别？"><a href="#Thread-类中的start-和-run-方法有什么区别？" class="headerlink" title="Thread 类中的start() 和 run() 方法有什么区别？"></a>Thread 类中的start() 和 run() 方法有什么区别？</h4><p> 这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。更多讨论请<a href="http://javarevisited.blogspot.sg/2012/03/difference-between-start-and-run-method.html" target="_blank" rel="external">点击这里</a>。</p>
<h4 id="可以直接调用Thread类的run-方法么？"><a href="#可以直接调用Thread类的run-方法么？" class="headerlink" title="可以直接调用Thread类的run()方法么？"></a>可以直接调用Thread类的run()方法么？</h4><p>当然可以，但是如果我们调用了Thread的run()方法，它的行为就会和普通的方法一样，为了在新的线程中执行我们的代码，必须使用Thread.start()方法。</p>
<h4 id="Java中Runnable和Callable有什么不同？"><a href="#Java中Runnable和Callable有什么不同？" class="headerlink" title="Java中Runnable和Callable有什么不同？"></a>Java中Runnable和Callable有什么不同？</h4><p>　　Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这些功能。Callable可以返回装载有计算结果的Future对象。更多讨论请<a href="http://java67.blogspot.com/2013/01/difference-between-callable-and-runnable-java.html" target="_blank" rel="external">点击这里</a>。</p>
<h4 id="Java中CyclicBarrier-和-CountDownLatch有什么不同？"><a href="#Java中CyclicBarrier-和-CountDownLatch有什么不同？" class="headerlink" title="Java中CyclicBarrier 和 CountDownLatch有什么不同？"></a>Java中CyclicBarrier 和 CountDownLatch有什么不同？</h4><p>　　CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。与 CyclicBarrier 不同的是，CountdownLatch 不能重新使用。点此查看更多信息和示例代码。</p>
<h4 id="Java中Semaphore是什么？"><a href="#Java中Semaphore是什么？" class="headerlink" title="Java中Semaphore是什么？"></a>Java中Semaphore是什么？</h4><p>　　Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。更多详细信息请<a href="http://javarevisited.blogspot.com/2012/05/counting-semaphore-example-in-java-5.html" target="_blank" rel="external">点击这里</a>。</p>
<h4 id="Java内存模型是什么？"><a href="#Java内存模型是什么？" class="headerlink" title="Java内存模型是什么？"></a>Java内存模型是什么？</h4><p>　　Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。比如，先行发生关系确保了：</p>
<p>线程内的代码能够按先后顺序执行，这被称为程序次序规则。<br>对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。<br>前一个对volatile的写操作在后一个volatile的读操作之前，也叫volatile变量规则。<br>一个线程内的任何操作必需在这个线程的start()调用之后，也叫作线程启动规则。<br>一个线程的所有操作都会在线程终止之前，线程终止规则。<br>一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。<br>可传递性<br>　强烈建议大家阅读《Java并发编程实践》第十六章来加深对Java内存模型的理解。</p>
<h4 id="Java中的volatile-变量是什么？"><a href="#Java中的volatile-变量是什么？" class="headerlink" title="Java中的volatile 变量是什么？"></a>Java中的volatile 变量是什么？</h4><p>　　volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生，就是上一题的volatile变量规则。<a href="http://javarevisited.blogspot.com/2011/06/volatile-keyword-java-example-tutorial.html" target="_blank" rel="external">点击这里</a>查看更多volatile的相关内容。</p>
<h4 id="volatile关键字在Java中有什么作用？"><a href="#volatile关键字在Java中有什么作用？" class="headerlink" title="volatile关键字在Java中有什么作用？"></a>volatile关键字在Java中有什么作用？</h4><p>当我们使用volatile关键字去修饰变量的时候，所以线程都会直接读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的。</p>
<h4 id="什么是线程安全？Vector是一个线程安全类吗？"><a href="#什么是线程安全？Vector是一个线程安全类吗？" class="headerlink" title="什么是线程安全？Vector是一个线程安全类吗？"></a>什么是线程安全？Vector是一个线程安全类吗？</h4><p>　　如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。<a href="http://javarevisited.blogspot.sg/2011/09/difference-vector-vs-arraylist-in-java.html" target="_blank" rel="external">点击这里</a>查看更多。</p>
<h4 id="如何确保线程安全？"><a href="#如何确保线程安全？" class="headerlink" title="如何确保线程安全？"></a>如何确保线程安全？</h4><p>在Java中可以有很多方法来保证线程安全——同步，使用原子类(atomic concurrent classes)，实现并发锁，使用volatile关键字，使用不变类和线程安全类。在<a href="https://www.journaldev.com/1061/thread-safety-in-java" target="_blank" rel="external">线程安全教程</a>中，你可以学到更多。</p>
<h4 id="Java中什么是竞态条件？-举个例子说明。"><a href="#Java中什么是竞态条件？-举个例子说明。" class="headerlink" title="Java中什么是竞态条件？ 举个例子说明。"></a>Java中什么是竞态条件？ 举个例子说明。</h4><p>　　竞态条件会导致程序在并发情况下出现一些bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的bugs。这种bugs很难发现而且会重复出现，因为线程间的随机竞争。一个例子就是无序处理，详见<a href="http://javarevisited.blogspot.com/2012/02/what-is-race-condition-in.html" target="_blank" rel="external">这里</a>。</p>
<h4 id="如何让正在运行的线程暂停一段时间？"><a href="#如何让正在运行的线程暂停一段时间？" class="headerlink" title="如何让正在运行的线程暂停一段时间？"></a>如何让正在运行的线程暂停一段时间？</h4><p>我们可以使用Thread类的Sleep()方法让线程暂停一段时间。需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为Runnable，并且根据线程调度，它将得到执行。</p>
<h4 id="Java中如何停止一个线程？"><a href="#Java中如何停止一个线程？" class="headerlink" title="Java中如何停止一个线程？"></a>Java中如何停止一个线程？</h4><p>　　Java提供了很丰富的API但没有为停止线程提供API。JDK 1.0本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了，之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当run() 或者 call() 方法执行完的时候线程会自动结束,如果要手动结束一个线程，你可以用volatile 布尔变量来退出run()方法的循环或者是取消任务来中断线程。点击<a href="http://javarevisited.blogspot.com/2011/10/how-to-stop-thread-java-example.html" target="_blank" rel="external">这里</a>查看示例代码。</p>
<h4 id="一个线程运行时发生异常会怎样？"><a href="#一个线程运行时发生异常会怎样？" class="headerlink" title="一个线程运行时发生异常会怎样？"></a>一个线程运行时发生异常会怎样？</h4><p>　　这是我在一次面试中遇到的一个<a href="http://java67.blogspot.sg/2012/09/top-10-tricky-java-interview-questions-answers.html" target="_blank" rel="external">很刁钻的Java面试题</a>, 简单的说，如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。</p>
<h4 id="如何在两个线程间共享数据？"><a href="#如何在两个线程间共享数据？" class="headerlink" title="如何在两个线程间共享数据？"></a>如何在两个线程间共享数据？</h4><p>　　你可以通过共享对象来实现这个目的，或者是使用像阻塞队列这样并发的数据结构。这篇教程<a href="http://javarevisited.blogspot.sg/2013/12/inter-thread-communication-in-java-wait-notify-example.html" target="_blank" rel="external">《Java线程间通信》</a>(涉及到在两个线程间共享对象)用wait和notify方法实现了生产者消费者模型。</p>
<h4 id="Java中notify-和-notifyAll有什么区别？"><a href="#Java中notify-和-notifyAll有什么区别？" class="headerlink" title="Java中notify 和 notifyAll有什么区别？"></a>Java中notify 和 notifyAll有什么区别？</h4><p>　　这又是一个刁钻的问题，因为多线程可以等待单监控锁，Java API 的设计人员提供了一些方法当等待条件改变的时候通知它们，但是这些方法没有完全实现。notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。<a href="http://javarevisited.blogspot.com/2012/10/difference-between-notify-and-notifyall-java-example.html" target="_blank" rel="external">详情</a>。</p>
<h4 id="为什么wait-notify-和-notifyAll这些方法不在thread类里面？"><a href="#为什么wait-notify-和-notifyAll这些方法不在thread类里面？" class="headerlink" title="为什么wait, notify 和 notifyAll这些方法不在thread类里面？"></a>为什么wait, notify 和 notifyAll这些方法不在thread类里面？</h4><p>   Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法<br>　这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。你也可以查看<a href="http://javarevisited.blogspot.sg/2012/02/why-wait-notify-and-notifyall-is.html" target="_blank" rel="external">这篇文章</a>了解更多。</p>
<h4 id="为什么wait-notify-和notifyAll-必须在同步方法或者同步块中被调用？"><a href="#为什么wait-notify-和notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？"></a>为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？</h4><p>当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用，否则会抛出<code>IllegalMonitorStateException</code>异常。</p>
<h4 id="Thread类中的yield方法有什么作用？"><a href="#Thread类中的yield方法有什么作用？" class="headerlink" title="Thread类中的yield方法有什么作用？"></a>Thread类中的yield方法有什么作用？</h4><p>　　Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。<br>  Thread.yield()在哪个线程中被调用就<br>表示哪个线程愿意放弃处理器资源.<a href="http://java67.blogspot.sg/2012/08/difference-between-yield-and-wait.html" target="_blank" rel="external">点击这里</a>查看更多yield方法的相关内容。</p>
<h4 id="为什么Thread类的sleep-和yield-方法是静态的？"><a href="#为什么Thread类的sleep-和yield-方法是静态的？" class="headerlink" title="为什么Thread类的sleep()和yield()方法是静态的？"></a>为什么Thread类的sleep()和yield()方法是静态的？</h4><p>Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</p>
<h4 id="你对线程优先级的理解是什么？"><a href="#你对线程优先级的理解是什么？" class="headerlink" title="你对线程优先级的理解是什么？"></a>你对线程优先级的理解是什么？</h4><p>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级。</p>
<h4 id="什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？"><a href="#什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？" class="headerlink" title="什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？"></a>什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？</h4><p>线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。</p>
<h4 id="什么是线程池？-为什么要使用它？"><a href="#什么是线程池？-为什么要使用它？" class="headerlink" title="什么是线程池？ 为什么要使用它？"></a>什么是线程池？ 为什么要使用它？</h4><p>　　创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。 一个线程池管理了一组工作线程，同时它还包括了一个用于放置等待执行的任务的队列。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。更多内容详见<a href="https://www.journaldev.com/2340/java-scheduler-scheduledexecutorservice-scheduledthreadpoolexecutor-example" target="_blank" rel="external">这篇文章</a>。</p>
<h4 id="在多线程中，什么是上下文切换-context-switching-？"><a href="#在多线程中，什么是上下文切换-context-switching-？" class="headerlink" title="在多线程中，什么是上下文切换(context-switching)？"></a>在多线程中，什么是上下文切换(context-switching)？</h4><p>上下文切换是存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。</p>
<h4 id="你如何确保main-方法所在的线程是Java程序最后结束的线程？"><a href="#你如何确保main-方法所在的线程是Java程序最后结束的线程？" class="headerlink" title="你如何确保main()方法所在的线程是Java程序最后结束的线程？"></a>你如何确保main()方法所在的线程是Java程序最后结束的线程？</h4><p>我们可以使用Thread类的join()方法来确保所有程序创建的线程在main()方法退出前结束。这里有一篇文章关于<a href="https://www.journaldev.com/1024/java-thread-join-example" target="_blank" rel="external">Thread类的joint()</a>方法。</p>
<h4 id="线程之间是如何通信的？"><a href="#线程之间是如何通信的？" class="headerlink" title="线程之间是如何通信的？"></a>线程之间是如何通信的？</h4><p>当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。Object类中wait()\notify()\notifyAll()方法可以用于线程间通信关于资源的锁的状态。点击<a href="https://www.journaldev.com/1037/java-thread-wait-notify-and-notifyall-example" target="_blank" rel="external">这里</a>有更多关于线程wait, notify和notifyAll。</p>
<h4 id="同步方法和同步块，哪个是更好的选择？"><a href="#同步方法和同步块，哪个是更好的选择？" class="headerlink" title="同步方法和同步块，哪个是更好的选择？"></a>同步方法和同步块，哪个是更好的选择？</h4><p>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</p>
<h4 id="如何创建守护线程？"><a href="#如何创建守护线程？" class="headerlink" title="如何创建守护线程？"></a>如何创建守护线程？</h4><p>使用Thread类的<code>setDaemon(true)</code>方法可以将线程设置为守护线程，需要注意的是，需要在调用start()方法前调用这个方法，否则会抛出<code>IllegalThreadStateException</code>异常。</p>
<h4 id="什么是ThreadLocal"><a href="#什么是ThreadLocal" class="headerlink" title="什么是ThreadLocal?"></a>什么是ThreadLocal?</h4><p>ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。</p>
<p>每个线程都会拥有他们自己的Thread变量，它们可以使用get()\set()方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal实例通常是希望它们同线程状态关联起来是private static属性。在<a href="https://www.journaldev.com/1076/java-threadlocal-example" target="_blank" rel="external">ThreadLocal</a>例子这篇文章中你可以看到一个关于ThreadLocal的小程序。</p>
<p>ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数。查看<a href="http://javarevisited.blogspot.sg/2012/05/how-to-use-threadlocal-in-java-benefits.html" target="_blank" rel="external">答案</a>了解更多。</p>
<h4 id="什么是FutureTask？"><a href="#什么是FutureTask？" class="headerlink" title="什么是FutureTask？"></a>什么是FutureTask？</h4><p>　　在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。</p>
<h4 id="Java中interrupted-和-isInterruptedd方法的区别？"><a href="#Java中interrupted-和-isInterruptedd方法的区别？" class="headerlink" title="Java中interrupted 和 isInterruptedd方法的区别？"></a>Java中interrupted 和 isInterruptedd方法的区别？</h4><p>　　interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用<a href="http://java67.blogspot.com/2012/11/what-is-static-class-variable-method.html" target="_blank" rel="external">静态方法</a>Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。</p>
<h4 id="什么是Thread-Group？为什么建议使用它？"><a href="#什么是Thread-Group？为什么建议使用它？" class="headerlink" title="什么是Thread Group？为什么建议使用它？"></a>什么是Thread Group？为什么建议使用它？</h4><p>ThreadGroup是一个类，它的目的是提供关于线程组的信息。</p>
<p>ThreadGroup API比较薄弱，它并没有比Thread提供了更多的功能。它有两个主要的功能：一是获取线程组中处于活跃状态线程的列表；二是设置为线程设置未捕获异常处理器(ncaught exception handler)。但在Java 1.5中Thread类也添加了setUncaughtExceptionHandler(UncaughtExceptionHandler eh) 方法，所以ThreadGroup是已经过时的，不建议继续使用。</p>
<pre><code>t1.setUncaughtExceptionHandler(new UncaughtExceptionHandler(){
@Override
public void uncaughtException(Thread t, Throwable e) {
System.out.println(&quot;exception occured:&quot;+e.getMessage());
}
});
</code></pre><h4 id="什么是Java-Timer类？如何创建一个有特定时间间隔的任务？"><a href="#什么是Java-Timer类？如何创建一个有特定时间间隔的任务？" class="headerlink" title="什么是Java Timer类？如何创建一个有特定时间间隔的任务？"></a>什么是Java Timer类？如何创建一个有特定时间间隔的任务？</h4><p>java.util.Timer是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer类可以用安排一次性任务或者周期任务。</p>
<p>java.util.TimerTask是一个实现了Runnable接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用Timer去安排它的执行。</p>
<p>这里有关于<a href="https://www.journaldev.com/1050/java-timer-timertask-example" target="_blank" rel="external">java Timer</a>的例子。</p>
<h4 id="为什么你应该在循环中检查等待条件"><a href="#为什么你应该在循环中检查等待条件" class="headerlink" title="为什么你应该在循环中检查等待条件?"></a>为什么你应该在循环中检查等待条件?</h4><p>　　处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因，你可以在Eclipse中创建模板调用wait和notify试一试。如果你想了解更多关于这个问题的内容，我推荐你阅读《Effective Java》这本书中的线程和同步章节。</p>
<h4 id="Java中的同步集合与并发集合有什么区别？"><a href="#Java中的同步集合与并发集合有什么区别？" class="headerlink" title="Java中的同步集合与并发集合有什么区别？"></a>Java中的同步集合与并发集合有什么区别？</h4><p>　　同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。更多内容详见<a href="http://javarevisited.blogspot.com/2010/10/what-is-difference-between-synchronized.html" target="_blank" rel="external">答案</a>。</p>
<h3 id="Java中ConcurrentHashMap的并发度是什么？"><a href="#Java中ConcurrentHashMap的并发度是什么？" class="headerlink" title="Java中ConcurrentHashMap的并发度是什么？"></a>Java中ConcurrentHashMap的并发度是什么？</h3><p>　　ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是ConcurrentHashMap类构造函数的一个可选参数，默认值为16，这样在多线程情况下就能避免争用。欲了解更多并发度和内部大小调整请阅读文章<a href="http://javarevisited.blogspot.com/2013/02/concurrenthashmap-in-java-example-tutorial-working.html" target="_blank" rel="external">How ConcurrentHashMap works in Java</a>。</p>
<h4 id="Java中堆和栈有什么不同？"><a href="#Java中堆和栈有什么不同？" class="headerlink" title="Java中堆和栈有什么不同？"></a>Java中堆和栈有什么不同？</h4><p>　　为什么把这个问题归类在多线程和并发面试题里？因为栈是一块和线程紧密相关的内存区域。每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。 更多内容详见<a href="http://javarevisited.blogspot.com/2013/01/difference-between-stack-and-heap-java.html" target="_blank" rel="external">答案</a>。</p>
<h4 id="如何写代码来解决生产者消费者问题？"><a href="#如何写代码来解决生产者消费者问题？" class="headerlink" title="如何写代码来解决生产者消费者问题？"></a>如何写代码来解决生产者消费者问题？</h4><p>　　在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务供其它线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比较低级的办法是用wait和notify来解决这个问题，比较赞的办法是用Semaphore 或者 BlockingQueue来实现生产者消费者模型，<a href="http://javarevisited.blogspot.sg/2012/02/producer-consumer-design-pattern-with.html" target="_blank" rel="external">这篇教程</a>有实现它。</p>
<h4 id="什么是死锁-Deadlock-？如何分析和避免死锁？"><a href="#什么是死锁-Deadlock-？如何分析和避免死锁？" class="headerlink" title="什么是死锁(Deadlock)？如何分析和避免死锁？"></a>什么是死锁(Deadlock)？如何分析和避免死锁？</h4><p>　　Java多线程中的死锁 死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：</p>
<ul>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<p>避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。<a href="http://javarevisited.blogspot.com/2010/10/what-is-deadlock-in-java-how-to-fix-it.html" target="_blank" rel="external">这篇教程</a>有代码示例和避免死锁的讨论细节。</p>
<p>分析死锁，我们需要查看Java应用程序的线程转储。我们需要找出那些状态为BLOCKED的线程和他们等待的资源。每个资源都有一个唯一的id，用这个id我们可以找出哪些线程已经拥有了它的对象锁。</p>
<p>避免嵌套锁，只在需要的地方使用锁和避免无限期等待是避免死锁的通常办法，阅读这篇文章去学习<a href="https://www.journaldev.com/1058/deadlock-in-java-example" target="_blank" rel="external">如何分析死锁</a>。</p>
<h4 id="Java中活锁和死锁有什么区别？"><a href="#Java中活锁和死锁有什么区别？" class="headerlink" title="Java中活锁和死锁有什么区别？"></a>Java中活锁和死锁有什么区别？</h4><p>　　这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。</p>
<h4 id="怎么检测一个线程是否拥有锁？"><a href="#怎么检测一个线程是否拥有锁？" class="headerlink" title="怎么检测一个线程是否拥有锁？"></a>怎么检测一个线程是否拥有锁？</h4><p>　　我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我参加了一次电话面试。在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。你可以查看<a href="http://javarevisited.blogspot.com/2010/10/how-to-check-if-thread-has-lock-on.html" target="_blank" rel="external">这篇文章</a>了解更多。</p>
<h4 id="什么是Java线程转储-Thread-Dump-如何在Java中获取线程堆栈？"><a href="#什么是Java线程转储-Thread-Dump-如何在Java中获取线程堆栈？" class="headerlink" title="什么是Java线程转储(Thread Dump)?如何在Java中获取线程堆栈？"></a>什么是Java线程转储(Thread Dump)?如何在Java中获取线程堆栈？</h4><p>   线程转储是一个JVM活动线程的列表，它对于分析系统瓶颈和死锁非常有用。<br>　对于不同的操作系统，有多种方法来获得Java进程的线程堆栈。当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台。在Windows你可以使用Ctrl + Break组合键来获取线程堆栈，Linux下用kill -3命令。你也可以用jstack这个工具来获取，它对线程id进行操作，你可以用jps这个工具找到id,可以编写一些脚本去定时的产生线程转储以待分析。<br>  读这篇文档可以了解更多关于产生<a href="https://www.journaldev.com/1053/java-thread-dump-visualvm-jstack-kill-3-jcmd" target="_blank" rel="external">线程转储</a>的知识。</p>
<h4 id="JVM中哪个参数是用来控制线程的栈堆栈小的"><a href="#JVM中哪个参数是用来控制线程的栈堆栈小的" class="headerlink" title="JVM中哪个参数是用来控制线程的栈堆栈小的"></a>JVM中哪个参数是用来控制线程的栈堆栈小的</h4><p>　　这个问题很简单， -Xss参数用来控制线程的堆栈大小。你可以查看<a href="http://javarevisited.blogspot.com/2011/11/hotspot-jvm-options-java-examples.html" target="_blank" rel="external">JVM配置列表</a>来了解这个参数的更多信息。</p>
<h4 id="Java中synchronized-和-ReentrantLock-有什么不同？"><a href="#Java中synchronized-和-ReentrantLock-有什么不同？" class="headerlink" title="Java中synchronized 和 ReentrantLock 有什么不同？"></a>Java中synchronized 和 ReentrantLock 有什么不同？</h4><p>　　Java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法或者块边界，尝试获取锁时不能中途取消等。Java 5 通过Lock接口提供了更复杂的控制来解决这些问题。 ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义且它还具有可扩展性。你可以查看<a href="http://javarevisited.blogspot.com/2013/03/reentrantlock-example-in-java-synchronized-difference-vs-lock.html" target="_blank" rel="external">这篇文章</a>了解更多</p>
<h4 id="Java中的ReadWriteLock是什么？"><a href="#Java中的ReadWriteLock是什么？" class="headerlink" title="Java中的ReadWriteLock是什么？"></a>Java中的ReadWriteLock是什么？</h4><p>　　一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。Java中的<code>ReadWriteLock</code>是Java 5 中新增的一个接口，一个<code>ReadWriteLock</code>维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下一个读锁可能会同时被多个读线程持有。写锁是独占的，你可以使用JDK中的ReentrantReadWriteLock来实现这个规则，它最多支持65535个写锁和65535个读锁。</p>
<h4 id="有三个线程T1，T2，T3，怎么确保它们按顺序执行？"><a href="#有三个线程T1，T2，T3，怎么确保它们按顺序执行？" class="headerlink" title="有三个线程T1，T2，T3，怎么确保它们按顺序执行？"></a>有三个线程T1，T2，T3，怎么确保它们按顺序执行？</h4><p>　　在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。你可以查看<a href="http://javarevisited.blogspot.sg/2013/02/how-to-join-multiple-threads-in-java-example-tutorial.html" target="_blank" rel="external">这篇文章</a>了解更多。</p>
<h4 id="如果你提交任务时，线程池队列已满。会时发会生什么？"><a href="#如果你提交任务时，线程池队列已满。会时发会生什么？" class="headerlink" title="如果你提交任务时，线程池队列已满。会时发会生什么？"></a>如果你提交任务时，线程池队列已满。会时发会生什么？</h4><p>　　这个问题问得很狡猾，许多程序员会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么<code>ThreadPoolExecutor’s submit()</code>方法将会抛出一个<code>RejectedExecutionException</code>异常。</p>
<h4 id="什么是阻塞式方法？"><a href="#什么是阻塞式方法？" class="headerlink" title="什么是阻塞式方法？"></a>什么是阻塞式方法？</h4><p>　　阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。更多详细信息请点击这里。</p>
<h4 id="Java线程池中submit-和-execute-方法有什么区别？"><a href="#Java线程池中submit-和-execute-方法有什么区别？" class="headerlink" title="Java线程池中submit() 和 execute()方法有什么区别？"></a>Java线程池中submit() 和 execute()方法有什么区别？</h4><p>　　两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。更多详细信息请<a href="http://javarevisited.blogspot.sg/2013/07/how-to-create-thread-pools-in-java-executors-framework-example-tutorial.html" target="_blank" rel="external">点击这里</a>。</p>
<h4 id="Swing是线程安全的吗？-为什么？"><a href="#Swing是线程安全的吗？-为什么？" class="headerlink" title="Swing是线程安全的吗？ 为什么？"></a>Swing是线程安全的吗？ 为什么？</h4><p>　　你可以很肯定的给出回答，Swing不是线程安全的，但是你应该解释这么回答的原因即便面试官没有问你为什么。当我们说swing不是线程安全的常常提到它的组件，这些组件不能在多线程中进行修改，所有对GUI组件的更新都要在AWT线程中完成，而Swing提供了同步和异步两种回调方法来进行更新。<a href="http://javarevisited.blogspot.com/2013/08/why-swing-is-not-thread-safe-in-java-Swingworker-Event-thread.html" target="_blank" rel="external">点击这里</a>查看更多swing和线程安全的相关内容。</p>
<h4 id="Java中invokeAndWait-和-invokeLater有什么区别？"><a href="#Java中invokeAndWait-和-invokeLater有什么区别？" class="headerlink" title="Java中invokeAndWait 和 invokeLater有什么区别？"></a>Java中invokeAndWait 和 invokeLater有什么区别？</h4><p>　　这两个方法是Swing API 提供给Java开发者用来从当前线程而不是事件派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用invokeAndWait()方法请求事件派发线程对组件进行相应更新。而invokeLater()方法是异步调用更新组件的。更多详细信息请<a href="http://javarevisited.blogspot.com/2011/09/invokeandwait-invokelater-swing-example.html" target="_blank" rel="external">点击这里</a>。</p>
<h4 id="Swing-API中哪些方法是线程安全的？"><a href="#Swing-API中哪些方法是线程安全的？" class="headerlink" title="Swing API中哪些方法是线程安全的？"></a>Swing API中哪些方法是线程安全的？</h4><p>　　这个问题又提到了swing和线程安全，虽然组件不是线程安全的但是有一些方法是可以被多线程安全调用的，比如<code>repaint()</code>, <code>revalidate()</code>。 <code>JTextComponent</code>的<code>setText()</code>方法和<code>JTextArea</code>的<code>insert()</code> 和 <code>append()</code> 方法也是线程安全的。</p>
<h4 id="如何在Java中创建Immutable对象？"><a href="#如何在Java中创建Immutable对象？" class="headerlink" title="如何在Java中创建Immutable对象？"></a>如何在Java中创建Immutable对象？</h4><p>　　这个问题看起来和多线程没什么关系， 但不变性有助于简化已经很复杂的并发程序。Immutable对象可以在没有同步的情况下共享，降低了对该对象进行并发访问时的同步化开销。可是Java没有@Immutable这个注解符，要创建不可变类，要实现下面几个步骤：通过构造方法初始化所有成员、对变量不要提供setter方法、将所有的成员声明为私有的，这样就不允许直接访问这些成员、在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝。<a href="http://javarevisited.blogspot.com/2013/03/how-to-create-immutable-class-object-java-example-tutorial.html" target="_blank" rel="external">how to make an object Immutable in Java</a>有详细的教程，看完你可以充满自信。</p>
<h4 id="多线程中的忙循环是什么"><a href="#多线程中的忙循环是什么" class="headerlink" title="多线程中的忙循环是什么?"></a>多线程中的忙循环是什么?</h4><p>　　忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。你可以查看<a href="http://java67.blogspot.com/2012/08/5-thread-interview-questions-answers-in.html" target="_blank" rel="external">这篇文章获</a>得更多信息。</p>
<h4 id="volatile-变量和-atomic-变量有什么不同？"><a href="#volatile-变量和-atomic-变量有什么不同？" class="headerlink" title="volatile 变量和 atomic 变量有什么不同？"></a>volatile 变量和 atomic 变量有什么不同？</h4><p>　　这是个有趣的问题。首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p>
<h4 id="如果同步块内的线程抛出异常会发生什么？"><a href="#如果同步块内的线程抛出异常会发生什么？" class="headerlink" title="如果同步块内的线程抛出异常会发生什么？"></a>如果同步块内的线程抛出异常会发生什么？</h4><p>　　这个问题坑了很多Java程序员，若你能想到锁是否释放这条线索来回答还有点希望答对。无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在<a href="http://javarevisited.blogspot.com/2012/11/difference-between-final-finally-and-finalize-java.html" target="_blank" rel="external">finally block</a>里释放锁实现。</p>
<h4 id="单例模式的双检锁是什么？"><a href="#单例模式的双检锁是什么？" class="headerlink" title="单例模式的双检锁是什么？"></a>单例模式的双检锁是什么？</h4><p>　　这个问题在Java面试中经常被问到，但是面试官对回答此问题的满意度仅为50%。一半的人写不出双检锁还有一半的人说不出它的隐患和Java1.5是如何对它修正的。它其实是一个用来创建线程安全的单例的老方法，当单例实例第一次被创建时它试图用单个锁进行性能优化，但是由于太过于复杂在JDK1.4中它是失败的，我个人也不喜欢它。无论如何，即便你也不喜欢它但是还是要了解一下，因为它经常被问到。你可以查看<a href="http://javarevisited.blogspot.sg/2014/05/double-checked-locking-on-singleton-in-java.html" target="_blank" rel="external">how double checked locking on Singleton works</a>这篇文章获得更多信息。</p>
<h4 id="如何在Java中创建线程安全的Singleton？"><a href="#如何在Java中创建线程安全的Singleton？" class="headerlink" title="如何在Java中创建线程安全的Singleton？"></a>如何在Java中创建线程安全的Singleton？</h4><p>　　这是上面那个问题的后续，如果你不喜欢双检锁而面试官问了创建Singleton类的替代方法，你可以利用JVM的类加载和静态变量初始化特征来创建Singleton实例，或者是利用枚举类型来创建Singleton，我很喜欢用这种方法。你可以查看<a href="http://javarevisited.blogspot.com/2012/12/how-to-create-thread-safe-singleton-in-java-example.html" target="_blank" rel="external">这篇文章</a>获得更多信息。</p>
<h4 id="写出3条你遵循的多线程最佳实践"><a href="#写出3条你遵循的多线程最佳实践" class="headerlink" title="写出3条你遵循的多线程最佳实践"></a>写出3条你遵循的多线程最佳实践</h4><p>　　这种问题我最喜欢了，我相信你在写并发代码来提升性能的时候也会遵循某些最佳实践。以下三条最佳实践我觉得大多数Java程序员都应该遵循：</p>
<ul>
<li>给你的线程起个有意义的名字。 这样可以方便找bug或追踪。   OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。</li>
<li>避免锁定和缩小同步的范围 锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。   </li>
<li>多用同步类少用wait 和 notify 首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。</li>
<li>多用并发集合少用同步集合 这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。<a href="http://javarevisited.blogspot.com/2013/02/concurrent-collections-from-jdk-56-java-example-tutorial.html" target="_blank" rel="external">Java并发集合</a>有更详细的说明。</li>
<li><h4 id="如何强制启动一个线程？"><a href="#如何强制启动一个线程？" class="headerlink" title="如何强制启动一个线程？"></a>如何强制启动一个线程？</h4>　　这个问题就像是如何强制进行Java垃圾回收，目前还没有觉得方法，虽然你可以使用System.gc()来进行垃圾回收，但是不保证能成功。在Java里面没有办法强制启动一个线程，它是被线程调度器控制着且Java没有公布相关的API。</li>
</ul>
<h4 id="Java中的fork-join框架是什么？"><a href="#Java中的fork-join框架是什么？" class="headerlink" title="Java中的fork join框架是什么？"></a>Java中的fork join框架是什么？</h4><p>　　fork join框架是JDK7中出现的一款高效的工具，Java开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。你可以查看<a href="http://javarevisited.blogspot.com/2011/09/fork-join-task-java7-tutorial.html" target="_blank" rel="external">这篇文章</a>获得更多信息。</p>
<h4 id="Java多线程中调用wait-和-sleep-方法有什么不同？"><a href="#Java多线程中调用wait-和-sleep-方法有什么不同？" class="headerlink" title="Java多线程中调用wait() 和 sleep()方法有什么不同？"></a>Java多线程中调用wait() 和 sleep()方法有什么不同？</h4><p>　　Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。你可以查看<a href="http://javarevisited.blogspot.com/2011/12/difference-between-wait-sleep-yield.html" target="_blank" rel="external">这篇文章</a>获得更多信息。</p>
<h3 id="Java并发面试问题"><a href="#Java并发面试问题" class="headerlink" title="Java并发面试问题"></a>Java并发面试问题</h3><h4 id="什么是原子操作？在Java-Concurrency-API中有哪些原子类-atomic-classes-？"><a href="#什么是原子操作？在Java-Concurrency-API中有哪些原子类-atomic-classes-？" class="headerlink" title="什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？"></a>什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？</h4><p>原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。</p>
<p>int++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。</p>
<p>为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。可以阅读这篇文章来了解<a href="https://www.journaldev.com/1095/atomicinteger-java" target="_blank" rel="external">Java的atomic类</a>。</p>
<h4 id="Java-Concurrency-API中的Lock接口-Lock-interface-是什么？对比同步它有什么优势？"><a href="#Java-Concurrency-API中的Lock接口-Lock-interface-是什么？对比同步它有什么优势？" class="headerlink" title="Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？"></a>Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？</h4><p>Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</p>
<p>它的优势有：</p>
<p>可以使锁更公平<br>可以使线程在等待锁的时候响应中断<br>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间<br>可以在不同的范围，以不同的顺序获取和释放锁<br><a href="https://www.journaldev.com/2377/java-lock-example-reentrantlock" target="_blank" rel="external">阅读更多关于锁的例子</a></p>
<h4 id="什么是Executors框架？"><a href="#什么是Executors框架？" class="headerlink" title="什么是Executors框架？"></a>什么是Executors框架？</h4><p>Executor框架同java.util.concurrent.Executor 接口在Java 5中被引入。Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。</p>
<p>无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用Executors框架可以非常方便的创建一个线程池，阅读这篇文章可以了解<a href="https://www.journaldev.com/1069/threadpoolexecutor-java-thread-pool-example-executorservice" target="_blank" rel="external">如何使用Executor框架创建一个线程池</a>。</p>
<h4 id="什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？"><a href="#什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？" class="headerlink" title="什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？"></a>什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？</h4><p>java.util.concurrent.BlockingQueue的特性是：当队列是空的时，从队列中获取或删除元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。</p>
<p>阻塞队列不接受空值，当你尝试向队列中添加空值的时候，它会抛出NullPointerException。</p>
<p>阻塞队列的实现都是线程安全的，所有的查询方法都是原子的并且使用了内部锁或者其他形式的并发控制。</p>
<p>BlockingQueue 接口是java collections框架的一部分，它主要用于实现生产者-消费者问题。</p>
<p>阅读这篇文章了解<a href="https://www.journaldev.com/1034/java-blockingqueue-example" target="_blank" rel="external">如何使用阻塞队列实现生产者-消费者问题</a>。</p>
<h4 id="什么是Callable和Future"><a href="#什么是Callable和Future" class="headerlink" title="什么是Callable和Future?"></a>什么是Callable和Future?</h4><p>Java 5在concurrency包中引入了java.util.concurrent.Callable 接口，它和Runnable接口很相似，但它可以返回一个对象或者抛出一个异常。</p>
<p><code>Callable</code>接口使用泛型去定义它的返回类型。<code>Executors</code>类提供了一些有用的方法去在线程池中执行Callable内的任务。由于<code>Callable</code>任务是并行的，我们必须等待它返回的结果。<code>java.util.concurrent.Future</code>对象为我们解决了这个问题。在线程池提交Callable任务后返回了一个Future对象，使用它我们可以知道Callable任务的状态和得到Callable返回的执行结果。Future提供了<code>get()</code>方法让我们可以等待Callable结束并获取它的执行结果。</p>
<p>阅读这篇文章了解更多关于<a href="https://www.journaldev.com/1090/java-callable-future-example" target="_blank" rel="external">Callable，Future</a>的例子。</p>
<h4 id="什么是FutureTask"><a href="#什么是FutureTask" class="headerlink" title="什么是FutureTask?"></a>什么是FutureTask?</h4><p><code>FutureTask</code>是<code>Future</code>的一个基础实现，我们可以将它同<code>Executors</code>使用处理异步任务。通常我们不需要使用<code>FutureTask</code>类，但当我们打算重写Future接口的一些方法并保持原来基础的实现是，它就变得非常有用。我们可以仅仅继承于它并重写我们需要的方法。阅读<a href="https://www.journaldev.com/1650/java-futuretask-example-program" target="_blank" rel="external">Java FutureTask</a>例子，学习如何使用它。</p>
<h4 id="什么是并发容器的实现？"><a href="#什么是并发容器的实现？" class="headerlink" title="什么是并发容器的实现？"></a>什么是并发容器的实现？</h4><p>Java集合类都是快速失败的，这就意味着当集合被改变且一个线程在使用迭代器遍历集合的时候，迭代器的next()方法将抛出<code>ConcurrentModificationException</code>异常。</p>
<p>并发容器支持并发的遍历和并发的更新。</p>
<p>主要的类有<code>ConcurrentHashMap</code>, <code>CopyOnWriteArrayList</code> 和<code>CopyOnWriteArraySet</code>。阅读这篇文章了解<a href="https://www.journaldev.com/378/java-util-concurrentmodificationexception" target="_blank" rel="external">如何避免<code>ConcurrentModificationException</code></a></p>
<h4 id="Executors类是什么？"><a href="#Executors类是什么？" class="headerlink" title="Executors类是什么？"></a>Executors类是什么？</h4><p><code>Executors</code>为<code>Executor</code>，<code>ExecutorService</code>，<code>ScheduledExecutorService</code>，<code>ThreadFactory</code>和<code>Callable</code>类提供了一些工具方法。</p>
<p><code>Executors</code>可以用于方便的创建线程池。</p>

      
      
        <div class="page-reward">
          <p><a href="javascript:void(0)" onclick="dashangToggle()" class="dashang">赏</a></p>
          <div class="hide_box"></div>
          <div class="shang_box">
            <a class="shang_close" href="javascript:void(0)" onclick="dashangToggle()">×</a>
            <div class="shang_tit">
              <p>如果文章对您有用请随意打赏！</p>
            </div>
            <div class="shang_payimg">
              <img src="/img/alipayimg.jpg" alt="扫码支持" title="扫一扫" />
            </div>
              <div class="pay_explain">谢谢支持！</div>
            <div class="shang_payselect">
              
                <div class="pay_item checked" data-id="alipay">
                  <span class="radiobox"></span>
                  <span class="pay_logo"><img src="/img/alipay.jpg" alt="支付宝" /></span>
                </div>
              
              
                <div class="pay_item" data-id="wechat">
                  <span class="radiobox"></span>
                  <span class="pay_logo"><img src="/img/weChat.jpg" alt="微信" /></span>
                </div>
              
            </div>
            <div class="shang_info">
              <p>打开<span id="shang_pay_txt">支付宝</span>扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
        </div>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
        <script type="text/javascript">
          $(".pay_item").click(function(){
            $(this).addClass('checked').siblings('.pay_item').removeClass('checked');
            var dataid=$(this).attr('data-id');
            $(".shang_payimg img").attr("src","/img/"+dataid+"img.jpg");
            $("#shang_pay_txt").text(dataid=="alipay"?"支付宝":"微信");
          });
          function dashangToggle(){
            
            $(".hide_box").fadeToggle();
            $(".shang_box").fadeToggle();
          }
        </script>
      
    </div>
    
  </div>
  
    
<div style="text-align:center;color: #ccc;font-size:14px;">
------ 本文结束 ------</div>
<br/>
<div style="border: 1px solid black">
<div style="margin-left:10px">
<span style="font-weight:blod">版权声明</span>
<img src="http://jet-han.gitee.io/img/copyright.png" >
<br/>
<p style="font-size: 10px;line-height: 30px"><a href="http://jet-han.gitee.io/" style="color:#258FC6">Jet's Blog</a> by <a href="http://jet-han.gitee.io/" style="color:#258FC6">Jet Han</a> is licensed under a <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" style="color:#258FC6">Creative Commons BY-NC-ND 4.0 International License</a>.<br/>
由<a href="http://jet-han.gitee.io" style="color:#258FC6"> jet han </a>创作并维护的<a href="http://jet-han.gitee.io" style="color:#258FC6"> jet </a>的博客采用<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" style="color:#258FC6">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br/>
本文首发于<a href="http://jet-han.gitee.io/" style="color:#258FC6">Jet</a> 的博客（ <a href="http://jet-han.gitee.io/" style="color:#258FC6">http://jet-han.oschina.io/</a> ），版权所有，侵权必究。</p>
</div>

    <div class="copyright">
        <p><span>本文标题:</span><a href="/2017/05/07/java后端开发面试/">java后端开发面试</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 Jet 的个人博客">Jet</a></p>
        <p><span>发布时间:</span>2017年05月07日 - 13时44分</p>
        <p><span>最后更新:</span>2017年05月07日 - 13时44分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2017/05/07/java后端开发面试/" title="java后端开发面试">https://jet-han.gitee.io/2017/05/07/java后端开发面试/</a>
            <span class="copy-path" data-clipboard-text="原文: https://jet-han.gitee.io/2017/05/07/java后端开发面试/　　作者: Jet" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
    <a href="/2017/05/27/Hexo-NexT主题搭建个人博客/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Hexo-NexT主题搭建个人博客
        
      </div>
    </a>
  
  
</nav>

</div>


  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#框架是重点，但别让人感觉你只会山寨别人的代码"><span class="toc-number">1.</span> <span class="toc-text">框架是重点，但别让人感觉你只会山寨别人的代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#别单纯看单机版的框架，适当了解些分布式"><span class="toc-number">2.</span> <span class="toc-text">别单纯看单机版的框架，适当了解些分布式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据库方面，别就知道增删改查，得了解性能优化"><span class="toc-number">3.</span> <span class="toc-text">数据库方面，别就知道增删改查，得了解性能优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java核心方面，围绕数据结构和性能优化准备面试题"><span class="toc-number">4.</span> <span class="toc-text">Java核心方面，围绕数据结构和性能优化准备面试题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux方面，至少了解如何看日志排查问题"><span class="toc-number">5.</span> <span class="toc-text">Linux方面，至少了解如何看日志排查问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通读一段底层代码，作为加分项"><span class="toc-number">6.</span> <span class="toc-text">通读一段底层代码，作为加分项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一切的一切，把上述技能嵌入到你做过的项目里"><span class="toc-number">7.</span> <span class="toc-text">一切的一切，把上述技能嵌入到你做过的项目里</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结：前文更多讲述的准备面试的方法"><span class="toc-number">8.</span> <span class="toc-text">小结：前文更多讲述的准备面试的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA多线程和并发基础面试问答"><span class="toc-number">9.</span> <span class="toc-text">JAVA多线程和并发基础面试问答</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java多线程面试问题"><span class="toc-number">9.1.</span> <span class="toc-text">Java多线程面试问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA多线程和并发基础面试问答-1"><span class="toc-number">10.</span> <span class="toc-text">JAVA多线程和并发基础面试问答</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java多线程面试问题-1"><span class="toc-number">10.1.</span> <span class="toc-text">Java多线程面试问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是线程？"><span class="toc-number">10.1.1.</span> <span class="toc-text">什么是线程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#进程和线程之间有什么不同？"><span class="toc-number">10.1.2.</span> <span class="toc-text">进程和线程之间有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有哪些不同的线程生命周期？"><span class="toc-number">10.1.3.</span> <span class="toc-text">有哪些不同的线程生命周期？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多线程编程的好处是什么？"><span class="toc-number">10.1.4.</span> <span class="toc-text">多线程编程的好处是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用户线程和守护线程有什么区别？"><span class="toc-number">10.1.5.</span> <span class="toc-text">用户线程和守护线程有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#我们如何创建一个线程？"><span class="toc-number">10.1.6.</span> <span class="toc-text">我们如何创建一个线程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用Runnable还是Thread？"><span class="toc-number">10.1.7.</span> <span class="toc-text">用Runnable还是Thread？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Thread-类中的start-和-run-方法有什么区别？"><span class="toc-number">10.1.8.</span> <span class="toc-text">Thread 类中的start() 和 run() 方法有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可以直接调用Thread类的run-方法么？"><span class="toc-number">10.1.9.</span> <span class="toc-text">可以直接调用Thread类的run()方法么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java中Runnable和Callable有什么不同？"><span class="toc-number">10.1.10.</span> <span class="toc-text">Java中Runnable和Callable有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java中CyclicBarrier-和-CountDownLatch有什么不同？"><span class="toc-number">10.1.11.</span> <span class="toc-text">Java中CyclicBarrier 和 CountDownLatch有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java中Semaphore是什么？"><span class="toc-number">10.1.12.</span> <span class="toc-text">Java中Semaphore是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java内存模型是什么？"><span class="toc-number">10.1.13.</span> <span class="toc-text">Java内存模型是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java中的volatile-变量是什么？"><span class="toc-number">10.1.14.</span> <span class="toc-text">Java中的volatile 变量是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile关键字在Java中有什么作用？"><span class="toc-number">10.1.15.</span> <span class="toc-text">volatile关键字在Java中有什么作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是线程安全？Vector是一个线程安全类吗？"><span class="toc-number">10.1.16.</span> <span class="toc-text">什么是线程安全？Vector是一个线程安全类吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何确保线程安全？"><span class="toc-number">10.1.17.</span> <span class="toc-text">如何确保线程安全？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java中什么是竞态条件？-举个例子说明。"><span class="toc-number">10.1.18.</span> <span class="toc-text">Java中什么是竞态条件？ 举个例子说明。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何让正在运行的线程暂停一段时间？"><span class="toc-number">10.1.19.</span> <span class="toc-text">如何让正在运行的线程暂停一段时间？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java中如何停止一个线程？"><span class="toc-number">10.1.20.</span> <span class="toc-text">Java中如何停止一个线程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一个线程运行时发生异常会怎样？"><span class="toc-number">10.1.21.</span> <span class="toc-text">一个线程运行时发生异常会怎样？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何在两个线程间共享数据？"><span class="toc-number">10.1.22.</span> <span class="toc-text">如何在两个线程间共享数据？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java中notify-和-notifyAll有什么区别？"><span class="toc-number">10.1.23.</span> <span class="toc-text">Java中notify 和 notifyAll有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么wait-notify-和-notifyAll这些方法不在thread类里面？"><span class="toc-number">10.1.24.</span> <span class="toc-text">为什么wait, notify 和 notifyAll这些方法不在thread类里面？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么wait-notify-和notifyAll-必须在同步方法或者同步块中被调用？"><span class="toc-number">10.1.25.</span> <span class="toc-text">为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Thread类中的yield方法有什么作用？"><span class="toc-number">10.1.26.</span> <span class="toc-text">Thread类中的yield方法有什么作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么Thread类的sleep-和yield-方法是静态的？"><span class="toc-number">10.1.27.</span> <span class="toc-text">为什么Thread类的sleep()和yield()方法是静态的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#你对线程优先级的理解是什么？"><span class="toc-number">10.1.28.</span> <span class="toc-text">你对线程优先级的理解是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？"><span class="toc-number">10.1.29.</span> <span class="toc-text">什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是线程池？-为什么要使用它？"><span class="toc-number">10.1.30.</span> <span class="toc-text">什么是线程池？ 为什么要使用它？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在多线程中，什么是上下文切换-context-switching-？"><span class="toc-number">10.1.31.</span> <span class="toc-text">在多线程中，什么是上下文切换(context-switching)？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#你如何确保main-方法所在的线程是Java程序最后结束的线程？"><span class="toc-number">10.1.32.</span> <span class="toc-text">你如何确保main()方法所在的线程是Java程序最后结束的线程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程之间是如何通信的？"><span class="toc-number">10.1.33.</span> <span class="toc-text">线程之间是如何通信的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步方法和同步块，哪个是更好的选择？"><span class="toc-number">10.1.34.</span> <span class="toc-text">同步方法和同步块，哪个是更好的选择？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何创建守护线程？"><span class="toc-number">10.1.35.</span> <span class="toc-text">如何创建守护线程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是ThreadLocal"><span class="toc-number">10.1.36.</span> <span class="toc-text">什么是ThreadLocal?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是FutureTask？"><span class="toc-number">10.1.37.</span> <span class="toc-text">什么是FutureTask？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java中interrupted-和-isInterruptedd方法的区别？"><span class="toc-number">10.1.38.</span> <span class="toc-text">Java中interrupted 和 isInterruptedd方法的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是Thread-Group？为什么建议使用它？"><span class="toc-number">10.1.39.</span> <span class="toc-text">什么是Thread Group？为什么建议使用它？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是Java-Timer类？如何创建一个有特定时间间隔的任务？"><span class="toc-number">10.1.40.</span> <span class="toc-text">什么是Java Timer类？如何创建一个有特定时间间隔的任务？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么你应该在循环中检查等待条件"><span class="toc-number">10.1.41.</span> <span class="toc-text">为什么你应该在循环中检查等待条件?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java中的同步集合与并发集合有什么区别？"><span class="toc-number">10.1.42.</span> <span class="toc-text">Java中的同步集合与并发集合有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中ConcurrentHashMap的并发度是什么？"><span class="toc-number">10.2.</span> <span class="toc-text">Java中ConcurrentHashMap的并发度是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java中堆和栈有什么不同？"><span class="toc-number">10.2.1.</span> <span class="toc-text">Java中堆和栈有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何写代码来解决生产者消费者问题？"><span class="toc-number">10.2.2.</span> <span class="toc-text">如何写代码来解决生产者消费者问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是死锁-Deadlock-？如何分析和避免死锁？"><span class="toc-number">10.2.3.</span> <span class="toc-text">什么是死锁(Deadlock)？如何分析和避免死锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java中活锁和死锁有什么区别？"><span class="toc-number">10.2.4.</span> <span class="toc-text">Java中活锁和死锁有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#怎么检测一个线程是否拥有锁？"><span class="toc-number">10.2.5.</span> <span class="toc-text">怎么检测一个线程是否拥有锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是Java线程转储-Thread-Dump-如何在Java中获取线程堆栈？"><span class="toc-number">10.2.6.</span> <span class="toc-text">什么是Java线程转储(Thread Dump)?如何在Java中获取线程堆栈？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM中哪个参数是用来控制线程的栈堆栈小的"><span class="toc-number">10.2.7.</span> <span class="toc-text">JVM中哪个参数是用来控制线程的栈堆栈小的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java中synchronized-和-ReentrantLock-有什么不同？"><span class="toc-number">10.2.8.</span> <span class="toc-text">Java中synchronized 和 ReentrantLock 有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java中的ReadWriteLock是什么？"><span class="toc-number">10.2.9.</span> <span class="toc-text">Java中的ReadWriteLock是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有三个线程T1，T2，T3，怎么确保它们按顺序执行？"><span class="toc-number">10.2.10.</span> <span class="toc-text">有三个线程T1，T2，T3，怎么确保它们按顺序执行？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如果你提交任务时，线程池队列已满。会时发会生什么？"><span class="toc-number">10.2.11.</span> <span class="toc-text">如果你提交任务时，线程池队列已满。会时发会生什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是阻塞式方法？"><span class="toc-number">10.2.12.</span> <span class="toc-text">什么是阻塞式方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java线程池中submit-和-execute-方法有什么区别？"><span class="toc-number">10.2.13.</span> <span class="toc-text">Java线程池中submit() 和 execute()方法有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Swing是线程安全的吗？-为什么？"><span class="toc-number">10.2.14.</span> <span class="toc-text">Swing是线程安全的吗？ 为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java中invokeAndWait-和-invokeLater有什么区别？"><span class="toc-number">10.2.15.</span> <span class="toc-text">Java中invokeAndWait 和 invokeLater有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Swing-API中哪些方法是线程安全的？"><span class="toc-number">10.2.16.</span> <span class="toc-text">Swing API中哪些方法是线程安全的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何在Java中创建Immutable对象？"><span class="toc-number">10.2.17.</span> <span class="toc-text">如何在Java中创建Immutable对象？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多线程中的忙循环是什么"><span class="toc-number">10.2.18.</span> <span class="toc-text">多线程中的忙循环是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-变量和-atomic-变量有什么不同？"><span class="toc-number">10.2.19.</span> <span class="toc-text">volatile 变量和 atomic 变量有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如果同步块内的线程抛出异常会发生什么？"><span class="toc-number">10.2.20.</span> <span class="toc-text">如果同步块内的线程抛出异常会发生什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单例模式的双检锁是什么？"><span class="toc-number">10.2.21.</span> <span class="toc-text">单例模式的双检锁是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何在Java中创建线程安全的Singleton？"><span class="toc-number">10.2.22.</span> <span class="toc-text">如何在Java中创建线程安全的Singleton？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#写出3条你遵循的多线程最佳实践"><span class="toc-number">10.2.23.</span> <span class="toc-text">写出3条你遵循的多线程最佳实践</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何强制启动一个线程？"><span class="toc-number">10.2.24.</span> <span class="toc-text">如何强制启动一个线程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java中的fork-join框架是什么？"><span class="toc-number">10.2.25.</span> <span class="toc-text">Java中的fork join框架是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java多线程中调用wait-和-sleep-方法有什么不同？"><span class="toc-number">10.2.26.</span> <span class="toc-text">Java多线程中调用wait() 和 sleep()方法有什么不同？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java并发面试问题"><span class="toc-number">10.3.</span> <span class="toc-text">Java并发面试问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是原子操作？在Java-Concurrency-API中有哪些原子类-atomic-classes-？"><span class="toc-number">10.3.1.</span> <span class="toc-text">什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-Concurrency-API中的Lock接口-Lock-interface-是什么？对比同步它有什么优势？"><span class="toc-number">10.3.2.</span> <span class="toc-text">Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是Executors框架？"><span class="toc-number">10.3.3.</span> <span class="toc-text">什么是Executors框架？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？"><span class="toc-number">10.3.4.</span> <span class="toc-text">什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是Callable和Future"><span class="toc-number">10.3.5.</span> <span class="toc-text">什么是Callable和Future?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是FutureTask"><span class="toc-number">10.3.6.</span> <span class="toc-text">什么是FutureTask?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是并发容器的实现？"><span class="toc-number">10.3.7.</span> <span class="toc-text">什么是并发容器的实现？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Executors类是什么？"><span class="toc-number">10.3.8.</span> <span class="toc-text">Executors类是什么？</span></a></li></ol></li></ol></li></ol>
</div>
<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
    }
</script>





<div class="bdsharebuttonbox">
	<a href="#" class="fx fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="fx fa-weixin bds_weixin" data-cmd="weixin" title="分享到微信"></a>
	<a href="#" class="fx fa-qq bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
	<a href="#" class="fx fa-facebook-official bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
	<a href="#" class="fx fa-twitter bds_twi" data-cmd="twi" title="分享到Twitter"></a>
	<a href="#" class="fx fa-linkedin bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
	<a href="#" class="fx fa-files-o bds_copy" data-cmd="copy" title="分享到复制网址"></a>
</div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>




    
        <!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" style="width:90%;margin:5% auto 0 auto;background: #fff;padding: 0 12px;border-radius: 5px;" data-uid="MTAyMC8yOTg3NS82NDQw">
	<script type="text/javascript">
   window.livereOptions = {
        refer: 'jet-han.gitee.io' + location.pathname
   };
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
	</script>
<noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->

  



    <div class="scroll" id="post-nav-button">
        
            <a href="/2017/05/27/Hexo-NexT主题搭建个人博客/" title="上一篇: Hexo-NexT主题搭建个人博客">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/" title="回到主页"><i class="fa fa-home"></i></a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/12/17/并发编程之synchronized与加锁机制/">并发编程之synchronized与加锁机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/12/jdk8💗特性/">jdk8💗特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/05/Cron/">Cron</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/30/Mybatis-MapperScannerConfigurer/">Mybatis-MapperScannerConfigurer</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/28/Mysql-SQL语句执行/">Mysql-SQL语句执行</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/28/Mysql-B-Tree索引/">Mysql-B-Tree索引</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/18/并发编程之CountDownLatch、CyclicBarrier和Semaphore/">并发编程之CountDownLatch、CyclicBarrier和Semaphore</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/14/Docker/">Docker</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/13/Spring中bean的生命周期/">Spring中bean的生命周期</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/08/设计模式/">设计模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/06/mysql数据库引擎/">mysql数据库引擎</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/06/并发编程之线程池ThreadPoolExecutor/">并发编程之线程池ThreadPoolExecutor</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/05/线程的实现方式/">线程的实现方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/05/jvm调优/">jvm调优</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/05/web-xml加载顺序/">web.xml加载顺序</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/05/sping之IOC，AOP/">sping之IOC，AOP</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/05/spring事务的传播属性和隔离级别/">spring事务的传播属性和隔离级别</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/05/乐观锁与悲观锁及应用举例/">乐观锁与悲观锁及应用举例</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/04/mysql事务隔离级别/">mysql事务隔离级别</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/01/equals、-和hashCode/">equals、==和hashCode</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/28/HashMap工作原理/">HashMap工作原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/28/volatile用法/">volatile用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/28/java常量池/">java常量池</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/28/string比较之‘’equals‘’和‘’==‘’/">string比较之‘’equals‘’和‘’==‘’</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/26/spring Bean的作用域/">spring Bean的作用域</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/20/jvm内存模型/">jvm内存模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/18/并发编程-线程间协作/">并发编程-线程间协作</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/17/nginx安装与使用/">nginx安装与使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/16/solr安装与使用/">solr安装与使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/16/crontab安装及使用/">crontab安装及使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/15/大数据平台-ambari/">大数据平台-ambari</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/10/mysql配置详解/">mysql配置详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/09/google-cloud搭建vpn/">google-cloud搭建vpn</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/08/java-IO/">java-IO</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/02/github搭建个人maven仓库/">github搭建个人maven仓库</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/24/git/">git</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/19/linux常用操作命令/">linux常用操作命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/17/redis安装及使用/">redis安装及使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/15/mysql主从备份/">mysql主从备份</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/12/Java Generics/">Java Generics</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/30/Markdown-语法说明/">Markdown-语法说明</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/30/java常见排序算法/">java常见排序算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/29/mysql索引及查询优化/">mysql索引及查询优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/28/java常用集合/">java常用集合/容器</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/27/递归和迭代/">递归和迭代</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/27/StringBuilder和StringBuffer/">StringBuilder和StringBuffer</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/27/Hexo-NexT主题搭建个人博客/">Hexo-NexT主题搭建个人博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/07/java后端开发面试/">java后端开发面试</a></li></ul>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
            }
        })
    </script>



    <script>
        
    </script>

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2020 学海无涯
            </div>
            <div class="footer-right">
                <span class="author" itemprop="copyrightHolder">Powered By - Jet</span>
            </div>
        </div>
        

      <div class="total_count">
          本站共 <span id="busuanzi_value_site_pv"></span><span id="site_pv">次访问</span>
          您是第 <span id="busuanzi_value_site_uv"></span><span id="site_uv">个小伙伴</span>
          本页累计 <span id="busuanzi_value_page_pv"></span><span id="page_pv">次阅读</span>
          已运行 <span id="showDays"></span><span id="show_days">天</span>
      </div>
      <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
      </script>
      <script>
        var birthDay = new Date('05/24/2017');
        var now = new Date();
        var duration = now.getTime() - birthDay.getTime();
        var total= Math.floor(duration / (1000 * 60 * 60 * 24));
        document.getElementById('showDays').innerHTML=total;
      </script>
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>
<!-- 优效ssp<script src="http://s.6travel.com/titi126.js"></script>-->

    <script>
        $(document).ready(function() {
            var backgroundnum = ;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>







  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("{{theme.leancloud_visitors.app_id}}", "{{theme.leancloud_visitors.app_key}}");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


    <script type="text/javascript">
      window.onload = function(){
        document.getElementById("search").onclick = function(){
            console.log("search")
            search();
        }
      }
      function search(){
        (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
        (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
        e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
        })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

        _st('install','A1Pz-LKMXbrzcFg2FWi6','2.0.0');
      }
    </script>


    <script type="text/javascript">
   document.oncontextmenu = function(){
     return false;
   }
   document.onkeydown = function(){
    if (event.ctrlKey && window.event.keyCode==67){
    return false;
    }
    if ((window.event.altKey)&& 
     ((window.event.keyCode==37)||   
      (window.event.keyCode==39))){alert("请访问主页"); 
    event.returnValue=false; 
    } 
if ((event.keyCode==8)||(event.keyCode==116)){//屏蔽 F5 刷新键 
    event.keyCode=0; 
    event.returnValue=false; 
    } 
if ((event.ctrlKey)&&(event.keyCode==78)){   //屏蔽 Ctrl+n 
    event.returnValue=false; 
    } 
if ((event.shiftKey)&&(event.keyCode==121)){ //屏蔽 shift+F10 
    event.returnValue=false; 
    }
if (event.keyCode==123){ //屏蔽 F12 
    event.returnValue=false;
    }
   }
  document.body.oncopy = function (){
   return false;
  }
  //不建议连选中文本都不行
  document.onselectstart = function(){
  //return false;
  }
    </script>


  </div>
</body>
</html>