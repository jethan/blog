<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>学海无涯</title>
  <subtitle>技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jet-han.oschina.io/"/>
  <updated>2017-07-02T14:49:25.107Z</updated>
  <id>http://jet-han.oschina.io/</id>
  
  <author>
    <name>JET</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>github搭建个人maven仓库</title>
    <link href="http://jet-han.oschina.io/2017/07/02/github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAmaven%E4%BB%93%E5%BA%93/"/>
    <id>http://jet-han.oschina.io/2017/07/02/github搭建个人maven仓库/</id>
    <published>2017-07-02T10:28:56.000Z</published>
    <updated>2017-07-02T14:49:25.107Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/images/icons/maven.jpg" alt="maven" title="maven"></p>
<a id="more"></a>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>三步：</p>
<p>deploy到本地目录<br>把本地目录提交到gtihub上<br>配置github地址为仓库地址<br>配置local file maven仓库</p>
<p>deploy到本地</p>
<p>maven可以通过http, ftp, ssh等deploy到远程服务器，也可以deploy到本地文件系统里。</p>
<p>例如把项目deploy到/home/jet/workspace/gerrit/maven_xm_repo/目录下：</p>
<pre><code>&lt;distributionManagement&gt;
    &lt;repository&gt;
      &lt;id&gt;hengyunabc-mvn-repo&lt;/id&gt;
      &lt;url&gt;file:/home/hengyunabc/code/maven-repo/repository/&lt;/url&gt;
    &lt;/repository&gt;
&lt;/distributionManagement&gt;
</code></pre><p>推荐使用命令行来deploy，避免在项目里显式配置:</p>
<pre><code>mvn deploy -DaltDeploymentRepository=maven_xm_repo::default::file:/home/jet/workspace/gerrit/maven_xm_repo/repository/
</code></pre><p>上面把项目deploy到本地目录/home/jet/workspace/gerrit/maven_xm_repo/repository/里，下面把这个目录提交到github上。</p>
<p>在Github上新建一个项目，然后把/home/jet/workspace/gerrit/maven_xm_repo/下的文件都提交到gtihub上。</p>
<pre><code>cd /home/jet/workspace/gerrit/maven_xm_repo/
git init
git add .
git commit -m &#39;deploy xxx&#39;
git remote add origin git@github.com:jethan/maven_xm_repo.git
git push origin master
</code></pre><p>最终效果可以参考我的个人仓库：</p>
<p><a href="https://github.com/jethan/maven_xm_repo" target="_blank" rel="external"><font color="#0366d6">maven_xm_repo</font></a></p>
<p><strong>github maven仓库的使用</strong></p>
<p>因为github使用了raw.githubusercontent.com这个域名用于raw文件下载。所以使用这个maven仓库，只要在pom.xml里增加：</p>
<pre><code>&lt;repositories&gt;
&lt;repository&gt;
&lt;id&gt;hengyunabc-maven-repo&lt;/id&gt;
&lt;url&gt;https://raw.githubusercontent.com/jethan/maven_xm_repo/master/repository&lt;/url&gt;
&lt;/repository&gt;
&lt;/repositories&gt;
</code></pre><p><strong>目录查看和搜索</strong></p>
<p>值得注意的是，github因为安全原因，把raw文件下载和原来的github域名分开了，而raw.githubusercontent.com这个域名是不支持目录浏览的。所以，想要浏览文件目录，或者搜索的话，可以直接到github域名下的仓库去查看。</p>
<p>比如文件fastjson-1.2.5.jar：</p>
<p><a href="https://github.com/jethan/maven_xm_repo/tree/master/repository/com/alibaba/fastjson/1.2.5/fastjson-1.2.5.jar" target="_blank" rel="external"><font color="#0366d6">浏览器url</font></a><br><a href="https://raw.githubusercontent.com/jethan/maven_xm_repo/repository/com/alibaba/fastjson/1.2.5/fastjson-1.2.5.jar" target="_blank" rel="external"><font color="#0366d6">maven仓库url</font></a></p>
<p><strong>maven仓库工作的机制</strong></p>
<p>下面介绍一些maven仓库工作的原理。典型的一个maven依赖下会有这三个文件：</p>
<pre><code>maven-metadata.xml
maven-metadata.xml.md5
maven-metadata.xml.sha1
</code></pre><p>maven-metadata.xml里面记录了最后deploy的版本和时间。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;metadata modelVersion=&quot;1.1.0&quot;&gt;
  &lt;groupId&gt;io.github.hengyunabc&lt;/groupId&gt;
  &lt;artifactId&gt;mybatis-ehcache-spring&lt;/artifactId&gt;
  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
  &lt;versioning&gt;
    &lt;snapshot&gt;
      &lt;timestamp&gt;20150804.095005&lt;/timestamp&gt;
      &lt;buildNumber&gt;1&lt;/buildNumber&gt;
    &lt;/snapshot&gt;
    &lt;lastUpdated&gt;20150804095005&lt;/lastUpdated&gt;

  &lt;/versioning&gt;
&lt;/metadata&gt;
</code></pre><p>其中md5, sha1校验文件是用来保证这个meta文件的完整性。</p>
<p>maven在编绎项目时，会先尝试请求<code>maven-metadata.xml</code>，如果没有找到，则会直接尝试请求到jar文件，在下载jar文件时也会尝试下载jar的md5, sha1文件。</p>
<p><code>maven-metadata.xml</code>文件很重要，如果没有这个文件来指明最新的jar版本，那么即使远程仓库里的jar更新了版本，本地maven编绎时用上-U参数，也不会拉取到最新的jar！</p>
<p>所以并不能简单地把jar包放到github上就完事了，一定要先在本地Deploy，生成maven-metadata.xml文件，并上传到github上。</p>
<p><a href="http://maven.apache.org/ref/3.2.2/maven-repository-metadata/repository-metadata.html" target="_blank" rel="external"><font color="#0366d6">参考</font></a></p>
<p><a href="https://maven.apache.org/repository/index.html" target="_blank" rel="external"><font color="#0366d6"><strong>maven的仓库关系</strong></font></a></p>
<p><img src="http://jet-han.oschina.io/images/github搭建个人maven仓库/maven-repositories.png" alt="maven" title="maven"></p>
<p>配置使用本地仓库</p>
<p>想要使用本地file仓库里，在项目的pom.xml里配置，如：</p>
<pre><code>&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;hengyunabc-maven-repo&lt;/id&gt;
        &lt;url&gt;file:/home/hengyunabc/code/maven-repo/repository/&lt;/url&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;
</code></pre><p><strong>注意事项</strong></p>
<p>maven的repository并没有优先级的配置，也不能单独为某些依赖配置repository。所以如果项目配置了多个repository，在首次编绎时，会依次尝试下载依赖。如果没有找到，尝试下一个，整个流程会很长。</p>
<p>所以尽量多个依赖放同一个仓库，不要每个项目都有一个自己的仓库。</p>
<p><a href="http://stackoverflow.com/questions/14013644/hosting-a-maven-repository-on-github/14013645#14013645" target="_blank" rel="external"><font color="#0366d6">参考1<font></font></font></a><br><a href="http://cemerick.com/2010/08/24/hosting-maven-repos-on-github/" target="_blank" rel="external"><font color="#0366d6">参考2<font></font></font></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/images/icons/maven.jpg&quot; alt=&quot;maven&quot; title=&quot;maven&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux常用操作命令(一)</title>
    <link href="http://jet-han.oschina.io/2017/06/19/linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4-%E4%B8%80/"/>
    <id>http://jet-han.oschina.io/2017/06/19/linux常用操作命令-一/</id>
    <published>2017-06-19T10:27:17.000Z</published>
    <updated>2017-06-24T08:51:50.158Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/images/icons/linux.jpg" alt="linux" title="linux"></p>
<a id="more"></a>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>　◆ <strong>安装和登录命令：</strong>login、shutdown、halt、reboot、install、mount、umount、chsh、exit、last；<br>　◆ <strong>文件处理命令：</strong>file、mkdir、dd、rm、grep、find、mv、cp、ls、diff、cat、ln、tail、head、more、less、cd、管道；<br>　◆ <strong>系统管理相关命令：</strong>df、top、free、quota、at、lp、adduser、groupadd、kill、crontab；<br>　◆ <strong>网络操作命令：</strong>ifconfig、ip、ping、netstat、telnet、ftp、route、rlogin、rcp、finger、mail、nslookup；<br>　◆ <strong>系统安全相关命令：</strong>passwd、su、umask、chgrp、chmod、chown、chattr、sudo ps、who、which、whois；<br>　◆ <strong>其它命令：</strong>tar、unzip、gunzip、unarj、mtools、man、unendcode、uudecode。</p>
<p><strong>系统管理命令</strong></p>
<pre><code>stat     ＃显示指定文件的详细信息，比ls更详细
who      ＃显示在线登陆用户
whoami   ＃显示当前操作用户
hostname 　＃显示主机名
uname    ＃显示系统信息
top      ＃动态显示当前耗费资源最多进程信息
ps       ＃显示瞬间进程状态 ps -aux
du       ＃查看目录大小 du -h /home带有单位显示目录信息
df       ＃查看磁盘大小 df -h 带有单位显示磁盘信息
ifconfig 　＃查看网络情况
ping     ＃测试网络连通
netstat  ＃显示网络状态信息
man      ＃命令不会用了，找男人? 如：man ls
clear    ＃清屏
alias    ＃对命令重命名 如：alias showmeit=”ps -aux” ，另外解除使用unaliax showmeit
kill    ＃杀死进程，可以先用ps 或 top命令查看进程的id，然后再用kill命令杀死进程。
</code></pre><p> <strong>常用基本指令</strong></p>
<pre><code>ls     #显示文件或目录
-l  #列出文件详细信息l(list)
-a  #列出当前目录下所有文件及目录，包括隐藏的a(all)
mkdir  #创建目录
-p  #创建目录，若无父目录，则创建p(parent)   
cd     #切换目录
touch  #创建空文件
echo   #创建带有内容的文件。
cat    #查看文件内容
cp     #拷贝
mv     #移动或重命名
rm     #删除文件
-r  #递归删除，可删除子目录及文件
-f  #强制删除
find   #在文件系统中搜索某文件
wc     #统计文本中行数、字数、字符数
grep   #在文本文件中查找某个字符串
rmdir  #删除空目录
tree   #树形结构显示目录，需要安装tree包
pwd    #显示当前目录
ln     #创建链接文件
more、less   #分页显示文本文件内容
head、tail   #显示文件头、尾内容
ctrl+alt+F1  #命令行全屏模式
</code></pre><p> <strong>下面只介绍一些常用的基本命令</strong></p>
<h2 id="安装和登录命令"><a href="#安装和登录命令" class="headerlink" title="安装和登录命令"></a>安装和登录命令</h2><h3 id="shutdown-halt-reboot-exit-logout"><a href="#shutdown-halt-reboot-exit-logout" class="headerlink" title="shutdown/halt/reboot/exit/logout"></a>shutdown/halt/reboot/exit/logout</h3><p><strong>命令说明</strong></p>
<pre><code>shutdown
-r      #关机重启
-h      #关机不重启
now     #立刻关机
halt        #关机
reboot      #重启
exit   #退出当前shell
logout  #退出登录shell
</code></pre><h3 id="mount-unmount"><a href="#mount-unmount" class="headerlink" title="mount/unmount"></a>mount/unmount</h3><p><strong>命令说明</strong></p>
<pre><code>fdisk -l   #查看磁盘情况
fdisk /dev/sda   #为/dev/sda设备分区
m   #显示所有命令
n     #添加分区
p/e    #主分区/逻辑分区
+50G  #指定分区大小为50G
p  #打印分区列表
w  #保存
reboot  #重启
cat /etc/fstab  #查看文件系统
mke2fs -t ext4 /dev/sda4 #格式化文件系统
mount /dev/sda4 /home #挂载到指定目录/home
umount #取消挂载

#开机自动挂载
echo &quot;/dev/sda4 /home ext4 defaults 1 1&quot; &gt;&gt; /etc/fstab
</code></pre><h2 id="文件处理命令"><a href="#文件处理命令" class="headerlink" title="文件处理命令"></a>文件处理命令</h2><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p><strong>一种编程语言，用于在linux/unix下对文本和数据进行处理</strong></p>
<p>数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。它在命令行中使用，但更多是作为脚本来使用。awk有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。</p>
<pre><code>  awk [options] &#39;script&#39; var=value file(s) 
  awk [options] -f scriptfile var=value file(s)

  -F fs   fs指定输入分隔符，fs可以是字符串或正则表达式，如-F: 
  -v var=value   赋值一个用户定义变量，将外部变量传递给awk 
  -f scripfile  从脚本文件中读取awk命令 
  -m[fr] val   对val值设置内在限制，-mf选项限制分配给val的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。
  {}  要执行的脚本内容 
  eg:
    cat /etc/passwd |awk  -F &#39;:&#39;  &#39;{print $1&quot;\t&quot;$7}&#39;
</code></pre><p> <strong>awk模式和操作</strong></p>
<p> awk脚本是由模式和操作组成的。 </p>
<p> <strong>模式 </strong></p>
<p> 模式可以是以下任意一个：</p>
<ol>
<li>/正则表达式/：使用通配符的扩展集。  </li>
<li>关系表达式：使用运算符进行操作，可以是字符串或数字的比较测试。  </li>
<li>模式匹配表达式：用运算符~（匹配）和~!（不匹配）。</li>
<li>BEGIN语句块、pattern语句块、END语句块：参见awk的工作原理 </li>
</ol>
<p><strong>操作</strong></p>
<p> 操作由一个或多个命令、函数、表达式组成，之间由换行符或分号隔开，并位于大括号内，主要部分是： </p>
<ol>
<li>变量或数组赋值  </li>
<li>输出命令   </li>
<li>内置函数  </li>
<li>控制流语句</li>
</ol>
<p><strong>awk脚本基本结构</strong></p>
<pre><code>awk &#39;BEGIN{ print &quot;start&quot; } pattern{ commands } END{ print &quot;end&quot; }&#39; file 
</code></pre><p>一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被单引号或双引号中，例如：</p>
<pre><code>awk &#39;BEGIN{ i=0 } { i++ } END{ print i }&#39; filename 
awk &quot;BEGIN{ i=0 } { i++ } END{ print i }&quot; filename 
</code></pre><p><strong>awk的工作原理</strong></p>
<pre><code>awk &#39;BEGIN{ commands } pattern{ commands } END{ commands }&#39; 
</code></pre><ul>
<li>第一步：执行BEGIN{ commands }语句块中的语句；  </li>
<li>第二步：从文件或标准输入(stdin)读取一行，然后执行pattern{ commands }语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。  </li>
<li>第三步：当读至输入流末尾时，执行END{ commands }语句块。 </li>
</ul>
<p><strong>BEGIN语句块</strong>在awk开始从输入流中读取行之前被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中。</p>
<p><strong>END语句块</strong>在awk从输入流中读取完所有的行之后即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它也是一个可选语句块。 </p>
<p><strong>pattern语句块</strong>中的通用命令是最重要的部分，它也是可选的。如果没有提供pattern语句块，则默认执行<code>{ print }</code>，即打印每一个读取到的行，awk读取的每一行都会执行该语句块。</p>
<p>eg：</p>
<pre><code>[jet@jet ~]$ echo -e &quot;A line 1\nA line 2&quot; | awk &#39;BEGIN{ print &quot;Start&quot; } { print } END{ print &quot;End&quot; }&#39;
Start
A line 1
A line 2
End
</code></pre><p>当使用不带参数的<code>print</code>时，它就打印当前行，当<code>print</code>的参数是以逗号进行分隔时，打印时则以空格作为定界符。<font color="#b22222">在awk的print语句块中双引号是被当作拼接符使用</font>，例如： </p>
<pre><code>echo | awk &#39;{ var1=&quot;v1&quot;; var2=&quot;v2&quot;; var3=&quot;v3&quot;; print var1,var2,var3; }&#39; 
v1 v2 v3 
</code></pre><p>双引号拼接使用： </p>
<pre><code>echo | awk &#39;{ var1=&quot;v1&quot;; var2=&quot;v2&quot;; var3=&quot;v3&quot;; print var1&quot;=&quot;var2&quot;=&quot;var3; }&#39; 
v1=v2=v3 
</code></pre><p>{ }类似一个循环体，会对文件中的每一行进行迭代，通常变量初始化语句（如：i=0）以及打印文件头部的语句放入BEGIN语句块中，将打印的结果等语句放在END语句块中。</p>
<p><strong>awk内置变量（预定义变量）</strong>  </p>
<p>说明：[A][N][P][G]表示第一个支持变量的工具，[A]=awk、[N]=nawk、[P]=POSIXawk、[G]=gawk </p>
<pre><code>$n 当前记录的第n个字段，比如n为1表示第一个字段，n为2表示第二个字段。 
$0 这个变量包含执行过程中当前行的文本内容。 
[N] ARGC 命令行参数的数目。 
[G] ARGIND 命令行中当前文件的位置（从0开始算）。 
[N] ARGV 包含命令行参数的数组。 
[G] CONVFMT 数字转换格式（默认值为%.6g）。 
[P] ENVIRON 环境变量关联数组。 
[N] ERRNO 最后一个系统错误的描述。 
[G] FIELDWIDTHS 字段宽度列表（用空格键分隔）。 
[A] FILENAME 当前输入文件的名。 
[P] FNR 同NR，但相对于当前文件。 
[A] FS 字段分隔符（默认是任何空格）。 
[G] IGNORECASE 如果为真，则进行忽略大小写的匹配。 
[A] NF 表示字段数，在执行过程中对应于当前的字段数。 
[A] NR 表示记录数，在执行过程中对应于当前的行号。 
[A] OFMT 数字的输出格式（默认值是%.6g）。
[A] OFS 输出字段分隔符（默认值是一个空格）。 
[A] ORS 输出记录分隔符（默认值是一个换行符）。 
[A] RS 记录分隔符（默认是一个换行符）。 
[N] RSTART 由match函数所匹配的字符串的第一个位置。 
[N] RLENGTH 由match函数所匹配的字符串的长度。 
[N] SUBSEP 数组下标分隔符（默认值是34）。 
</code></pre><p><strong>eg:</strong></p>
<pre><code>echo -e &quot;line1 f2 f3nline2 f4 f5nline3 f6 f7&quot; | awk &#39;{print &quot;Line No:&quot;NR&quot;, No of fields:&quot;NF, &quot;$0=&quot;$0, &quot;$1=&quot;$1, &quot;$2=&quot;$2, &quot;$3=&quot;$3}&#39; 
Line No:1, No of fields:3 $0=line1 f2 f3 $1=line1 $2=f2 $3=f3 
Line No:2, No of fields:3 $0=line2 f4 f5 $1=line2 $2=f4 $3=f5 
Line No:3, No of fields:3 $0=line3 f6 f7 $1=line3 $2=f6 $3=f7
</code></pre><p>使用<code>print $NF</code>可以打印出一行中的最后一个字段，使用<code>$(NF-1)</code>则是打印倒数第二个字段，其他以此类推：</p>
<pre><code>echo -e &quot;line1 f2 f3n line2 f4 f5&quot; | awk &#39;{print $NF}&#39; 
f3 
f5

echo -e &quot;line1 f2 f3n line2 f4 f5&quot; | awk &#39;{print $(NF-1)}&#39; 
f2 
f4 
</code></pre><p>打印每一行的第二和第三个字段：</p>
<pre><code>awk &#39;{ print $2,$3 }&#39; filename 
</code></pre><p>统计文件中的行数： </p>
<pre><code>awk &#39;END{ print NR }&#39; filename 
</code></pre><p>以上命令只使用了END语句块，在读入每一行的时，awk会将NR更新为对应的行号，当到达最后一行NR的值就是最后一行的行号，所以END语句块中的NR就是文件的行数。 </p>
<p>一个每一行中第一个字段值累加的例子：</p>
<pre><code>seq 5 | awk &#39;BEGIN{ sum=0; print &quot;总和：&quot; } { print $1&quot;+&quot;; sum+=$1 } END{ print &quot;等于&quot;; print sum }&#39; 
总和： 
1+ 
2+ 
3+ 
4+ 
5+ 
等于 
15
</code></pre><p><strong>将外部变量值传递给awk</strong></p>
<p>借助<code>-v</code><strong>选项</strong>，可以将外部值（并非来自stdin）传递给awk：</p>
<pre><code>VAR=10000 
echo | awk -v VARIABLE=$VAR &#39;{ print VARIABLE }&#39; 
</code></pre><p>另一种传递外部变量方法：</p>
<p>var1=”aaa”<br>var2=”bbb”<br>echo | awk ‘{ print v1,v2 }’ v1=$var1 v2=$var2 </p>
<p>当输入来自于文件时使用： </p>
<p>awk ‘{ print v1,v2 }’ v1=$var1 v2=$var2 filename </p>
<p>以上方法中，变量之间用空格分隔作为awk的命令行参数跟随在BEGIN、{}和END语句块之后。</p>
<p><strong>awk运算与判断</strong></p>
<p>作为一种程序设计语言所应具有的特点之一，awk支持多种运算，这些运算与C语言提供的基本相同。awk还提供了一系列内置的运算函数（如log、sqr、cos、sin等）和一些用于对字符串进行操作（运算）的函数（如length、substr等等）。这些函数的引用大大的提高了awk的运算功能。作为对条件转移指令的一部分，关系判断是每种程序设计语言都具备的功能，awk也不例外，awk中允许进行多种测试，作为样式匹配，还提供了模式匹配表达式~（匹配）和~!（不匹配）。作为对测试的一种扩充，awk也支持用逻辑运算符。</p>
<p><strong>算术运算符</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述符</th>
</tr>
</thead>
<tbody>
<tr>
<td>+ -</td>
<td>加，减</td>
</tr>
<tr>
<td>* / &amp;</td>
<td>乘，除与求余</td>
</tr>
<tr>
<td>+ - ！</td>
<td>一元加 ，减和逻辑非</td>
</tr>
<tr>
<td>^ ***</td>
<td>求冥</td>
</tr>
<tr>
<td>++ —</td>
<td>自增,自减 作为前缀或后缀</td>
</tr>
</tbody>
</table>
</div>
<p><strong>eg：</strong> </p>
<pre><code>awk &#39;BEGIN{a=&quot;b&quot;;print a++,++a;}&#39; 
0 
2 
</code></pre><font color="#b22222">注意：所有用作算术运算符进行操作，操作数自动转为数值，所有非数值都变为0</font> 

<p><strong>赋值运算符</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述符</th>
</tr>
</thead>
<tbody>
<tr>
<td>= += -= *= /= %= ^= **=</td>
<td>赋值语句</td>
</tr>
</tbody>
</table>
</div>
<p><strong>eg：</strong></p>
<pre><code>a+=5; 等价于：a=a+5; 
</code></pre><p><strong>逻辑运算符</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述  </th>
</tr>
</thead>
<tbody>
<tr>
<td>&#124;&#124;</td>
<td>逻辑或</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与</td>
</tr>
</tbody>
</table>
</div>
<p><strong>eg：</strong></p>
<pre><code>awk &#39;BEGIN{a=1;b=2;print (a&gt;5 &amp;&amp; b&lt;=2),(a&gt;5 || b&lt;=2);}&#39;
0 1 
</code></pre><p><strong>正则运算符</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>~ ~!</td>
<td>匹配正则表达式和不匹配正则表达式</td>
</tr>
</tbody>
</table>
</div>
<p><strong>eg：</strong></p>
<pre><code>awk &#39;BEGIN{a=&quot;100testa&quot;;if(a ~ /^100*/){print &quot;ok&quot;;}}&#39; 
ok 
</code></pre><p><strong>关系运算符</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt; &lt;= &gt; &gt;= != ==</td>
<td>关系运算符</td>
</tr>
</tbody>
</table>
</div>
<p><strong>eg：</strong></p>
<pre><code>awk &#39;BEGIN{a=11;if(a &gt;= 9){print &quot;ok&quot;;}}&#39; 
ok
</code></pre><font color="#b22222">注意：> < 可以作为字符串比较，也可以用作数值比较，关键看操作数如果是字符串就会转换为字符串比较。两个都为数字才转为数值比较。字符串比较：按照ASCII码顺序比较。</font>

<p><strong>其它运算符</strong> </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>$</td>
<td>字段引用</td>
</tr>
<tr>
<td>空格</td>
<td>字符串连接符</td>
</tr>
<tr>
<td>?:</td>
<td>C条件表达式</td>
</tr>
<tr>
<td>in</td>
<td>数组中是否存在某键值</td>
</tr>
</tbody>
</table>
</div>
<p><strong>eg：</strong></p>
<pre><code>awk &#39;BEGIN{a=&quot;b&quot;;print a==&quot;b&quot;?&quot;ok&quot;:&quot;err&quot;;}&#39; 
ok 
awk &#39;BEGIN{a=&quot;b&quot;;arr[0]=&quot;b&quot;;arr[1]=&quot;c&quot;;print (a in arr);}&#39; 
0 
awk &#39;BEGIN{a=&quot;b&quot;;arr[0]=&quot;b&quot;;arr[&quot;b&quot;]=&quot;c&quot;;print (a in arr);}&#39; 
1 
</code></pre><p><strong>运算级优先级表</strong></p>
<p><img src="http://jet-han.oschina.io/images/linux/awk.gif" alt="级别越高越优先" title="级别越高越优先"></p>
<p><strong>awk高级输入输出</strong></p>
<p>读取下一条记录 </p>
<p>awk中next语句使用：在循环逐行匹配，如果遇到next，就会跳过当前行，直接忽略下面语句。而进行下一行匹配。net语句一般用于多行合并： </p>
<pre><code>cat text.txt 
a 
b 
c 
d 
e 

awk &#39;NR%2==1{next}{print NR,$0;}&#39; text.txt 
2 b 
4 d 
</code></pre><p>当记录行号除以2余1，就跳过当前行。下面的<code>print NR,$0</code>也不会执行。下一行开始，程序有开始判断<code>NR%2</code>值。这个时候记录行号是<code>：2</code> ，就会执行下面语句块：<code>&#39;print NR,$0&#39;</code> </p>
<p>分析发现需要将包含有“web”行进行跳过，然后需要将内容与下面行合并为一行：</p>
<pre><code>[jet@jet oschina_hexo_server]$ cat test.txt 
web01[192.168.2.100] 
httpd ok 
tomcat ok 
sendmail ok 
web02[192.168.2.101] 
httpd ok 
postfix ok 
web03[192.168.2.102] 
mysqld ok 
httpd ok 
0

[jet@jet oschina_hexo_server]$ awk &#39;/^web/{T=$0;next;}{print T&quot;:\t&quot;$0;}&#39; test.txt 
web01[192.168.2.100] :    httpd ok 
web01[192.168.2.100] :    tomcat ok 
web01[192.168.2.100] :    sendmail ok 
web02[192.168.2.101] :    httpd ok 
web02[192.168.2.101] :    postfix ok 
web03[192.168.2.102] :    mysqld ok 
web03[192.168.2.102] :    httpd ok 
web03[192.168.2.102] :    0
web03[192.168.2.102] :    
</code></pre><p>简单地读取一条记录 <code>awk getline用法</code>：输出重定向需用到<code>getline函数</code>。getline从标准输入、管道或者当前正在处理的文件之外的其他输入文件获得输入。它负责从输入获得下一行的内容，并给NF,NR和FNR等内建变量赋值。<font color="#b22222">如果得到一条记录，getline函数返回1，如果到达文件的末尾就返回0，如果出现错误，例如打开文件失败，就返回-1。</font> </p>
<p>getline语法：getline var，变量var包含了特定行的内容。</p>
<p>awk getline从整体上来说，用法说明： </p>
<p><strong>当其左右<font color="#f00">无</font>重定向符<code>|</code>或<code>&lt;</code>时：</strong>getline作用于当前文件，读入当前文件的第一行给其后跟的变量<code>var</code>或<code>$0</code>（无变量），应该注意到，由于awk在处理getline之前已经读入了一行，所以getline得到的返回结果是隔行的。 </p>
<p><strong>当其左右<font color="#f00">有</font>重定向符<code>|</code>或<code>&lt;</code>时：</strong>getline则作用于定向输入文件，由于该文件是刚打开，并没有被awk读入一行，只是getline读入，那么getline返回的是该文件的第一行，而不是隔行。 </p>
<p><strong>eg：</strong> </p>
<p>执行linux的<a href="http://jet-han.oschina.io/2017/06/19/linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4-%E4%B8%80/#date">date</a>命令，并通过管道输出给<code>getline</code>，然后再把输出赋值给自定义变量out，并打印它： </p>
<pre><code>awk &#39;BEGIN{ &quot;date&quot; | getline out; print out }&#39; test 
</code></pre><p>执行shell的date命令，并通过管道输出给getline，然后getline从管道中读取并将输入赋值给out，split函数把变量out转化成数组mon，然后打印数组mon的第二个元素：</p>
<pre><code>awk &#39;BEGIN{ &quot;date&quot; | getline out; split(out,mon); print mon[2] }&#39; test 
</code></pre><p>命令<a href="http://jet-han.oschina.io/2017/06/19/linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4-%E4%B8%80/#ls">ls</a>的输出传递给geline作为输入，循环使getline从ls的输出中读取一行，并把它打印到屏幕。这里没有输入文件，因为BEGIN块在打开输入文件前执行，所以可以忽略输入文件。</p>
<pre><code>awk &#39;BEGIN{ while( &quot;ls&quot; | getline) print }&#39; 
</code></pre><p><strong>关闭文件</strong> </p>
<p>awk中允许在程序中关闭一个输入或输出文件，方法是使用awk的close语句。 </p>
<pre><code>close(&quot;filename&quot;) 
</code></pre><p>filename可以是getline打开的文件，也可以是stdin，包含文件名的变量或者getline使用的确切命令。或一个输出文件，可以是stdout，包含文件名的变量或使用管道的确切命令。 </p>
<p>输出到一个文件 awk中允许用如下方式将结果输出到一个文件： </p>
<pre><code>echo | awk &#39;{printf(&quot;hello word!n&quot;) &gt; &quot;datafile&quot;}&#39; 
或 
echo | awk &#39;{printf(&quot;hello word!n&quot;) &gt;&gt; &quot;datafile&quot;}&#39; 
</code></pre><p><strong>设置字段定界符</strong></p>
<p>默认的字段定界符是空格，可以使用<code>-F &quot;定界符&quot;</code>明确指定一个定界符： </p>
<pre><code>awk -F: &#39;{ print $NF }&#39; /etc/passwd 
或 
awk &#39;BEGIN{ FS=&quot;:&quot; } { print $NF }&#39; /etc/passwd 
</code></pre><p>在<code>BEGIN语句块</code>中则可以用<code>OFS=“定界符”</code>设置输出字段的定界符。 </p>
<p><strong>流程控制语句</strong></p>
<p>在linux awk的while、do-while和for语句中允许使用break,continue语句来控制流程走向，也允许使用exit这样的语句来退出。break中断当前正在执行的循环并跳到循环外执行下一条语句。if 是流程选择用法。awk中，流程控制语句，语法结构，与c语言类型。有了这些语句，其实很多shell程序都可以交给awk，而且性能是非常快的。下面是各个语句用法。 </p>
<p><strong>条件判断语句</strong></p>
<pre><code>if(表达式) 
语句1 
else 
语句2 
</code></pre><p>格式中语句1可以是多个语句，为了方便判断和阅读，最好将多个语句用{}括起来。awk分枝结构允许嵌套，其格式为：</p>
<pre><code>if(表达式) 
{语句1} 
else if(表达式) 
{语句2} 
else {语句3} 
</code></pre><p><strong>eg：</strong></p>
<pre><code>awk &#39;BEGIN{
test=100;
if(test&amp;gt;90){
  print &quot;very good&quot;;
  }
  else if(test&amp;gt;60){
    print &quot;good&quot;;
  }
  else{
    print &quot;no pass&quot;;
  }
}&#39;
</code></pre><p>   <span style="color:#808080;">very good</span></p>
<p>每条命令语句后面可以用<code>;</code>分号结尾。 </p>
<p><strong>循环语句</strong></p>
<p><strong>while语句</strong></p>
<pre><code>while(表达式) 
{语句} 
</code></pre><p><strong>eg：</strong></p>
<pre><code>awk &#39;BEGIN{
test=100;
total=0;
while(i&amp;lt;=test){
  total+=i;
  i++;
}
print total;
}&#39;
</code></pre><p>   <span style="color:#808080;">5050</span></p>
<p><strong>for循环</strong></p>
<p><strong>for循环有两种格式：</strong> </p>
<font color="#f00">格式1：</font>

<pre><code>for(变量 in 数组) 
{语句} 
</code></pre><p><strong>eg：</strong> </p>
<pre><code>awk &#39;BEGIN{
for(k in ENVIRON){
  print k&quot;=&quot;ENVIRON[k];
}
}&#39;

TERM=linux
G_BROKEN_FILENAMES=1
SHLVL=1 
pwd=/root/text
... 
logname=root 
HOME=/root 
SSH_CLIENT=192.168.1.21 53087 22
</code></pre><p>【注】ENVIRON是awk常量，是子典型数组。 </p>
<font color="#f00">格式2：</font> 

<pre><code>for(变量;条件;表达式) 
{语句} 
</code></pre><p><strong>eg：</strong></p>
<pre><code>awk &#39;BEGIN{
total=0;
for(i=0;i&amp;lt;=100;i++){
  total+=i;
}
print total;
}&#39;
</code></pre><p><strong>do循环</strong></p>
<pre><code>do {语句} 
while(条件) 
</code></pre><p><strong>eg：</strong></p>
<pre><code>awk &#39;BEGIN{ 
total=0;
i=0;
do {total+=i;i++;} while(i&amp;lt;=100)
  print total;
}&#39;
</code></pre><p> <span style="color:#808080;">5050</span></p>
<p><strong>其他语句</strong></p>
<ul>
<li><strong>break</strong> 当 break 语句用于 while 或 for 语句时，导致退出程序循环。  </li>
<li><strong>continue</strong> 当 continue 语句用于 while 或 for 语句时，使程序循环移动到下一个迭代。  </li>
<li><strong>next</strong> 能能够导致读入下一个输入行，并返回到脚本的顶部。这可以避免对当前输入行执行其他的操作过程。  </li>
<li><strong>exit</strong> 语句使主输入循环退出并将控制转移到END,如果END存在的话。如果没有定义END规则，或在END中应用exit语句，则终止脚本的执行。 </li>
</ul>
<p><strong>数组应用</strong></p>
<p>数组是awk的灵魂，处理文本中最不能少的就是它的数组处理。因为数组索引（下标）可以是数字和字符串在awk中数组叫做关联数组(associative arrays)。awk 中的数组不必提前声明，也不必声明大小。数组元素用0或空字符串来初始化，这根据上下文而定。 </p>
<p><strong>数组的定义</strong></p>
<p>数字做数组索引（下标）：</p>
<pre><code>Array[1]=&quot;sun&quot; 
Array[2]=&quot;kai&quot; 
</code></pre><p>字符串做数组索引（下标）： </p>
<pre><code>Array[&quot;first&quot;]=&quot;www&quot; 
Array[&quot;last&quot;]=&quot;name&quot; 
Array[&quot;birth&quot;]=&quot;1987&quot; 
</code></pre><p>使用中<code>print Array[1]</code>会打印出<code>sun；</code>使用<code>print Array[2]</code>会打印出kai；使用<code>print[&quot;birth&quot;]</code>会得到1987。</p>
<p><strong>读取数组的值</strong> </p>
<pre><code>{ for(item in array) {print array[item]}; } #输出的顺序是随机的 
{ for(i=1;i&lt;=len;i++) {print array[i]}; } #Len是数组的长度 
</code></pre><p><strong>数组相关函数</strong></p>
<p><strong>得到数组长度:</strong> </p>
<pre><code>awk &#39;BEGIN{info=&quot;it is a test&quot;;lens=split(info,tA,&quot; &quot;);print length(tA),lens;}&#39; 
4 4 
</code></pre><p>length返回字符串以及数组长度，split进行分割字符串为数组，也会返回分割得到数组长度。</p>
<pre><code>awk &#39;BEGIN{info=&quot;it is a test&quot;;split(info,tA,&quot; &quot;);print asort(tA);}&#39;
4 
</code></pre><p>asort对数组进行排序，返回数组长度。 </p>
<p>输出数组内容（无序，有序输出）：</p>
<p>awk ‘BEGIN{info=”it is a test”;split(info,tA,” “);for(k in tA){print k,tA[k];}}’<br>4 test<br>1 it<br>2 is<br>3 a </p>
<p><code>for…in</code>输出，因为数组是关联数组，默认是无序的。所以通过for…in得到是无序的数组。如果需要得到有序数组，需要通过下标获得。 </p>
<pre><code>awk &#39;BEGIN{info=&quot;it is a test&quot;;tlen=split(info,tA,&quot; &quot;);for(k=1;k&lt;=tlen;k++){print k,tA[k];}}&#39; 
1 it 
2 is 
3 a 
4 test 
</code></pre><p>注意：数组下标是从1开始，与C数组不一样。 </p>
<p><strong>判断键值存在以及删除键值：</strong> </p>
<pre><code>#错误的判断方法： 
awk &#39;BEGIN{tB[&quot;a&quot;]=&quot;a1&quot;;tB[&quot;b&quot;]=&quot;b1&quot;;if(tB[&quot;c&quot;]!=&quot;1&quot;){print &quot;no found&quot;;};for(k in tB){print k,tB[k];}}&#39; 
no found 
a a1 
b b1 
c 
</code></pre><p>以上出现奇怪问题，<code>tB[“c”]</code>没有定义，但是循环时候，发现已经存在该键值，它的值为空，这里需要注意，awk数组是关联数组，只要通过数组引用它的key，就会自动创建改序列。</p>
<pre><code>#正确判断方法： 
awk &#39;BEGIN{tB[&quot;a&quot;]=&quot;a1&quot;;tB[&quot;b&quot;]=&quot;b1&quot;;if( &quot;c&quot; in tB){print &quot;ok&quot;;};for(k in tB){print k,tB[k];}}&#39; 
a a1 
b b1 
</code></pre><p><code>if(key in array)</code>通过这种方法判断数组中是否包含<code>key</code>键值。</p>
<pre><code>#删除键值： 
[chengmo@localhost ~]$ awk &#39;BEGIN{tB[&quot;a&quot;]=&quot;a1&quot;;tB[&quot;b&quot;]=&quot;b1&quot;;delete tB[&quot;a&quot;];for(k in tB){print k,tB[k];}}&#39; 
b b1 
</code></pre><p><code>delete array[key]</code>可以删除，对应数组<code>ke</code>y的，序列值。</p>
<p><strong>二维、多维数组使用</strong></p>
<p>awk的多维数组在本质上是一维数组，更确切一点，awk在存储上并不支持多维数组。awk提供了逻辑上模拟二维数组的访问方式。例如，<code>array[2,4]=1</code>这样的访问是允许的。awk使用一个特殊的字符串<code>SUBSEP(�34)</code>作为分割字段，在上面的例子中，关联数组array存储的键值实际上是2�344。</p>
<p>类似一维数组的成员测试，多维数组可以使用<code>if ( (i,j) in array)</code>这样的语法，但是下标必须放置在圆括号中。类似一维数组的循环访问，多维数组使用<code>for ( item in array )</code>这样的语法遍历数组。与一维数组不同的是，多维数组必须使用<code>split()</code>函数来访问单独的下标分量。 </p>
<pre><code>awk &#39;BEGIN{
for(i=1;i&amp;lt;=9;i++){
  for(j=1;j&amp;lt;=9;j++){
    tarr[i,j]=i*j; print i,&quot;*&quot;,j,&quot;=&quot;,tarr[i,j];
  }
}
}&#39;

1 * 1 = 1
1 * 2 = 2
1 * 3 = 3
1 * 4 = 4
1 * 5 = 5
1 * 6 = 6 
...
9 * 6 = 54
9 * 7 = 63
9 * 8 = 72
9 * 9 = 81
</code></pre><p>可以通过array[k,k2]引用获得数组内容。 </p>
<p>另一种方法：</p>
<p>awk ‘BEGIN{ for(i=1;i&lt;=9;i++){ for(j=1;j&lt;=9;j++){ tarr[i,j]=i<em>j; } } for(m in tarr){ split(m,tarr2,SUBSEP); print tarr2[1],”</em>“,tarr2[2],”=”,tarr[m]; } }’</p>
<p><strong>内置函数</strong> </p>
<p>awk内置函数，主要分以下3种类似：算数函数、字符串函数、其它一般函数、时间函数</p>
<p><strong>算术函数</strong> </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>atan2( y, x )</td>
<td>返回 y/x 的反正切。</td>
</tr>
<tr>
<td>cos( x )</td>
<td>返回 x 的余弦；x 是弧度。</td>
</tr>
<tr>
<td>sin( x )</td>
<td>返回 x 的正弦；x 是弧度。</td>
</tr>
<tr>
<td>exp( x )</td>
<td>返回 x 幂函数。</td>
</tr>
<tr>
<td>log( x )</td>
<td>返回 x 的自然对数。</td>
</tr>
<tr>
<td>sqrt( x )</td>
<td>返回 x 平方根。</td>
</tr>
<tr>
<td>int( x )</td>
<td>返回 x 的截断至整数的值。</td>
</tr>
<tr>
<td>rand( )</td>
<td>返回任意数字 n，其中 0 &lt;= n &lt; 1。</td>
</tr>
<tr>
<td>srand( [expr] )</td>
<td>将 rand 函数的种子值设置为 Expr 参数的值，或如果省略 Expr 参数则使用某天的时间。返回先前的种子值。</td>
</tr>
</tbody>
</table>
</div>
<p>举例说明：</p>
<pre><code>awk &#39;BEGIN{OFMT=&quot;%.3f&quot;;fs=sin(1);fe=exp(10);fl=log(10);fi=int(3.1415);print fs,fe,fl,fi;}&#39; 

0.841 22026.466 2.303 3 
</code></pre><p>OFMT 设置输出数据格式是保留3位小数。 </p>
<p>获得随机数：</p>
<pre><code>awk &#39;BEGIN{srand();fr=int(100*rand());print fr;}&#39; 
78 
awk &#39;BEGIN{srand();fr=int(100*rand());print fr;}&#39; 
31 
awk &#39;BEGIN{srand();fr=int(100*rand());print fr;}&#39; 
41 
</code></pre><p><strong>字符串函数</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>gsub( Ere, Repl, [ In ] )</td>
<td>除了正则表达式所有具体值被替代这点，它和 sub 函数完全一样地执行。</td>
</tr>
<tr>
<td>sub( Ere, Repl, [ In ] )</td>
<td>用 Repl 参数指定的字符串替换 In 参数指定的字符串中的由 Ere 参数指定的扩展正则表达式的第一个具体值。sub 函数返回替换的数量。出现在 Repl 参数指定的字符串中的 &amp;（和符号）由 In 参数指定的与 Ere 参数的指定的扩展正则表达式匹配的字符串替换。如果未指定 In 参数，缺省值是整个记录（$0 记录变量）。</td>
</tr>
<tr>
<td>index( String1, String2 )</td>
<td>在由 String1 参数指定的字符串（其中有出现 String2 指定的参数）中，返回位置，从 1 开始编号。如果 String2 参数不在 String1 参数中出现，则返回 0（零）。 length [(String)]    返回 String 参数指定的字符串的长度（字符形式）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。 blength [(String)]    返回 String 参数指定的字符串的长度（以字节为单位）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。</td>
</tr>
<tr>
<td>substr( String, M, [ N ] )</td>
<td>返回具有 N 参数指定的字符数量子串。子串从 String 参数指定的字符串取得，其字符以 M 参数指定的位置开始。M 参数指定为将 String 参数中的第一个字符作为编号 1。如果未指定 N 参数，则子串的长度将是 M 参数指定的位置到 String 参数的末尾 的长度。</td>
</tr>
<tr>
<td>match( String, Ere )</td>
<td>在 String 参数指定的字符串（Ere 参数指定的扩展正则表达式出现在其中）中返回位置（字符形式），从 1 开始编号，或如果 Ere 参数不出现，则返回 0（零）。RSTART 特殊变量设置为返回值。RLENGTH 特殊变量设置为匹配的字符串的长度，或如果未找到任何匹配，则设置为 -1（负一）。</td>
</tr>
<tr>
<td>split( String, A, [Ere] )</td>
<td>将 String 参数指定的参数分割为数组元素 A[1], A[2], . . ., A[n]，并返回 n 变量的值。此分隔可以通过 Ere 参数指定的扩展正则表达式进行，或用当前字段分隔符（FS 特殊变量）来进行（如果没有给出 Ere 参数）。除非上下文指明特定的元素还应具有一个数字值，否则 A 数组中的元素用字符串值来创建。</td>
</tr>
<tr>
<td>tolower( String )</td>
<td>返回 String 参数指定的字符串，字符串中每个大写字符将更改为小写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。</td>
</tr>
<tr>
<td>toupper( String )</td>
<td>返回 String 参数指定的字符串，字符串中每个小写字符将更改为大写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。</td>
</tr>
<tr>
<td>sprintf(Format, Expr, Expr, . . . )</td>
<td>根据 Format 参数指定的 printf 子例程格式字符串来格式化 Expr 参数指定的表达式并返回最后生成的字符串。</td>
</tr>
</tbody>
</table>
</div>
<font color="#f00">注：Ere都可以是正则表达式。</font>

<p><strong>gsub,sub使用</strong></p>
<pre><code>awk &#39;BEGIN{info=&quot;this is a test2010test!&quot;;gsub(/[0-9]+/,&quot;!&quot;,info);print info}&#39; 
this is a test!test! 
</code></pre><p>在 info中查找满足正则表达式，<code>/[0-9]+/</code>用<code>””</code>替换，并且替换后的值，赋值给info 未给info值，默认是<code>$0</code> </p>
<p><strong>查找字符串（index使用）</strong></p>
<pre><code>awk &#39;BEGIN{info=&quot;this is a test2010test!&quot;;print index(info,&quot;test&quot;)?&quot;ok&quot;:&quot;no found&quot;;}&#39; 
ok 
</code></pre><p>未找到，返回0 </p>
<p><strong>正则表达式匹配查找(match使用）</strong></p>
<pre><code>awk &#39;BEGIN{info=&quot;this is a test2010test!&quot;;print match(info,/[0-9]+/)?&quot;ok&quot;:&quot;no found&quot;;}&#39; 
ok 
</code></pre><p><strong>截取字符串(substr使用）</strong></p>
<pre><code>[wangsl@centos5 ~]$ awk &#39;BEGIN{info=&quot;this is a test2010test!&quot;;print substr(info,4,10);}&#39; 
s is a tes 
</code></pre><p>从第 4个 字符开始，截取10个长度字符串 </p>
<p><strong>字符串分割（split使用）</strong></p>
<pre><code>awk &#39;BEGIN{info=&quot;this is a test&quot;;split(info,tA,&quot; &quot;);print length(tA);for(k in tA){print k,tA[k];}}&#39; 
4 
4 test 
1 this 
2 is 
3 a 
</code></pre><p>分割info，动态创建数组tA，这里比较有意思，awk for …in循环，是一个无序的循环。 并不是从数组下标1…n ，因此使用时候需要注意。</p>
<p><strong>格式化字符串输出（sprintf使用）</strong></p>
<p><strong>格式化字符串格式：</strong></p>
<p>其中格式化字符串包括两部分内容：一部分是正常字符，这些字符将按原样输出; 另一部分是格式化规定字符，以”%”开始，后跟一个或几个规定字符,用来确定输出内容格式。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>%d</td>
<td>十进制有符号整数</td>
</tr>
<tr>
<td>%u</td>
<td>十进制无符号整数</td>
</tr>
<tr>
<td>%f</td>
<td>浮点数</td>
</tr>
<tr>
<td>%s</td>
<td>字符串</td>
</tr>
<tr>
<td>%c</td>
<td>单个字符</td>
</tr>
<tr>
<td>%p</td>
<td>指针的值</td>
</tr>
<tr>
<td>%e</td>
<td>指数形式的浮点数</td>
</tr>
<tr>
<td>%x</td>
<td>%X无符号以十六进制表示的整数</td>
</tr>
<tr>
<td>%o</td>
<td>无符号以八进制表示的整数</td>
</tr>
<tr>
<td>%g</td>
<td>自动选择合适的表示法</td>
</tr>
</tbody>
</table>
</div>
<pre><code>awk &#39;BEGIN{n1=124.113;n2=-1.224;n3=1.2345; printf(&quot;%.2f,%.2u,%.2g,%X,%on&quot;,n1,n2,n3,n1,n1);}&#39;

124.11,18446744073709551615,1.2,7C,174            
</code></pre><p><strong>一般函数</strong> </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>close( Expression )</td>
<td>用同一个带字符串值的 Expression 参数来关闭由 print 或 printf 语句打开的或调用 getline 函数打开的文件或管道。如果文件或管道成功关闭，则返回 0；其它情况下返回非零值。如果打算写一个文件，并稍后在同一个程序中读取文件，则 close 语句是必需的。</td>
</tr>
<tr>
<td>system(command )</td>
<td>执行 Command 参数指定的命令，并返回退出状态。等同于 system 子例程。</td>
</tr>
<tr>
<td>Expression&#124;getline [ Variable ]</td>
<td>从来自 Expression 参数指定的命令的输出中通过管道传送的流中读取一个输入记录，并将该记录的值指定给 Variable 参数指定的变量。如果当前未打开将 Expression 参数的值作为其命令名称的流，则创建流。创建的流等同于调用 popen 子例程，此时 Command 参数取 Expression 参数的值且 Mode 参数设置为一个是 r 的值。只要流保留打开且 Expression 参数求得同一个字符串，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录。</td>
</tr>
<tr>
<td>getline [ Variable ] &lt; Expression</td>
<td>从 Expression 参数指定的文件读取输入的下一个记录，并将 Variable 参数指定的变量设置为该记录的值。只要流保留打开且 Expression 参数对同一个字符串求值，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录。</td>
</tr>
<tr>
<td>getline [ Variable ]</td>
<td>将 Variable 参数指定的变量设置为从当前输入文件读取的下一个输入记录。如果未指定 Variable 参数，则 $0 记录变量设置为该记录的值，还将设置 NF、NR 和 FNR 特殊变量。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>打开外部文件（close用法）</strong></p>
<pre><code>awk &#39;BEGIN{while(&quot;cat /etc/passwd&quot;|getline){print $0;};close(&quot;/etc/passwd&quot;);}&#39; root:x:0:0:root:/root:/bin/bash 
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin 
</code></pre><p><strong>逐行读取外部文件(getline使用方法）</strong> </p>
<pre><code>awk &#39;BEGIN{while(getline &lt; &quot;/etc/passwd&quot;){print $0;};close(&quot;/etc/passwd&quot;);}&#39; root:x:0:0:root:/root:/bin/bash 
bin:x:1:1:bin:/bin:/sbin/nologin 
daemon:x:2:2:daemon:/sbin:/sbin/nologin 

awk &#39;BEGIN{print &quot;Enter your name:&quot;;getline name;print name;}&#39; 
Enter your name: 
chengmo 
chengmo  
</code></pre><p><strong>调用外部应用程序(system使用方法）</strong></p>
<pre><code>awk &#39;BEGIN{b=system(&quot;ls -al&quot;);print b;}&#39; 
total 42092 
drwxr-xr-x 14 chengmo chengmo 4096 09-30 17:47 . 
drwxr-xr-x 95 root root 4096 10-08 14:01 .. 
</code></pre><p>b返回值，是执行结果。 </p>
<p><strong>时间函数</strong> </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>函数名</td>
<td>说明</td>
</tr>
<tr>
<td>mktime( YYYY MM dd HH MM ss[ DST])</td>
<td>生成时间格式</td>
</tr>
<tr>
<td>strftime([format [, timestamp]])</td>
<td>格式化时间输出，将时间戳转为时间字符串 具体格式，见下表. </td>
</tr>
<tr>
<td>systime()</td>
<td>得到时间戳,返回从1970年1月1日开始到当前时间(不计闰年)的整秒数</td>
</tr>
</tbody>
</table>
</div>
<p><strong>建指定时间(mktime使用）</strong></p>
<pre><code>awk &#39;BEGIN{tstamp=mktime(&quot;2001 01 01 12 12 12&quot;);print strftime(&quot;%c&quot;,tstamp);}&#39; 2001年01月01日 星期一 12时12分12秒 

awk &#39;BEGIN{tstamp1=mktime(&quot;2001 01 01 12 12 12&quot;);tstamp2=mktime(&quot;2001 02 01 0 0 0&quot;);print tstamp2-tstamp1;}&#39;
2634468 
</code></pre><p>求2个时间段中间时间差，介绍了strftime使用方法 </p>
<pre><code>awk &#39;BEGIN{tstamp1=mktime(&quot;2001 01 01 12 12 12&quot;);tstamp2=systime();print tstamp2-tstamp1;}&#39; 
308201392 
</code></pre><p><strong>strftime日期和时间格式说明符</strong> </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>%a</td>
<td>星期几的缩写(Sun)</td>
</tr>
<tr>
<td>%A</td>
<td>星期几的完整写法(Sunday)</td>
</tr>
<tr>
<td>%b</td>
<td>月名的缩写(Oct)</td>
</tr>
<tr>
<td>%B</td>
<td>月名的完整写法(October)</td>
</tr>
<tr>
<td>%c</td>
<td>本地日期和时间</td>
</tr>
<tr>
<td>%d</td>
<td>十进制日期</td>
</tr>
<tr>
<td>%D</td>
<td>日期 08/20/99</td>
</tr>
<tr>
<td>%e</td>
<td>日期，如果只有一位会补上一个空格</td>
</tr>
<tr>
<td>%H</td>
<td>用十进制表示24小时格式的小时</td>
</tr>
<tr>
<td>%I</td>
<td>用十进制表示12小时格式的小时</td>
</tr>
<tr>
<td>%j</td>
<td>从1月1日起一年中的第几天</td>
</tr>
<tr>
<td>%m</td>
<td>十进制表示的月份</td>
</tr>
<tr>
<td>%M</td>
<td>十进制表示的分钟</td>
</tr>
<tr>
<td>%p</td>
<td>12小时表示法(AM/PM)</td>
</tr>
<tr>
<td>%S</td>
<td>十进制表示的秒</td>
</tr>
<tr>
<td>%U</td>
<td>十进制表示的一年中的第几个星期(星期天作为一个星期的开始)</td>
</tr>
<tr>
<td>%w</td>
<td>十进制表示的星期几(星期天是0)</td>
</tr>
<tr>
<td>%W</td>
<td>十进制表示的一年中的第几个星期(星期一作为一个星期的开始)</td>
</tr>
<tr>
<td>%x</td>
<td>重新设置本地日期(08/20/99)</td>
</tr>
<tr>
<td>%X</td>
<td>重新设置本地时间(12：00：00)</td>
</tr>
<tr>
<td>%y</td>
<td>两位数字表示的年(99)</td>
</tr>
<tr>
<td>%Y</td>
<td>当前月份</td>
</tr>
<tr>
<td>%Z</td>
<td>时区(PDT)</td>
</tr>
<tr>
<td>%%</td>
<td>百分号(%)</td>
</tr>
</tbody>
</table>
</div>
<h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><ul>
<li><p><strong>对数据行进行替换、删除、新增、选取等操作</strong></p>
<pre><code>a   新增，在新的下一行出现
c   取代，取代 n1,n2 之间的行 eg: sed &#39;1,2c Hi&#39; ab
d   删除
i   插入，在新的上一行出现

eg:
  #指定时间段查看日志
  sed -n &#39;/2016-10-21 14:18:29/,/2016-10-21 18:18:29/p&#39; catalina.out
  #替换当前目录下所有文件中的 /usr/local为/data/dshp
  sed -i &quot;s/\/usr\/local/\/data\/dshp/g&quot; .
</code></pre></li>
</ul>
<h3 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h3><ul>
<li><p><strong>合并文件，需确保合并的两文件行数相同</strong></p>
<pre><code>-d  指定不同于空格或tab键的域分隔符
-s  按行合并，单独一个文件为一行
</code></pre></li>
</ul>
<h3 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h3><ul>
<li><p><strong>wc 计算数字</strong></p>
<p>利用wc指令我们可以计算文件的Byte数、字数或是列数，若不指定文件名称，或是所给予的文件名为“-”，则wc指令会从标准输入设备读取数据</p>
<pre><code>  wc(选项)(参数)
  #(选项)
  -c或--bytes或——chars：只显示Bytes数； 
  -l或——lines：只显示列数； 
  -w或——words：只显示字数。

  #(参数)
  文件：需要统计的文件列表。
</code></pre><p>统计当前文件夹下文件的个数</p>
<pre><code> ls -l |grep &quot;^-&quot;|wc -l
</code></pre><p>统计当前文件夹下目录的个数</p>
<pre><code> ls -l |grep &quot;^d&quot;|wc -l
</code></pre><p>统计当前文件夹下文件的个数，包括子文件夹里的</p>
<pre><code> ls -lR|grep &quot;^-&quot;|wc -l
</code></pre><p>统计文件夹下目录的个数，包括子文件夹里的</p>
<pre><code>ls -lR|grep &quot;^d&quot;|wc -l

ls -l #长列表输出当前文件夹下文件信息(注意这里的文件，不同于一般的文件，可能是目录、链接、设备文件等)
grep &quot;^-&quot; #这里将长列表输出信息过滤一部分，只保留一般文件，如果只保留目录就是 ^d
wc -l  #统计当前目录下指定文件后缀的行数，既可以统计项目的代码量
find . -name &quot;*.java&quot; -or -name &quot;*.jsp&quot; -or -name &quot;*.xml&quot; -or -name &quot;*.c&quot; |xargs grep -v &quot;^$&quot;|wc -l  #统计输出信息的行数，因为已经过滤得只剩一般文件了，所以统计结果就是一般文件信息的行数，又由于一行信息对应一个文件，所以也就是文件的个数  
</code></pre></li>
</ul>
<h3 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h3><ul>
<li><p><strong>uniq 去除文件中相邻的重复行</strong></p>
<pre><code>  清空/新建文件，将内容重定向输入进去 
  &amp;&gt; 正确、错误都重定向过去

  后面追加
</code></pre></li>
</ul>
<h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><ul>
<li><p>该命令用于判断接在file命令后的文件的基本数据，因为在Linux下文件的类型并不是以后缀为分的，所以这个命令对我们来说就很有用了，它的用法非常简单，基本语法如下：</p>
<pre><code> [plain] view plain copy print?
 file filename  
 #例如：  
 file ./test 
</code></pre></li>
</ul>
<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><ul>
<li><p><strong>创建新目录</strong></p>
<pre><code>mkdir [选项] 目录…
  -p  #递归创建目录，若父目录不存在则依次创建
    eg: mkdir -p ~/temp/test
  -m  #自定义创建目录的权限  
    eg:mkdir -m 777 temp
  -v  #显示创建目录的详细信息 
    eg:mkdir -m 662 -pv ~/temp/test
</code></pre></li>
</ul>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><ul>
<li><p><strong>用正则表达式搜索文本，并把匹配的行打印出来</strong></p>
<pre><code>grep ‘正则表达式’ 文件名 |
 -c  只输出匹配行的计数。
 -I  不区分大小写(只适用于单字符)。
 -l  只显示文件名
 -v  显示不包含匹配文本的所有行。
 -n  显示匹配行数据及其行号
 eg:
  # 取出文件urls.txt中包含mysql的行，并把找到的关键字加上颜色  
   grep --color=auto &#39;mysql&#39; urls.txt  
  # 把ls -l的输出中包含字母file（不区分大小写）的内容输出  
   ls -l | grep -i file
  # 查找当前目录下所有包含mysql的文件并逐行显示,文件路径+行号+匹配内容
  grep -rn  &quot;mysql&quot; ./*
</code></pre></li>
</ul>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><ul>
<li><p>在文件树种查找文件，并作出相应的处理</p>
<pre><code>find [PATH] [option] [action]
</code></pre><p>选项与参数：</p>
</li>
</ul>
<ol>
<li><p>与时间有关的选项：共有 -atime, -ctime 与 -mtime 和-amin,-cmin与-mmin，以 -mtime 说明</p>
<pre><code>-mtime n ：n 为数字，意义为在 n 天之前的『一天之内』被更动过内容的档案；
-mtime +n ：列出在 n 天之前(不含 n 天本身)被更动过内容的档案档名；
-mtime -n ：列出在 n 天之内(含 n 天本身)被更动过内容的档案档名。
-newer file ：file 为一个存在的档案，列出比 file 还要新的档案档名
eg：  
 find ./ -mtime 0 # 在当前目录下查找今天之内有改动的文件 
</code></pre></li>
<li><p>与使用者或组名有关的参数：</p>
<pre><code>-uid n ：n 为数字，这个数字是用户的账号 ID，亦即 UID
-gid n ：n 为数字，这个数字是组名的 ID，亦即 GID
-user name ：name 为使用者账号名称！例如 dmtsai
-group name：name 为组名，例如 users ；
-nouser ：寻找档案的拥有者不存在 /etc/passwd 的人！
-nogroup ：寻找档案的拥有群组不存在于 /etc/group 的档案！
eg：  
  find /home/jet -user jet # 在目录/home/jet中找出所有者为jet的文件  
</code></pre></li>
<li><p>与档案权限及名称有关的参数：</p>
<pre><code> -name filename #搜寻文件名为 filename 的档案（可使用通配符）  
 -size [+-]SIZE #搜寻比 SIZE 还要大(+)或小(-)的档案。这个 SIZE 的规格有：
    c: 代表 byte
    k: 代表 1024bytes。所以，要找比 50KB还要大的档案，就是『 -size +50k 』
 -type TYPE  #搜寻档案的类型为 TYPE 的，类型主要有：
    一般正规档案 (f)
    装置档案 (b, c)
    目录 (d)
    连结档 (l)
    socket (s)
    FIFO (p)
  -perm mode #搜寻档案权限『刚好等于』 mode的档案，这个mode为类似chmod的属性值  
  举例来说，-rwsr-xr-x 的属性为4755！  
  -perm -mode #搜寻档案权限『必须要全部囊括 mode 的权限』的档案  
  举例来说，我们要搜寻-rwxr--r-- 亦即 0744 的档案，使用-perm -0744，当一个档案的权限为 -rwsr-xr-x ，亦即 4755 时，也会被列出来，因为 -rwsr-xr-x 的属性已经囊括了 -rwxr--r-- 的属性了。  
  -perm +mode #搜寻档案权限『包含任一 mode 的权限』的档案  
  举例来说，我们搜寻-rwxr-xr-x ，亦即 -perm +755 时，但一个文件属性为 -rw-------也会被列出来，因为他有 -rw.... 的属性存在！  
    eg：  
      find / -name passwd # 查找文件名为passwd的文件  
      find . -perm 0755 # 查找当前目录中文件权限的0755的文件  
      find . -size +12k # 查找当前目录中大于12KB的文件，注意c表示byte  
</code></pre></li>
<li><p>额外可进行的动作：</p>
<pre><code>  -exec command #command 为其他指令，-exec 后面可再接额外的指令来处理搜寻到的结果。  
  -print ：将结果打印到屏幕上，这个动作是预设动作！  
  eg:
    find / -perm +7000 -exec ls -l {} \;  #额外指令以-exec开头，以\;结尾{}代替前面找到的内容
  | xargs 
    -i  默认的前面输出用{}代替 
    eg:
        find . -name &quot;*.log&quot; | xargs -i mv {} test4
        # 查找当前目录下所有log结尾的文件并删除
        find . -name *.log | xargs rm
</code></pre></li>
</ol>
<h3 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h3><ul>
<li><p>用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换(convert and copy a file )</p>
<pre><code>语法：dd [选项] 
if =输入文件（或设备名称）。 
of =输出文件（或设备名称）。 
ibs = bytes 一次读取bytes字节，即读入缓冲区的字节数。 
skip = blocks 跳过读入缓冲区开头的ibs*blocks块。 
obs = bytes 一次写入bytes字节，即写入缓冲区的字节数。 
bs = bytes 同时设置读/写缓冲区的字节数（等于设置ibs和obs）。 
cbs = byte 一次转换bytes字节。 
count=blocks 只拷贝输入的blocks块。 
conv = ASCII 把EBCDIC码转换为ASCIl码。 
conv = ebcdic 把ASCIl码转换为EBCDIC码。 
conv = ibm 把ASCIl码转换为alternate EBCDIC码。 
conv = block 把变动位转换成固定字符。 
conv = ublock 把固定位转换成变动位。 
conv = ucase 把字母由小写转换为大写。 
conv = lcase 把字母由大写转换为小写。 
conv = notrunc 不截短输出文件。 
conv = swab 交换每一对输入字节。 
conv = noerror 出错时不停止处理。 
conv = sync 把每个输入记录的大小都调到ibs的大小（用NUL填充）。 
</code></pre><p>例1：要把一张软盘的内容拷贝到另一张软盘上，利用/tmp作为临时存储区。把源盘插入驱动器中，输入下述命令： </p>
<pre><code>$ dd if =/dev/fd0 of = /tmp/tmpfile 
</code></pre><p>拷贝完成后，将源盘从驱动器中取出，把目标盘插入，输入命令： </p>
<pre><code>$ dd if = /tmp/tmpfile of =/dev/fd0 
</code></pre><p>软盘拷贝完成后，应该将临时文件删除： </p>
<pre><code>$ rm /tmp/tmpfile 
</code></pre><p>例2：把net.i这个文件写入软盘中，并设定读/写缓冲区的数目。 </p>
<p>（注意：软盘中的内容会被完全覆盖掉） </p>
<pre><code>$ dd if = net.i of = /dev/fd0 bs = 16384 
</code></pre><p>例3：将文件sfile拷贝到文件 dfile中。 </p>
<pre><code>$ dd if=sfile of=dfile
</code></pre><p>例4：创建一个100M的空文件</p>
<pre><code>$　dd if=/dev/zero of=hello.txt bs=100M count=1
# 创建一个大小为1k的空文件
$ dd if=/dev/zero of=./test.txt bs=1k count=1  
$ ls -l  
total 4  
-rw-rw-r--. 1 jet jet 1024 Jun 20 16:36 test.txt  
# 将access_log中错误信息丢弃  
$ find / -name access_log  2&gt;/dev/null
</code></pre></li>
</ul>
<h3 id="gt-gt-gt-dev-null-dev-zero"><a href="#gt-gt-gt-dev-null-dev-zero" class="headerlink" title="&gt;-&gt;&gt;-/dev/null-/dev/zero"></a>&gt;-&gt;&gt;-/dev/null-/dev/zero</h3><p>　　<strong>/dev/null:</strong> 它是空设备，也称为位桶（bit bucket），外号叫无底洞，任何写入它的输出都会被抛弃。如果不想让消息以标准输出显示或写入文件，那么可以将消息重定向到位桶。<br>　　<strong>/dev/zero:</strong> 是一个输入设备，该设备无穷尽地提供0，可以使用任何你需要的数目，用于向设备或文件写入字符串0，你可你用它来初始化文件。<br>　　<strong>&lt;  ：</strong>由 &lt; 的右边读入参数档案；<br>　　<strong>&gt;  ：</strong>将原本由屏幕输出的正确数据输出到 &gt; 右边的 file ( 文件名称 ) 或 device ( 装置，如 printer )去；<br>　　<strong>&gt;&gt; ：</strong>将原本由屏幕输出的正确数据输出到 &gt;&gt; 右边，与 &gt; 不同的是，该档案将不会被覆盖，而新的数据将以『增加的方式』增加到该档案的最后面；<br>　　<strong>2&gt; ：</strong>将原本应该由屏幕输出的错误数据输出到 2&gt; 的右边去。</p>
<ul>
<li><p>说明</p>
<pre><code>[jet @jet oschina_hexo_server]# ls -al &gt;  test.txt  
# 将显示的结果输出到 test.txt 档案中，若该档案以存在则覆盖！ 
[jet @jet oschina_hexo_server]# ls -al &gt;&gt; test.txt  
# 将显示的结果追加到 test.txt 档案中，该档案为累加的，旧数据保留！ 
[jet @jet oschina_hexo_server]# ls -al 1&gt; test.txt 2&gt; test.err  
# 将显示的数据，正确的输出到 test.txt 错误的数据输出到 test.err 
[jet @jet oschina_hexo_server]# ls -al 1&gt; test.txt 2&gt;&amp;1  
# 将显示的数据，不论正确或错误均输出到 test.txt 当中！ 
[jet @jet oschina_hexo_server]# ls -al 1&gt; test.txt 2&gt; /dev/null 
# 将显示的数据，正确的输出到 test.txt 错误的数据则予以丢弃！
</code></pre><p>【注意】错误与正确档案输出到同一个档案中，则必须以上面的方法来写！ 不能写成其它格式！<br>这个观念相当的重要，尤其是在 /etc/crontab 当中执行的时候，如果我们已经知道错误的讯息为何，又不想要让错误的讯息一直填满 root 的信箱，就必须以 2&gt; 搭配 /dev/null 这个垃圾桶黑洞装置，来将数据丢弃！这个相当的重要！</p>
</li>
</ul>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><ul>
<li><p><strong>删除文件</strong></p>
<pre><code>rm [选项] 文件
  -r  【--recursive】删除文件夹即递归的删除目录下面文件以及子目录下文件。
  -f  【--force】强制删除不提示，忽略不存在的文件。
  -i  【--interactive】交互模式删除文件，删除文件前给出提示
  -v  【-verbose】详细显示进行步骤
</code></pre></li>
</ul>
<h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><ul>
<li><p><strong>切换工作目录</strong></p>
<pre><code>cd .    #返回上层目录  
cd ..   #返回上层目录  
cd 回车  #返回主目录同cd ~ 
cd /    #根目录  
cd ~/git/ #主目录下的git目录
cd -    #回到之前的目录
</code></pre></li>
</ul>
<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><ul>
<li><p><strong>列出相关目录下的所有目录和文件</strong></p>
<pre><code>  ls [选项] [目录名]
    -a  列出包括.a开头的隐藏文件的所有文件
    -A  通-a，但不列出&quot;.&quot;和&quot;..&quot;
    -l  列出文件的详细信息
    -c  根据ctime排序显示
    -t  根据文件修改时间排序
    ---color[=WHEN] 用色彩辨别文件类型 WHEN 可以是’never’、’always’或’auto’其中之一
      白色：表示普通文件
      蓝色：表示目录
      绿色：表示可执行文件
      红色：表示压缩文件
      浅蓝色：链接文件
      红色闪烁：表示链接的文件有问题
      黄色：表示设备文件
      灰色：表示其它文件
</code></pre></li>
</ul>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><ul>
<li><p><strong>移动或重命名文件</strong></p>
<pre><code>  mv [选项] 源文件或目录 目录或多个源文件
    -b  覆盖前做备份  
    -f  如存在不询问而强制覆盖  
    -i  如存在则询问是否覆盖  
    -u  较新才覆盖  
    -t  将多个源文件移动到统一目录下，目录参数在前，文件参数在后  
    eg:
        mv a /tmp/ 将文件a移动到 /tmp目录下
        mv a b 将a命名为b
        mv /home/zenghao test1.txt test2.txt test3.txt
</code></pre></li>
</ul>
<h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><ul>
<li><p><strong>将源文件复制至目标文件，或将多个源文件复制至目标目录。</strong></p>
<pre><code> cp [选项] 源文件或目录 目录或多个源文件
   -r -R #递归复制该目录及其子目录内容
   -p  #连同档案属性一起复制过去
   -f  #不询问而强制复制
   -s  #生成快捷方式
   -a  #将档案的所有特性都一起复制
   eg:
     cp -a file1 file2 #连同文件的所有特性把文件file1复制成文件file2  
     cp file1 file2 file3 dir #把文件file1、file2、file3复制到目录dir中 
</code></pre></li>
</ul>
<h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><ul>
<li><p><strong>创建空文件或更新文件时间</strong></p>
<pre><code>touch [选项] 文件
  -a  #只修改存取时间
  -m  #值修改变动时间
  -r  #eg:touch -r a b ,使b的时间和a相同
  -t  #指定特定的时间 
  eg:touch -t 201211142234.50 log.log 
     #-t time [[CC]YY]MMDDhhmm[.SS],C:年前两位
</code></pre></li>
</ul>
<h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><ul>
<li><strong>查看当前所在路径</strong></li>
</ul>
<h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><ul>
<li><p><strong>删除空目录</strong></p>
<pre><code>-v  显示执行过程
-p  若自父母删除后父目录为空则一并删除
</code></pre></li>
</ul>
<h3 id="rm-1"><a href="#rm-1" class="headerlink" title="rm"></a>rm</h3><ul>
<li><p><strong>删除一个或多个文件或目录</strong></p>
<pre><code>rm [选项].. 文件
  -f  忽略不存在的文件，不给出提示
  -i  交互式删除
  -r  将列出的目录及其子目录递归删除
  -v  列出详细信息
</code></pre></li>
</ul>
<h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><ul>
<li><p><strong>显示内容到屏幕</strong></p>
<pre><code>-n  输出后不换行
-e  遇到转义字符特殊处理  
    eg:
        echo &quot;hello\nworld&quot;   显示hello\nworld
        ehco -e &quot;hello\nworld&quot;    显示hello(换行了)world
</code></pre></li>
</ul>
<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><ul>
<li><p><strong>一次显示整个文件或从键盘创建一个文件或将几个文件合并成一个文件</strong></p>
<pre><code>cat [选项] [文件]..
  -n  编号文件内容再输出
  -E  在结束行提示$
</code></pre></li>
</ul>
<h3 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h3><ul>
<li><strong>cat的反向显示</strong></li>
</ul>
<h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><ul>
<li><p><strong>按页查看文章内容，从前向后读取文件，因此在启动时就加载整个文件</strong></p>
<pre><code>+n  从第n行开始显示
-n  每次查看n行数据
+/String    搜寻String字符串位置，从其前两行开始查看
-c  清屏再显示
-p  换页时清屏
</code></pre></li>
</ul>
<h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><ul>
<li><p><strong>可前后移动地逐屏查看文章内容，在查看前不会加载整个文件</strong></p>
<pre><code>-m  显示类似于more命令的百分比
-N  显示行号
/   字符串：向下搜索“字符串”的功能
?   字符串：向上搜索“字符串”的功能
n   重复前一个搜索（与 / 或 ? 有关）
N   反向重复前一个搜索（与 / 或 ? 有关）
b   向后翻一页
d   向后翻半页
</code></pre></li>
</ul>
<h3 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h3><ul>
<li><p><strong>将输出内容自动加上行号</strong></p>
<pre><code>nl [选项]… [文件]…
  -b
  -b a 不论是否有空行，都列出行号（类似 cat -n)
  -b t 空行则不列行号（默认）
  -n 有ln rn rz三个参数，分别为再最左方显示，最右方显示不加0，最右方显示加0
</code></pre></li>
</ul>
<h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><ul>
<li><p><strong>显示档案开头，默认开头10行</strong></p>
<pre><code>head [参数]… [文件]…
  -v  显示文件名
  -c number   显示前number个字符,若number为负数,则显示除最后number个字符的所有内容
  -number/n (+)number     显示前number行内容，
  -n number   若number为负数，则显示除最后number行数据的所有内容
</code></pre></li>
</ul>
<h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><ul>
<li><p><strong>显示文件结尾内容</strong></p>
<pre><code>tail [必要参数] [选择参数] [文件]
-v  #显示详细的处理信息
-q  #不显示处理信息
-num/-n (-)num      #显示最后num行内容
-n +num #从第num行开始显示后面的数据
-c  #显示最后c个字符
-f  #循环读取
# 实时查看日志，从文件最后50行开始
tail -fn 50 ExecuteConfig.log
</code></pre></li>
</ul>
<h3 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h3><ul>
<li><p><strong>编辑文件</strong></p>
<pre><code>:w filename #将文章以指定的文件名保存起来  
:q            #退出
:q!           #强制退出
:wq           #保存并退出
:set nu   #显示行号
:set nonu #隐藏行号
/git      #在文档中查找git 按n跳到下一个，shift+n上一个
yyp           #复制光标所在行，并粘贴
h(左移一个字符←)、j(下一行↓)、k(上一行↑)、l(右移一个字符→)
</code></pre><p><strong>命令行模式功能键</strong></p>
<p><strong>1. 插入模式</strong></p>
<pre><code> 按「i」切换进入插入模式「insert mode」，按&quot;i&quot;进入插入模式后是从光标当前位置开始输入文件；
 按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字；
 按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。
</code></pre><p><strong>2. 从插入模式切换为命令行模式</strong></p>
<pre><code> 按「ESC」键。
</code></pre><p><strong>3. 移动光标</strong></p>
<pre><code>    vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。
    按「ctrl」+「b」#屏幕往&quot;后&quot;移动一页。
    按「ctrl」+「f」#屏幕往&quot;前&quot;移动一页。
    按「ctrl」+「u」#屏幕往&quot;后&quot;移动半页。
    按「ctrl」+「d」#屏幕往&quot;前&quot;移动半页。
    按数字「0」#移到文章的开头。
    按「G」#移动到文章的最后。
    按「$」#移动到光标所在行的&quot;行尾&quot;。
    按「^」#移动到光标所在行的&quot;行首&quot;
    按「w」#光标跳到下个字的开头
    按「e」#光标跳到下个字的字尾
    按「b」#光标回到上个字的开头
    按「#l」#光标移到该行的第#个位置，如：5l,56l。
</code></pre><p><strong>4. 删除文字</strong></p>
<pre><code>    「x」#每按一次，删除光标所在位置的&quot;后面&quot;一个字符。
    「#x」#例如，「6x」表示删除光标所在位置的&quot;后面&quot;6个字符。
    「X」#大写的X，每按一次，删除光标所在位置的&quot;前面&quot;一个字符。
    「#X」#例如，「20X」表示删除光标所在位置的&quot;前面&quot;20个字符。
    「dd」#删除光标所在行。
    「#dd」#从光标所在行开始删除#行
</code></pre><p><strong>5. 复制</strong></p>
<pre><code>    「yw」#将光标所在之处到字尾的字符复制到缓冲区中。
    「#yw」#复制#个字到缓冲区
    「yy」#复制光标所在行到缓冲区。
    「#yy」#例如，「6yy」表示拷贝从光标所在的该行&quot;往下数&quot;6行文字。
    「p」#将缓冲区内的字符贴到光标所在位置。注意：所有与&quot;y&quot;有关的复制命令都必须与&quot;p&quot;配合才能完成复制与粘贴功能。
</code></pre><p><strong>6. 替换</strong></p>
<pre><code>    「r」#替换光标所在处的字符。
    「R」#替换光标所到之处的字符，直到按下「ESC」键为止。
</code></pre><p><strong>7. 恢复上一次操作</strong></p>
<pre><code>         「u」#如果您误执行一个命令，可以马上按下「u」，回到上一个操作。按多次&quot;u&quot;可以执行多次回复。
</code></pre><p><strong>8. 更改</strong></p>
<pre><code>    「cw」#更改光标所在处的字到字尾处
    「c#w」#例如，「c3w」表示更改3个字
</code></pre><p><strong>9. 跳至指定的行</strong></p>
<pre><code>    「ctrl」+「g」 #列出光标所在行的行号。
    「#G」：例如，「15G」，表示移动光标至文章的第15行行首。
</code></pre><p><strong>10.视图模式</strong></p>
<pre><code>     「ctrl」+「v」#进入视图模式，可以移动方向键选中多行，按d键可以删除
</code></pre><p><strong>11.清空文件</strong></p>
<pre><code>     :.,$d 回车  #命令模式输入 .,$d 后回车
</code></pre><p><strong>12.替换文本内容</strong></p>
<pre><code>     #可以替换当前行的所有/usr/local为/data/dshp，命令模式输入s/old\new/g
     :s/\/usr\/local/\/data\/dshp/g
</code></pre></li>
</ul>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><ul>
<li><p><strong>将一个命令的标准输出作为另一个命令的标准输入。也就是把几个命令组合起来使用，后一个命令除以前一个命令的结果。</strong></p>
<pre><code>grep -r “close” /home/* | more 在home目录下所有文件中查找，包括close的文件，并分页输出。
</code></pre></li>
</ul>
<h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><ul>
<li><p><strong>以逐行的方式，比较文本文件的异同处。指定要比较目录，则diff会比较目录中相同文件名的文件，但不会比较其中子目录。</strong></p>
<pre><code>diff [参数] [文件1或目录1] [文件2或目录2]
-&lt;行数&gt; 　指定要显示多少行的文本。此参数必须与-c或-u参数一并使用。
-a或--text 　diff预设只会逐行比较文本文件。
-b或--ignore-space-change 　不检查空格字符的不同。
-B或--ignore-blank-lines 　不检查空白行。
-c 　显示全部内文，并标出不同之处。
-C&lt;行数&gt;或--context&lt;行数&gt; 　与执行&quot;-c-&lt;行数&gt;&quot;指令相同。
-d或--minimal 　使用不同的演算法，以较小的单位来做比较。
-D&lt;巨集名称&gt;或ifdef&lt;巨集名称&gt; 　此参数的输出格式可用于前置处理器巨集。
-e或--ed 　此参数的输出格式可用于ed的script文件。
-f或-forward-ed 　输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处。
-H或--speed-large-files 　比较大文件时，可加快速度。
-l&lt;字符或字符串&gt;或--ignore-matching-lines&lt;字符或字符串&gt; 　若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异。
-i或--ignore-case 　不检查大小写的不同。
-l或--paginate 　将结果交由pr程序来分页。
-n或--rcs 　将比较结果以RCS的格式来显示。
-N或--new-file 　在比较目录时，若文件A仅出现在某个目录中，预设会显示：
Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较。
-p 　若比较的文件为C语言的程序码文件时，显示差异所在的函数名称。
-P或--unidirectional-new-file 　与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。
-q或--brief 　仅显示有无差异，不显示详细的信息。
-r或--recursive 　比较子目录中的文件。
-s或--report-identical-files 　若没有发现任何差异，仍然显示信息。
-S&lt;文件&gt;或--starting-file&lt;文件&gt; 　在比较目录时，从指定的文件开始比较。
-t或--expand-tabs 　在输出时，将tab字符展开。
-T或--initial-tab 　在每行前面加上tab字符以便对齐。
-u,-U&lt;列数&gt;或--unified=&lt;列数&gt; 　以合并的方式来显示文件内容的不同。
-v或--version 　显示版本信息。
-w或--ignore-all-space 　忽略全部的空格字符。
-W&lt;宽度&gt;或--width&lt;宽度&gt; 　在使用-y参数时，指定栏宽。
-x&lt;文件名或目录&gt;或--exclude&lt;文件名或目录&gt; 　不比较选项中所指定的文件或目录。
-X&lt;文件&gt;或--exclude-from&lt;文件&gt; 　您可以将文件或目录类型存成文本文件，然后在=&lt;文件&gt;中指定此文本文件。
-y或--side-by-side 　以并列的方式显示文件的异同之处。
--help 　显示帮助。
--left-column 　在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容。
--suppress-common-lines 　在使用-y参数时，仅显示不同之处
</code></pre><p><strong>示例：</strong></p>
<p>比较两个文件</p>
<pre><code>[root@localhost test3]# diff log2014.log log2013.log 
3c3
&lt; 2014-03
---
&gt; 2013-03
8c8
&lt; 2013-07
---
&gt; 2013-08
11,12d10
&lt; 2013-11
&lt; 2013-12
</code></pre><p>【注】<br>　上面的”3c3”和”8c8”表示log2014.log和log20143log文件在3行和第8行内容有所不同；”11,12d10”表示第一个文件比第二个文件多了第11和12行。</p>
<p>并排格式输出</p>
<pre><code>[root@localhost test3]# diff log2014.log log2013.log  -y -W 50
2013-01                 2013-01
2013-02                 2013-02
2014-03               | 2013-03
2013-04                 2013-04
2013-05                 2013-05
2013-06                 2013-06
2013-07                 2013-07
2013-07               | 2013-08
2013-09                 2013-09
2013-10                 2013-10
2013-11               &lt;
2013-12               &lt;
[root@localhost test3]# diff log2013.log log2014.log  -y -W 50
2013-01                 2013-01
2013-02                 2013-02
2013-03               | 2014-03
2013-04                 2013-04
2013-05                 2013-05
2013-06                 2013-06
2013-07                 2013-07
2013-08               | 2013-07
2013-09                 2013-09
2013-10                 2013-10
                      &gt; 2013-11
                      &gt; 2013-12
</code></pre><p>【注】<br>　　 “|”表示前后2个文件内容有不同<br>　　 “&lt;”表示后面文件比前面文件少了1行内容<br>　　“&gt;”表示后面文件比前面文件多了1行内容  </p>
</li>
</ul>
<h3 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h3><ul>
<li><p><strong>某一个文件在另外一个位置建立一个同步的链接，通常给/usr/bin/下建立软连接，相当于给某个应用程序配置环境变量一样，可以不带路径直接运行命令</strong></p>
<pre><code>ln [参数] [源文件或目录] [目标文件或目录]
-s  建立软连接   
-v  显示详细的处理过程
</code></pre></li>
</ul>
<h3 id="which"><a href="#which" class="headerlink" title="which"></a>which</h3><ul>
<li><p><strong>查看可执行文件的位置，在PATH变量指定的路径中查看系统命令是否存在及其位置</strong></p>
<pre><code> which 可执行文件名称 
</code></pre></li>
</ul>
<h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h3><ul>
<li><p><strong>定位可执行文件、源代码文件、帮助文件在文件系统中的位置</strong></p>
<pre><code>whereis [-bmsu] [BMS 目录名 -f ] 文件名
  -b   定位可执行文件。
  -m   定位帮助文件。
  -s   定位源代码文件。
  -u   搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。
  -B   指定搜索可执行文件的路径。
  -M   指定搜索帮助文件的路径。
  -S   指定搜索源代码文件的路径。
</code></pre></li>
</ul>
<h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h3><ul>
<li><p><strong>通过搜寻数据库快速搜寻档案</strong></p>
<pre><code>-r  使用正规运算式做寻找的条件
</code></pre></li>
</ul>
<h2 id="系统管理相关命令"><a href="#系统管理相关命令" class="headerlink" title="系统管理相关命令"></a>系统管理相关命令</h2><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><ul>
<li><p><strong>列出当前进程的快照</strong></p>
<pre><code>a   显示所有的进程
-a  显示同一终端下的所有程序
e   显示环境变量
f   显示进程间的关系
-H  显示树状结构
r   显示当前终端的程序
T   显示当前终端的所有程序
-au 显示更详细的信息
-aux    显示所有包含其他使用者的行程 
-u  指定用户的所有进程
eg:
  ps aux # 查看系统所有的进程数据  
  ps ax # 查看不与terminal有关的所有进程  
  ps -lA # 查看系统所有的进程数据  
  ps axjf # 查看连同一部分进程树状态 
  ps aux | grep tomcat
  ps -ef | grep tomcat
</code></pre></li>
</ul>
<h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><ul>
<li><p><strong>显示指定磁盘文件的可用空间,如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示</strong></p>
<pre><code>df [选项] [文件]
-a  显示全部文件系统
-h  文件大小友好显示，即会显示单位
-l  只显示本地文件系统
-i  显示inode信息
-T  显示文件系统类型
</code></pre></li>
</ul>
<h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><ul>
<li><p><strong>显示每个文件和目录的磁盘使用空间</strong></p>
<pre><code>du [选项] [文件]
-h  方便阅读的方式，会带单位
-s  只显示总和的大小
</code></pre></li>
</ul>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><ul>
<li><p><strong>显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等</strong></p>
<pre><code> top [参数]
</code></pre></li>
</ul>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><ul>
<li><p><strong>显示Linux系统中空闲的、已用的物理内存及swap内存,及被内核使用的buffer</strong></p>
<pre><code>free [参数]
</code></pre></li>
</ul>
<h3 id="quota"><a href="#quota" class="headerlink" title="quota"></a>quota</h3><ul>
<li><p><strong>显示用户或者工作组的磁盘配额信息。输出信息包括磁盘使用和配额限制</strong></p>
<pre><code>quota(选项)(参数)
-g：列出群组的磁盘空间限制；  
-q：简明列表，只列出超过限制的部分；
-u：列出用户的磁盘空间限制；
-v：显示该用户或群组，在所有挂入系统的存储设备的空间限制；
-V：显示版本信息。
</code></pre><p>我们可以限制某一群组所能使用的最大磁盘配额，而且可以再限制某一使用者的最大磁盘配额 ，好比做一个收费的应用，vip可以得到空间更大一些。另外，以 Link 的方式，来使邮件可以作为限制的配额（更改/var/spool/mail 这个路径），不2，需要重新再规划一个硬盘！直接使用 Link 的方式指向 /home （或者其它已经做好的 quota 磁盘）就可以！这通常是用在原本规划不好，但是却又不想要更动原有主机架构的情况中！</p>
<p>要求：Linux 主机里面主要针对 quser1 及 quser2 两个使用者来进行磁盘配额， 且这两个使用者都是挂在 qgroup 组里面的。每个使用者总共有 50MB 的磁盘空间 (不考虑 inode) 限制！并且 soft limit 为 45 MB；而宽限时间设定为 1 天， 但是在一天之内必须要将多余的文件删除掉，否则将无法使用剩下的空间 ；gquota 这个组考虑最大限额，所以设定为 90 MB！（注意，这样设置的好处是富有弹性，好比现在的邮件服务，那么多用户，承诺给用户每人最大空间为数GB，然而人们不可能每人都会使用那么大的空间，所以邮件服务的总空间，实际上肯定不是注册客户数乘以数GB，否则这样得多大啊。）</p>
<pre><code>[root@jet ~]# groupadd qgroup 
[root@jet ~]# useradd -m -g qgroup quser1
[root@jet ~]# useradd -m -g qgroup quser2
[root@jet ~]# passwd quser1 
[root@jet ~]# passwd quser2 
[root@jet ~]# df    #用/disk2测试
Filesystem   1K-blocks   Used     Available    Use%   Mounted on 
/dev/hda1    5952252     3193292   2451720     57%     / 
/dev/hdb1    28267608    77904     26730604     1%     /disk2 
/dev/hda5    9492644     227252    8775412     3%     /disk1

[root@jet ~]# vi /etc/fstab 
LABEL=/     /     ext3  defaults             1    1 
LABEL=/disk1  /disk1  ext3  defaults             1    2 
LABEL=/disk2  /disk2  ext3  defaults,usrquota,grpquota 1    2 
/dev/hda3    swap   swap  defaults             0    0
</code></pre><p>注意多了usrquota,grpquota，在defaults,usrquota,grpquota之间都没有空格，务必正确书写。这样就算加入了 quota 的磁盘格式了！不过，由于真正的 quota 在读取的时候是读取/etc/mtab这个文件的，而该文件需要重新开机之后才能够以/etc/fstab 的新数据进行改写！所以这个时候可以选择：重新开机 (reboot)。</p>
<p>重新remount filesystem来驱动设定值。</p>
<pre><code> [root@jet ~]# umount /dev/hdb1 
 [root@jet ~]# mount -a 
 [root@jet ~]# grep &#39;/disk2&#39; /etc/mtab 
 /dev/hdb1  /disk2  ext3  rw,usrquota,grpquota  0  0
</code></pre><p>事实上，也可以利用 mount 的 remount 功能。</p>
<pre><code>[root@jet ~]# mount -o remount /disk2 
</code></pre><p>这样就已经成功的将 filesystem 的 quota 功能加入。</p>
<p>扫瞄磁盘的使用者使用状况，并产生重要的 aquota.group 与 aquota.user：</p>
<pre><code>[root@jet ~]# quotacheck -avug 
quotacheck: Scanning /dev/hdb1 [/disk2] done 
quotacheck: Checked 3 directories and 4 files 
[root@localhost ~]# ll /disk2 
-rw------- 1 root root 6144 Sep 6 11:44 aquota.group 
-rw------- 1 root root 6144 Sep 6 11:44 aquota.user 
</code></pre><p>使用 quotacheck 就可以轻易的将所需要的数据给他输出了！但奇怪的是，在某些 Linux 版本中，不能够以 aquota.user(group) 来启动quota ，可能是因为旧版 quota 的关系， 所以就另外做了一个 link 文件按来欺骗 quota，这个动作非必要。（主要是学习这个思维很重要）</p>
<pre><code>[root@localhost ~]# cd /disk2 
[root@localhost ~]# ln -s aquota.user quota.user 
[root@localhost ~]# ln -s aquota.group quota.group 
</code></pre><p>启动 quota 的限额： </p>
<pre><code>[root@localhost ~]# quotaon -avug 
/dev/hdb1 [/disk2]: group quotas turned on 
/dev/hdb1 [/disk2]: user quotas turned on ===&gt; 看到turned on，才是真的成功！
</code></pre><p>编辑使用者的可使用空间：</p>
<pre><code> [root@localhost ~]# edquota -u quser1 
 Disk quotas for user quser1 (uid 502): 
 Filesystem  blocks  soft   hard   inodes   soft hard 
 /dev/hdb1   0     45000  50000   0      0   0 
 [root@localhost ~]# edquota -p quser1 quser2 ===&gt; 直接复制给quser2 
</code></pre><p>接下来要来设定宽限时间，还是使用 edquota </p>
<pre><code> [root@localhost ~]# edquota -t  
 Grace period before enforcing soft limits for users: 
 time units may be: days, hours, minutes, or seconds
 Filesystem    Block grace period    Inode grace period 
 /dev/hdb1        1days             7days 
</code></pre><p>使用quota -v来查询：</p>
<pre><code> [root@localhost ~]# quota -vu quser1 quser2 
 Disk quotas for user quser1 (uid 502): 
 Filesystem   blocks  quota  limit  grace files quota limit grace 
 /dev/hdb1    0     45000  50000           0    0    0 
 Disk quotas for user quser2 (uid 503): 
 Filesystem blocks quota   limit grace files quota limit grace 
 /dev/hdb1   0    45000   50000         0    0    0 
</code></pre><p>注意，由于使用者尚未超过45 MB，所以 grace ( 宽限时间 ) 就不会出现。 编辑群组可使用的空间：</p>
<pre><code> [root@localhost ~]# edquota -g qgroup 
 Disk quotas for group qgroup (gid 502):
 Filesystem  blocks soft   hard   inodes soft hard 
 /dev/hdb1    0   80000   90000   0    0   0 
 [root@localhost ~]# quota -vg qgroup 
 Disk quotas for group qgroup (gid 502):
 Filesystem   blocks quota  limit  grace files quota limit grace 
 /dev/hdb1     0   80000  90000           0    0    0
</code></pre></li>
</ul>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><ul>
<li><p><strong>用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与ps和jobs命令一起使用</strong></p>
<pre><code>  kill [参数] [进程号]
  1：SIGHUP，启动被终止的进程  
  2：SIGINT，相当于输入ctrl+c，中断一个程序的进行  
  9：SIGKILL，强制中断一个进程的进行  
  15：SIGTERM，以正常的结束进程方式来终止进程  
  17：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行
  eg:
    kill -9 19785
</code></pre></li>
</ul>
<h3 id="killall"><a href="#killall" class="headerlink" title="killall"></a>killall</h3><ul>
<li><p><strong>杀死同一进程组内的所有进程。其允许指定要终止的进程的名称，而非PID</strong></p>
<pre><code>  -i ：交互式的意思，若需要删除时，会询问用户  
  -e ：表示后面接的command name要一致，但command name不能超过15个字符  
  -I ：命令名称忽略大小写  
  eg: 
    killall -SIGHUP syslogd # 重新启动syslogd  
</code></pre></li>
</ul>
<h3 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h3><ul>
<li><p><strong>创建的新的系统用户</strong></p>
<p>帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。  </p>
<p>在Slackware中，adduser指令是个script程序，利用交谈的方式取得输入的用户帐号资料，然后再交由真正建立帐号的useradd命令建立新用户，如此可方便管理员建立用户帐号。在Red Hat Linux中，adduser命令则是useradd命令的符号连接，两者实际上是同一个指令</p>
<pre><code>useradd(选项)(参数)
-c&lt;备注&gt;：加上备注文字。备注文字会保存在passwd的备注栏位中； 
-d&lt;登入目录&gt;：指定用户登入时的启始目录；
-D：变更预设值； 
-e&lt;有效期限&gt;：指定帐号的有效期限；
-f&lt;缓冲天数&gt;：指定在密码过期后多少天即关闭该帐号；
-g&lt;群组&gt;：指定用户所属的群组； 
-G&lt;群组&gt;：指定用户所属的附加群组；
-m：自动建立用户的登入目录； 
-M：不要自动建立用户的登入目录；
-n：取消建立以用户名称为名的群组；
-r：建立系统帐号；
-s：指定用户登入后所使用的shell；
-u：指定用户id。
</code></pre><p>新建用户加入组：</p>
<pre><code>useradd –g sales jack –G company,employees //-g：加入主要组、-G：加入次要组
</code></pre><p>建立一个新用户账户，并设置ID：</p>
<pre><code>useradd caojh -u 544 
</code></pre><p>需要说明的是，设定ID值时尽量要大于500，以免冲突。因为Linux安装后会建立一些特殊用户，一般0到499之间的值留给bin、mail这样的系统账号</p>
</li>
</ul>
<h3 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h3><ul>
<li><p><strong>创建一个新的工作组，新工作组的信息将被添加到系统文件中</strong></p>
<pre><code>groupadd(选项)(参数)
-g：指定新建工作组的id；
-r：创建系统工作组，系统工作组的组ID小于500；
-K：覆盖配置文件“/ect/login.defs”；
-o：允许添加组ID号不唯一的工作组。
</code></pre><p>实例 建立一个新组，并设置组ID加入系统：</p>
<pre><code>groupadd -g 344 linuxde 
</code></pre><p>此时在/etc/passwd文件中产生一个组ID（GID）是344的项目</p>
</li>
</ul>
<h3 id="groupdel"><a href="#groupdel" class="headerlink" title="groupdel"></a>groupdel</h3><ul>
<li><p><strong>删除指定的工作组</strong></p>
<p>要修改的系统文件包括/ect/group和/ect/gshadow。若该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组</p>
<pre><code> groupdel(参数)
 eg:
   groupadd damon //创建damon工作组 
   groupdel damon //删除这个工作组
</code></pre></li>
</ul>
<h3 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h3><ul>
<li><p><strong>提交和管理用户的需要周期性执行的任务</strong></p>
<p>与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。</p>
<pre><code>crontab(选项)(参数)
-e：编辑该用户的计时器设置；
-l：列出该用户的计时器设置； 
-r：删除该用户的计时器设置；
-u&lt;用户名称&gt;：指定要设定计时器的用户名称。
</code></pre><p>Linux下的任务调度分为两类：系统任务调度和用户任务调度。</p>
<p><strong>系统任务调度：</strong>系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。</p>
<p>/etc/crontab文件包括下面几行：</p>
<pre><code>SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=&quot;&quot;HOME=/

# run-parts
51 * * * * root run-parts /etc/cron.hourly
24 7 * * * root run-parts /etc/cron.daily
22 4 * * 0 root run-parts /etc/cron.weekly
42 4 1 * * root run-parts /etc/cron.monthly 
</code></pre><p>【注】<br>　　前四行是用来配置crond任务运行的环境变量，第一行SHELL变量指定了系统要使用哪个shell，这里是bash，第二行PATH变量指定了系统执行命令的路径，第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务执行信息给用户，第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。 </p>
<p><strong>用户任务调度：</strong>用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab文件都被保存在/var/spool/cron目录中。其文件名与用户名一致，使用者权限文件如下：</p>
<pre><code>/etc/cron.deny     该文件中所列用户不允许使用crontab命令
/etc/cron.allow    该文件中所列用户允许使用crontab命令
/var/spool/cron/   所有用户crontab文件存放的目录,以用户名命名
</code></pre><p>crontab文件的含义：用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：</p>
<pre><code>minute hour day month week command 顺序：分 时 日 月 周

minute： 表示分钟，可以是从0到59之间的任何整数。
hour：表示小时，可以是从0到23之间的任何整数。 
day：表示日期，可以是从1到31之间的任何整数。 
month：表示月份，可以是从1到12之间的任何整数。 
week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。 
command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。
</code></pre><p>在以上各个字段中，还可以使用以下特殊字符： </p>
<pre><code> 星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。 
 逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9” 
 中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6” 正
 斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。 

service crond start    #启动服务
service crond stop     #关闭服务
service crond restart  #重启服务
service crond reload   #重新载入配置
service crond status   #查看crontab服务状态
ntsysv #查看crontab服务是否已设置为开机启动
chkconfig –level 35 crond on   #开机启动

eg:
 * * * * * command  #每1分钟执行一次command
 3,15 * * * * command #每小时的第3和第15分钟执行
 3,15 8-11 * * * command #在上午8点到11点的第3和第15分钟执行
 3,15 8-11 */2 * * command #每隔两天的上午8点到11点的第3和第15分钟执行
 3,15 8-11 * * 1 command #每个星期一的上午8点到11点的第3和第15分钟执行 
 30 21 * * * /etc/init.d/smb restart #每晚的21:30重启smb
 45 4 1,10,22 * * /etc/init.d/smb restart #每月1、10、22日的4 : 45重启smb
 10 1 * * 6,0 /etc/init.d/smb restart #每周六、周日的1:10重启smb
 0,30 18-23 * * * /etc/init.d/smb restart #每天18 : 00至23 : 00之间每隔30分钟重启smb  
 0 23 * * 6 /etc/init.d/smb restart #每星期六的晚上11:00 pm重启smb  
 * */1 * * * /etc/init.d/smb restart #每一小时重启smb  
 * 23-7/1 * * * /etc/init.d/smb restart #晚上11点到早上7点之间，每隔一小时重启smb
 0 11 4 * mon-wed /etc/init.d/smb restart  #每月的4号与每周一到周三的11点重启smb  
 0 4 1 jan * /etc/init.d/smb restart #一月一号的4点重启smb 
 01 * * * * root run-parts /etc/cron.hourly  #每小时执行/etc/cron.hourly目录内的脚本 
</code></pre></li>
</ul>
<h2 id="网络操作命令"><a href="#网络操作命令" class="headerlink" title="网络操作命令"></a>网络操作命令</h2><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><ul>
<li><p><strong>配置和显示Linux内核中网络接口的网络参数</strong></p>
<p>用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。</p>
<pre><code>ifconfig(参数)

add&lt;地址&gt;：设置网络设备IPv6的ip地址；
del&amp;lt;地址&amp;gt;：删除网络设备IPv6的IP地址；
down：关闭指定的网络设备；
&amp;lt;hw&amp;lt;网络设备类型&amp;gt;&amp;lt;硬件地址&amp;gt;：设置网络设备的类型与硬件地址；
io_addr&amp;lt;I/O地址&amp;gt;：设置网络设备的I/O地址；
irq&amp;lt;IRQ地址&amp;gt;：设置网络设备的IRQ；
media&amp;lt;网络媒介类型&amp;gt;：设置网络设备的媒介类型；
mem_start&amp;lt;内存地址&amp;gt;：设置网络设备在主内存所占用的起始地址；
metric&amp;lt;数目&amp;gt;：指定在计算数据包的转送次数时，所要加上的数目；
mtu&amp;lt;字节&amp;gt;：设置网络设备的MTU；
netmask&amp;lt;子网掩码&amp;gt;：设置网络设备的子网掩码；
tunnel&amp;lt;地址&amp;gt;：建立IPv4与IPv6之间的隧道通信地址；
up：启动指定的网络设备；
-broadcast&amp;lt;地址&amp;gt;：将要送往指定地址的数据包当成广播数据包来处理；
-pointopoint&amp;lt;地址&amp;gt;：与指定地址的网络设备建立直接连线，此模式具有保密功能；
-promisc：关闭或启动指定网络设备的promiscuous模式；
IP地址：指定网络设备的IP地址；
网络设备：指定网络设备的名称。
</code></pre><p>显示网络设备信息（激活状态的）：</p>
<pre><code>[root@jet ~]# ifconfig
eth0       Link encap:Ethernet  HWaddr 00:16:3E:00:1E:51  
          inet addr:10.160.7.81  Bcast:10.160.15.255  Mask:255.255.240.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:61430830 errors:0 dropped:0 overruns:0 frame:0
          TX packets:88534 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:3607197869 (3.3 GiB)  TX bytes:6115042 (5.8 MiB)

 lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:56103 errors:0 dropped:0 overruns:0 frame:0
          TX packets:56103 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:5079451 (4.8 MiB)  TX bytes:5079451 (4.8 MiB)
</code></pre><p>【注】<br><strong>eth0</strong>表示第一块网卡，其中HWaddr表示网卡的物理地址，可以看到目前这个网卡的物理地址(MAC地址）是00:16:3E:00:1E:51。 </p>
<p><strong>inet addr**</strong>用来表示网卡的IP地址，此网卡的IP地址是10.160.7.81，广播地址Bcast:10.160.15.255，掩码地址Mask:255.255.240.0。</p>
<p><strong>lo</strong>是表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。比如把 httpd服务器的指定到回坏地址，在浏览器输入127.0.0.1就能看到你所架WEB网站了。但只是您能看得到，局域网的其它主机或用户无从知道。  </p>
<p>第一行：连接类型：Ethernet（以太网）HWaddr（硬件mac地址）。<br>第二行：网卡的IP地址、子网、掩码。<br>第三行：UP（代表网卡开启状态）RUNNING（代表网卡的网线被接上）MULTICAST（支持组播）MTU:1500（最大传输单元）：1500字节。<br>第四、五行：接收、发送数据包情况统计。<br>第七行：接收、发送数据字节数统计信息。 </p>
<p>启动关闭指定网卡：</p>
<pre><code> ifconfig eth0 up 
 ifconfig eth0 down 
</code></pre><p>ifconfig eth0 up为启动网卡eth0，ifconfig eth0 down为关闭网卡eth0。ssh登陆linux服务器操作要小心，关闭了就不能开启了，除非你有多网卡。  </p>
<p>为网卡配置和删除IPv6地址：</p>
<pre><code> ifconfig eth0 add 33ffe:3240:800:1005::2/64 #为网卡eth0配置IPv6地址 
 ifconfig eth0 del 33ffe:3240:800:1005::2/64 #为网卡eth0删除IPv6地址 
</code></pre><p>用ifconfig修改MAC地址：</p>
<pre><code>ifconfig eth0 hw ether 00:AA:BB:CC:dd:EE 
</code></pre><p>配置IP地址：</p>
<pre><code>[root@localhost ~]# ifconfig eth0 192.168.2.10
[root@localhost ~]# ifconfig eth0 192.168.2.10 netmask 255.255.255.0 
[root@localhost ~]# ifconfig eth0 192.168.2.10 netmask 255.255.255.0 broadcast 192.168.2.255 
</code></pre><p>启用和关闭arp协议： </p>
<pre><code>ifconfig eth0 arp #开启网卡eth0 的arp协议 
ifconfig eth0 -arp #关闭网卡eth0 的arp协议 
</code></pre><p>设置最大传输单元： </p>
<pre><code>ifconfig eth0 mtu 1500 #设置能通过的最大数据包大小为 1500 bytes
</code></pre></li>
</ul>
<h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><ul>
<li><p><strong>打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况</strong></p>
<pre><code>netstat(选项)

-a或--all：显示所有连线中的Socket；
-A&amp;lt;网络类型&amp;gt;或--&amp;lt;网络类型&amp;gt;：列出该网络类型连线中的相关地址；
-c或--continuous：持续列出网络状态；
-C或--cache：显示路由器配置的快取信息；
-e或--extend：显示网络其他相关信息；
-F或--fib：显示FIB；
-g或--groups：显示多重广播功能群组组员名单；
-h或--help：在线帮助； 
-i或--interfaces：显示网络界面信息表单； 
-l或--listening：显示监控中的服务器的Socket；
-M或--masquerade：显示伪装的网络连线； 
-n或--numeric：直接使用ip地址，而不通过域名服务器；
-N或--netlink或--symbolic：显示网络硬件外围设备的符号连接名称； 
-o或--timers：显示计时器； 
-p或--programs：显示正在使用Socket的程序识别码和程序名称；
-r或--route：显示Routing Table；
-s或--statistice：显示网络工作信息统计表； 
-t或--tcp：显示TCP传输协议的连线状况；
-u或--udp：显示UDP传输协议的连线状况； 
-v或--verbose：显示指令执行过程； 
-V或--version：显示版本信息； 
-w或--raw：显示RAW传输协议的连线状况； 
-x或--unix：此参数的效果和指定&quot;-A unix&quot;参数相同； 
--ip或--inet：此参数的效果和指定&quot;-A inet&quot;参数相同。

eg:
  netstat -a #列出所有端口 
  netstat -at #列出所有tcp端口 
  netstat -au #列出所有udp端口 

  netstat -l #只显示监听端口 
  netstat -lt #只列出所有监听 tcp 端口 
  netstat -lu #只列出所有监听 udp 端口 
  netstat -lx #只列出所有监听 UNIX 端口

  netstat -s #显示所有端口的统计信息
  netstat -st #显示TCP端口的统计信息 
  netstat -su #显示UDP端口的统计信息

  netstat -pt #在netstat输出中显示 PID 和进程名称
</code></pre><p>netstat -p可以与其它开关一起使用，就可以添加“PID/进程名称”到netstat输出中，这样debugging的时候可以很方便的发现特定端口运行的程序。</p>
<p>在netstat输出中不显示主机，端口和用户名(host, port or user) 当你不想让主机，端口和用户名显示，使用netstat -n。将会使用数字代替那些名称。同样可以加速输出，因为不用进行比对查询。</p>
<pre><code> netstat -an 
</code></pre><p>如果只是不想让这三个名称中的一个被显示，使用以下命令: </p>
<pre><code> netsat -a --numeric-ports 
 netsat -a --numeric-hosts 
 netsat -a --numeric-users 
</code></pre><p>持续输出netstat信息</p>
<pre><code>netstat -c #每隔一秒输出网络信息 
</code></pre><p>显示系统不支持的地址族(Address Families) </p>
<pre><code>netstat --verbose 
</code></pre><p>在输出的末尾，会有如下的信息：</p>
<pre><code> netstat: no support for `AF IPX&#39; on this system. 
 netstat: no support for `AF AX25&#39; on this system. 
 netstat: no support for `AF X25&#39; on this system. 
 netstat: no support for `AF NETROM&#39; on this system. 
</code></pre><p>显示核心路由信息 </p>
<pre><code> netstat -r 
</code></pre><p>使用netstat -rn显示数字格式，不查询主机名称。</p>
<p>找出程序运行的端口 </p>
<p>并不是所有的进程都能找到，没有权限的会不显示，使用 root 权限查看所有的信息。</p>
<pre><code>netstat -ap | grep ssh 
</code></pre><p>找出运行在指定端口的进程：</p>
<pre><code>netstat -an | grep &#39;:80&#39; 
</code></pre><p>显示网络接口列表 </p>
<pre><code>netstat -i 
</code></pre><p>显示详细信息，像是ifconfig使用</p>
<pre><code>netstat -ie。 
</code></pre><p>IP和TCP分析 查看连接某服务端口最多的的IP地址：</p>
<pre><code>netstat -ntu | grep :80 | awk &#39;{print $5}&#39; | cut -d: -f1 | awk &#39;{++ip[$1]} END {for(i in ip) print ip[i],&quot;\t&quot;,i}&#39; | sort -nr  
</code></pre><p>TCP各种状态列表： </p>
<pre><code>netstat -nt | grep -e 127.0.0.1 -e 0.0.0.0 -e ::: -v | awk &#39;/^tcp/ {++state[$NF]} END {for(i in state) print i,&quot;\t&quot;,state[i]}&#39;
</code></pre><p>查看phpcgi进程数，如果接近预设值，说明不够用，需要增加： </p>
<pre><code>netstat -anpo | grep &quot;php-cgi&quot; | wc -l
</code></pre></li>
</ul>
<h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><ul>
<li><p><strong>登录远程主机，对远程主机进行管理</strong></p>
<p>telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh方式了。但仍然有很多别的系统可能采用了telnet方式来提供远程登录，因此弄清楚telnet客户端的使用方式仍是很有必要的。</p>
<pre><code>telnet(选项)(参数)

-8：允许使用8位字符资料，包括输入与输出；
-a：尝试自动登入远端系统； 
-b&lt;主机别名&gt;：使用别名指定远端主机名称；
-c：不读取用户专属目录里的.telnetrc文件； 
-d：启动排错模式； 
-e&lt;脱离字符&gt;：设置脱离字符；
-E：滤除脱离字符； 
-f：此参数的效果和指定&quot;-F&quot;参数相同； 
-F：使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机； 
-k&lt;域名&gt;：使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名；
-K：不自动登入远端主机； 
-l&lt;用户名称&gt;：指定要登入远端主机的用户名称；
-L：允许输出8位字符资料； 
-n&lt;记录文件&gt;：指定文件记录相关信息； 
-r：使用类似rlogin指令的用户界面； 
-S&lt;服务类型&gt;：设置telnet连线所需的ip TOS信息； 
-x：假设主机有支持数据加密的功能，就使用它；
-X&lt;认证形态&gt;：关闭指定的认证形态。

eg:
  [root@jet oschina_hexo_server]# telnet 124.251.54.61 5001
  Trying 124.251.54.61...
  Connected to 124.251.54.61.
  Escape character is &#39;^]&#39;.
  SSH-2.0-OpenSSH_6.7
</code></pre></li>
</ul>
<h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><ul>
<li><p><strong>测试主机之间网络的连通性</strong></p>
<p>执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</p>
<pre><code>  ping(选项)(参数)

  -d：使用Socket的SO_DEBUG功能；
  -c&lt;完成次数&gt;：设置完成要求回应的次数；
  -f：极限检测； 
  -i&lt;间隔秒数&gt;：指定收发信息的间隔时间； 
  -I&lt;网络界面&gt;：使用指定的网络界面送出数据包； 
  -l&lt;前置载入&gt;：设置在送出要求信息之前，先行发出的数据包；
  -n：只输出数值； 
  -p&lt;范本样式&gt;：设置填满数据包的范本样式； 
  -q：不显示指令执行过程，开头和结尾的相关信息除外； 
  -r：忽略普通的Routing Table，直接将数据包送到远端主机上；
  -R：记录路由过程； 
  -s&lt;数据包大小&gt;：设置数据包的大小； 
  -t&lt;存活数值&gt;：设置存活数值TTL的大小； 
  -v：详细显示指令的执行过程。

  eg:
    [root@jet oschina_hexo_server]# ping www.baidu.com
    PING www.a.shifen.com (220.181.112.244) 56(84) bytes of data.
    64 bytes from 220.181.112.244: icmp_seq=1 ttl=45 time=13.9 ms
    64 bytes from 220.181.112.244: icmp_seq=2 ttl=45 time=3.27 ms
    64 bytes from 220.181.112.244: icmp_seq=3 ttl=45 time=2.46 ms
    64 bytes from 220.181.112.244: icmp_seq=4 ttl=45 time=3.39 ms
    64 bytes from 220.181.112.244: icmp_seq=5 ttl=45 time=2.42 ms
    64 bytes from 220.181.112.244: icmp_seq=6 ttl=45 time=2.70 ms
    64 bytes from 220.181.112.244: icmp_seq=7 ttl=45 time=2.54 ms
    64 bytes from 220.181.112.244: icmp_seq=8 ttl=45 time=3.78 ms
    64 bytes from 220.181.112.244: icmp_seq=9 ttl=45 time=3.20 ms
    64 bytes from 220.181.112.244: icmp_seq=10 ttl=45 time=2.46 ms
    64 bytes from 220.181.112.244: icmp_seq=11 ttl=45 time=2.56 ms
    64 bytes from 220.181.112.244: icmp_seq=12 ttl=45 time=2.74 ms
    64 bytes from 220.181.112.244: icmp_seq=13 ttl=45 time=2.42 ms
    64 bytes from 220.181.112.244: icmp_seq=14 ttl=45 time=2.46 ms
    #ctrl + c 结束
    --- www.a.shifen.com ping statistics ---
    14 packets transmitted, 14 received, 0% packet loss, time 13555ms
    rtt min/avg/max/mdev = 2.420/3.596/13.902/2.889 ms
</code></pre></li>
</ul>
<h3 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h3><ul>
<li><p><strong>用来设置文件系统相关功能</strong></p>
<p>ftp服务器在网上较为常见，Linux ftp命令的功能是用命令的方式来控制在本地机和远程机之间传送文件，这里详细介绍Linux ftp命令的一些经常使用的命令，相信掌握了这些使用Linux进行ftp操作将会非常容易。</p>
<pre><code>  ftp(选项)(参数)

  -d：详细显示指令执行过程，便于排错或分析程序执行的情况；
  -i：关闭互动模式，不询问任何问题；
  -g：关闭本地主机文件名称支持特殊字符的扩充特性； 
  -n：不使用自动登录； 
  -v：显示指令执行过程。

  FTP&gt;ascii: 设定以ASCII方式传送文件(缺省值) 
  FTP&gt;bell: 每完成一次文件传送,报警提示. 
  FTP&gt;binary: 设定以二进制方式传送文件. 
  FTP&gt;bye: 终止主机FTP进程,并退出FTP管理方式. 
  FTP&gt;case: 当为ON时,用MGET命令拷贝的文件名到本地机器中,全部转换为小写字母. 
  FTP&gt;cd: 同UNIX的CD命令. 
  FTP&gt;cdup: 返回上一级目录. 
  FTP&gt;chmod: 改变远端主机的文件权限. 
  FTP&gt;close: 终止远端的FTP进程,返回到FTP命令状态, 所有的宏定义都被删除. 
  FTP&gt;delete: 删除远端主机中的文件. 
  FTP&gt;dir [remote-directory] [local-file] 列出当前远端主机目录中的文件.如果有本地文件,就将结果写至本地文件. 
  FTP&gt;get [remote-file] [local-file] 从远端主机中传送至本地主机中. 
  FTP&gt;help [command] 输出命令的解释. 
  FTP&gt;lcd: 改变当前本地主机的工作目录,如果缺省,就转到当前用户的HOME目录. 
  FTP&gt;ls [remote-directory] [local-file] 同DIR. 
  FTP&gt;macdef: 定义宏命令. 
  FTP&gt;mdelete [remote-files] 删除一批文件. 
  FTP&gt;mget [remote-files] 从远端主机接收一批文件至本地主机. 
  FTP&gt;mkdir directory-name 在远端主机中建立目录.
  FTP&gt;mput local-files 将本地主机中一批文件传送至远端主机. 
  FTP&gt;open host [port] 重新建立一个新的连接. 
  FTP&gt;prompt: 交互提示模式. 
  FTP&gt;put local-file [remote-file] 将本地一个文件传送至远端主机中. 
  FTP&gt;pwd: 列出当前远端主机目录.
  FTP&gt;quit: 同BYE. 
  FTP&gt;recv remote-file [local-file] 同GET. 
  FTP&gt;rename [from] [to] 改变远端主机中的文件名. 
  FTP&gt;rmdir directory-name 删除远端主机中的目录. 
  FTP&gt;send local-file [remote-file] 同PUT.
  FTP&gt;status: 显示当前FTP的状态. 
  FTP&gt;system: 显示远端主机系统类型. 
  FTP&gt;user user-name [password] [account] 重新以别的用户名登录远端主机.
  FTP&gt;? [command]: 同HELP. [command]指定需要帮助的命令名称。如果没有指定 command，ftp 将显示全部命令的列表。 
  FTP&gt;! 从 ftp 子系统退出到外壳。
</code></pre></li>
</ul>
<h3 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h3><ul>
<li><p><strong>交互式的文件传输程序</strong></p>
<p>命令的运行和使用方式与ftp命令相似，但是，sftp命令对传输的所有信息使用ssh加密，它还支持公钥认证和压缩等功能</p>
<pre><code>-B：指定传输文件时缓冲区的大小； 
-l：使用ssh协议版本1； 
-b：指定批处理文件； 
-C：使用压缩； 
-o：指定ssh选项；
-F：指定ssh配置文件；
-R：指定一次可以容忍多少请求数； 
-v：升高日志等级。
</code></pre><p>推荐一款sftp连接工具 <a href="https://www.baidu.com/s?wd=FlashFXP&amp;rsv_spt=1&amp;rsv_iqid=0x95df0dfd0017c7a0&amp;issp=1&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_sug3=2&amp;rsv_sug1=1&amp;rsv_sug7=001&amp;rsv_n=2" target="_blank" rel="external">FlashFXP</a></p>
</li>
</ul>
<h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><ul>
<li><p><strong>Linux上常用的防火墙软件</strong></p>
<p>是netfilter项目的一部分。可以直接配置，也可以通过许多前端和图形界面配置。</p>
<pre><code>iptables(选项)(参数)

-t&lt;表&gt;：指定要操纵的表； 
-A：向规则链中添加条目； 
-D：从规则链中删除条目； 
-i：向规则链中插入条目；
-R：替换规则链中的条目；
-L：显示规则链中已有的条目； 
-F：清楚规则链中已有的条目；
-Z：清空规则链中的数据包计算器和字节计数器；
-N：创建新的用户自定义规则链； 
-P：定义规则链中的默认目标； 
-h：显示帮助信息； 
-p：指定要匹配的数据包协议类型；
-s：指定要匹配的数据包源ip地址； 
-j&lt;目标&gt;：指定要跳转的目标； 
-i&lt;网络接口&gt;：指定数据包进入本机的网络接口； 
-o&lt;网络接口&gt;：指定数据包要离开本机所使用的网络接口。
</code></pre><p>iptables命令选项输入顺序：</p>
<pre><code>   iptables -t 表名 &lt;-A/I/D/R&gt; 规则链名 [规则号] &lt;-i/o 网卡名&gt; -p 协议名 &lt;-s 源IP/源子网&gt; --sport 源端口 &lt;-d 目标IP/目标子网&gt; --dport 目标端口 -j 动作 
</code></pre><p>表名包括：</p>
<pre><code> raw：高级功能，如：网址过滤。
 mangle：数据包修改（QOS），用于实现服务质量。 
 net：地址转换，用于网关路由器。 
 filter：包过滤，用于防火墙规则。 
</code></pre><p>规则链名包括： I</p>
<pre><code> NPUT链：处理输入数据包。
 OUTPUT链：处理输出数据包。 
 PORWARD链：处理转发数据包。 
 PREROUTING链：用于目标地址转换（DNAT）。 
 POSTOUTING链：用于源地址转换（SNAT）。 
</code></pre><p>动作包括：</p>
<pre><code> accept：接收数据包。 
 DROP：丢弃数据包。 
 REDIRECT：重定向、映射、透明代理。 
 SNAT：源地址转换。
 DNAT：目标地址转换。 
 MASQUERADE：IP伪装（NAT），用于ADSL。 LOG：日志记录。 
</code></pre><p>清除已有iptables规则 </p>
<pre><code> iptables -F 
 iptables -X 
 iptables -Z 
</code></pre><p>开放指定的端口 </p>
<pre><code> iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT #允许本地回环接口(即运行本机访问本机) 
 iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT #允许已建立的或相关连的通行   
 iptables -A OUTPUT -j ACCEPT #允许所有本机向外的访问  
 iptables -A INPUT -p tcp --dport 22 -j ACCEPT #允许访问22端口  
 iptables -A INPUT -p tcp --dport 80 -j ACCEPT #允许访问80端口  
 iptables -A INPUT -p tcp --dport 21 -j ACCEPT #允许ftp服务的21端口  
 iptables -A INPUT -p tcp --dport 20 -j ACCEPT #允许FTP服务的20端口  
 iptables -A INPUT -j reject #禁止其他未允许的规则访问  
 iptables -A FORWARD -j REJECT #禁止其他未允许的规则访问 
</code></pre><p>屏蔽IP  </p>
<pre><code> iptables -I INPUT -s 123.45.6.7 -j DROP #屏蔽单个IP的命令  
 iptables -I INPUT -s 123.0.0.0/8 -j DROP #封整个段即从123.0.0.1到123.255.255.254的命令  
 iptables -I INPUT -s 124.45.0.0/16 -j DROP #封IP段即从123.45.0.1到123.45.255.254的命令  
 iptables -I INPUT -s 123.45.6.0/24 -j DROP #封IP段即从123.45.6.1到123.45.6.254的命令是 
</code></pre><p>查看已添加的 iptables规则  </p>
<pre><code>iptables -L -n -v 
Chain INPUT (policy DROP 48106 packets, 2690K bytes)
 pkts bytes target     prot opt in     out     source               destination         
 5075  589K ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0           
 191K   90M ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0           tcp dpt:22
1499K  133M ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0           tcp dpt:80
4364K 6351M ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0           state RELATED,ESTABLISHED
 6256  327K ACCEPT     icmp --  *      *       0.0.0.0/0            0.0.0.0/0           

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 3382K packets, 1819M bytes)
 pkts bytes target     prot opt in     out     source               destination         
 5075  589K ACCEPT     all  --  *      lo      0.0.0.0/0            0.0.0.0/0  
</code></pre><p>删除已添加的iptables规则 </p>
<p>将所有iptables以序号标记显示，执行： </p>
<pre><code>iptables -L -n --line-numbers 
</code></pre><p>比如要删除INPUT里序号为8的规则，执行：</p>
<pre><code>iptables -D INPUT 8
</code></pre></li>
</ul>
<h3 id="mail"><a href="#mail" class="headerlink" title="mail"></a>mail</h3><ul>
<li><p><strong>命令行的电子邮件发送和接收工具</strong></p>
<p>操作的界面不像elm或pine那么容易使用，但功能非常完整。</p>
<pre><code>mail(选项)(参数)

-b&lt;地址&gt;：指定密件副本的收信人地址； 
-c&lt;地址&gt;：指定副本的收信人地址； 
-f&lt;邮件文件&gt;：读取指定邮件文件中的邮件； 
-i：不显示终端发出的信息； 
-I：使用互动模式； 
-n：程序使用时，不使用mail.rc文件中的设置；
-N：阅读邮件时，不显示邮件的标题； 
-s&lt;邮件主题&gt;：指定邮件的主题；
-u&lt;用户帐号&gt;：读取指定用户的邮件； 
-v：执行时，显示详细的信息。

mail -s &quot;Hello from jet-han.oschina.io by shell&quot; admin@oschina.io 
hello,this is the content of mail. 
welcome to jet-han.oschina.io
</code></pre><p>【注】<br>　第一行是输入的命令，-s表示邮件的主题，后面的admin@oschina.io则是邮件的接收人，输入完这行命令后回车，会进入邮件正文的编写，我们可以输入任何文字，比如上面的两行。当邮件正文输入完成后，需要按CTRL+D结束输入，此时会提示你输入Cc地址，即邮件抄送地址，没有直接回车就完成了邮件的发送</p>
<p>使用管道进行邮件发送 </p>
<pre><code>echo &quot;hello,this is the content of mail.welcome to jet-han.oschina.io&quot; | mail -s &quot;Hello from jet-han.oschina.io by pipe&quot; admin@oschina.io  
</code></pre></li>
</ul>
<p>　【注】<br> 　使用管道直接敲入这行命令即可完成邮件的发送，其中echo后的是邮件正文。</p>
<p> 使用文件进行邮件发送 </p>
<pre><code>  mail -s &quot;Hello from jet-han.oschina.io by file&quot; admin@oschina.io  &lt; mail.txt 
</code></pre><p> 使用上面的命令后，我们就可以把mail.txt文件的内容作为邮件的内容发送给admin@oschina.io了。</p>
<p> 使用上述三种方式都可以给外部邮箱进行邮件发送，但因为前面2种都是直接在shell中敲入邮件内容，因此无法输入中文，即使我们使用粘贴的方式输入了中文，那么收到的邮件也是乱码的。但第3种方式，我们可以在window下编辑好邮件内容后，放到linux下，再进行发送，这样就可以正常发送中文了。不过目前邮件的中文标题暂时没有找到解决办法。 因为mail程序本身就是调用sendmail来进行邮件发送的，因此我们可以在mail命令中使用sendmail的参数进行配置，比如我想使用特定的发件人发送邮件，可以使用如下命令：</p>
<pre><code>  mail -s &quot;Hello from linuxde.net with sender&quot; admin@oschina.io -- -f jet@oschina.io&lt; mail.txt
</code></pre><p> 【注】<br> 　上面的命令中，我们使用了– -f jet@oschina.io这样的参数，这是sendmail的选项，其中-f表示邮件的发送人邮件地址</p>
<p> 很多情况下，我们也需要使用邮件来发送附件，在linux下使用mail命令发送附件也很简单，不过首先需要安装uuencode软件包，这个程序是对二进制文件进行编码使其适合通过邮件进行发送，在CentOS上安装该软件包如下：</p>
<pre><code>yum install sharutils 
</code></pre><p> 安装完成后我们就可以来进行附件的发送了，使用如下命令：</p>
<pre><code>uuencode test.txt test | mail -s &quot;hello,see the attachement&quot; admin@oschina.io
</code></pre><p> 完成后就可以把text.txt文件作为邮件的附件发送出去了。uuencode有两个参数，第一个是要发送的文件，第二个是显示的文件名称。 </p>
<p> 这里我主要介绍的是在CentOS下使用mail发送电子邮件的一些使用方法，需要的要求是你的linux必须安装了sendmail并开启了，同时保证可以连接外网。另外，文章中提到的命令本人都经过亲自测试，保证完全可用，不过你需要将命令中的电子邮件地址换成自己的电子邮件地址</p>
<p> 如果出现错误[Postfix] – warning: mail_queue_enter: create file maildrop Permission denied</p>
<pre><code>    [jet@jet oschina_hexo_server]$ lpostdrop: warning: mail_queue_enter: create file maildrop/820792.3848: Permission denied
    postdrop: warning: mail_queue_enter: create file maildrop/821453.3848: Permission denied
    postdrop: warning: mail_queue_enter: create file maildrop/821762.3848: Permission denied
    postdrop: warning: mail_queue_enter: create file maildrop/822488.3848: Permission denied
    postdrop: warning: mail_queue_enter: create file maildrop/822928.3848: Permission denied
    postdrop: warning: mail_queue_enter: create file maildrop/823425.3848: Permission denied
    postdrop: warning: mail_queue_enter: create file maildrop/823907.3848: Permission denied
    postdrop: warning: mail_queue_enter: create file maildrop/824427.3848: Permission denied
    postdrop: warning: mail_queue_enter: create file maildrop/824928.3848: Permission denied
    postdrop: warning: mail_queue_enter: create file maildrop/825368.3848: Permission denied
    postdrop: warning: mail_queue_enter: create file maildrop/825899.3848: Permission denied
    postdrop: warning: mail_queue_enter: create file maildrop/826355.3848: Permission denied


    root@jet:/var/spool/postfix# postfix check  
    postfix/postfix-script: warning: not owned by group postdrop: /var/spool/postfix/public  
    postfix/postfix-script: warning: not owned by group postdrop: /var/spool/postfix/maildrop 

    root@jet:/var/spool/postfix# /etc/init.d/postfix stop  
    root@jet:/var/spool/postfix# killall -9 postdrop  
    root@jet:/var/spool/postfix# chgrp -R postdrop /var/spool/postfix/public  
    root@jet:/var/spool/postfix# chgrp -R postdrop /var/spool/postfix/maildrop/  
    root@jet:/var/spool/postfix# postfix check 
    root@jet:/var/spool/postfix# postfix start 
    root@jet:/var/spool/postfix# postfix reload 
    chmod g+s /usr/sbin/postqueue  
    chmod g+s /usr/sbin/postdrop 

    root@gandalf:/var/spool/postfix# postfix check #此时没有警告了
</code></pre><h3 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h3><ul>
<li><p><strong>命令是常用域名查询工具，就是查DNS信息用的命令</strong></p>
<p>nslookup4有两种工作模式，即“交互模式”和“非交互模式”。在“交互模式”下，用户可以向域名服务器查询各类主机、域名的信息，或者输出域名中的主机列表。而在“非交互模式”下，用户可以针对一个主机或域名仅仅获取特定的名称或所需信息。  </p>
<p>进入交互模式，直接输入nslookup命令，不加任何参数，则直接进入交互模式，此时nslookup会连接到默认的域名服务器（即<code>/etc/resolv.conf</code> 的第一个dns地址）。或者输入<code>nslookup -nameserver/ip</code>。进入非交互模式，就直接输入<code>nslookup 域名</code>就可以了。</p>
<pre><code>  nslookup(选项)(参数)

  -sil：不显示任何警告信息。

  eg:
    [jet@jet oschina_hexo_server]$ nslookup jet-han.oschina.io
    Server:        114.114.114.114
    Address:    114.114.114.114#53

    Non-authoritative answer:
    Name:    jet-han.oschina.io
    Address: 103.21.119.115
</code></pre></li>
</ul>
<h3 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h3><ul>
<li><p><strong>显示或操纵Linux主机的路由、网络设备、策略路由和隧道，是Linux下较新的功能强大的网络配置工具</strong></p>
<pre><code>  ip(选项)(参数)

  #(参数)
  网络对象：指定要管理的网络对象； 
  具体操作：对指定的网络对象完成具体操作； 
  help：显示网络对象支持的操作命令的帮助信息。

  #(选项)
  -V：显示指令版本信息；
  -s：输出更详细的信息；
  -f：强制使用指定的协议族；
  -4：指定使用的网络层协议是IPv4协议； 
  -6：指定使用的网络层协议是IPv6协议； 
  -0：输出信息每条记录输出一行，即使内容较多也不换行显示； 
  -r：显示主机时，不使用IP地址，而使用主机的域名。
</code></pre><p>用ip命令显示网络设备的运行状态 </p>
<pre><code>  [jet@jet oschina_hexo_server]$ ip -s link list
  1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN 
      link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
      RX: bytes  packets  errors  dropped overrun mcast   
      830        14       0       0       0       0       
      TX: bytes  packets  errors  dropped carrier collsns 
      830        14       0       0       0       0       
  2: eth3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:8b:22:5e brd ff:ff:ff:ff:ff:ff
    RX: bytes  packets  errors  dropped overrun mcast   
    121209665  198774   0       0       0       0       
    TX: bytes  packets  errors  dropped carrier collsns 
    227857521  157867   0       0       0       0 
</code></pre><p>显示核心路由表</p>
<pre><code>  [jet@jet oschina_hexo_server]$ ip route list 
  10.111.24.0/24 dev eth3  proto kernel  scope link  src 10.111.24.222  metric 1 
  default via 10.111.24.1 dev eth3  proto static 
</code></pre><p>显示邻居表</p>
<pre><code>  [jet@jet oschina_hexo_server]$ ip neigh list
  fe80::ac9e:6493:cb07:4add dev eth3 lladdr 54:ee:75:03:60:e7 STALE
  fe80::1870:3ef3:ba4f:e55b dev eth3 lladdr bc:9f:ef:8e:d3:13 STALE
  fe80::a28d:16ff:fe84:ac43 dev eth3 lladdr a0:8d:16:84:ac:43 STALE
  fe80::ca6:b92b:4736:a95a dev eth3 lladdr 24:a2:e1:39:ba:21 STALE
  fe80::83c:b2a6:cc95:fae7 dev eth3 lladdr 54:4e:90:7a:6b:e3 STALE
  fe80::8486:b8c:5150:15c1 dev eth3 lladdr 28:d2:44:74:a0:d4 STALE
  fe80::1c2f:e7e6:82ee:17f0 dev eth3 lladdr 20:3c:ae:b0:87:88 STALE
  fe80::78d2:a70e:cba3:5373 dev eth3 lladdr 28:d2:44:68:36:3c STALE
  fe80::9c19:a5e5:918b:b069 dev eth3 lladdr 50:7b:9d:e6:7c:ac STALE
  fe80::1c12:cb63:3897:fcb0 dev eth3 lladdr fc:d8:48:92:44:c9 STALE
  fe80::184c:1bc1:a201:2fa7 dev eth3 lladdr 90:b0:ed:77:94:4a STALE
  fe80::792a:9e54:8679:cb84 dev eth3 lladdr b8:ee:65:04:81:89 STALE
  fe80::1098:1ed2:b23a:4ef dev eth3 lladdr 5c:ad:cf:6e:11:6a STALE
  fe80::28bc:6b21:4fce:f51a dev eth3 lladdr 28:d2:44:c9:c0:ed STALE
  fe80::1895:8cec:208d:5eec dev eth3 lladdr f4:5c:89:8e:ad:a5 STALE
  fe80::1c44:bede:96a5:499a dev eth3 lladdr 20:ab:37:93:1f:43 STALE
  fe80::5a:d7d:e3f6:6f9f dev eth3 lladdr 14:2d:27:f8:4b:79 STALE
  fe80::61e9:b002:68c1:7ba dev eth3 lladdr 28:d2:44:6e:11:d7 STALE
  fe80::1cbe:22d4:b466:d564 dev eth3 lladdr 40:33:1a:ad:1b:8c STALE
  fe80::1863:6370:356f:c6ec dev eth3 lladdr 24:24:0e:de:6c:86 STALE
  fe80::426c:8fff:fe3f:304e dev eth3 lladdr 40:6c:8f:3f:30:4e STALE
  fe80::1824:b631:d44a:5bf3 dev eth3 lladdr 9c:fc:01:e7:c8:21 STALE
  fe80::1038:72ee:9f9e:51ea dev eth3 lladdr 70:48:0f:60:e7:0d STALE
  fe80::a069:d8a9:5fc0:219d dev eth3 lladdr ac:22:0b:c9:bb:6c STALE
  fe80::8e4:27f0:1ac7:97cc dev eth3 lladdr 28:d2:44:6d:fb:6f STALE
  fe80::59a0:8d02:8cb7:430c dev eth3 lladdr 28:d2:44:68:74:80 STALE
  fe80::3884:7711:39ce:2b96 dev eth3 lladdr 48:5a:b6:df:8f:8d STALE
  fe80::f8c1:52f5:5286:9bae dev eth3 lladdr 28:d2:44:75:5d:ec STALE
  fe80::c9c:69:70b5:2796 dev eth3 lladdr 2c:20:0b:bf:2d:16 STALE
  fe80::ee01:eeff:fe0a:fe55 dev eth3 lladdr ec:01:ee:0a:fe:55 STALE
  fe80::3ea3:48ff:fe99:5bf6 dev eth3 lladdr 3c:a3:48:99:5b:f6 STALE
  fe80::1092:6d00:3bfa:ad5f dev eth3 lladdr 7c:04:d0:32:44:24 STALE
  fe80::c3e:8ab7:92f8:d0f6 dev eth3 lladdr 64:b0:a6:26:a5:f0 STALE
  fe80::ca6:3dd9:1fe:f6a0 dev eth3 lladdr 24:24:0e:be:1a:57 STALE
  fe80::d265:caff:fece:62c9 dev eth3 lladdr d0:65:ca:ce:62:c9 STALE
  fe80::163e:bfff:fefc:ac78 dev eth3 lladdr 14:3e:bf:fc:ac:78 STALE
  fe80::9ef3:87ff:fec0:c6fa dev eth3 lladdr 9c:f3:87:c0:c6:fa STALE
  fe80::1415:65e3:71b0:4c9e dev eth3 lladdr d8:1d:72:52:6f:84 STALE
  10.111.24.248 dev eth3 lladdr bc:75:74:5e:fb:2e STALE
  10.111.24.220 dev eth3 lladdr 14:3e:bf:fc:ac:78 STALE
  10.111.24.1 dev eth3 lladdr 10:47:80:28:02:e0 STALE
  10.111.24.227 dev eth3 lladdr f4:8e:38:ba:47:3f REACHABLE
</code></pre></li>
</ul>
<h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><ul>
<li><p><strong>远程拷贝文件的命令</strong></p>
<p>和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读read only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。</p>
<pre><code>scp(选项)(参数)

#(选项)
-1：使用ssh协议版本1； 
-2：使用ssh协议版本2； 
-4：使用ipv4； -6：使用ipv6；
-B：以批处理模式运行； 
-C：使用压缩； 
-F：指定ssh配置文件； 
-l：指定宽带限制； 
-o：指定使用的ssh选项； 
-P：指定远程主机的端口号； 
-p：保留文件的最后修改时间，最后访问时间和权限模式； 
-q：不显示复制进度； 
-r：以递归方式复制；
-v  详细显示输出的具体情况。

#(参数) 
源文件：指定要复制的源文件。 
目标文件：目标文件。格式为user@host：filename（文件名为目标文件的名称）。
</code></pre></li>
</ul>
<p>  (1) 复制文件：</p>
<p>  命令格式：  </p>
<pre><code>   scp local_file remote_username@remote_ip:remote_folder  
</code></pre><p>  或者  </p>
<pre><code>   scp local_file remote_username@remote_ip:remote_file  
</code></pre><p>  或者  </p>
<pre><code>   scp local_file remote_ip:remote_folder  
</code></pre><p>  或者 </p>
<pre><code>   scp local_file remote_ip:remote_file 
</code></pre><p>  第1,2个指定了用户名，命令执行后需要输入用户密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名 </p>
<p>  第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名 </p>
<p>  (2) 复制目录：</p>
<p>  命令格式：</p>
<pre><code>   scp -r local_folder remote_username@remote_ip:remote_folder 
</code></pre><p>  或者  </p>
<pre><code>   scp -r local_folder remote_ip:remote_folder  
</code></pre><p>  第1个指定了用户名，命令执行后需要输入用户密码；<br>  第2个没有指定用户名，命令执行后需要输入用户名和密码；</p>
<pre><code>  eg:
  #从 本地 上传到 远程
  scp /home/daisy/full.tar.gz root@172.19.2.75:/home/root 
  #从 远程 下载到 本地
  scp root@172.19.2.75:/home/root/full.tar.gz /home/daisy/
</code></pre><h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><ul>
<li><p><strong>直接从网络上下载文件</strong></p>
<pre><code>wget [参数] [URL地址]
-o FILE 把记录写到FILE文件中    eg : wget -O a.txt URL
wget --limit-rate=300k URL  限速下载
</code></pre></li>
</ul>
<h2 id="系统安全相关命令"><a href="#系统安全相关命令" class="headerlink" title="系统安全相关命令"></a>系统安全相关命令</h2><h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><ul>
<li><strong>对操作系统的虚拟内存、进程、CPU活动进行监控</strong></li>
</ul>
<h3 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h3><ul>
<li><p><strong>对系统的磁盘操作活动进行监视,汇报磁盘活动统计情况，同时也会汇报出CPU使用情况</strong></p>
<pre><code> -p[磁盘] 显示磁盘和分区的情况
</code></pre></li>
</ul>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><ul>
<li><p><strong>重复执行某一命令以观察变化</strong></p>
<pre><code>watch [参数] [命令]
-n  时隔多少秒刷新
-d  高亮显示动态变化
</code></pre></li>
</ul>
<h3 id="at"><a href="#at" class="headerlink" title="at"></a>at</h3><ul>
<li><p><strong>在一个指定的时间执行一个指定任务，只能执行一次</strong></p>
<pre><code>at [参数] [时间]
HH:MM[am|pm] + number [minutes|hours|days|weeks] 强制在某年某月某日的某时刻进行该项任务
atq 查看系统未执行的任务
atrm n 删除编号为n的任务
at -c n 显示编号为n的任务的内容
</code></pre></li>
</ul>
<h3 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h3><ul>
<li><p><strong>用于设置用户的认证信息，包括用户密码、密码过期时间等</strong></p>
<p>系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。</p>
<pre><code>passwd(选项)(参数)

#(选项)
-l  使密码失效
-u  与-l相对，用户解锁
-S  列出登陆用户passwd文件内的相关参数
-n  后面接天数，shadow 的第 4 字段，多久不可修改密码天数
-x  后面接天数，shadow 的第 5 字段，多久内必须要更动密码
-w  后面接天数，shadow 的第 6 字段，密码过期前的警告天数
-i  后面接『日期』，shadow 的第 7 字段，密码失效日期
使用管道刘设置密码：echo &quot;zeng&quot; | passwd --stdin zenghao

#(参数)
用户名：需要设置密码的用户名。
</code></pre><p>与用户、组账户信息相关的文件 存放用户信息：</p>
<pre><code> /etc/passwd 
 /etc/shadow 
</code></pre><p>存放组信息：</p>
<pre><code> /etc/group 
 /etc/gshadow 
</code></pre><p>用户信息文件分析（每项用:隔开） </p>
<pre><code>例如：jack:X:503:504:::/home/jack/:/bin/bash
jack　　//用户名
X　　//口令、密码
503　　//用户
（0代表root、普通新建用户从500开始）
504　　//所在组
:　　//描述
/home/jack/　　//用户主目录
/bin/bash　　//用户缺省Shell
</code></pre><p>组信息文件分析</p>
<pre><code>例如：jack:$!$:???:13801:0:99999:7:*:*:
jack　　//组名
$!$　　//被加密的口令
13801　　//创建日期与今天相隔的天数
0　　//口令最短位数
99999　　//用户口令
7　　//到7天时提醒
*　　//禁用天数
*　　//过期天数
</code></pre><p>如果是普通用户执行passwd只能修改自己的密码。如果新建用户后，要为新用户创建密码，则用passwd用户名，注意要以root用户的权限来创建</p>
<pre><code>[root@jet ~]# passwd linuxde    //更改或创建linuxde用户的密码；
Changing password for user linuxde.
New UNIX password:          //请输入新密码；
Retype new UNIX password:   //再输入一次；
passwd: all authentication tokens updated successfully. //成功；
</code></pre><p>普通用户如果想更改自己的密码，直接运行passwd即可，比如当前操作的用户是jet</p>
<pre><code>[jet@jet ~]$ passwd
Changing password for user linuxde. //更改jet用户的密码；
(current) UNIX password:   //请输入当前密码；
New UNIX password:         //请输入新密码；
Retype new UNIX password:  //确认新密码；
passwd: all authentication tokens updated successfully. //更改成功；
</code></pre><p>比如我们让某个用户不能修改密码，可以用-l选项来锁定：</p>
<pre><code>[root@localhost ~]# passwd -l linuxde    //锁定用户jet不能更改密码；
Locking password for user linuxde.
passwd: Success           //锁定成功；

[jet@jet ~]# su linuxde   //通过su切换到jet用户；
[jet@jet ~]$ passwd      //jet来更改密码；
Changing password for user jet.
Changing password for linuxde
(current) UNIX password:          //输入jet的当前密码；
passwd: Authentication token manipulation error     //失败，不能更改密码；
</code></pre><p>清除密码</p>
<pre><code>[root@jet ~]# passwd -d jet  //清除jet用户密码；
Removing password for user jet.
passwd: Success                         //清除成功；

[root@jet ~]# passwd -S jet    //查询jet用户密码状态；
Empty password.                         //空密码，也就是没有密码；
</code></pre><p>【注】<br>　当我们清除一个用户的密码时，登录时就无需密码，这一点要加以注意。</p>
</li>
</ul>
<h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3><ul>
<li><p><strong>切换当前用户身份到其他用户身份，变更时须输入所要变更的用户帐号与密码</strong></p>
<pre><code>su [参数] user

-c&lt;指令&gt;或--command=&lt;指令&gt;：执行完指定的指令后，即恢复原来的身份；  
-f或——fast：适用于csh与tsch，使shell不用去读取启动文件； 
-l或——login：改变身份时，也同时变更工作目录，以及HOME,SHELL,USER,logname。此外，也会变更PATH变量； 
-m,-p或--preserve-environment：变更身份时，不要变更环境变量； 
-s或--shell=：指定要执行的shell； 
--help：显示帮助； 
--version；显示版本信息。

eg:
  #变更帐号为root并在执行ls指令后退出变回原使用者： 
  su -c ls root 
  #变更帐号为root并传入-f选项给新执行的shell： 
  su root -f 
  #变更帐号为test并改变工作目录至test的家目录： 
  su -test
</code></pre></li>
</ul>
<h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><ul>
<li><p><strong>以其他身份来执行命令，预设的身份为root</strong></p>
<p>在/etc/sudoers中设置了可执行sudo指令的用户。若其未经授权的用户企图使用sudo，则会发出警告的邮件给管理员。用户使用sudo时，必须先输入密码，之后有5分钟的有效期限，超过期限则必须重新输入密码。</p>
<pre><code>sudo(选项)(参数)

-b：在后台执行指令； 
-h：显示帮助； 
-H：将HOME环境变量设为新身份的HOME环境变量； 
-k：结束密码的有效期限，也就是下次再执行sudo时便需要输入密码；。 
-l：列出目前用户可执行与无法执行的指令； 
-p：改变询问密码的提示符号； 
-s：执行指定的shell； -u&lt;用户&gt;：以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份； -v：延长密码有效期限5分钟； 
-V ：显示版本信息。
</code></pre><p>配置sudo必须通过编辑<code>/etc/sudoers</code>文件，而且只有超级用户才可以修改它，还必须使用visudo编辑。之所以使用visudo有两个原因，一是它能够防止两个用户同时修改它；二是它也能进行有限的语法检查。所以，即使只有你一个超级用户，你也最好用visudo来检查一下语法。 </p>
<p>visudo默认的是在vi里打开配置文件，用vi来修改文件。我们可以在编译时修改这个默认项。visudo不会擅自保存带有语法错误的配置文件，它会提示你出现的问题，并询问该如何处理，就像：</p>
<pre><code>&gt;&gt;&gt; sudoers file: syntax error, line 22 &lt;&lt;
</code></pre><p>此时我们有三种选择：键入“e”是重新编辑，键入“x”是不保存退出，键入“Q”是退出并保存。如果真选择Q，那么sudo将不会再运行，直到错误被纠正。 </p>
<p>现在，我们一起来看一下神秘的配置文件，学一下如何编写它。让我们从一个简单的例子开始：让用户Foobar可以通过sudo执行所有root可执行的命令。以root身份用visudo打开配置文件，可以看到类似下面几行：</p>
<pre><code># Runas alias specification 
# User privilege specificationroot ALL=(ALL)ALL
</code></pre><p>我们一看就明白个差不多了，root有所有权限，只要仿照现有root的例子就行，我们在下面加一行（最好用tab作为空白）： </p>
<pre><code>foobar ALL=(ALL) ALL 
</code></pre><p>保存退出后，切换到foobar用户，我们用它的身份执行命令：</p>
<pre><code>[foobar@localhost ~]$ ls /root 
ls: /root: 权限不够 

[foobar@localhost ~]$ sudo ls /root 
PassWord: 
anaconda-ks.cfg Desktop install.log install.log.syslog 
</code></pre><p>好了，我们限制一下foobar的权利，不让他为所欲为。比如我们只想让他像root那样使用ls和ifconfig，把那一行改为： </p>
<pre><code>foobar localhost= /sbin/ifconfig, /bin/ls
</code></pre><p>再来执行命令： </p>
<pre><code>[foobar@localhost ~]$ sudo head -5 /etc/shadow 
Password: 
Sorry, user foobar is not allowed to execute &#39;/usr/bin/head -5 /etc/shadow&#39; as root on localhost.localdomain. 
[foobar@localhost ~]$ sudo /sbin/ifconfigeth0 Linkencap:Ethernet HWaddr 00:14:85:EC:E9:9B...
</code></pre><p>现在让我们来看一下那三个ALL到底是什么意思。第一个ALL是指网络中的主机，我们后面把它改成了主机名，它指明foobar可以在此主机上执行后面的命令。第二个括号里的ALL是指目标用户，也就是以谁的身份去执行命令。最后一个ALL当然就是指命令名了。例如，我们想让foobar用户在linux主机上以jimmy或rene的身份执行kill命令，这样编写配置文件：</p>
<pre><code>foobar linux=(jimmy,rene) /bin/kill
</code></pre><p>但这还有个问题，foobar到底以jimmy还是rene的身份执行？这时我们应该想到了sudo -u了，它正是用在这种时候。 foobar可以使用sudo -u jimmy kill PID或者sudo -u rene kill PID，但这样挺麻烦，其实我们可以不必每次加-u，把rene或jimmy设为默认的目标用户即可。再在上面加一行：</p>
<pre><code>Defaults:foobar runas_default=rene 
</code></pre><p>Defaults后面如果有冒号，是对后面用户的默认，如果没有，则是对所有用户的默认。就像配置文件中自带的一行： </p>
<pre><code> Defaults env_reset 
</code></pre><p>另一个问题是，很多时候，我们本来就登录了，每次使用sudo还要输入密码就显得烦琐了。我们可不可以不再输入密码呢？当然可以，我们这样修改配置文件： </p>
<pre><code> foobar localhost=NOPASSWD: /bin/cat, /bin/ls 
</code></pre><p>再来sudo一下： </p>
<pre><code> [foobar@localhost ~]$ sudo ls /rootanaconda-ks.cfg Desktop install.log install.log.syslog 
</code></pre><p>当然，你也可以说“某些命令用户foobar不可以运行”，通过使用!操作符，但这不是一个好主意。因为，用!操作符来从ALL中“剔出”一些命令一般是没什么效果的，一个用户完全可以把那个命令拷贝到别的地方，换一个名字后再来运行。</p>
<p><strong>日志与安全</strong> </p>
<p>sudo为安全考虑得很周到，不仅可以记录日志，还能在有必要时向系统管理员报告。但是，sudo的日志功能不是自动的，必须由管理员开启。这样来做： </p>
<pre><code> touch /var/log/sudo 
 vi /etc/syslog.conf 
</code></pre><p>在syslog.conf最后面加一行（必须用tab分割开）并保存：</p>
<pre><code> local2.debug /var/log/sudo 
</code></pre><p>重启日志守候进程，</p>
<pre><code> ps aux grep syslogd 
</code></pre><p>把得到的syslogd进程的PID（输出的第二列是PID）填入下面：</p>
<pre><code> kill –HUP PID 
</code></pre><p>这样，sudo就可以写日志了： </p>
<pre><code> [foobar@localhost ~]$ sudo ls /rootanaconda-ks.cfg 
 Desktop install.log 
 install.log.syslog 
 $cat /var/log/sudoJul 28 22:52:54 localhost sudo: foobar : 
 TTY=pts/1 ; pwd=/home/foobar ; USER=root ; command=/bin/ls /root 
</code></pre><p>不过，有一个小小的“缺陷”，sudo记录日志并不是很忠实： </p>
<pre><code> [foobar@localhost ~]$ sudo cat /etc/shadow &gt; /dev/null 
 cat /var/log/sudo...Jul 28 23:10:24 localhost sudo: foobar : TTY=pts/1 ;
 PWD=/home/foobar ; USER=root ; COMMAND=/bin/cat /etc/shadow 
</code></pre><p>重定向没有被记录在案！为什么？因为在命令运行之前，shell把重定向的工作做完了，sudo根本就没看到重定向。这也有个好处，下面的手段不会得逞： </p>
<pre><code>[foobar@localhost ~]$ sudo ls /root &gt; /etc/shadowbash: /etc/shadow: 权限不够 
</code></pre><p>sudo 有自己的方式来保护安全。以root的身份执行sudo-V，查看一下sudo的设置。因为考虑到安全问题，一部分环境变量并没有传递给sudo后面的命令，或者被检查后再传递的，比如：PATH，HOME，SHELL等。当然，你也可以通过sudoers来配置这些环境变量。</p>
</li>
</ul>
<h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3><ul>
<li><p><strong>改变文件或目录所属的用户组</strong></p>
<p>该命令用来改变指定文件所属的用户组。其中，组名可以是用户组的id，也可以是用户组的组名。文件名可以 是由空格分开的要改变属组的文件列表，也可以是由通配符描述的文件集合。如果用户不是该文件的文件主或超级用户(root)，则不能改变该文件的组</p>
<pre><code> chgrp(选项)(参数)

 #(选项)
 -c或——changes：效果类似“-v”参数，但仅回报更改的部分；
 -f或--quiet或——silent：不显示错误信息； 
 -h或--no-dereference：只对符号连接的文件作修改，而不是该其他任何相关文件； 
 -R或——recursive：递归处理，将指令目录下的所有文件及子目录一并处理；
 -v或——verbose：显示指令执行过程； 
 --reference=&lt;参考文件或目录&gt;：把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同；

 #(参数)
 组：指定新工作名称； 
 文件：指定要改变所属组的文件列表。多个文件或者目录之间使用空格隔开。

 eg：  
 chgrp users -R ./dir #递归地把dir目录下中的所有文件和子目录下所有文件的用户组修改为users 
</code></pre></li>
</ul>
<h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><ul>
<li><p><strong>改变某个文件或目录的所有者和所属的组</strong></p>
<p>该命令可以向某个用户授权，使该用户变成指定文件的所有者或者改变文件所属的组。用户可以是用户或者是用户D，用户组可以是组名或组id。文件名可以使由空格分开的文件列表，在文件名中可以包含通配符。</p>
<pre><code>chown(选项)(参数)
#(选项)
-c或——changes：效果类似“-v”参数，但仅回报更改的部分； 
-f或--quite或——silent：不显示错误信息； 
-h或--no-dereference：只对符号连接的文件作修改，而不更改其他任何相关文件；
-R或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理； 
-v或——version：显示指令执行过程； 
--dereference：效果和“-h”参数相同； 
--help：在线帮助； 
--reference=&lt;参考文件或目录&gt;：把指定文件或目录的拥有者与所属群组全部设成和参考文件或目录的拥有者与所属群组相同； 
--version：显示版本信息。

#(参数)
用户：组：指定所有者和所属工作组。当省略“：组”，仅改变文件所有者； 
文件：指定要改变所有者和工作组的文件列表。支持多个文件和目标，支持shell通配符。

#将目录/usr/meng及其下面的所有文件、子目录的文件主改成 liu： 
chown -R liu /usr/meng

#文件的属主和属组属性设置 
chown user:market f01　　//把文件f01给uesr，添加到market组 ll -d f1 查看目录f1的属性
</code></pre></li>
</ul>
<h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><ul>
<li><p><strong>变更文件或目录的权限</strong></p>
<p>在UNIX系统家族里，文件或目录权限的控制分别以读取、写入、执行3种一般权限来区分，另有3种特殊权限可供运用。用户可以使用chmod指令去变更文件与目录的权限，设置方式采用文字或数字代号皆可。符号连接的权限无法变更，如果用户对符号连接修改权限，其改变会作用在被连接的原始文件。</p>
<p>权限范围的表示法如下：<br><code>u</code> User，即文件或目录的拥有者；<br><code>g</code> Group，即文件或目录的所属群组；<br><code>o</code> Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围；<br><code>a</code> All，即全部的用户，包含拥有者，所属群组以及其他用户 ；<br><code>r</code> 读取权限，数字代号为“4”;<br><code>w</code> 写入权限，数字代号为“2”；<br><code>x</code> 执行或切换权限，数字代号为“1”； - 不具任何权限，数字代号为“0”；<br><code>s</code> 特殊功能说明：变更文件或目录的权限。 </p>
<pre><code> chmod(选项)(参数)
 #(选项)
 -c或——changes：效果类似“-v”参数，但仅回报更改的部分； 
 -f或--quiet或——silent：不显示错误信息； 
 -R或——recursive：递归处理，将指令目录下的所有文件及子目录一并处理； 
 -v或——verbose：显示指令执行过程；
 --reference=&lt;参考文件或目录&gt;：把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同； 
 &lt;权限范围&gt;+&lt;权限设置&gt;：开启权限范围的文件或目录的该选项权限设置； 
 &lt;权限范围&gt;-&lt;权限设置&gt;：关闭权限范围的文件或目录的该选项权限设置； 
 &lt;权限范围&gt;=&lt;权限设置&gt;：指定权限范围的文件或目录的该选项权限设置；

 #(参数)
 权限模式：指定文件的权限模式； 
 文件：要改变权限的文件。

eg：  
  chmod 0755 file # 把file的文件权限改变为-rxwr-xr-x  
  chmod g+w file # 向file的文件权限中加入用户组可写权限  
</code></pre><p>Linux用 户分为：拥有者、组群(Group)、其他（other），Linux系统中，预设的情況下，系统中所有的帐号与一般身份使用者，以及root的相关信 息， 都是记录在<code>/etc/passwd</code>文件中。每个人的密码则是记录在<code>/etc/shadow</code>文件下。 此外，所有的组群名称记录在<code>/etc/group</code>內！ </p>
<p>linux文件的用户权限的分析图</p>
<p><img src="http://jet-han.oschina.io/images/linux/linux.gif" alt="权限" title="权限"></p>
</li>
<li><p><strong>文件权限管理</strong></p>
<p><strong>三种基本权限</strong></p>
<pre><code>   R   读  数值表示为4  
   W   写  数值表示为2  
   X   可执行 数值表示为1  
</code></pre></li>
</ul>
<p><img src="http://jet-han.oschina.io/images/linux/linux.png" alt="权限" title="权限"></p>
<ul>
<li><p>如图所示，copyright.html文件的权限为-rw-rw-r—</p>
<pre><code>-rw-rw-r-- 一共十个字符，分成四段。
第一个字符“-”表示普通文件；这个位置还可能会出现“l”链接；“d”表示目录
第二三四个字符“rw-”表示当前所属用户的权限。     所以用数值表示为4+2=6
第五六七个字符“rw-”表示当前所属组的权限。        所以用数值表示为4+2=6
第八九十个字符“r-–”表示其他用户权限。                 所以用数值表示为4
所以操作此文件的权限用数值表示为664
</code></pre></li>
<li><p><strong>用户及用户组管理</strong></p>
<pre><code>/etc/passwd    存储用户账号
/etc/group     存储组账号
/etc/shadow    存储用户账号的密码
/etc/gshadow   存储用户组账号的密码
useradd        添加用户名
userdel        删除用户名
adduser        添加用户名
groupadd       添加组名
groupdel       删除组名
passwd root    给root设置密码
su root
su – root
/etc/profile   系统环境变量
bash_profile   用户环境变量
.bashrc        用户环境变量
su user        切换用户，加载配置文件.bashrc
su – user      切换用户，加载配置文件/etc/profile ，加载bash_profile
</code></pre></li>
</ul>
<h3 id="who"><a href="#who" class="headerlink" title="who"></a>who</h3><ul>
<li><p><strong>显示目前登录系统的用户信息</strong></p>
<p>执行who命令可得知目前有那些用户登入系统，单独执行who命令会列出登入帐号，使用的终端机，登入时间以及从何处登入或正在使用哪个X显示器。</p>
<pre><code>  who(选项)(参数)
  #(选项)
  -H或--heading：显示各栏位的标题信息列；
  -i或-u或--idle：显示闲置时间，若该用户在前一分钟之内有进行任何动作，将标示成&quot;.&quot;号，如果该用户已超过24小时没有任何动作，则标示出&quot;old&quot;字符串； 
  -m：此参数的效果和指定&quot;am i&quot;字符串相同； 
  -q或--count：只显示登入系统的帐号名称和总人数； 
  -s：此参数将忽略不予处理，仅负责解决who指令其他版本的兼容性问题；
  -w或-T或--mesg或--message或--writable：显示用户的信息状态栏； 
  --help：在线帮助；
  --version：显示版本信息。

  #(参数)
  文件：指定查询文件。
</code></pre></li>
</ul>
<h3 id="whoami"><a href="#whoami" class="headerlink" title="whoami"></a>whoami</h3><ul>
<li><p><strong>打印当前有效的用户名称，相当于执行id -un命令</strong></p>
<pre><code>  whoami(选项)

  (选项)
  --help：在线帮助；
  --version：显示版本信息。
</code></pre></li>
</ul>
<h3 id="which-1"><a href="#which-1" class="headerlink" title="which"></a>which</h3><ul>
<li><p><strong>查找并显示给定命令的绝对路径</strong></p>
<p>环境变量PATH中保存了查找命令时需要遍历的目录。which指令会在环境变量$PATH设置的目录里查找符合条件的文件。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>
<pre><code>which(选项)(参数)
#(选项)
-n&lt;文件名长度&gt;：制定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名； 
-p&lt;文件名长度&gt;：与-n参数相同，但此处的&lt;文件名长度&gt;包含了文件的路径；
-w：指定输出时栏位的宽度；
-V：显示版本信息。

#(参数)
指令名：指令名列表。

查找文件、显示命令路径： 

[root@jet ~]# which pwd 
/bin/pwd 
[root@jet ~]# which adduser 
/usr/sbin/adduser 
</code></pre></li>
</ul>
<p>　【注】<br>　which是根据使用者所配置的 PATH 变量内的目录去搜寻可运行档的！所以，不同的 PATH 配置内容所找到的命令当然不一样的！</p>
<h3 id="ntpdate"><a href="#ntpdate" class="headerlink" title="ntpdate"></a>ntpdate</h3><p><strong>设置本地日期和时间</strong></p>
<p> 服务器的时间不对的时候，可以使用ntpdate工具来校正时间。</p>
<pre><code> ntpdate ip/site

 eg:
  /usr/sbin/ntpdate time.windows.com
</code></pre><p> 以下是一些可用的NTP服务器地址：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Name</th>
<th>IP</th>
<th>Location</th>
</tr>
</thead>
<tbody>
<tr>
<td>210.72.145.44</td>
<td>210.72.145.44</td>
<td>中国（国家授时中心）</td>
</tr>
<tr>
<td>133.100.11.8</td>
<td>133.100.11.8</td>
<td>日本（福冈大学）</td>
</tr>
<tr>
<td>time-a.nist.gov</td>
<td>129.6.15.28</td>
<td>NIST,Gaithersburg,Maryland</td>
</tr>
<tr>
<td>time-b.nist.gov</td>
<td>129.6.15.29</td>
<td>NIST,Gaithersburg,Maryland</td>
</tr>
<tr>
<td>time-a.timefreq.bldrdoc.gov</td>
<td>132.163.4.101</td>
<td>NIST,Boulder,Colorado</td>
</tr>
<tr>
<td>time-b.timefreq.bldrdoc.gov</td>
<td>132.163.4.102</td>
<td>NIST,Boulder,Colorado</td>
</tr>
<tr>
<td>time-c.timefreq.bldrdoc.gov</td>
<td>132.163.4.103</td>
<td>NIST,Boulder,Colorado</td>
</tr>
<tr>
<td>utcnist.colorado.edu</td>
<td>128.138.140.44</td>
<td>UniversityofColorado,Boulder</td>
</tr>
<tr>
<td>time.nist.gov</td>
<td>192.43.244.18</td>
<td>NCAR,Boulder,Colorado</td>
</tr>
<tr>
<td>time-nw.nist.gov</td>
<td>131.107.1.10</td>
<td>Microsoft,Redmond,Washington</td>
</tr>
<tr>
<td>nist1.symmetricom.com</td>
<td>69.25.96.13</td>
<td>Symmetricom,SanJose,California</td>
</tr>
<tr>
<td>nist1-dc.glassey.com</td>
<td>216.200.93.8</td>
<td>Abovenet,Virginia</td>
</tr>
<tr>
<td>nist1-ny.glassey.com</td>
<td>208.184.49.9</td>
<td>Abovenet,NewYorkCity</td>
</tr>
<tr>
<td>nist1-sj.glassey.com</td>
<td>207.126.98.204</td>
<td>Abovenet,SanJose,California</td>
</tr>
<tr>
<td>nist1.aol-ca.truetime.com</td>
<td>207.200.81.113</td>
<td>TrueTime,AOLfacility,Sunnyvale,California</td>
</tr>
<tr>
<td>nist1.aol-va.truetime.com</td>
<td>64.236.96.53</td>
<td>TrueTime,AOLfacility,Virginia</td>
</tr>
</tbody>
</table>
</div>
<h2 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h2><h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><ul>
<li><p><strong>压缩文件</strong></p>
<p>gzip是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，文件经它压缩过后，其名称后面会多处“.gz”扩展名，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和tar命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。</p>
<pre><code>gzip(选项)(参数)
#(选项)
-a或——ascii：使用ASCII文字模式；
-d或--decompress或----uncompress：解开压缩文件； 
-f或——force：强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接； 
-h或——help：在线帮助；
-l或——list：列出压缩文件的相关信息；
-L或——license：显示版本与版权信息； 
-n或--no-name：压缩文件时，不保存原来的文件名称及时间戳记； 
-N或——name：压缩文件时，保存原来的文件名称及时间戳记； 
-q或——quiet：不显示警告信息；
-r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理； 
-S或&lt;压缩字尾字符串&gt;或----suffix&lt;压缩字尾字符串&gt;：更改压缩字尾字符串；
-t或——test：测试压缩文件是否正确无误； 
-v或——verbose：显示指令执行过程； 
-V或——version：显示版本信息； -&lt;压缩效率&gt;：压缩效率是一个介于1~9的数值，预设值为“6”，指定愈大的数值，压缩效率就会愈高；
--best：此参数的效果和指定“-9”参数相同； 
--fast：此参数的效果和指定“-1”参数相同。

#(参数)
文件列表：指定要压缩的文件列表。
</code></pre><p>把test6目录下的每个文件压缩成.gz文件 </p>
<pre><code>gzip * 
</code></pre><p>把上例中每个压缩的文件解压，并列出详细的信息 </p>
<pre><code>gzip -dv * 
</code></pre><p>详细显示例1中每个压缩的文件的信息，并不解压 </p>
<pre><code>gzip -l * 
</code></pre><p>压缩一个tar备份文件，此时压缩文件的扩展名为.tar.gz </p>
<pre><code>gzip -r log.tar 
</code></pre><p>递归的压缩目录 </p>
<pre><code>gzip -rv test6 
</code></pre><p>这样，所有test下面的文件都变成了<em>.gz，目录依然存在只是目录里面的文件相应变成了</em>.gz.这就是压缩，和打包不同。因为是对目录操作，所以需要加上-r选项，这样也可以对子目录进行递归了。 </p>
<p>递归地解压目录 </p>
<pre><code>gzip -dr test6
</code></pre></li>
</ul>
<h3 id="gunzip"><a href="#gunzip" class="headerlink" title="gunzip"></a>gunzip</h3><ul>
<li><p><strong>解压缩文件</strong></p>
<p>gunzip是个使用广泛的解压缩程序，它用于解开被gzip压缩过的文件，这些压缩文件预设最后的扩展名为.gz。事实上gunzip就是gzip的硬连接，因此不论是压缩或解压缩，都可通过gzip指令单独完成。</p>
<pre><code>gunzip(选项)(参数)
#(选项)
-a或——ascii：使用ASCII文字模式； 
-c或--stdout或--to-stdout：把解压后的文件输出到标准输出设备； 
-f或-force：强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接；
-h或——help：在线帮助； 
-l或——list：列出压缩文件的相关信息；
-L或——license：显示版本与版权信息； 
-n或--no-name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其忽略不予处理； 
-N或——name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上； 
-q或——quiet：不显示警告信息； 
-r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理； 
-S或&lt;压缩字尾字符串&gt;或----suffix&lt;压缩字尾字符串&gt;：更改压缩字尾字符串；
-t或——test：测试压缩文件是否正确无误； 
-v或——verbose：显示指令执行过程； 
-V或——version：显示版本信息；

#(参数)
文件列表：指定要解压缩的压缩包。
</code></pre><p>首先将/etc目录下的所有文件以及子目录进行压缩，备份压缩包etc.zip到/opt目录，然后对etc.zip文件进行gzip压缩，设置gzip的压缩级别为9。 </p>
<pre><code>zip –r /opt/etc.zip /etc 
gzip -9v /opt/etc.zip
</code></pre><p>查看上述etc.zip.gz文件的压缩信息。</p>
<pre><code>gzip -l /opt/etc.zip.gz 
compressed uncompressed ratio uncompressed_name 
11938745 12767265 6.5% /opt/etc.zip 
</code></pre><p>解压上述etc.zip.gz文件到当前目录。 </p>
<pre><code>[root@mylinux ~]#gzip –d /opt/etc.zip.gz 
或者执行 
[root@mylinux ~]#gunzip /opt/etc.zip.gz 
</code></pre><p>通过上面的示例可以知道gzip –d等价于gunzip命令。</p>
</li>
</ul>
<h3 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h3><ul>
<li><p><strong>创建和管理（包括解压缩）“.bz2”格式的压缩包</strong></p>
<p>我们遇见Linux压缩打包方法有很多种，以下讲解了Linux压缩打包方法中的Linux bzip2命令的多种范例供大家查看，相信大家看完后会有很多收获。</p>
<pre><code>bzip2(选项)(参数)
#(选项)
-c或——stdout：将压缩与解压缩的结果送到标准输出；
-d或——decompress：执行解压缩； 
-f或-force：bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖。请使用此参数； 
-h或——help：在线帮助； 
-k或——keep：bzip2在压缩或解压缩后，会删除原始文件。若要保留原始文件，请使用此参数； 
-s或——small：降低程序执行时内存的使用量； 
-t或——test：测试.bz2压缩文件的完整性； 
-v或——verbose：压缩或解压缩文件时，显示详细的信息； 
-z或——compress：强制执行压缩； 
-V或——version：显示版本信息； 
--repetitive-best：若文件中有重复出现的资料时，可利用此参数提高压缩效果； 
--repetitive-fast：若文件中有重复出现的资料时，可利用此参数加快执行效果。

#(参数)
文件：指定要压缩的文件。
</code></pre><p>压缩指定文件filename: </p>
<pre><code>bzip2 filename 
或 
bzip2 -z filename 
</code></pre><p>这里，压缩的时候不会输出，会将原来的文件filename给删除，替换成filename.bz2.如果以前有filename.bz2则不会替换并提示错误（如果想要替换则指定-f选项，例如bzip2 -f filename；如果filename是目录则也提醒错误不做任何操作；如果filename已经是压过的了有bz2后缀就提醒一下，不再压缩，没有bz2后缀会再次压缩。</p>
<p>解压指定的文件filename.bz2: </p>
<pre><code>bzip2 -d filename.bz2
或
bunzip2 filename.bz2 
</code></pre><p>这里，解压的时候没标准输出，会将原来的文件filename.bz2给替换成filename。如果以前有filename则不会替换并提示错误（如果想要替换则指定-f选项，例如bzip2 -df filename.bz2。</p>
<p>压缩解压的时候将结果也输出： </p>
<pre><code>$bzip2 -v filename
</code></pre><p>输入之后，输出如下：</p>
<pre><code>filename: 0.119:1, 67.200 bits/byte, -740.00% saved, 5 in, 42 out.
</code></pre><p>这里，加上-v选项就会输出了,只用压缩举例了，解压的时候同理bzip2 -dv filename.bz2不再举例了。</p>
<p>模拟解压实际并不解压：</p>
<pre><code>bzip2 -tv filename.bz2 
</code></pre><p>输入之后，输出如下：</p>
<pre><code>filename.bz2: ok 
</code></pre><p>这里，-t指定要进行模拟解压，不实际生成结果，也就是说类似检查文件,当然就算目录下面有filename也不会有什么错误输出了，因为它根本不会真的解压文件。为了在屏幕上输出，这里加上-v选项了,如果是真的解压bzip2 -dv filename.bz2则输出的是把”ok”替换成了”done”。</p>
<p>压缩解压的时候，除了生成结果文件，将原来的文件也保存: </p>
<pre><code>bzip2 -k filename 
</code></pre><p>这里，加上-k就保存原始的文件了，否则原始文件会被结果文件替代。只用压缩举例了，解压的时候同理$bzip2 -dk filename.bz2不再举例了。 </p>
<p>解压到标准输出：</p>
<pre><code>bzip2 -dc filename.bz2 
</code></pre><p>输入之后，输出如下： </p>
<pre><code>hahahhaahahha 
</code></pre><p>这里，使用-c指定到标准输出，输出的是文件filename的内容，不会将filename.bz2删除。 </p>
<p>压缩到标准输出： </p>
<pre><code>bzip2 -c filename 
bzip2: I won&#39;t write compressed data to a terminal.
bzip2: For help, type: `bzip2 --help&#39;.
</code></pre><p>这里，使用<code>-c</code>指定压缩到标准输出不删除原有文件，不同的是，压缩后的文件无法输出到标准输出。</p>
<p>使用bzip2的时候将所有后面的看作文件(即使文件名以’-‘开头)：</p>
<pre><code>bzip2 -- -myfilename 
</code></pre><p>这里主要是为了防止文件名中-产生以为是选项的歧义。</p>
</li>
</ul>
<h3 id="bzcat"><a href="#bzcat" class="headerlink" title="bzcat"></a>bzcat</h3><ul>
<li><p><strong>读取数据而无需解压</strong></p>
<p>解压缩指定的.bz2文件，并显示解压缩后的文件内容。保留原压缩文件，并且不生成解压缩后的文件</p>
<pre><code> bzcat(参数)
 #(参数)
 .bz2压缩文件：指定要显示内容的.bz2压缩文件。
</code></pre><p>将/tmp/man.config以bzip2格式压缩：</p>
<pre><code>bzip2 -z man.config 
</code></pre><p>此时man.config会变成man.config.bz2 将上面的压缩文件内容读出来： </p>
<pre><code>bzcat man.config.bz2 
</code></pre><p>此时屏幕上会显示 man.config.bz2 解压缩之后的文件内容。</p>
</li>
</ul>
<h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><ul>
<li><p><strong>为linux的文件和目录创建档案</strong></p>
<p>利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。 首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。 为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。</p>
<pre><code> tar(选项)(参数)
 #(选项)
 -A或--catenate：新增文件到以存在的备份文件；
 -B：设置区块大小； 
 -c或--create：建立新的备份文件； 
 -C &lt;目录&gt;：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。
 -d：记录文件的差别； 
 -x或--extract或--get：从备份文件中还原文件；
 -t或--list：列出备份文件的内容； 
 -z或--gzip或--ungzip：通过gzip指令处理备份文件；
 -Z或--compress或--uncompress：通过compress指令处理备份文件；
 -f&lt;备份文件&gt;或--file=&lt;备份文件&gt;：指定备份文件；
 -v或--verbose：显示指令执行过程； 
 -r：添加文件到已经压缩的文件； 
 -u：添加改变了和现有的文件到已经存在的压缩文件； 
 -j：支持bzip2解压文件；
 -v：显示操作过程；
 -l：文件系统边界设置；
 -k：保留原有文件不覆盖；
 -m：保留文件不被覆盖；
 -w：确认压缩文件的正确性； 
 -p或--same-permissions：用原来的文件权限还原文件；
 -P或--absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号； 
 -N &lt;日期格式&gt; 或 --newer=&lt;日期时间&gt;：只将较指定日期更新的文件保存到备份文件里； 
 --exclude=&lt;范本样式&gt;：排除符合范本样式的文件。

 #(参数)
 文件或目录：指定要打包的文件或目录列表。
</code></pre><p>将文件全部打包成tar包：</p>
<pre><code> tar -jcvf filename.tar.bz2 要被压缩的档案或目录名称 #压 缩
 tar -jtvf filename.tar.bz2 #查 询
 tar -jxvf filename.tar.bz2 -C 欲解压缩的目录 #解压缩
 tar -cvf log.tar log2012.log  #仅打包，不压缩！ 
 tar -zcvf log.tar.gz log2012.log  #打包后，以 gzip 压缩 
 tar -jcvf log.tar.bz2 log2012.log #打包后，以 bzip2 压缩 
</code></pre><p>在选项f之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。 如果加z选项，则以.tar.gz或.tgz来代表gzip压缩过的tar包；如果加j选项，则以.tar.bz2来作为tar包名。</p>
<p>查阅上述tar包内有哪些文件： </p>
<p>   tar -ztvf log.tar.gz </p>
<p>由于我们使用 gzip 压缩的log.tar.gz，所以要查阅log.tar.gz包内的文件时，就得要加上z这个选项了。 </p>
<p>将tar包解压缩：</p>
<p>   tar -zxvf /opt/soft/test/log.tar.gz </p>
<p>在预设的情况下，我们可以将压缩档在任何地方解开的 </p>
<p>只将tar内的部分文件解压出来： </p>
<p>   tar -zxvf /opt/soft/test/log30.tar.gz log2013.log </p>
<p>我可以透过tar -ztvf来查阅 tar 包内的文件名称，如果单只要一个文件，就可以透过这个方式来解压部分文件！ </p>
<p>文件备份下来，并且保存其权限：</p>
<p>   tar -zcvpf log31.tar.gz log2014.log log2015.log log2016.log </p>
<p>这个-p的属性是很重要的，尤其是当您要保留原本文件的属性时。</p>
<p>在文件夹当中，比某个日期新的文件才备份： </p>
<p>   tar -N “2012/11/13” -zcvf log17.tar.gz test </p>
<p>备份文件夹内容是排除部分文件：</p>
<p>   tar —exclude scf/service -zcvf scf.tar.gz scf/* </p>
<p>其实最简单的使用 tar 就只要记忆底下的方式即可：</p>
<p>   压　缩：tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称<br>   查　询：tar -jtv -f filename.tar.bz2<br>   解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</p>
</li>
</ul>
<h3 id="users"><a href="#users" class="headerlink" title="users"></a>users</h3><ul>
<li><strong>显示当前登录系统地用户</strong></li>
</ul>
<h3 id="who-1"><a href="#who-1" class="headerlink" title="who"></a>who</h3><ul>
<li><p><strong>登录在本机的用户与来源</strong></p>
<pre><code>-H或--heading 　显示各栏位的标题信息列。
</code></pre></li>
</ul>
<h3 id="w"><a href="#w" class="headerlink" title="w"></a>w</h3><ul>
<li><p><strong>登录在本机的用户及其运行的程序</strong></p>
<pre><code>  -s 　使用简洁格式列表，不显示用户登入时间，终端机阶段作业和程序所耗费的CPU时间。
  -h 　不显示各栏位的标题信息列。
</code></pre></li>
</ul>
<h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><ul>
<li><strong>给当前联机的用户发消息</strong></li>
</ul>
<h3 id="wall"><a href="#wall" class="headerlink" title="wall"></a>wall</h3><ul>
<li><strong>给所有登录再本机的用户发消息</strong></li>
</ul>
<h3 id="last"><a href="#last" class="headerlink" title="last"></a>last</h3><ul>
<li><strong>查看用户的登陆日志</strong></li>
</ul>
<h3 id="lastlog"><a href="#lastlog" class="headerlink" title="lastlog"></a>lastlog</h3><ul>
<li><strong>查看每个用户最后的登陆时间</strong></li>
</ul>
<h3 id="finger"><a href="#finger" class="headerlink" title="finger"></a>finger</h3><ul>
<li><p><strong>查看用户信息</strong></p>
<pre><code>-s 显示用户的注册名、实际姓名、终端名称、写状态、停滞时间、登录时间等信息
-l 除了用-s选项显示的信息外，还显示用户主目录、登录shell、邮件状态等信息，以及用户主目录下的.plan、.project和.forward文件的内容。
-p 除了不显示.plan文件和.project文件以外，与-l选项相同
</code></pre></li>
</ul>
<h3 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a>hostname</h3><ul>
<li><strong>查看主机名</strong></li>
</ul>
<h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><ul>
<li><strong>添加别名</strong></li>
</ul>
<h3 id="unalias"><a href="#unalias" class="headerlink" title="unalias"></a>unalias</h3><ul>
<li><strong>清除别名</strong></li>
</ul>
<h3 id="chage"><a href="#chage" class="headerlink" title="chage"></a>chage</h3><ul>
<li><p>**修改用户密码的相关属性</p>
<pre><code>-l  列出该账号的详细密码参数；
-d  后面接日期，修改 shadow 第三字段(最近一次更改密码的日期)，格式YYYY-MM-DD
-E  后面接日期，修改 shadow 第八字段(账号失效日)，格式 YYYY-MM-DD
-I  后面接天数，修改 shadow 第七字段(密码失效日期)
-m  后面接天数，修改 shadow 第四字段(密码最短保留天数)
-M  后面接天数，修改 shadow 第五字段(密码多久需要进行变更)
-W  后面接天数，修改 shadow 第六字段(密码过期前警告日期)
</code></pre><h3 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h3></li>
<li><p><strong>修改用户的相关属性</strong></p>
<pre><code>-c  后面接账号的说明，即 /etc/passwd 第五栏的说明栏，可以加入一些账号的说明。
-d  后面接账号的家目录，即修改 /etc/passwd 的第六栏；
-e  后面接日期，格式是 YYYY-MM-DD 也就是在 /etc/shadow 内的第八个字段数据啦！
-f  后面接天数为 shadow 的第七字段。
-g  后面接初始群组，修改 /etc/passwd 的第四个字段，亦即是GID的字段！
-G  后面接次要群组，修改这个使用者能够支持的群组
-l  后面接账号名称。亦即是修改账号名称， /etc/passwd 的第一栏！
-s  后面接 Shell 的实际档案，例如 /bin/bash 或 /bin/csh 等等。
-u  后面接 UID 数字啦！即 /etc/passwd 第三栏的资料；
-L  冻结密码
-U  解冻密码
</code></pre></li>
</ul>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><ul>
<li><strong>查看用户相关的id信息，还可以用来判断用户是否存在</strong></li>
</ul>
<h3 id="groups"><a href="#groups" class="headerlink" title="groups"></a>groups</h3><ul>
<li><strong>查看登陆用户支持的群组， 第一个输出的群组为有效群组</strong></li>
</ul>
<h3 id="newgrp"><a href="#newgrp" class="headerlink" title="newgrp"></a>newgrp</h3><ul>
<li><strong>切换有效群组</strong></li>
</ul>
<h3 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h3><ul>
<li><p><strong>修改组信息</strong></p>
<pre><code>-g  修改既有的 GID 数字
-n  修改既有的组名
</code></pre></li>
</ul>
<h3 id="groupdel-1"><a href="#groupdel-1" class="headerlink" title="groupdel"></a>groupdel</h3><ul>
<li><strong>删除群组</strong></li>
</ul>
<h3 id="gpasswd"><a href="#gpasswd" class="headerlink" title="gpasswd"></a>gpasswd</h3><ul>
<li><p><strong>群组管理员功能</strong></p>
<pre><code>root管理员动作：
    -gpasswd groupname 设定密码
    -gpasswd [-A user1,...] [-M user3,...] groupname
        -A  将 groupname 的主控权交由后面的使用者管理(该群组的管理员)
        -M  将某些账号加入这个群组当中
    -gpasswd [-r] groupname
        -r  将 groupname 的密码移除
群组管理员动作：
    - gpasswd [-ad] user groupname 
        -a  将某位使用者加入到 groupname 这个群组当中
        -d  将某位使用者移除出 groupname 这个群组当中
</code></pre></li>
</ul>
<h3 id="chfn"><a href="#chfn" class="headerlink" title="chfn"></a>chfn</h3><ul>
<li><strong>修改个人信息</strong></li>
</ul>
<h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><ul>
<li><p><strong>Print selected parts of lines from each FILE to standard output</strong></p>
<pre><code>  -b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。
  -c ：以字符为单位进行分割。
  -d ：自定义分隔符，默认为制表符。
  -f  ：与-d一起使用，指定显示哪个区域。
</code></pre></li>
</ul>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><ul>
<li><p><strong>sort</strong></p>
<pre><code>  -n   依照数值的大小排序。
  -o&lt;输出文件&gt;   将排序后的结果存入指定的文件。
  -r   以相反的顺序来排序。
  -t&lt;分隔字符&gt;   指定排序时所用的栏位分隔字符。
  -k  选择以哪个区间进行排序。
</code></pre></li>
</ul>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><ul>
<li><strong>显示环境变量和普通变量</strong></li>
</ul>
<h3 id="env"><a href="#env" class="headerlink" title="env"></a>env</h3><ul>
<li><strong>显示环境变量</strong></li>
</ul>
<h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><ul>
<li><strong>把普通变量变成环境变量</strong></li>
</ul>
<h3 id="unset"><a href="#unset" class="headerlink" title="unset"></a>unset</h3><ul>
<li><p><strong>删除一个环境变量</strong></p>
<pre><code>aaa(){} 定义函数
</code></pre><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3></li>
<li><p><strong>read</strong></p>
<pre><code>-p  接提示字符
-t  接等待的秒数
</code></pre></li>
</ul>
<h3 id="declare-typeset"><a href="#declare-typeset" class="headerlink" title="declare/typeset"></a>declare/typeset</h3><ul>
<li><p><strong>declare、typeset</strong></p>
<pre><code>-i 声明为整数
-a 声明为数组
-f 声明为函数
-r 声明为只读
</code></pre></li>
</ul>
<h3 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h3><ul>
<li><p><strong>限制使用者的某些系统资源</strong></p>
<pre><code>-f  此 shell 可以建立的最大档案容量 (一般可能设定为 2GB)单位为 Kbytes eg: ulimit -f 1024 
限制使用者仅能建立 1MBytes 以下的容量的档案
</code></pre></li>
</ul>
<h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><ul>
<li><p><strong>显示或设定系统的日期与时间</strong></p>
<pre><code>date [参数]… [+格式]

%H 小时(以00-23来表示)。 
%M 分钟(以00-59来表示)。 
%P AM或PM。
%D 日期(含年月日)
%U 该年中的周数。
date -s “2015-10-17 01:01:01″ //时间设定
date +%Y%m%d         //显示前天年月日
date +%Y%m%d --date=&quot;+1 day/month/year&quot;  //显示前一天/月/年的日期
date +%Y%m%d --date=&quot;-1 day/month/year&quot;  //显示后一天/月/年的日期
date -d &#39;2 weeks&#39; 2周后的日期
</code></pre></li>
</ul>
<h3 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h3><ul>
<li><p><strong>查看日历</strong></p>
<pre><code>-1  显示当月的月历
-3  显示前、当、后一个月的日历
-m  显示星期一为一个星期的第一天
-s  （默认）星期天为第一天
-j  显示当月是一年中的第几天的日历
-y  显示当前年份的日历
</code></pre></li>
</ul>
<h3 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h3><ul>
<li><p><strong>命令</strong></p>
<p>对于一个用Linux开发C程序的人来说，这个命令就非常重要了，它用于把C语言的源程序文件，编译成可执行程序，由于g++的很多参数跟它非常相似，所以这里只介绍gcc的参数，它的常用参数如下：</p>
<pre><code>[plain] view plain copy print?
-o ：output之意，用于指定生成一个可执行文件的文件名  
-c ：用于把源文件生成目标文件（.o)，并阻止编译器创建一个完整的程序  
-I ：增加编译时搜索头文件的路径  
-L ：增加编译时搜索静态连接库的路径  
-S ：把源文件生成汇编代码文件  
-lm：表示标准库的目录中名为libm.a的函数库  
-lpthread ：连接NPTL实现的线程库  
-std= ：用于指定把使用的C语言的版本  

# 例如：  
# 把源文件test.c按照c99标准编译成可执行程序test  
gcc -o test test.c -lm -std=c99  
#把源文件test.c转换为相应的汇编程序源文件test.s  
gcc -S test.c  
</code></pre><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3></li>
<li><p><strong>测算一个命令（即程序）的执行时间</strong></p>
<p>它的使用非常简单，就像平时输入命令一样，不过在命令的前面加入一个time即可，例如：</p>
<pre><code>[plain] view plain copy print?
time ./process  
time ps aux  
</code></pre><p>在程序或命令运行结束后，在最后输出了三个时间，它们分别是：<br>user：用户CPU时间，命令执行完成花费的用户CPU时间，即命令在用户态中执行时间总和；<br>system：系统CPU时间，命令执行完成花费的系统CPU时间，即命令在核心态中执行时间总和；<br>real：实际时间，从command命令行开始执行到运行终止的消逝时间；</p>
<p>注：用户CPU时间和系统CPU时间之和为CPU时间，即命令占用CPU执行的时间总和。实际时间要大于CPU时间，因为Linux是多任务操作系统，往往在执行一条命令时，系统还要处理其它任务。另一个需要注意的问题是即使每次执行相同命令，但所花费的时间也是不一样，其花费时间是与系统运行相关的。</p>
</li>
</ul>
<h3 id="查看内存溢出"><a href="#查看内存溢出" class="headerlink" title="查看内存溢出"></a>查看内存溢出</h3><ul>
<li><p><strong>查看内存溢出</strong></p>
<pre><code>jmap -heap pid #打印heap的概要信息 
jmap -histo pid #打印每个class的实例数目，内存占用，类全名信息 
jmap -dump:format=b,file=heap.bin pid #输出heap信息到heap.bin文件 
jhat -J-mx768m heap.bin #分析heap.bin文件 
jstack -l pid &gt; deadlock.jstack #输出stack信息到deadlock.jstack 
vi deadlock.jstack #使用vi查看
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/images/icons/linux.jpg&quot; alt=&quot;linux&quot; title=&quot;linux&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://jet-han.oschina.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="linux" scheme="http://jet-han.oschina.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>数据库之mysql(一)</title>
    <link href="http://jet-han.oschina.io/2017/06/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8Bmysql-%E4%B8%80/"/>
    <id>http://jet-han.oschina.io/2017/06/10/数据库之mysql-一/</id>
    <published>2017-06-10T02:28:09.000Z</published>
    <updated>2017-06-24T08:51:50.159Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/images/icons/mysql.jpg" alt="mysql" title="mysql"></p>
<a id="more"></a>
<h1 id="忘记mysql-root密码"><a href="#忘记mysql-root密码" class="headerlink" title="忘记mysql root密码"></a>忘记mysql root密码</h1><ul>
<li><p>本站所有环境都是linux下</p>
<pre><code>service mysqld stop  #停止mysql服务，注意权限
mysqld_safe --skip-grant-tables&amp; #也可以在配置文件中添加--skip-grant-tables
mysql -u root mysql #这里就不用指定-p了，直接登录
use mysql #选择使用mysql数据库
UPDATE user SET Password = PASSWORD(&#39;new password&#39;) WHERE user = &#39;root&#39;; #修改密码
FLUSH PRIVILEGES; #刷新，生效
</code></pre></li>
</ul>
<h1 id="mysql配置文件my-cnf详解1"><a href="#mysql配置文件my-cnf详解1" class="headerlink" title="mysql配置文件my.cnf详解1"></a>mysql配置文件my.cnf详解1</h1><ul>
<li><p><strong>mysqld程序：基本配置 </strong></p>
<pre><code> basedir = path #使用给定目录作为根目录(安装目录)。
 character-sets-dir = path     #给出存放着字符集的目录。
 datadir = path     #从给定目录读取数据库文件。
 pid-file = filename    #为mysqld程序指定一个存放进程ID的文件(仅适用于UNIX/Linux系统); Init-V脚本需要使用这个文件里的进程ID结束mysqld进程。
 socket = filename     #为MySQL客户程序与服务器之间的本地通信指定一个套接字文件(仅适用于UNIX/Linux系统; 默认设置一般是/var/lib/mysql/mysql.sock文件)。在Windows环境下，如果MySQL客户与服务器是通过命名管道进行通信 的，–sock选项给出的将是该命名管道的名字(默认设置是MySQL)。
 lower_case_table_name = 1/0     #新目录和数据表的名字是否只允许使用小写字母; 这个选项在Windows环境下的默认设置是1(只允许使用小写字母)。
</code></pre><p><strong>mysqld程序：语言设置</strong></p>
<pre><code> character-sets-server = name    #新数据库或数据表的默认字符集。为了与MySQL的早期版本保持兼容，这个字符集也可以用–default-character-set选项给出; 但这个选项已经显得有点过时了。
 collation-server = name    #新数据库或数据表的默认排序方式。
 language = name    #用指定的语言显示出错信息。
</code></pre><p><strong>mysqld程序：通信、网络、信息安全</strong></p>
<pre><code>enable-named-pipes    #允许Windows 2000/XP环境下的客户和服务器使用命名管道(named pipe)进行通信。这个命名管道的默认名字是MySQL，但可以用–socket选项来改变。
local-infile [=0]     #允许/禁止使用LOAD DATA LOCAL语句来处理本地文件。
myisam-recover [=opt1, opt2, ...]    在启动时自动修复所有受损的MyISAM数据表。这个选项的可取值有4种:DEFAULT、BACKUP、QUICK和FORCE; 它们与myisamchk程序的同名选项作用相同。
old-passwords     #使用MySQL 3.23和4.0版本中的老算法来加密mysql数据库里的密码(默认使用MySQL 4.1版本开始引入的新加密算法)。
port = n    #为MySQL程序指定一个TCP/IP通信端口(通常是3306端口)。
safe-user-create    #只有在mysql.user数据库表上拥有INSERT权限的用户才能使用GRANT命令; 这是一种双保险机制(此用户还必须具备GRANT权限才能执行GRANT命令)。
shared-memory    #允许使用内存(shared memory)进行通信(仅适用于Windows)。
shared-memory-base-name = name    #给共享内存块起一个名字(默认的名字是MySQL)。
skip-grant-tables     #不使用mysql数据库里的信息来进行访问控制(警告:这将允许用户任何用户去修改任何数据库)。
skip-host-cache    #不使用高速缓存区来存放主机名和IP地址的对应关系。
skip-name-resovle     #不把IP地址解析为主机名; 与访问控制(mysql.user数据表)有关的检查全部通过IP地址行进。
skip-networking    #只允许通过一个套接字文件(Unix/Linux系统)或通过命名管道(Windows系统)进行本地连接，不允许ICP/IP连接; 这提高了安全性，但阻断了来自网络的外部连接和所有的Java客户程序(Java客户即使在本地连接里也使用TCP/IP)。
user = name    #mysqld程序在启动后将在给定UNIX/Linux账户下执行; mysqld必须从root账户启动才能在启动后切换到另一个账户下执行; mysqld_safe脚本将默认使用–user=mysql选项来启动mysqld程序。
</code></pre><p><strong>mysqld程序：内存管理、优化、查询缓存区</strong></p>
<pre><code>bulk_insert_buffer_size = n    #为一次插入多条新记录的INSERT命令分配的缓存区长度(默认设置是8M)。
key_buffer_size = n    #用来存放索引区块的RMA值(默认设置是8M)。
join_buffer_size = n    #在参加JOIN操作的数据列没有索引时为JOIN操作分配的缓存区长度(默认设置是128K)。
max_heap_table_size = n    #HEAP数据表的最大长度(默认设置是16M); 超过这个长度的HEAP数据表将被存入一个临时文件而不是驻留在内存里。
max_connections = n    #MySQL服务器同时处理的数据库连接的最大数量(默认设置是100)。
query_cache_limit = n     #允许临时存放在查询缓存区里的查询结果的最大长度(默认设置是1M)。
query_cache_size = n    #查询缓存区的最大长度(默认设置是0，不开辟查询缓存区)。
query_cache_type = 0/1/2    #查询缓存区的工作模式:0, 禁用查询缓存区; 1，启用查询缓存区(默认设置); 2，”按需分配”模式，只响应SELECT SQL_CACHE命令。
read_buffer_size = n     #为从数据表顺序读取数据的读操作保留的缓存区的长度(默认设置是128KB); 这个选项的设置值在必要时可以用SQL命令SET SESSION read_buffer_size = n命令加以改变。
read_rnd_buffer_size = n    #类似于read_buffer_size选项，但针对的是按某种特定顺序(比如使用了ORDER BY子句的查询)输出的查询结果(默认设置是256K)。
sore_buffer = n    #为排序操作分配的缓存区的长度(默认设置是2M); 如果这个缓存区太小，则必须创建一个临时文件来进行排序。
table_cache = n    #同时打开的数据表的数量(默认设置是64)。
tmp_table_size = n    #临时HEAP数据表的最大长度(默认设置是32M); 超过这个长度的临时数据表将被转换为MyISAM数据表并存入一个临时文件。
</code></pre><p><strong>mysqld程序：日志</strong></p>
<pre><code>log [= file]    #把所有的连接以及所有的SQL命令记入日志(通用查询日志); 如果没有给出file参数，MySQL将在数据库目录里创建一个hostname.log文件作为这种日志文件(hostname是服务器的主机名)。
log-slow-queries [= file]    #把执行用时超过long_query_time变量值的查询命令记入日志(慢查询日志); 如果没有给出file参数，MySQL将在数据库目录里创建一个hostname-slow.log文件作为这种日志文件(hostname是服务器主机 名)。
long_query_time = n    #慢查询的执行用时上限(默认设置是10s)。
long_queries_not_using_indexs    #把慢查询以及执行时没有使用索引的查询命令全都记入日志(其余同–log-slow-queries选项)。
log-bin [= filename]    #把对数据进行修改的所有SQL命令(也就是INSERT、UPDATE和DELETE命令)以二进制格式记入日志(二进制变更日志，binary update log)。这种日志的文件名是filename.n或默认的hostname.n，其中n是一个6位数字的整数(日志文件按顺序编号)。
log-bin-index = filename    #二进制日志功能的索引文件名。在默认情况下，这个索引文件与二进制日志文件的名字相同，但后缀名是.index而不是.nnnnnn。
max_binlog_size = n    #二进制日志文件的最大长度(默认设置是1GB)。在前一个二进制日志文件里的信息量超过这个最大长度之前，MySQL服务器会自动提供一个新的二进制日志文件接续上。
binlog-do-db = dbname    #只把给定数 据库里的变化情况记入二进制日志文件，其他数据库里的变化情况不记载。如果需要记载多个数据库里的变化情况，就必须在配置文件使用多个本选项来设置，每个数据库一行。
binlog-ignore-db = dbname    #不把给定数据库里的变化情况记入二进制日志文件。
sync_binlog = n    #每经过n次日志写操作就把日志文件写入硬盘一次(对日志信息进行一次同步)。n=1是最安全的做法，但效率最低。默认设置是n=0，意思是由操作系统来负责二进制日志文件的同步工作。
log-update [= file]    #记载出错情况的日志文件名(出错日志)。这种日志功能无法禁用。如果没有给出file参数，MySQL会使用hostname.err作为种日志文件的名字。
</code></pre><p><strong>mysqld程序：镜像(主控镜像服务器)</strong></p>
<pre><code>  server-id = n    #给服务器分配一个独一无二的ID编号; n的取值范围是1~2的32次方启用二进制日志功能。
  log-bin = name    #启用二进制日志功能。这种日志的文件名是filename.n或默认的hostname.n，其中的n是一个6位数字的整数(日志文件顺序编号)。
  binlog-do/ignore-db = dbname    #只把给定数据库里的变化情况记入二进制日志文件/不把给定的数据库里的变化记入二进制日志文件。
</code></pre><p><strong>mysqld程序：镜像(从属镜像服务器)</strong></p>
<pre><code>server-id = n    #给服务器分配一个唯一的ID编号
log-slave-updates    #启用从属服务器上的日志功能，使这台计算机可以用来构成一个镜像链(A-&gt;B-&gt;C)。
master-host = hostname    #主控服务器的主机名或IP地址。如果从属服务器上存在mater.info文件(镜像关系定义文件)，它将忽略此选项。
master-user = replicusername    #从属服务器用来连接主控服务器的用户名。如果从属服务器上存在mater.info文件，它将忽略此选项。
master-password = passwd    #从属服务器用来连接主控服务器的密码。如果从属服务器上存在mater.info文件，它将忽略此选项。
master-port = n    #从属服务器用来连接主控服务器的TCP/IP端口(默认设置是3306端口)。
master-connect-retry = n    #如果与主控服务器的连接没有成功，则等待n秒(s)后再进行管理方式(默认设置是60s)。如果从属服务器存在mater.info文件，它将忽略此选项。
master-ssl-xxx = xxx    #对主、从服务器之间的SSL通信进行配置。
read-only = 0/1    #0: 允许从属服务器独立地执行SQL命令(默认设置); 1: 从属服务器只能执行来自主控服务器的SQL命令。
read-log-purge = 0/1    #1: 把处理完的SQL命令立刻从中继日志文件里删除(默认设置); 0: 不把处理完的SQL命令立刻从中继日志文件里删除。
replicate-do-table = dbname.tablename    与–replicate-do-table选项的含义和用法相同，但数据库和数据库表名字里允许出现通配符”%” (例如: test%.%–对名字以”test”开头的所有数据库里的所以数据库表进行镜像处理)。

replicate-do-db = name    #只对这个数据库进行镜像处理。
replicate-ignore-table = dbname.tablename    #不对这个数据表进行镜像处理。
replicate-wild-ignore-table = dbn.tablen    #不对这些数据表进行镜像处理。
replicate-ignore-db = dbname    #不对这个数据库进行镜像处理。
replicate-rewrite-db = db1name &gt; db2name    #把主控数据库上的db1name数据库镜像处理为从属服务器上的db2name数据库。
report-host = hostname    #从属服务器的主机名; 这项信息只与SHOW SLAVE HOSTS命令有关–主控服务器可以用这条命令生成一份从属服务器的名单。
slave-compressed-protocol = 1    #主、从服务器使用压缩格式进行通信–如果它们都支持这么做的话。
slave-skip-errors = n1, n2, …或all    #即使发生出错代码为n1、n2等的错误，镜像处理工作也继续进行(即不管发生什么错误，镜像处理工作也继续进行)。如果配置得当，从属服务器不应该在执行 SQL命令时发生错误(在主控服务器上执行出错的SQL命令不会被发送到从属服务器上做镜像处理); 如果不使用slave-skip-errors选项，从属服务器上的镜像工作就可能因为发生错误而中断，中断后需要有人工参与才能继续进行。
</code></pre><p><strong>mysqld–InnoDB：基本设置、表空间文件</strong></p>
<pre><code>skip-innodb    #不加载InnoDB数据表驱动程序–如果用不着InnoDB数据表，可以用这个选项节省一些内存。
innodb-file-per-table    #为每一个新数据表创建一个表空间文件而不是把数据表都集中保存在中央表空间里(后者是默认设置)。该选项始见于MySQL 4.1。
innodb-open-file = n    #InnoDB数据表驱动程序最多可以同时打开的文件数(默认设置是300)。如果使用了innodb-file-per-table选项并且需要同时打开很多数据表的话，这个数字很可能需要加大。
innodb_data_home_dir = p    #InnoDB主目录，所有与InnoDB数据表有关的目录或文件路径都相对于这个路径。在默认的情况下，这个主目录就是MySQL的数据目录。
innodb_data_file_path = ts    #用来容纳InnoDB为数据表的表空间: 可能涉及一个以上的文件; 每一个表空间文件的最大长度都必须以字节(B)、兆字节(MB)或千兆字节(GB)为单位给出; 表空间文件的名字必须以分号隔开; 最后一个表空间文件还可以带一个autoextend属性和一个最大长度(max:n)。例如，ibdata1:1G; ibdata2:1G:autoextend:max:2G的意思是: 表空间文件ibdata1的最大长度是1GB，ibdata2的最大长度也是1G，但允许它扩充到2GB。除文件名外，还可以用硬盘分区的设置名来定义表 空间，此时必须给表空间的最大初始长度值加上newraw关键字做后缀，给表空间的最大扩充长度值加上raw关键字做后缀(例如/dev/hdb1: 20Gnewraw或/dev/hdb1:20Graw); MySQL 4.0及更高版本的默认设置是ibdata1:10M:autoextend。
innodb_autoextend_increment = n    #带有autoextend属性的表空间文件每次加大多少兆字节(默认设置是8MB)。这个属性不涉及具体的数据表文件，那些文件的增大速度相对是比较小的。
innodb_lock_wait_timeout = n    #如果某个事务在等待n秒(s)后还没有获得所需要的资源，就使用ROLLBACK命令放弃这个事务。这项设置对于发现和处理未能被InnoDB数据表驱动 程序识别出来的死锁条件有着重要的意义。这个选项的默认设置是50s。
innodb_fast_shutdown 0/1    #是否以最快的速度关闭InnoDB，默认设置是1，意思是不把缓存在INSERT缓存区的数据写入数据表，那些数据将在MySQL服务器下次启动时再写入 (这么做没有什么风险，因为INSERT缓存区是表空间的一个组成部分，数据不会丢失)。把这个选项设置为0反面危险，因为在计算机关闭时，InnoDB 驱动程序很可能没有足够的时间完成它的数据同步工作，操作系统也许会在它完成数据同步工作之前强行结束InnoDB，而这会导致数据不完整。
</code></pre><p><strong>mysqld程序：InnoDB–日志</strong></p>
<pre><code>innodb_log_group_home_dir = p    #用来存放InnoDB日志文件的目录路径(如ib_logfile0、ib_logfile1等)。在默认的情况下，InnoDB驱动程序将使用 MySQL数据目录作为自己保存日志文件的位置。
innodb_log_files_in_group = n    #使用多少个日志文件(默认设置是2)。InnoDB数据表驱动程序将以轮转方式依次填写这些文件; 当所有的日志文件都写满以后，之后的日志信息将写入第一个日志文件的最大长度(默认设置是5MB)。这个长度必须以MB(兆字节)或GB(千兆字节)为单 位进行设置。
innodb_flush_log_at_trx_commit = 0/1/2    #这个选项决定着什么时候把日志信息写入日志文件以及什么时候把这些文件物理地写(术语称为”同步”)到硬盘上。设置值0的意思是每隔一秒写一次日志并进行 同步，这可以减少硬盘写操作次数，但可能造成数据丢失; 设置值1(设置设置)的意思是在每执行完一条COMMIT命令就写一次日志并进行同步，这可以防止数据丢失，但硬盘写操作可能会很频繁; 设置值2是一般折衷的办法，即每执行完一条COMMIT命令写一次日志，每隔一秒进行一次同步。
innodb_flush_method = x    #InnoDB日志文件的同步办法(仅适用于UNIX/Linux系统)。这个选项的可取值有两种: fdatasync，用fsync()函数进行同步; O_DSYNC，用O_SYNC()函数进行同步。
innodb_log_archive = 1    #启用InnoDB驱动程序的archive(档案)日志功能，把日志信息写入ib_arch_log_n文件。启用这种日志功能在InnoDB与 MySQL一起使用时没有多大意义(启用MySQL服务器的二进制日志功能就足够用了)。
</code></pre><p><strong>mysqld程序–InnoDB：缓存区的设置和优化</strong></p>
<pre><code>innodb_log_buffer_pool_size = n    #为InnoDB数据表及其索引而保留的RAM内存量(默认设置是8MB)。这个参数对速度有着相当大的影响，如果计算机上只运行有 MySQL/InnoDB数据库服务器，就应该把全部内存的80%用于这个用途。

innodb_log_buffer_size = n    #事务日志文件写操作缓存区的最大长度(默认设置是1MB)。
innodb_additional_men_pool_size = n    #为用于内部管理的各种数据结构分配的缓存区最大长度(默认设置是1MB)。
innodb_file_io_threads = n    #I/O操作(硬盘写操作)的最大线程个数(默认设置是4)。
innodb_thread_concurrency = n     #InnoDB驱动程序能够同时使用的最大线程个数(默认设置是8)。
</code></pre><p><strong>mysqld程序：其它选项</strong></p>
<pre><code>bind-address = ipaddr     #MySQL服务器的IP地址。如果MySQL服务器所在的计算机有多个IP地址，这个选项将非常重要。
default-storage-engine = type    #新数据表的默认数据表类型(默认设置是MyISAM)。这项设置还可以通过–default-table-type选项来设置。
default-timezone = name    #为MySQL服务器设置一个地理时区(如果它与本地计算机的地理时区不一样)。
ft_min_word_len = n    #全文索引的最小单词长度工。这个选项的默认设置是4，意思是在创建全文索引时不考虑那些由3个或更少的字符构建单词。
Max-allowed-packet = n    #客户与服务器之间交换的数据包的最大长度，这个数字至少应该大于客户程序将要处理的最大BLOB块的长度。这个选项的默认设置是1MB。
Sql-mode = model1, mode2, …    #MySQL将运行在哪一种SQL模式下。这个选项的作用是让MySQL与其他的数据库系统保持最大程度的兼容。这个选项的可取值包括ansi、db2、 oracle、no_zero_date、pipes_as_concat。
</code></pre></li>
</ul>
<h1 id="mysql配置文件my-cnf详解2"><a href="#mysql配置文件my-cnf详解2" class="headerlink" title="mysql配置文件my.cnf详解2"></a>mysql配置文件my.cnf详解2</h1><ul>
<li>配置MySQL服务器是一个丰富而复杂的工作。在本文中，我只能肤浅的说一下各种选项。可以使用的mysql配置文件共有５个。<br>·/etc/my.cnf是默认的MySQL配置文件。应该对这个文件配置修改。它是为学习目的而设计的。<br>·my-small.cnf是为了小型数据库而设计的。不应该把这个模型用于含有一些常用项目的数据库。<br>·my-medium.cnf是为中等规模的数据库而设计的。如果你正在企业中使用RHEL,可能会比这个操作系统的最小RAM需求(256MB)明显多得多的物理内存。由此可见，如果有那么多RAM内存可以使用，自然可以在同一台机器上运行其它服务。<br>·my-large.cnf是为专用于一个SQL数据库的计算机而设计的。由于它可以为该数据库使用多达512MB的内存，所以在这种类型的系统上将需要至少1GB的RAM,以便它能够同时处理操作系统与数据库应用程序。<br>·my-huge.cnf是为企业中的数据库而设计的。这样的数据库要求专用服务器和1GB或1GB以上的RAM。<br>这些选择高度依赖于内存的数量、计算机的运算速度、数据库的细节大小、访问数据库的用户数量以及在数据库中装入并访问数据的用户数量。随着数据库和用户的不断增加，数据库的性能可能会发生变化。<br>我将逐个的说明这些配置文件。如果用户决定使用my-<em>.cnf文件之一，将首先需要把这个文件复制到/etc/my.cnf文件上。<br>由于这些原因，用户应该仔细观察数据库系统的性能。如果发现问题，可能需要增加更多的RAM，或者把数据库迁移到一个含有附加资源(比如多个CPU)的系统上。<br>提示：数据库变得非常大。把一个SQL数据库目录配置在一个专用分区上可能更有道理。虽然一个不断增长的数据库可能会占满整个分区，但它至少不会吞掉RHEL运行所必需的磁盘空间。<br>/etc/my.cnf文件<br>默认是/etc/my.cnf文件。它包含6条命令，并且这6条命令被组织在3个配置段中。这些配置段与Samba配置文件中的配置段相似，并且含有功能组名称和相关的命令。本文将逐行的说明这个文件的默认版本。如果用户进行了任何修改，将需要确保MySQL启动脚本(即/etc/rc.d /init.d/mysqld)中的命令一致。<br><strong>[mysqld]</strong><br>在这个配置段之内，将会看到与MySQL守护进程相关的命令。<br><strong>datadir=/var/lib/mysql</strong><br>MySQL服务器把数据库存储在由datadir变量所定义的目录中。<br><strong>Socket=/var/lib/mysql/mysql.sock</strong><br>MySQL套接字把数据库程序局部的或通过网络连接到MySQL客户。<br>提示：MySQL被配置成使用InnoDB存储器引擎。如果用户在自己的系统上还没有一个InnoDB数据库，将需要给[mysqld]配置段添加skip-innodb语句。<br><strong>[mysql.server]</strong><br>在这个配置段之内，将会看到MySQL服务器守护进程有关的命令。这个配置段的较早期版本被命名为[mysql_server]。如果使用 MySQL4.X或MySQL4.X以上版本，将必须把这个配置段标题改成[mysql_server]。当启动MySQL服务时，它使用这个配置段中的选项。<br><strong>user=mysql</strong><br>与MySQL服务相关联的标准用户名是mysql。它应该是/etc/passwd文件的一部分；如果在这个文件中没有发现它，用户可能还没有安装Red Hat Enterprise Linux mysql-server RPM程序包。<br><strong>basedir=/var/lib</strong><br>这表示MySQL数据库的顶级目录。它充当MySQL系统上的一个根目录；这个数据库中的其它目录都是相对于这个目录。<br><strong>[safe_mysqld]</strong><br>这个配置段包含MySQL启动脚本所引用的命令。如果使用MySQL4.X或4.X以上版本，必须把这个配置段改成[mysqld_safe]。<br><strong>err-log=/var/log/mysqld.log</strong><br>这是MySQL所关联的错误被发送到的这个文件。如果使用MySQL4.X或4.X以上版本，必须使用log-error指令替换这条命令。<br><strong>pid-file=/var/run/mysqld/mysqld.pid</strong><br>最后，pid-file指令定义MySQL服务器在运作期间的进程标识符(PID)。如果MySQL服务器当前没有运行，这个文件应该不存在。<br>提示：用户可以配置与用户特定相关的MySQL配置文件；为此，只需给指定用户主目录中的.my.cnf隐含文件添加所选的配置命令即可。<br><strong>my-samll-cnf</strong><br>在本文中，将说明my-small-cnf配置文本中的所有命令。当回顾其它MySQL样本配置文件时，将参考本文所解释的各条命令和指令的含义。先从下面这个配置段开始分析该文件中的有效命令和指令：<br><strong>[client]</strong><br>这个配置把指令传递给与MySQL服务器相关的客户。<br><strong>port＝3306</strong><br>MySQL所相关的标准TCP/IP端口是3306。如果需要修改这个端口号(可以增强安全)，必须确保用于MySQL客户与服务器的所有相应配置文件中均修改这个号。<br><strong>socket=/var/lib/mysql/mysql.sock</strong><br>正像默认的/etc/my.cnf文件中所定义的那样，这是控制MySQL客户与服务器间通信的标准套接字文件。<br><strong>[mysqld]</strong><br>当启动MySQL服务器时，它由[mysqld]配置段中所定义的命令来控制。<br><strong>port=3306</strong><br><strong>socket=/var/lib/mysql/mysql.sock</strong><br>当然，与同一个MySQL数据库相关的客户与服务器需要使用相同的TCP/IP端口和套接字。<br><strong>skip-locking</strong><br>多个客户可能会访问同一个数据库，因此这防止外部客户锁定MySQL服务器。这个skip-locking命令是MySQL4.X或4.X以上版本中的skip-external-locking命令。<br>一般来说，如果正在使用MySQL4.X或4.X上以版本，这个set-variable指令没有必要带有这个列表中的这些命令。<br><strong>set-variable=key_buffer=16k</strong><br>这个缓冲区确实很小；如果一个数据库在一个文本文件中包含不止几百行数据，它将会超载这个缓冲区的容量。这个数据库可能不会超载一个文本文件地址簿的容量。如果这不只是一个供个人使用的数据库，这个限额很快就会被达到。假使那样的话，可能需要考虑与其它配置文件之一相关的那些限额。<br><strong>set-variable=max_allowed_packet=1M</strong><br>当然，与一个数据库相关的信息会增加到超出实际数据。在默认的情况下，如果该信息在一个服务器上超过1MB以上，MySQL将会产生一条错误信息。<br><strong>set-variable=thread_stack=64k</strong><br>这条指令限定用于每个数据库线程的栈大小。默认设置足以满足大多数应用。<br><strong>set-variable=table_cache=4</strong><br>用户可以限定一个数据库中打开表的数量；越小的限额(默认值是64)适合越小规模的数据库。<br><strong>set-variable=sort_buffer=64k</strong><br>在处理一个数据库时，用户可能需要内存中附加的缓冲区空间。<br><strong>set-variable=net_buffer_length=2k</strong><br>正如net_buffer_length指令所定义的，MySQL服务器还给传入的请求保留了空间。<br><strong>server-id=1</strong><br>一般来说，如果有一个MySQL主服务器，应该把它的server-id设置成１；应该把MySQL从属服务器的server-id设置成２；<br><strong>[mysqldump]</strong><br>用户可以在不同类型的SQL数据库之间传输数据，这由[mysqldump]配置段中的命令来控制。<br><strong>quick</strong><br>quick选项支持较大数据库的转储。<br><strong>set-variable=max_allowed_packet=16M</strong><br>当然，用来传输数据库表到其它数据库的max_allowed_packet大于客户与服务器之间的简单通信所使用的信息包。<br><strong>[mysql]</strong><br><strong>no-auto-rehash</strong><br>这个配置段设置启动MySQL服务的条件；在这种情况下，no-auto-rehash确保这个服务启动得比较快。<br><strong>[isamchk]</strong><br><strong>[myisamchk]</strong><br>像SQL这样的关系数据库用所谓的Indexed Sequential Access Method(索引顺序存取方法，简称ISAM)来处理。这两个配置段中的命令是相同的；这些命令与检查并修复数据库表的同名命令有关。<br><strong>set-variable=key_buffer=8M</strong><br><strong>set-variable=sort_buffer=8M</strong><br>在前面谈及MySQL服务器时，用户己经见过这些变量。它们在这里都比较大，以便支持数据库的较快速检查与修复。<br><strong>[mysqlhotcopy]</strong><br><strong>interactive-timeout</strong><br>正如[mysqlhotcopy]配置段所指定的，在一个数据库复制操作期间，连接会挂起。在默认情况下，interactive-timeout变量把一个数据传输的最大时间量设置为28800秒(8个小时)。<br><strong>my-medium.cnf文件</strong><br>与中等数据库相关的MySQL配置文件含有和my-small-cnf配置文件中一样的有效配置段。在[mysqld]配置段中，下面这些命令支持较大规模的服务器数据库：<br><strong>set-variable=key_buffer=16M</strong><br><strong>set-variable=table_cache=64</strong><br><strong>set-variable=sort_buffer=512K</strong><br><strong>set-variable=net_buffer_length=8K</strong><br><strong>log-bin</strong><br>一般来说，这个配置段中的命令支持服务器上的较大高速缓存与缓冲区长度。应该看到两条新命令。<br><strong>set-variable=myisam_sort_buffer_size=8M</strong><br><strong>log-bin</strong><br>myisam_sort_buffer_size命令允许MySQL索引数据库，第二条命令支持二进制日志记录方法。<br><strong>[isamchk]</strong><br><strong>[myisamchk]</strong><br>当然，这两个配置段中的缓冲区比用于数据库传输的缓冲区大，这个文件包含下面这些命令；它们发送消息到服务器和接收来自服务器的消息。<br><strong>set-variable=read_buffer=2M</strong><br><strong>set-variable=write_buffer=2M</strong><br><strong>my-large.cnf文件</strong><br>与较大型数据库相关的MySQL配置文件含有和my-samll-cnf配置文件中一样的有效配置段。在本文中，将比较my-large-cnf与my-medium-cnf样本文件中的各条命令。在[mysqld]配置段中，下面这些命令支持较大型的服务器数据库：<br><strong>set-variable=key_buffer=256M</strong><br><strong>set-variable=table_cache=256</strong><br><strong>set-variable=sort_buffer=1M</strong><br><strong>set-variable=myisam_sort_buffer_size=64M</strong><br><strong>set-variable=net_buffer_length=8K</strong><br>这个配置段中有３条附加的命令。record_buffer命令保存对一个数据库中不同表的扫描结果。thread_cache命令对多请求有用；空闲线程被高速缓存起来，进而允许新的搜索操作采用己有的线程。只要这防止搜索操作启动新的服务器进程，这就能减轻系统上的负荷。<br><strong>set-variable=record_buffer=1M</strong><br><strong>set-variable=thread_cache=8</strong><br><strong>set-variable=thread_concurrency=8</strong><br>thread_concurrency变量限定同时运行的线程数量。my-large.cnf样本文件建议用户应该把这个数量限定于本计算机上CPU数量的两倍；这个特定设置相当于４个CPU。<br><em>*my-huge.cnf文件</em></em><br>my-huge.cnf文件含有和my-large.cnf配置文件中一样的命令。当然，分配给大多数指令的值比较大并适合较大型的数据库。</li>
</ul>
<h1 id="mysql备份和恢复数据库"><a href="#mysql备份和恢复数据库" class="headerlink" title="mysql备份和恢复数据库"></a>mysql备份和恢复数据库</h1><ul>
<li><p>mysqldump默认是锁表进行备份的</p>
<p>注意，如果你运行mysqldump没有—quick或—opt选项，mysqldump将在导出结果前装载<br>整个结果集到内存中，如果你正在导出一个大的数据库，这将可能是一个问题。<br>锁表进行备份时可能会影响业务操作，根据自身情况选择即可</p>
<p><strong>打包成gz到当前目录</strong></p>
<pre><code>mysqldump -h 192.168.167.55 -utest1 -ptest2 --opt --compress --single-transaction test3 | gzip &gt; test3.sql.gz
</code></pre><p><strong>恢复备份数据库</strong></p>
<pre><code>gunzip test3.sql.gz #解压
mysql&gt;source test3.sql #恢复
</code></pre><p><strong>直接备份恢复到本地数据库</strong></p>
<pre><code>mysqldump -h 192.168.167.55 -utest1 -ptest2 --opt --compress --skip-lock-tables | mysql -h localhost -uroot -proot database
</code></pre><p><strong>解释：</strong><br>192.168.167.55 远程服务器名称<br>test1 远程数据库登录名<br>test2 远程数据库登录密码<br>test3 远程数据库名（即：复制的源<br>localhost 本地数据库名称（一般情况下都是这个）<br>root 本地数据库登录名（一般情况下都是这个）<br>root 本地数据库登录密码（一般情况下都是这个）<br>database 本地（即：复制的目标数据库）<br><strong>sql解释：</strong>&lt;/br&gt;<br>mysqldump 是mysql的一个专门用于拷贝操作的命令<br>—single-transaction 不锁表进行备份<br>—opt 操作的意思<br>—compress 压缩要传输的数据<br>—skip-lock 忽略锁住的表（加上这句能防止当表有外键时的报错）<br>-tables 某数据库所有表<br>-h 服务器名称<br>-u 用户名（<em>后面无空格，直接加用户名）<br>-p 密码（</em>后面无空格，直接加密码）<br>注意：<br>-u、-p的后面没有空格，直接加用户名和密码！！！</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/images/icons/mysql.jpg&quot; alt=&quot;mysql&quot; title=&quot;mysql&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="http://jet-han.oschina.io/categories/database/"/>
    
    
      <category term="-mysql" scheme="http://jet-han.oschina.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Markdown-语法说明</title>
    <link href="http://jet-han.oschina.io/2017/05/30/Markdown-%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E/"/>
    <id>http://jet-han.oschina.io/2017/05/30/Markdown-语法说明/</id>
    <published>2017-05-30T09:21:02.000Z</published>
    <updated>2017-06-24T08:51:50.157Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/images/icons/markdown.jpg" alt="Markdown" title="Markdown"></p>
<a id="more"></a>
<h1 id="斜体和粗体"><a href="#斜体和粗体" class="headerlink" title="斜体和粗体"></a>斜体和粗体</h1><ul>
<li><p><strong>代码:</strong></p>
<pre><code>1.*斜体* 或者 _斜体_
2.**粗体**
3.***加粗斜体***
4.~~删除线~~
</code></pre></li>
<li><p><strong>显示效果:</strong></p>
<p>1.<em>斜体</em> 或者 <em>斜体</em></p>
<p>2.<strong>粗体</strong></p>
<p>3.<strong><em>加粗斜体</em></strong></p>
<p>4.<del>删除线</del></p>
</li>
</ul>
<h1 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h1><ul>
<li><p><strong>写法1，代码:</strong></p>
<pre><code># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题
</code></pre><p><strong>效果如下：</strong></p>
</li>
</ul>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><ul>
<li><p><strong>写法2，代码:</strong></p>
<pre><code>一级标题
============================

二级标题
----------------------------
</code></pre><p><strong>效果如下：</strong></p>
<h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2></li>
</ul>
<h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><ul>
<li>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。</li>
</ul>
<h2 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h2><p> <strong>语法说明：</strong><br> []里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。<a href="链接地址 “链接标题”">链接文字</a>’这样的形式。链接地址与链接标题前有一个空格。</p>
<p> <strong>代码：</strong></p>
<pre><code>   欢迎来到[jet&#39;s blog](http://jethan.bid/)
   欢迎来到[jet&#39;s blog](http://jethan.bid/ &quot;jet&#39;s blog&quot;)
</code></pre><p> <strong>显示效果：</strong></p>
<p> 欢迎来到<a href="http://jethan.bid/" target="_blank" rel="external">jet’s blog</a></p>
<p> 欢迎来到<a href="http://jethan.bid/" title="jet&#39;s blog" target="_blank" rel="external">jet’s blog</a></p>
<h2 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h2><ul>
<li><p>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。</p>
<p><strong>语法说明：</strong><br>参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。</p>
<p>如果链接文字本身可以做为链接标记，你也可以写成[链接文字][]<br>[链接文字]：链接地址的形式，见代码的最后一行。</p>
<p><strong>代码：</strong></p>
<pre><code>  1.我经常去的几个网站[Google][1]、[印象笔记][2]以及[自己的博客][3]
  2.[印象 笔记][2]是一个不错的[网站][]。

  3.[1]:http://www.google.com &quot;Google&quot;
  4.[2]:https://app.yinxiang.com &quot;印象笔记&quot;
  5.[3]:http://jethan.bid &quot;jet&#39;s blog&quot;
  6.[网站]:https://app.yinxiang.com
</code></pre><p><strong>显示效果：</strong></p>
<ul>
<li><p>我经常去的几个网站<a href="http://www.google.com" title="Google" target="_blank" rel="external">Google</a>、<a href="https://app.yinxiang.com" title="印象笔记" target="_blank" rel="external">印象笔记</a>以及<a href="http://jethan.bid" title="jet&#39;s blog" target="_blank" rel="external">自己的博客</a></p>
<p><a href="https://app.yinxiang.com" title="印象笔记" target="_blank" rel="external">印象 笔记</a>是一个不错的<a href="https://app.yinxiang.com" target="_blank" rel="external">网站</a>。</p>
</li>
</ul>
</li>
</ul>
<h2 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h2><ul>
<li><p><strong>语法说明：</strong><br>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>
<p><strong>代码：</strong></p>
<pre><code>https://www.baidu.com/
&lt;fajie_han@foxmail.com&gt;
</code></pre><p><strong>显示效果：</strong></p>
<p> <a href="https://www.baidu.com/" target="_blank" rel="external">https://www.baidu.com/</a></p>
<p> <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#x66;&#x61;&#106;&#x69;&#x65;&#95;&#104;&#97;&#x6e;&#x40;&#102;&#x6f;&#120;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;">&#x66;&#x61;&#106;&#x69;&#x65;&#95;&#104;&#97;&#x6e;&#x40;&#102;&#x6f;&#120;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;</a></p>
</li>
</ul>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul>
<li><p>使用 *，+，- 表示无序列表</p>
<p><strong>代码：</strong></p>
<pre><code>- 无序列表项 一
+ 无序列表项 二
* 无序列表项 三
</code></pre><p><strong>显示效果：</strong></p>
<ul>
<li>无序列表项 一</li>
</ul>
<ul>
<li>无序列表项 二</li>
</ul>
<ul>
<li>无序列表项 三</li>
</ul>
</li>
</ul>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><ul>
<li><p>有序列表则使用数字接着一个英文句点。</p>
<p><strong>代码：</strong></p>
<pre><code>1. 有序列表项 一
2. 有序列表项 二
3. 有序列表项 三
</code></pre><p><strong>显示效果：</strong></p>
<p>1.有序列表项 一</p>
<p>2.有序列表项 二</p>
<p>3.有序列表项 三</p>
</li>
</ul>
<h2 id="定义型列表"><a href="#定义型列表" class="headerlink" title="定义型列表"></a>定义型列表</h2><ul>
<li><p><strong>语法说明：</strong></p>
<p>定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab)</p>
<p><strong>代码：</strong></p>
<pre><code>Markdown
:    轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格）
代码块 2
:    这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）
代码块（左侧有八个不可见的空格）
</code></pre><p><strong> 显示效果：</strong></p>
<p>   <strong>Markdown</strong><br>   轻量级文本标记语言，可以转换成html，pdf等格式<br>   <strong>代码块 2</strong><br>   这是代码块的定义</p>
<pre><code>代码块（左侧有八个不可见的空格）
</code></pre></li>
</ul>
<h2 id="列表缩进"><a href="#列表缩进" class="headerlink" title="列表缩进"></a>列表缩进</h2><ul>
<li><p><strong>语法说明：</strong></p>
<p>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。<br>要让列表看起来更漂亮，你可以把内容用固定的缩进整理好（显示效果与代码一致）：</p>
<p>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</p>
<p>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！<br>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</p>
<p>但是如果你懒，那也行：</p>
<p><strong>代码：</strong></p>
<pre><code>* 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。
那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。
软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！

* 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。
寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。
但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！
悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。
</code></pre><p><strong>显示效果：</strong></p>
<ul>
<li><p>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</p>
</li>
<li><p>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！<br>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</p>
</li>
</ul>
</li>
</ul>
<h2 id="包含引用的列表"><a href="#包含引用的列表" class="headerlink" title="包含引用的列表"></a>包含引用的列表</h2><ul>
<li><p><strong>语法说明：</strong></p>
<p>如果要在列表项目内放进引用，那 &gt; 就需要缩进：</p>
<p><strong>代码：</strong></p>
<pre><code>* 阅读的方法:
&gt; 打开书本。
&gt; 打开电灯。
</code></pre><p><strong>显示效果：</strong></p>
<ul>
<li><p>阅读的方法</p>
<blockquote>
<p>打开书本。</p>
<p>打开电灯。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="包含代码区块的引用"><a href="#包含代码区块的引用" class="headerlink" title="包含代码区块的引用"></a>包含代码区块的引用</h2><ul>
<li><p><strong>语法说明：</strong></p>
<p>如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：</p>
<p>一列表项包含一个列表区块：</p>
<pre><code>&lt;代码写在这&gt;
</code></pre></li>
</ul>
<h2 id="一个特殊情况"><a href="#一个特殊情况" class="headerlink" title="一个特殊情况"></a>一个特殊情况</h2><ul>
<li><p>在特殊情况下，项目列表很可能会不小心产生，像是下面这样的写法：</p>
<pre><code>1986. What a great season.
</code></pre><p>会显示成：</p>
<ol>
<li>What a great season.</li>
</ol>
<p>换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠：</p>
<pre><code>1986\. What a great season.
</code></pre><p>会显示成：</p>
<p>1986. What a great season.</p>
</li>
</ul>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><p><strong>语法说明：</strong></p>
<p>引用需要在被引用的文本前加上&gt;符号。</p>
<p><strong>代码：</strong></p>
<pre><code>&gt; 这是一个有两段文字的引用,

&gt; 无意义的占行文字1.

&gt; 无意义的占行文字2.

&gt; 无意义的占行文字3.

&gt; 无意义的占行文字4.
</code></pre><p><strong>显示效果：</strong></p>
</li>
</ul>
<blockquote>
<p>这是一个有两段文字的引用,</p>
<p>无意义的占行文字1.</p>
<p>无意义的占行文字2.</p>
<p>无意义的占行文字3.</p>
<p>无意义的占行文字4.</p>
</blockquote>
<h2 id="引用的多层嵌套"><a href="#引用的多层嵌套" class="headerlink" title="引用的多层嵌套"></a>引用的多层嵌套</h2><ul>
<li><p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ：</p>
<p><strong>代码：</strong></p>
<pre><code>&gt;&gt;&gt; 请问 Markdwon 怎么用？ - 小白

&gt;&gt; 自己看教程！ - 愤青

&gt; 教程在哪？ - 小白
</code></pre></li>
<li><p><strong> 显示效果：</strong></p>
</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>请问 Markdwon 怎么用？ - 小白</p>
</blockquote>
<p>自己看教程！ - 愤青</p>
</blockquote>
<p>教程在哪？ - 小白</p>
</blockquote>
<h2 id="引用其它要素"><a href="#引用其它要素" class="headerlink" title="引用其它要素"></a>引用其它要素</h2><ul>
<li><p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</p>
<p><strong>代码：</strong></p>
<pre><code>&gt; 1. 这是第一行列表项。
&gt; 2. 这是第二行列表项。
&gt;

&gt; 给出一些例子代码：
&gt;

&gt; return shell_exec(&quot;echo $input | $markdown_script&quot;);
</code></pre></li>
<li><p><strong>显示效果：</strong></p>
</li>
</ul>
<blockquote>
<ol>
<li>这是第一行列表项。</li>
<li>这是第二行列表项。</li>
</ol>
<p>给出一些例子代码：</p>
<p>return shell_exec(“echo $input | $markdown_script”);</p>
</blockquote>
<h1 id="插入图像"><a href="#插入图像" class="headerlink" title="插入图像"></a>插入图像</h1><ul>
<li>图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。<br>语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和 链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。</li>
</ul>
<h2 id="行内式-1"><a href="#行内式-1" class="headerlink" title="行内式"></a>行内式</h2><ul>
<li><p><strong>语法说明：</strong> </p>
<pre><code>![图片Alt](图片地址 “图片Title”)
</code></pre><p><strong>代码：</strong></p>
<pre><code> 阿狸：

 ![阿狸](http://jethan.bid/images/ali.jpg &quot;阿狸&quot;)
</code></pre></li>
<li><p><strong>显示效果：</strong></p>
<p>阿狸：</p>
<p><img src="http://jethan.bid/images/ali.jpg" alt="阿狸" title="阿狸"></p>
</li>
</ul>
<h2 id="参考式-1"><a href="#参考式-1" class="headerlink" title="参考式"></a>参考式</h2><ul>
<li><p><strong>语法说明：</strong></p>
<p>在文档要插入图片的地方写![图片Alt][标记]</p>
<p>在文档的最后写上[标记]:图片地址 “Title”</p>
<p><strong>代码：</strong></p>
<pre><code> 1.阿狸：

 2.![阿狸][Ali]

 3.[Ali]:http://jet-han.oschina.io/images/ali.jpg &quot;阿狸&quot;
</code></pre></li>
<li><p><strong>显示效果：</strong></p>
<p>阿狸：</p>
<p><img src="http://jet-han.oschina.io/images/ali.jpg" alt="阿狸" title="阿狸"></p>
</li>
</ul>
<h1 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h1><ul>
<li><p><strong>语法说明：</strong></p>
<p>在需要添加注脚的文字后加上脚注名字<sup><a href="#fn_注脚名字" id="reffn_注脚名字">注脚名字</a></sup>,称为加注。 然后在文本的任意位置(一般在最后)添加脚注， 脚注前必须有对应的脚注名字。</p>
<p>注意：经测试注脚与注脚之间必须空一行，不然会失效。成功后会发现，即使你没有把注脚写在文末，经Markdown转换后，也会自动归类到文章的最后。</p>
<p><strong>代码：</strong></p>
<pre><code> 1.使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。
 2.
 3.[^1]:Markdown是一种纯文本标记语言
 4.
 5.[^2]:HyperText Markup Language 超文本标记语言 #此处有空格会不起作用
 6.
 7.[^Le]:开源笔记平台，支持Markdown和笔记直接发为博文
</code></pre><p><strong>显示效果：</strong></p>
<p>使用 Markdown<sup><a href="#fn_1" id="reffn_1">1</a></sup>可以效率的书写文档, 直接转换成 HTML<sup><a href="#fn_2" id="reffn_2">2</a></sup>, 你可以使用 Leanote<sup><a href="#fn_Le" id="reffn_Le">Le</a></sup> 编辑器进行书写。</p>
</li>
</ul>
<h1 id="LaTeX-公式"><a href="#LaTeX-公式" class="headerlink" title="LaTeX 公式"></a>LaTeX 公式</h1><h2 id="渲染MathJax数学公式"><a href="#渲染MathJax数学公式" class="headerlink" title="渲染MathJax数学公式"></a>渲染MathJax数学公式</h2><ul>
<li><p>在用markdown写技术文档时，免不了会碰到数学公式。常用的Markdown编辑器都会集成Mathjax，用来渲染文档中的类Latex格式书写的数学公式。基于Hexo搭建的个人博客，默认情况下渲染数学公式却会出现各种各样的问题。</p>
<p><strong>原因</strong></p>
<p>Hexo默认使用”hexo-renderer-marked”引擎渲染网页，该引擎会把一些特殊的markdown符号转换为相应的html标签，比如在markdown语法中，下划线’_’代表斜体，会被渲染引擎处理为&lt;\em&gt;标签。</p>
<p>因为类Latex格式书写的数学公式下划线 ‘_’ 表示下标，有特殊的含义，如果被强制转换为&lt;\em&gt;标签，那么  MathJax引擎在渲染数学公式的时候就会出错。例如，$x_i$在开始被渲染的时候，处理为$x&lt;\em&gt;i&lt;\/em&gt;$，这样MathJax引擎就认为该公式有语法错误，因为不会渲染。</p>
<p>类似的语义冲突的符号还包括’*’, ‘{‘, ‘}’, ‘\’等。</p>
<p><strong>解决方法</strong></p>
<p>更换Hexo的markdown渲染引擎，hexo-renderer-kramed引擎是在默认的渲染引擎hexo-renderer-marked的基础上修改了一些bug，两者比较接近，也比较轻量级。</p>
<pre><code>npm uninstall hexo-renderer-marked --save
npm install hexo-renderer-kramed --save
</code></pre><p>执行上面的命令即可，先卸载原来的渲染引擎，再安装新的。</p>
<p>然后，跟换引擎后行间公式可以正确渲染了，但是这样还没有完全解决问题，行内公式的渲染还是有问题，因为hexo-renderer-kramed引擎也有语义冲突的问题。接下来到博客根目录下，找到node_modules\kramed\lib\rules\inline.js，把第11行的escape变量的值做相应的修改：</p>
<pre><code>//  escape: /^\\([\\`*{}\[\]()#$+\-.!_&gt;])/,
escape: /^\\([`*\[\]()#$+\-.!_&gt;])/
</code></pre><p>这一步是在原基础上取消了对\,{,}的转义(escape)。<br>同时把第20行的em变量也要做相应的修改。</p>
<pre><code>//  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
  em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/
</code></pre><p>重新启动hexo（先clean再generate）,问题完美解决。哦，如果不幸还没解决的话，看看是不是还需要在使用的主题中配置mathjax开关。</p>
<p>在主题中开启mathjax开关</p>
<p>如何使用了主题了，别忘了在主题（Theme）中开启mathjax开关，下面以next主题为例，介绍下如何打开mathjax开关。</p>
<p>进入到主题目录，找到_config.yml配置问题，把mathjax默认的false修改为true，具体如下：</p>
<pre><code># MathJax Support
mathjax:
  enable: true
  per_page: true
</code></pre><p>别着急，这样还不够，还需要在文章的Front-matter里打开mathjax开关，如下：</p>
<pre><code>---
title: index.html
date: 2016-12-28 21:01:30
tags:
mathjax: true
--
</code></pre><p>不要嫌麻烦，之所以要在文章头里设置开关，是因为考虑只有在用到公式的页面才加载 Mathjax，这样不需要渲染数学公式的页面的访问速度就不会受到影响了。</p>
</li>
</ul>
<ul>
<li><p>$ 表示行内公式：</p>
<p><strong>代码：</strong></p>
<pre><code>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。
</code></pre><p><strong>显示效果：</strong></p>
<p>质能守恒方程可以用一个很简洁的方程式  $E=mc^2$  来表达。</p>
<ul>
<li>$$ 表示整行公式：</li>
</ul>
<p><strong>代码：</strong></p>
<pre><code>$$\sum_{i=1}^n a_i=0$$
$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$
$$\sum^{j-1}_{k=0}{\widehat{\gamma}_{kj} z_k}$$
</code></pre><p><strong>显示效果：</strong></p>
<script type="math/tex; mode=display">\sum_{i=1}^n a_i=0</script><script type="math/tex; mode=display">f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2</script><script type="math/tex; mode=display">\sum^{j-1}_{k=0}{\widehat{\gamma}_{kj} z_k}</script><p>访问 <a href="https://www.mathjax.org/" target="_blank" rel="external">MathJax</a> 参考更多使用方法。</p>
</li>
</ul>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><ul>
<li><p><strong>代码：</strong></p>
<pre><code>  &lt;div id=&quot;flowchart-0&quot; class=&quot;flow-chart&quot;&gt;&lt;/div&gt;
</code></pre><p><strong>显示效果：</strong></p>
</li>
</ul>
<div id="flowchart-1" class="flow-chart"></div>

<h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><ul>
<li><p>Generate flowchart diagrams for Hexo.</p>
<p>   npm install —save hexo-filter-flowchart</p>
<p><strong>config</strong></p>
<p>In your site’s _config.yml:</p>
<pre><code>flowchart:
  raphael: http://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js
  flowchart: https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js
</code></pre></li>
</ul>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><ul>
<li><p><strong>语法说明：</strong></p>
<p>不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。</p>
<p>列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。</p>
<p>第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。</p>
<p><strong>代码：</strong></p>
<p>为列指定方向写表格：</p>
<pre><code>| Item    | Value   | Qty  |
| :-     | -:     | :-:  |
| Computer | 1600 USD | 5   |
| Phone   |   12 USD|  12  |
| Pipe    |    1 USD| 234  |
</code></pre><p>原生方式写表格：</p>
<pre><code>|Item|Value|Qty|
|-|-|-|
|Computer|1600 USD|5|
|Phone|12 USD|12|
|Pipe|1 USD|234|
</code></pre><p><strong>显示效果：</strong></p>
<p>为列指定方向写表格：</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Item</th>
<th style="text-align:right">Value</th>
<th style="text-align:center">Qty</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Computer</td>
<td style="text-align:right">1600 USD</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:left">Phone</td>
<td style="text-align:right">12 USD</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:left">Pipe</td>
<td style="text-align:right">1 USD</td>
<td style="text-align:center">234</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>原生方式写表格：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Item</th>
<th>Value</th>
<th>Qty</th>
</tr>
</thead>
<tbody>
<tr>
<td>Computer</td>
<td>1600 USD</td>
<td>5</td>
</tr>
<tr>
<td>Phone</td>
<td>12 USD</td>
<td>12</td>
</tr>
<tr>
<td>Pipe</td>
<td>1 USD</td>
<td>234</td>
</tr>
</tbody>
</table>
</div>
<h1 id="使用Echarts动态图表"><a href="#使用Echarts动态图表" class="headerlink" title="使用Echarts动态图表"></a>使用Echarts动态图表</h1><ul>
<li><p>在博客页面中引用js文件</p>
<p>在所用主题目录下layout_partial中的head.swig里加入：</p>
<pre><code>&lt;script src=&quot;http://echarts.baidu.com/dist/echarts.common.min.js&quot;&gt;&lt;/script&gt;
</code></pre><p>安装hexo-tag-echarts插件</p>
<pre><code>npm install hexo-tag-echarts --save
</code></pre><p><strong>使用范例</strong></p>
<p>对于<a href="http://echarts.baidu.com/demo.html#bar-negative" target="_blank" rel="external">echarts实例</a>，将其提供的option部分复制，形成下述代码即可。</p>
<pre><code> {% echarts 400 '81%' %}
      {
          tooltip : {
              trigger: 'axis',
              axisPointer : {            // 坐标轴指示器，坐标轴触发有效
                  type : 'shadow'        // 默认为直线，可选为：'line' | 'shadow'
              }
          },
          legend: {
              data:['利润', '支出', '收入']
          },
          grid: {
              left: '3%',
              right: '4%',
              bottom: '3%',
              containLabel: true
          },
          xAxis : [
              {
                  type : 'value'
              }
          ],
          yAxis : [
              {
                  type : 'category',
                  axisTick : {show: false},
                  data : ['周一','周二','周三','周四','周五','周六','周日']
              }
          ],
          series : [
              {
                  name:'利润',
                  type:'bar',
                  itemStyle : {
                      normal: {
                          label: {show: true, position: 'inside'}
                      }
                  },
                  data:[200, 170, 240, 244, 200, 220, 210]
              },
              {
                  name:'收入',
                  type:'bar',
                  stack: '总量',
                  itemStyle: {
                      normal: {
                          label : {show: true}
                      }
                  },
                  data:[320, 302, 341, 374, 390, 450, 420]
              },
              {
                  name:'支出',
                  type:'bar',
                  stack: '总量',
                  itemStyle: {normal: {
                      label : {show: true, position: 'left'}
                  }},
                  data:[-120, -132, -101, -134, -190, -230, -210]
              }
          ]
      };
      {% endecharts %}
</code></pre><p><strong>效果显示</strong></p>
</li>
</ul>
<div id="echarts2738" style="width: 81%;height: 400px;margin: 0 auto"></div>
<script type="text/javascript">
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('echarts2738'));

        // 指定图表的配置项和数据
        var option = {
    tooltip : {
        trigger: 'axis',
        axisPointer : {            // 坐标轴指示器，坐标轴触发有效
            type : 'shadow'        // 默认为直线，可选为：'line' | 'shadow'
        }
    },
    legend: {
        data:['利润', '支出', '收入']
    },
    grid: {
        left: '3%',
        right: '4%',
        bottom: '3%',
        containLabel: true
    },
    xAxis : [
        {
            type : 'value'
        }
    ],
    yAxis : [
        {
            type : 'category',
            axisTick : {show: false},
            data : ['周一','周二','周三','周四','周五','周六','周日']
        }
    ],
    series : [
        {
            name:'利润',
            type:'bar',
            itemStyle : {
                normal: {
                    label: {show: true, position: 'inside'}
                }
            },
            data:[200, 170, 240, 244, 200, 220, 210]
        },
        {
            name:'收入',
            type:'bar',
            stack: '总量',
            itemStyle: {
                normal: {
                    label : {show: true}
                }
            },
            data:[320, 302, 341, 374, 390, 450, 420]
        },
        {
            name:'支出',
            type:'bar',
            stack: '总量',
            itemStyle: {normal: {
                label : {show: true, position: 'left'}
            }},
            data:[-120, -132, -101, -134, -190, -230, -210]
        }
    ]
};

        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
</script>
<h1 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h1><ul>
<li><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<p><strong>代码：</strong></p>
<pre><code>* * *

***

*****

- - -

---------------------------------------
</code></pre></li>
<li><p>显示效果都一样：</p>
<hr>
<hr>
<hr>
<hr>
<hr>
</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><ul>
<li><p>对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用”`”符号（一般在ESC键下方）包裹代码。</p>
<p><strong>语法说明：</strong></p>
<p>插入行内代码，即插入一个单词或者一句代码的情况，使用`code`这样的形式插入。<br>插入多行代码，可以使用缩进或者“` code “`,具体看示例。<br>注意： 缩进式插入前方必须有空行</p>
</li>
</ul>
<h2 id="行内式-2"><a href="#行内式-2" class="headerlink" title="行内式"></a>行内式</h2><ul>
<li><p><strong>代码：</strong></p>
<pre><code>C语言里的函数 `scanf()` 怎么使用？
</code></pre><p>显示效果：</p>
<p>C语言里的函数 <code>scanf()</code> 怎么使用？</p>
</li>
</ul>
<h2 id="缩进式多行代码"><a href="#缩进式多行代码" class="headerlink" title="缩进式多行代码"></a>缩进式多行代码</h2><ul>
<li><p>缩进 4 个空格或是 1 个制表符</p>
<p>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p>
<p><strong>代码：</strong></p>
<pre><code>#include &lt;stdio.h&gt;
int main(void)
{
    printf(&quot;Hello world\n&quot;);
}
</code></pre><p><strong>显示效果：</strong></p>
<pre><code> #include &lt;stdio.h&gt;
 int main(void)
 {
  printf(&quot;Hello world\n&quot;);
 }
</code></pre></li>
</ul>
<h2 id="用六个-包裹多行代码"><a href="#用六个-包裹多行代码" class="headerlink" title="用六个`包裹多行代码"></a>用六个`包裹多行代码</h2><ul>
<li><p><strong>代码：</strong></p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    printf(&quot;Hello world\n&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p><strong>显示效果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">printf(&quot;Hello world\n&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="HTML-原始码"><a href="#HTML-原始码" class="headerlink" title="HTML 原始码"></a>HTML 原始码</h2><ul>
<li><p>在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理，例如：</p>
<p><strong>代码：</strong></p>
<pre><code>&lt;table&gt;
    &lt;tr&gt;
        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;
        &lt;th&gt;星期一&lt;/th&gt;
        &lt;th&gt;星期二&lt;/th&gt;
        &lt;th&gt;星期三&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;李强&lt;/td&gt;
        &lt;td&gt;张明&lt;/td&gt;
        &lt;td&gt;王平&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</code></pre><p>显示效果：</p>
<table>
          <tr>
              <th rowspan="2">值班人员</th>
              <th>星期一</th>
              <th>星期二</th>
              <th>星期三</th>
          </tr>
          <tr>
              <td>李强</td>
              <td>张明</td>
              <td>王平</td>
          </tr>
 </table>

</li>
</ul>
<h1 id="自定义字体"><a href="#自定义字体" class="headerlink" title="自定义字体"></a>自定义字体</h1><ul>
<li><p>在 <a href="http://theme-next.iissnan.com/theme-settings.html#fonts-customization" target="_blank" rel="external">主题配置 - NexT 使用文档</a> 中提及了如何设置字体样式，这里就不再赘述了。如果想自定义字体大小以及颜色，可以直接在 Markdown 文档中使用 html 语法</p>
<pre><code>&lt;font size=4 &gt; 这里输入文字，自定义大小 &lt;/font&gt;
&lt;font color=&quot;#FF0000&quot;&gt; 这里输入文字，自定义颜色的字体 &lt;/font&gt;
</code></pre><p><strong>效果：</strong></p>
<p><font size="5"> 这里输入文字，自定义大小 </font><br><br><font color="#FF0000"> 这里输入文字，自定义颜色的字体 </font><script src="http://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">        st=>start: Start|past:>http://www.google.com[blank]
        e=>end: End:>http://www.google.com
        op1=>operation: My Operation|past
        op2=>operation: Stuff|current
        sub1=>subroutine: My Subroutine|invalid
        cond=>condition: Yes
        or No?|approved:>http://www.google.com
        c2=>condition: Good idea|rejected
        io=>inputoutput: catch something...|request

        st->op1(right)->cond
        cond(yes, right)->c2
        cond(no)->sub1(left)->op1
        c2(yes)->io->e
        c2(no)->op2->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">st=>start: Start|past:>http://www.google.com[blank]
e=>end: End:>http://www.google.com
op1=>operation: My Operation|past
op2=>operation: Stuff|current
sub1=>subroutine: My Subroutine|invalid
cond=>condition: Yes
or No?|approved:>http://www.google.com
c2=>condition: Good idea|rejected
io=>inputoutput: catch something...|request

st->op1(right)->cond
cond(yes, right)->c2
cond(no)->sub1(left)->op1
c2(yes)->io->e
c2(no)->op2->e</textarea><textarea id="flowchart-1-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/images/icons/markdown.jpg&quot; alt=&quot;Markdown&quot; title=&quot;Markdown&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Markdown" scheme="http://jet-han.oschina.io/categories/Markdown/"/>
    
    
      <category term="Markdown" scheme="http://jet-han.oschina.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-NexT主题搭建个人博客</title>
    <link href="http://jet-han.oschina.io/2017/05/27/Hexo-NexT%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://jet-han.oschina.io/2017/05/27/Hexo-NexT主题搭建个人博客/</id>
    <published>2017-05-27T07:27:00.000Z</published>
    <updated>2017-06-24T08:51:50.157Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/images/icons/hexo.jpg" alt="Hexo-NexT" title="Hexo-NexT"></p>
<a id="more"></a>
<p>linux下搭建hexo之next主题个人博客，仅供参考！有问题请留言，谢谢支持！</p>
<h1 id="所需环境"><a href="#所需环境" class="headerlink" title="所需环境"></a>所需环境</h1><ul>
<li>下载安装nodejs和git(for linux)，声明一下我的搭建环境centos6.8</li>
</ul>
<h2 id="nodejs安装"><a href="#nodejs安装" class="headerlink" title="nodejs安装"></a>nodejs安装</h2><ul>
<li><p>准备命令：</p>
<pre><code>yum -y install gcc make gcc-c++ openssl-devel wget
</code></pre></li>
<li><p>载源码及解压：</p>
<pre><code>wget http://nodejs.org/dist/v0.10.26/node-v0.10.26.tar.gz
tar -zvxf node-v0.10.26.tar.gz
</code></pre></li>
<li><p>编译及安装：</p>
<pre><code>make &amp;&amp; make install
</code></pre></li>
<li><p>验证是否安装配置成功：</p>
<pre><code>node -v
</code></pre></li>
<li><p>安装Express开发框架</p>
<pre><code>npm install -g express
npm install -g express-generator
express -t ejs newsproject
npm install
</code></pre></li>
<li><p>新建成功在nodesj目录下会生成newproject目录，其目录下大致有以下文件</p>
<pre><code>bin          相关运行脚本
public       静态资源
routes       路由表
views        试图模板  
app.js       视图文件夹  
packge.json  项目依赖说明
</code></pre></li>
<li><p>启动项目</p>
<pre><code>npm start
</code></pre></li>
<li><p>在浏览器访问<a href="http://127.0.0.1:3000/" target="_blank" rel="external">http://127.0.0.1:3000/</a> 测试出现下面图视表示nodejs安装成功，并可以正常部署项目</p>
<p><img src="http://jethan.bid/images/Hexo-NexT%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/express.png" alt="express" title="express"></p>
<pre><code>node -v
npm -v
</code></pre></li>
</ul>
<h2 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h2><ul>
<li><p>在线源安装</p>
<pre><code>yum install git
</code></pre></li>
</ul>
<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><h2 id="命令解释"><a href="#命令解释" class="headerlink" title="命令解释"></a>命令解释</h2><ul>
<li><p><strong>常用命令:</strong></p>
<pre><code>hexo help #查看帮助
hexo init #初始化一个目录
hexo new &quot;postName&quot; #新建文章
hexo new page &quot;pageName&quot; #新建页面
hexo generate #生成网页, 可以在 public 目录查看整个网站的文件
hexo server #本地预览, &#39;Ctrl+C&#39;关闭
hexo deploy #部署.deploy目录
hexo clean #清除缓存, 
</code></pre><p>强烈建议每次执行命令前先清理缓存, 每次部署前先删除 .deploy 文件夹</p>
<p><strong>复合命令:</strong></p>
<pre><code>hexo deploy -g #生成加部署
hexo server -g #生成加预览
</code></pre><p><strong>简写：</strong></p>
<pre><code>hexo n == hexo new
hexo g == hexo generate
hexo s == hexo server
hexo d == hexo deploy
</code></pre><p><strong>安装插件, plugin-name为插件名</strong></p>
<pre><code>npm install plugin-name --save #安装
npm update #升级
npm uninstall plugin-name #卸载
</code></pre><p><strong>安装主题, repository为主题的 git 仓库, 为要存放在本地的目录名</strong></p>
<pre><code>git clone repository themes/theme-name
</code></pre><p><strong>修改网站配置文件</strong></p>
<pre><code>theme: theme-name
</code></pre><p><strong>在线源安装</strong></p>
<pre><code>npm install -g hexo-cli  #g代表全局,npm默认为当前项目安装
hexo init #hexo初始化
npm install #安装依赖包
hexo g #生成静态资源生成public文件夹(浏览器访问资源)
hexo s #启动服务
</code></pre><p><strong>在浏览器访问：<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> 便可查看hexo默认的主题</strong></p>
<p><img src="http://jethan.bid/images/Hexo-NexT%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo.png" alt="hexo" title="hexo"></p>
<p><strong>clone NexT主题,在blog根目录执行命令</strong></p>
<pre><code>git clone https://github.com/iissnan/hexo-theme-next themes/next
</code></pre><p>clone完成后打开blog下的themes文件夹就可以看到有两个主题，一个是默认的，一个是刚刚clone的NexT主题<br>站点配置文件_config.yml<br>主题配置文件themes/next/_config.yml<br>在站点配置文件_config.yml中进行搜索key为’theme’，如果没有theme就添加key为  theme，其值为next</p>
<pre><code>#Extensions
##Plugins: https://hexo.io/plugins/
##Themes: https://hexo.io/themes/
#theme: landscape
theme: next
</code></pre><p>需要注意的是theme: next ，冒号后面有一个空格</p>
<pre><code>hexo clean #清除静态资源
hexo g
hexo s
</code></pre><p>在浏览器中访问<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> 便可看到效果</p>
<p><img src="http://jethan.bid/images/Hexo-NexT%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo-next.png" alt="hexo" title="hexo"></p>
<p>打开主题配置文件_config.yml找到Schemes，如下所示有三种方案可选，只需将#去掉就可以了，可以都尝试一下，选择喜欢的风格，修改之后不用重启服务直接刷新浏览器就能看到效果</p>
<pre><code>#切换样式
#Schemes
#scheme: Muse
#scheme: Mist
scheme: Pisces
</code></pre><p>到此本地资源基本上完成了，下面贴出站点配置_config.yml和主题配置themes/next/_config.yml里面注释了信息仅供参考</p>
<p>全局配置 _config.yml，配置文件的冒号”:”后面有空格</p>
<pre><code># Site #站点信息
title: Hank
subtitle: Hank&#39;s Blog
description: 关注WEB前端，前端开发
author: hank
author_title: &#39;Web Developer &amp; Designer&#39;
avatar: css/images/avatar.png
location: &#39;Beijing, China&#39;
follow: https://github.com/huangjihua/
language: zh-CN
since: 2015
timezone: Asia/Beijing #时区

# URL #链接格式
url: http://blog.huangjihua.com #网址
root: / #根目录
permalink: post/:title.html #文章的链接格式
permalink_defaults:

# Directory #目录
source_dir: source #源文件
public_dir: public #生成的网页文件
tag_dir: tags #标签
archive_dir: archives #归档
category_dir: categories #分类
code_dir: downloads/code
i18n_dir: :lang #国际化
skip_render:

# Writing #写作
new_post_name: :title.md #新文章标题
default_layout: post #默认模板(post page photo draft)
titlecase: false #标题转换成大写
external_link: true #新标签页里打开连接
filename_case: 0
render_drafts: false
post_asset_folder: false
relative_link: false
future: true
highlight: #语法高亮
  enable: true
  line_number: false #显示行号
  auto_detect: true
  tab_replace:

# Category &amp; Tag #分类和标签
default_category: uncategorized #默认分类
category_map:
tag_map:

# Date / Time format #日期时间格式
## http://momentjs.com/docs/#/displaying/format/
date_format: YYYY-MM-DD
time_format: HH:mm:ss

# Pagination #分页
per_page: 20 #每页文章数, 设置成 0 禁用分页
pagination_dir: page

# Extensions #插件和主题
## 插件: http://hexo.io/plugins/
## 主题: http://hexo.io/themes/
theme: next

# Deployment #部署, huangjihua是我的用户名, 同时发布在 GitHub 和 GitCafe 上面
deploy:
  type: git
  repository:
    github: https://github.com/huangjihua/huangjihua.github.io.git,master
    gitcafe: https://gitcafe.com/huangjihua/huangjihua.git,master

# Disqus #Disqus评论系统
disqus_shortname:

plugins: #插件，例如生成 RSS 和站点地图的
- hexo-generator-feed
- hexo-generator-sitemap

# Assets
css: css
js: js
images: images
# Theme version
version: 5.0.1
# Donate 文章末尾显示打赏按钮
reward_comment: 如果文章对您有用请随意打赏，谢谢支持！
wechatpay: /images/w.png
alipay: /images/z.jpg
</code></pre></li>
</ul>
<h2 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h2><ul>
<li><p>菜单栏为中文简体字，主题配置文件</p>
<pre><code>language: zh-Hans
</code></pre><p>这样就引用了themes\next\languages\zh-Hans.yml文件，打开这个文件就可以看每个key对应的都是中文字体</p>
</li>
</ul>
<h2 id="标签和分类"><a href="#标签和分类" class="headerlink" title="标签和分类"></a>标签和分类</h2><ul>
<li><p>在主题配置文件中找到menu，如果想隐藏菜单栏中的某个选项只要在前面加上 # 即可</p>
<pre><code>menu:
  home: /
  categories: /categories #分类
  archives: /archives     #归档
  tags: /tags             #标签
  message: /message       #留言
  about: /about           #关于
  # commonweal: /404.html #公益
</code></pre></li>
<li><p>我们将categories 和tags 设为显示,再找到menu_icons, 这里是每一个菜单选项前面对应的小图标icon</p>
<pre><code>menu_icons:
  enable: true
  #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome
  home: home
  categories: th
  tags: tags
  archives: archive
  commonweal: heartbeat
  message: external-link
  about: user
</code></pre></li>
<li><p>我们将categories 和tags 设为显示,生成categories 和 tags的页面</p>
<pre><code>hexo n page &quot;categories&quot;
hexo n page &quot;tags&quot;
</code></pre><p>会生成source\categories 和 source\tags 两个文件夹，里面都有index.md文件.修改内容为</p>
<pre><code>---
title: categories
type: categories
---

---
title: tags
type: tags
---
</code></pre></li>
<li><p>再使用命令生成博文文件</p>
<pre><code>hexo n &quot;name&quot;    #name 文章名称
</code></pre></li>
<li><p>生成文章时，在对应的name.md中可以这样添加标签和分类</p>
<pre><code>---
title: Hexo-NexT主题搭建个人博客
date: 2017-05-24 15:39:31
update: 2017-05-24 06:19:11
categories: hexo             #分类
tags: [nodejs, hexo, next]   #[标签1, 标签2..., 标签n]
---
</code></pre></li>
</ul>
<h2 id="网易云跟帖评论功能"><a href="#网易云跟帖评论功能" class="headerlink" title="网易云跟帖评论功能"></a>网易云跟帖评论功能</h2><ul>
<li><p>主题配置文件</p>
<pre><code>menu:
  home: /
  categories: /categories
  archives: /archives
  tags: /tags
  message: /message       #新增 message
  about: /about
  #commonweal: /404.html
</code></pre></li>
<li><p>配置图标</p>
<pre><code> menu_icons:
   enable: true
   home: home
   categories: th
   tags: tags
   archives: archive
   commonweal: heartbeat
   message: external-link  #新增 message
   about: user
</code></pre><p>配置对应的中文名称，在themes/next/languages/zh-Hans.yml文件中修改如下</p>
<pre><code> menu:
  home: 首页
  archives: 归档
  categories: 分类
  tags: 标签
  about: 关于
  search: 搜索
  message: 留言            #新增 留言
  commonweal: 公益404
  udpate: 更新
</code></pre></li>
<li><p>然后执行如下命令</p>
<pre><code>hexo n page &quot;message&quot;
</code></pre></li>
<li><p>重新清除，生成和启动便可看到效果，只不过留言功能什么也没有</p>
<pre><code>hexo clean
hexo g
hexo s
</code></pre></li>
<li><p>进入官网<a href="https://manage.gentie.163.com" target="_blank" rel="external">https://manage.gentie.163.com</a> 进行注册、登录（可以用QQ）。登录完成在首页进入后台管理，填写基本信息（站点信息），获取代码找到 <code>productKey</code>的值，写入主题配置文件<code>gentie_productKey</code>处<br>在主题配置文件中<br>修改如下</p>
<pre><code> # Gentie productKey
 gentie_productKey: your key
</code></pre></li>
<li><p>留言功能已完成<br>去掉分类和其他的选项的留言功能，只需修改index.md<br>在source/categories/index.md 中修改如下</p>
<pre><code>---
title: categories
type: categories
comments: false       #去掉评论功能
date: 2017-05-24 21:07:35
---
</code></pre></li>
</ul>
<h2 id="修改头像"><a href="#修改头像" class="headerlink" title="修改头像"></a>修改头像</h2><ul>
<li>设置菜单栏头像<br>把头像0.jpg图片放在themes/next/source/images中<br>在站点的_config.yml，修改字段 avatar</li>
</ul>
<ul>
<li><p>设置头像</p>
<pre><code>avatar: /images/0.jpg
</code></pre><p>可以指定网址图片url</p>
</li>
</ul>
<h2 id="侧边栏社交链接"><a href="#侧边栏社交链接" class="headerlink" title="侧边栏社交链接"></a>侧边栏社交链接</h2><ul>
<li><p>侧栏社交链接的修改包含两个部分，第一是链接，第二是链接图标。 两者配置均在 主题配置文件 中。<br>social 字段下，一行一个链接。其键值格式是 显示文本: 链接地址</p>
<pre><code>##Social links
social:
  GitHub: https://github.com/your-user-name
  Twitter: https://twitter.com/your-user-name
  微博: http://weibo.com/your-user-name
  豆瓣: http://douban.com/people/your-user-name
  知乎: http://www.zhihu.com/people/your-user-name

#Social Icons
</code></pre></li>
<li><p>设定链接的图标，对应的字段是 social_icons。其键值格式是 匹配键: Font Awesome 图标名称， 匹配键 与上一步所配置的链接的 显示文本 相同（大小写严格匹配），图标名称 是 Font Awesome 图标的名字（不必带 fa- 前缀）。 enable 选项用于控制是否显示图标，你可以设置成 false 来去掉图标。</p>
<pre><code>social_icons:
  enable: true
  #Icon Mappings
  GitHub: github
  Twitter: twitter
  微博: weibo
</code></pre></li>
</ul>
<h2 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h2><ul>
<li><p>编辑 主题配置文件 添加：</p>
<pre><code># Blogrolls
links_title: 友情链接
links_layout: inline
links_icon: link  # 设置图标
links:
  百度: http://www.baidu.com
</code></pre></li>
</ul>
<h2 id="文章配置"><a href="#文章配置" class="headerlink" title="文章配置"></a>文章配置</h2><h3 id="开启阅读全文"><a href="#开启阅读全文" class="headerlink" title="开启阅读全文"></a>开启阅读全文</h3><ul>
<li><p>修改主题配置文件</p>
<pre><code>auto_excerpt:
  enable: true  # 开启文章阅全文
  length: 2000   # 显示长度
</code></pre></li>
</ul>
<h2 id="新增阅读量"><a href="#新增阅读量" class="headerlink" title="新增阅读量"></a>新增阅读量</h2><ul>
<li><p>为每一篇文章统计阅读量<br>使用leancloud进行文章变更统计，进入官网<a href="https://leancloud.cn/" target="_blank" rel="external">https://leancloud.cn/</a> 注册<br>打开LeanCloud官网，进入注册页面注册。完成邮箱激活后，点击头像，进入控制台页面<br>创建新应用<br>点击应用创建新应用，应用名称随便起<br>创建Class文件<br>进入到应用后点击存储，在左侧点击设置，选择”创建Class”，名称必须为Counter<br>修改主题配置文件</p>
<pre><code>##文章阅读量
  leancloud_visitors:
enable: true
app_id: **你的app_id**
app_key: **你的app_key**
</code></pre><p>其中，app_id和app_key在你所创建的应用的设置-&gt;应用Key中<br>修改 themes/next/layout_macro/post.swig 文件<br>配置themes/next/layout/_layout.swig文件<br>在最后div标签中查找是否引用了_scripts/third-party/lean-analytics.swig文件，如果没有增加以下代码<br>修改语言配置文件 themes/next/languages/zh-Hans.yml post字段</p>
<pre><code>post:
  sticky: 置顶
  posted: 发表于
  updated: 最近
  update: 更新于
  in: 分类于
  visitors: 阅读量
  read_more: 阅读全文
  untitled: 未命名
  toc_empty: 此文章未包含目录
</code></pre></li>
<li><p>其他语言与之类似，将visitors设置成你希望翻译的字段。最后，重新清除并生成你的网站即可。<br>Web安全性<br>为了保证应用的统计计数功能仅应用于自己的博客系统，你可以在应用-&gt;设置-&gt;安全中心的Web安全域名中加入自己的博客域名，以保证数据的调用安全。直接加上首页地址即可,保存三分之后生效，这时在本地方访问便不会统计。</p>
</li>
</ul>
<h2 id="文章最近更新时间"><a href="#文章最近更新时间" class="headerlink" title="文章最近更新时间"></a>文章最近更新时间</h2><ul>
<li><p>确保themes/next/layout_scripts/third-party/lean-analytics.swig文件已有update<br>添加文章更新时间<br>scaffolds/post.md 文件</p>
<pre><code>---
title: {{ title }}
date: {{ date }}
categories:
tags:
update: {{ date }}  # 新增更新时间
---
</code></pre><p>themes/next/layout_macro/post.swig 文件<br>在每次新建文章时，默认更新时间就是发表时间，更新文章时需要手动修改udpate的值。例如source_posts\hexo之next主题.md</p>
<pre><code>---
title: Hexo之NexT主题搭建博客详细过程
date: 2017-05-24 15:39:31
update: 2017-05-24 15:39:31     #每次更新需手动修改成这样的格式时间
categories: hexo
tags: [nodejs, hexo]
---
</code></pre><p>修改themes\next\languages\zh-Hans.yml</p>
<pre><code>post:
  sticky: 置顶
  posted: 发表于
  updated: 最近
  update: 更新于     # 新增
  in: 分类于
  visitors: 阅读量
  read_more: 阅读全文
  untitled: 未命名
  toc_empty: 此文章未包含目录
</code></pre></li>
</ul>
<h2 id="为文章增加分享"><a href="#为文章增加分享" class="headerlink" title="为文章增加分享"></a>为文章增加分享</h2><ul>
<li><p>使用百度分享<br>只修改主题配置文件即可</p>
<pre><code> baidushare:
   type: button
</code></pre></li>
</ul>
<h2 id="为文章增加打赏"><a href="#为文章增加打赏" class="headerlink" title="为文章增加打赏"></a>为文章增加打赏</h2><ul>
<li><p>修改主题配置文件, 收款二维码放在themes/next/source/images 目录下</p>
<pre><code>#Donate 文章末尾显示打赏按钮
reward_comment: 如果文章对您有用请随意打赏，谢谢支持！
wechatpay: /images/w.png
alipay: /images/z.jpg
</code></pre></li>
</ul>
<h2 id="设置代码高亮主题"><a href="#设置代码高亮主题" class="headerlink" title="设置代码高亮主题"></a>设置代码高亮主题</h2><ul>
<li><p>NexT 使用 Tomorrow Theme 作为代码高亮，共有5款主题供你选择。 NexT 默认使用的是 白色的 normal 主题，可选的值有 normal，night， night blue， night bright， night eighties：<br>在主题配置文件中修改</p>
<pre><code># Code Highlight theme
# Available value:
#    normal | night | night eighties | night blue | night bright
# https://github.com/chriskempson/tomorrow-theme
highlight_theme: night eighties       # 修改即可
</code></pre></li>
</ul>
<h2 id="文章添加音乐链接"><a href="#文章添加音乐链接" class="headerlink" title="文章添加音乐链接"></a>文章添加音乐链接</h2><ul>
<li><p>Hexo支持解析markdown语法，因此每篇博文都是以.md结尾的文件。而markdown又支持如表格、脚注、内嵌HTML等等，所以在.md文件中直接添加html代码！<br>网音乐云音乐，虾米音乐都可以生成内嵌音乐的html代码，复制粘贴到.md文件中即可</p>
<pre><code>&lt;div&gt;
    &lt;center&gt;
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86
            src=&quot;https://music.163.com/outchain/player?type=2&amp;id=33856282&amp;auto=0&amp;height=66&quot;&gt;
        &lt;/iframe&gt;
    &lt;/center&gt;
&lt;/div&gt;
</code></pre></li>
</ul>
<h2 id="本地站内搜索"><a href="#本地站内搜索" class="headerlink" title="本地站内搜索"></a>本地站内搜索</h2><ul>
<li><p>以前使用的Swiftype现在不能免费使用了，我这里就是用本地配置进行站内搜索<br>安装 hexo-generator-search，在站点的根目录下执行以下命令:</p>
<pre><code>npm install hexo-generator-search --save
</code></pre></li>
<li><p>编辑 站点配置文件，新增以下内容到任意位置：</p>
<pre><code>search:
  path: search.xml
  field: post
</code></pre></li>
</ul>
<h2 id="不蒜子统计站点访次数和访问量"><a href="#不蒜子统计站点访次数和访问量" class="headerlink" title="不蒜子统计站点访次数和访问量"></a>不蒜子统计站点访次数和访问量</h2><ul>
<li><p>修改themes/next/layout/_partials目录下的footer.swig</p>
<pre><code>&lt;div class=&quot;total_count&quot;&gt;
本站共 &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;&lt;span id=&quot;site_pv&quot;&gt;次访问&lt;/span&gt;
您是第 &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;span id=&quot;site_uv&quot;&gt;个小伙伴&lt;/span&gt;
本页累计 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page_pv&quot;&gt;次阅读&lt;/span&gt;
&lt;span id=&quot;showDays&quot;&gt;&lt;/span&gt;
&lt;/div&gt;
{% endif %}
</code></pre></li>
</ul>
<h2 id="百度-google收录你的站点"><a href="#百度-google收录你的站点" class="headerlink" title="百度/google收录你的站点"></a>百度/google收录你的站点</h2><ul>
<li><p>安装sitemap插件</p>
<pre><code>npm install hexo-generator-sitemap --save      #google
npm install hexo-generator-baidu-sitemap --save  #百度
</code></pre><p>在站点配置文件_config.yml中添加如下代码：</p>
<pre><code>#自动生成sitemap
sitemap:
path: sitemap.xml
baidusitemap:
path: baidusitemap.xml
</code></pre><p>会在public目录下生成baidusitmap.xml 和 sitemap.xml两个文件<br>安装hexo-deployer-git插件</p>
<pre><code>npm install hexo-deployer-git --save #部署到github
</code></pre><p>在项目根目录下执行命令</p>
<pre><code>hexo clean # 清除资源
hexo g     # 生成静态资源
hexo d     # 部署
</code></pre><p>登录在github打开存放博客资源的仓库，就能看到部署的资源文件<br>分别向google,baidu提交站点地图sitemap.xml,baidusitmap.xml<br>百度站长： <a href="http://zhanzhang.baidu.com/site/index" target="_blank" rel="external">http://zhanzhang.baidu.com/site/index</a><br>输入你想添加的网站：你的博客首页地址<br>然后按照提示选择验证方式，点击完成验证。</p>
<p>google站长： <a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="external">https://www.google.com/webmasters/tools/home?hl=zh-CN</a><br>添加网站后，进行左侧抓取站点地图，添加/测试站点地图，填写sitemap.xml。sitemap.xml就在github存放博客  仓库的根目录下<br>验证完成后大概过一天时间便可google到你的站点了，百度不定。</p>
</li>
</ul>
<h2 id="统计本站运行天数"><a href="#统计本站运行天数" class="headerlink" title="统计本站运行天数"></a>统计本站运行天数</h2><ul>
<li><p>修改blog/themes/next/layout_partials/footer.swig文件，在后面追加以下代码</p>
<pre><code>&lt;script&gt;
    var birthDay = new Date(&#39;05/24/2016&#39;);
    var now = new Date();
    var duration = now.getTime() - birthDay.getTime();
    var total= Math.floor(duration / (1000 * 60 * 60 * 24));
    document.getElementById(&#39;showDays&#39;).innerHTML=&#39;本站已运行&#39; + total + &#39;天&#39;;
&lt;/script&gt;
</code></pre><p>在最后一个div中追加一下代码</p>
<pre><code>&lt;span id=&quot;showDays&quot;&gt;&lt;/span&gt;
</code></pre></li>
</ul>
<h1 id="腾讯公益404页面"><a href="#腾讯公益404页面" class="headerlink" title="腾讯公益404页面"></a>腾讯公益404页面</h1><ul>
<li><p>腾讯公益404页面，寻找丢失儿童，让大家一起关注此项公益事业！效果如下 <a href="http://www.ixirong.com/404.html" target="_blank" rel="external">http://www.ixirong.com/404.html</a></p>
<p>使用方法，新建 404.html 页面，放到主题的 source 目录下，内容如下：</p>
<pre><code> &lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;
  &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt;
  &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;
  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://qzone.qq.com/gy/404/style/404style.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script type=&quot;text/plain&quot; src=&quot;http://www.qq.com/404/search_children.js&quot;
          charset=&quot;utf-8&quot; homePageUrl=&quot;/&quot;
          homePageName=&quot;回到我的主页&quot;&gt;
  &lt;/script&gt;
  &lt;script src=&quot;https://qzone.qq.com/gy/404/data.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://qzone.qq.com/gy/404/page.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt; 
</code></pre></li>
<li><p>到此本地资源博客搭建已经完成，有些细微调节可根据浏览器控制台找到对应的模板进行调节，比如站点背景，代码字体字体颜色，页面宽度等等(参考资源： <a href="http://gniba.com/2016/07/11/next-custom.html" target="_blank" rel="external">http://gniba.com/2016/07/11/next-custom.html</a> )</p>
</li>
</ul>
<h1 id="托管到github"><a href="#托管到github" class="headerlink" title="托管到github"></a>托管到github</h1><ul>
<li><p>修改站点配置文件</p>
<pre><code># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
  type: git
  repository: git@github.com:jethan/githug.git
  branch: master
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/images/icons/hexo.jpg&quot; alt=&quot;Hexo-NexT&quot; title=&quot;Hexo-NexT&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://jet-han.oschina.io/categories/Hexo/"/>
    
    
      <category term="个人博客" scheme="http://jet-han.oschina.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
