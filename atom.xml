<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>学海无涯</title>
  <subtitle>技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jethan.bid/"/>
  <updated>2017-12-17T10:00:26.000Z</updated>
  <id>http://jethan.bid/</id>
  
  <author>
    <name>Jet</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发编程之synchronized与加锁机制</title>
    <link href="http://jethan.bid/2017/12/17/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsynchronized%E4%B8%8E%E5%8A%A0%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>http://jethan.bid/2017/12/17/并发编程之synchronized与加锁机制/</id>
    <published>2017-12-17T10:00:26.000Z</published>
    <updated>2017-12-17T10:00:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../../../../../img/icons/java.jpg" alt="java" title="java"></p>
<h1 id="synchronized-与-Lock"><a href="#synchronized-与-Lock" class="headerlink" title="synchronized 与 Lock"></a>synchronized 与 Lock</h1><p>目前在Java中存在两种锁机制：synchronized和Lock，Lock接口及其实现类是JDK5增加的内容。 </p>
<p>数据同步需要依赖锁，那锁的同步又依赖谁？synchronized给出的答案是在软件层面依赖JVM，而Lock给出的方案是在硬件层面依赖特殊的CPU指令。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">synchronized</th>
<th style="text-align:center">volatile</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">原子性</td>
<td style="text-align:center">true</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">可见性</td>
<td style="text-align:center">true</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">是否阻塞线程</td>
<td style="text-align:center">true</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">使用级别</td>
<td style="text-align:center">变量、方法、类</td>
<td style="text-align:center">变量</td>
</tr>
<tr>
<td style="text-align:center">用途</td>
<td style="text-align:center">锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住</td>
<td style="text-align:center">告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取</td>
</tr>
<tr>
<td style="text-align:center">使用范围</td>
<td style="text-align:center"></td>
<td style="text-align:center">a、对变量的写操作不依赖于当前值。b、该变量没有包含在具有其他变量的不变式中。</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">synchronized</th>
<th style="text-align:center">ReentrantLock</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">是否需要手动释放</td>
<td style="text-align:center">false</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">等待中的线程是否可以中断等待</td>
<td style="text-align:center">false</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">是否可以主动获得锁</td>
<td style="text-align:center">false</td>
<td style="text-align:center">true（投票等方式）</td>
</tr>
<tr>
<td style="text-align:center">是否支持定时</td>
<td style="text-align:center">false</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">其他</td>
<td style="text-align:center">synchronized是在JVM层面上实现的(语言级别)JVM会自动释放锁定</td>
<td style="text-align:center">lock是通过代码实现的，要保证锁定一定会被释放，就必须将unLock()放到finally{}中</td>
</tr>
</tbody>
</table>
</div>
<a id="more"></a>
<p>如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：  </p>
<p>　　1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；<br>　　2）线程执行发生异常，此时JVM会让线程自动释放锁。</p>
<p>  那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。</p>
<p>因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。</p>
<p>再举个例子：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。</p>
<p>但是采用synchronized关键字来实现同步的话，就会导致一个问题：</p>
<p>如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。</p>
<p>因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。</p>
<p>另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。</p>
<p>总结一下，也就是说Lock提供了比synchronized更多的功能。但是要注意以下几点：</p>
<p>　　1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；<br>　　2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>  本文所指说的JVM是指Hotspot的6u23版本<br> <code>synrhronized</code>关键字简洁、清晰、语义明确，因此即使有了<code>Lock</code>接口，使用的还是非常广泛。其应用层的语义是可以把任何一个非<code>null</code>对象作为”锁”，当synchronized作用在方法上时，锁住的便是<code>对象实例（this）</code>；当作用在<code>静态方法</code>时锁住的便是<code>对象对应的Class实例</code>，因为Class数据存在于永久代，因此<code>静态方法锁相当于该类的一个全局锁</code>；当synchronized作用于某一个对象实例时，锁住的便是对应的代码块。在HotSpot JVM实现中，锁有个专门的名字：<code>对象监视器</code>。</p>
<ul>
<li>在同步代码块中，同步锁就是这个代码块所属的那个对象 </li>
<li>在同步方法中（非静态），同步锁就是调用这个方法的那个对象 </li>
<li>在同步方法中（静态），同步锁就是这个方法所属的这个类的字节码文件，即 类名.class;</li>
</ul>
<h3 id="线程状态及状态转换"><a href="#线程状态及状态转换" class="headerlink" title="线程状态及状态转换"></a>线程状态及状态转换</h3><p> 当多个线程同时请求某个对象监视器时，对象监视器会设置几种状态用来区分请求的线程：</p>
<ul>
<li>Contention List：所有请求锁的线程将被首先放置到该竞争队列</li>
<li>Entry List：Contention List中那些有资格成为候选人的线程被移到Entry - List</li>
<li>Wait Set：那些调用wait方法被阻塞的线程被放置到Wait Set</li>
<li>OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck</li>
<li>Owner：获得锁的线程称为Owner</li>
<li>!Owner：释放锁的线程</li>
</ul>
<p>下图反映了个状态转换关系：</p>
<p><img src="并发编程之synchronized与加锁机制/synchronized1.jpg" alt="synchronized" title="synchronized"></p>
<p>新请求锁的线程将首先被加入到ConetentionList中，当某个拥有锁的线程（Owner状态）调用unlock之后，如果发现EntryList为空则从ContentionList中移动线程到EntryList，下面说明下ContentionList和EntryList的实现方式：</p>
<h4 id="ContentionList虚拟队列"><a href="#ContentionList虚拟队列" class="headerlink" title="ContentionList虚拟队列"></a>ContentionList虚拟队列</h4><p><code>ContentionList</code>并不是一个真正的<code>Queue</code>，而只是一个虚拟队列，原因在于<code>ContentionList</code>是由<code>Node</code>及其<code>next</code>指针逻辑构成，并不存在一个Queue的数据结构。<code>ContentionList</code>是一个后进先出（LIFO）的队列，每次新加入Node时都会在队头进行，通过CAS改变第一个节点的的指针为新增节点，同时设置新增节点的<code>next</code>指向后续节点，而取得操作则发生在队尾。显然，该结构其实是个<code>Lock-Free</code>的队列。</p>
<p>因为只有<code>Owner线程</code>才能从队尾取元素，也即线程出列操作无争用，当然也就避免了<code>CAS</code>的<code>ABA</code>问题。</p>
<p><img src="并发之synchronized与加锁机制/synchronized2.jpg" alt="synchronized" title="synchronized"></p>
<h4 id="EntryList"><a href="#EntryList" class="headerlink" title="EntryList"></a>EntryList</h4><p><code>EntryList</code>与<code>ContentionList</code>逻辑上同属等待队列，<code>ContentionList</code>会被线程并发访问，为了降低对<code>ContentionList</code>队尾的争用，而建立<code>EntryList</code>。<code>Owner</code>线程在<code>unlock</code>时会从<code>ContentionList</code>中迁移线程到<code>EntryList</code>，并会指定<code>EntryList</code>中的某个线程（一般为<code>Head</code>）为<code>Ready（OnDeck）</code>线程。<code>Owner</code>线程并不是把锁传递给<code>OnDeck</code>线程，只是把竞争锁的权利交给<code>OnDeck</code>，OnDeck线程需要重新竞争锁。这样做虽然牺牲了一定的公平性，但极大的提高了整体吞吐量，在Hotspot中把<code>OnDeck</code>的选择行为称之为“竞争切换”。</p>
<p><code>OnDeck</code>线程获得锁后即变为owner线程，无法获得锁则会依然留在<code>EntryList</code>中，考虑到公平性，在<code>EntryList</code>中的位置不发生变化（依然在队头）。如果Owner线程被<code>wait</code>方法阻塞，则转移到<code>WaitSet</code>队列；如果在某个时刻被<code>notify/notifyAll</code>唤醒，则再次转移到<code>EntryList</code>。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>那些处于ContetionList、EntryList、WaitSet中的线程均处于阻塞状态，阻塞操作由操作系统完成（在Linxu下通过pthread_mutex_lock函数）。线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能。  </p>
<p>缓解上述问题的办法便是自旋，其原理是：当发生争用时，若Owner线程能在很短的时间内释放锁，则那些正在争用线程可以稍微等一等（自旋），在Owner线程释放锁后，争用线程可能会立即得到锁，从而避免了系统阻塞。但Owner运行的时间可能会超出了临界值，争用线程自旋一段时间后还是无法获得锁，这时争用线程则会停止自旋进入阻塞状态（后退）。基本思路就是自旋，不成功再阻塞，尽量降低阻塞的可能性，这对那些执行时间很短的代码块来说有非常重要的性能提高。自旋锁有个更贴切的名字：自旋-指数后退锁，也即复合锁。很显然，自旋在多处理器上才有意义。  </p>
<p>还有个问题是，线程自旋时做些啥？其实啥都不做，可以执行几次for循环，可以执行几条空的汇编指令，目的是占着CPU不放，等待获取锁的机会。所以说，自旋是把双刃剑，如果旋的时间过长会影响整体性能，时间过短又达不到延迟阻塞的目的。显然，自旋的周期选择显得非常重要，但这与操作系统、硬件体系、系统的负载等诸多场景相关，很难选择，如果选择不当，不但性能得不到提高，可能还会下降，因此大家普遍认为自旋锁不具有扩展性。  </p>
<p>对自旋锁周期的选择上，HotSpot认为最佳时间应是一个线程上下文切换的时间，但目前并没有做到。经过调查，目前只是通过汇编暂停了几个CPU周期，除了自旋周期选择，HotSpot还进行许多其他的自旋优化策略，具体如下：</p>
<ul>
<li>如果平均负载小于CPUs则一直自旋  </li>
<li>如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞  </li>
<li>如果正在自旋的线程发现Owner发生了变化则延迟自旋时间（自旋计数）或进入阻塞  </li>
<li>如果CPU处于节电模式则停止自旋  </li>
<li>自旋时间的最坏情况是CPU的存储延迟（CPU A存储了一个数据，到CPU B得知这个数据直接的时间差）  </li>
<li>自旋时会适当放弃线程优先级之间的差异  </li>
</ul>
<p>那<code>synchronized</code>实现何时使用了自旋锁？答案是在线程进入<code>ContentionList</code>时，也即第一步操作前。线程在进入等待队列时首先进行自旋尝试获得锁，如果不成功再进入等待队列。这对那些已经在等待队列中的线程来说，稍微显得不公平。还有一个不公平的地方是自旋线程可能会抢占了<code>Ready</code>线程的锁。自旋锁由每个监视对象维护，每个监视对象一个。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>在JVM1.6中引入了偏向锁，偏向锁主要解决无竞争下的锁性能问题，首先我们看下无竞争下锁存在什么问题： </p>
<p>现在几乎所有的锁都是可重入的，也即已经获得锁的线程可以多次锁住/解锁监视对象，按照之前的HotSpot设计，每次加锁/解锁都会涉及到一些CAS操作（比如对等待队列的CAS操作），CAS操作会延迟本地调用，因此偏向锁的想法是一旦线程第一次获得了监视对象，之后让监视对象“偏向”这个线程，之后的多次调用则可以避免CAS操作，说白了就是置个变量，如果发现为true则无需再走各种加锁/解锁流程。但还有很多概念需要解释、很多引入的问题需要解决：</p>
<h4 id="CAS及SMP架构"><a href="#CAS及SMP架构" class="headerlink" title="CAS及SMP架构"></a>CAS及SMP架构</h4><p>CAS为什么会引入本地延迟？这要从SMP（对称多处理器）架构说起，下图大概表明了SMP的结构：  </p>
<p> <img src="并发之synchronized与加锁机制/synchronized3.jpg" alt="synchronized" title="synchronized"></p>
<p>其意思是所有的CPU会共享一条系统总线（BUS），靠此总线连接主存。每个核都有自己的一级缓存，各核相对于BUS对称分布，因此这种结构称为“对称多处理器”。  </p>
<p>而CAS的全称为Compare-And-Swap，是一条CPU的原子指令，其作用是让CPU比较后原子地更新某个位置的值，经过调查发现，其实现方式是基于硬件平台的汇编指令，就是说CAS是靠硬件实现的，JVM只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的接口。  </p>
<p>Core1和Core2可能会同时把主存中某个位置的值Load到自己的L1 Cache中，当Core1在自己的L1 Cache中修改这个位置的值时，会通过总线，使Core2中L1 Cache对应的值“失效”，而Core2一旦发现自己L1 Cache中的值失效（称为Cache命中缺失）则会通过总线从内存中加载该地址最新的值，大家通过总线的来回通信称为“Cache一致性流量”，因为总线被设计为固定的“通信能力”，如果Cache一致性流量过大，总线将成为瓶颈。而当Core1和Core2中的值再次一致时，称为“Cache一致性”，从这个层面来说，锁设计的终极目标便是减少Cache一致性流量。  </p>
<p>而CAS恰好会导致Cache一致性流量，如果有很多线程都共享同一个对象，当某个Core CAS成功时必然会引起总线风暴，这就是所谓的本地延迟，本质上偏向锁就是为了消除CAS，降低Cache一致性流量。  </p>
<p><strong>Cache一致性：</strong><br>上面提到Cache一致性，其实是有协议支持的，现在通用的协议是MESI（最早由Intel开始支持），具体参考：  <a href="http://en.wikipedia.org/wiki/MESI_protocol，以后会仔细讲解这部分。" target="_blank" rel="external">http://en.wikipedia.org/wiki/MESI_protocol，以后会仔细讲解这部分。</a><br><strong>Cache一致性流量的例外情况：</strong><br>其实也不是所有的CAS都会导致总线风暴，这跟Cache一致性协议有关，具体参考：<a href="http://blogs.oracle.com/dave/entry/biased_locking_in_hotspot" target="_blank" rel="external">http://blogs.oracle.com/dave/entry/biased_locking_in_hotspot</a><br><strong>NUMA(Non Uniform Memory Access Achitecture）架构：</strong><br>与SMP对应还有非对称多处理器架构，现在主要应用在一些高端处理器上，主要特点是没有总线，没有公用主存，每个Core有自己的内存，针对这种结构此处不做讨论。  </p>
<h4 id="偏向解除"><a href="#偏向解除" class="headerlink" title="偏向解除"></a>偏向解除</h4><p>偏向锁引入的一个重要问题是，在多争用的场景下，如果另外一个线程争用偏向对象，拥有者需要释放偏向锁，而释放的过程会带来一些性能开销，但总体说来偏向锁带来的好处还是大于CAS代价的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于锁，JVM中还引入了一些其他技术比如锁膨胀等，这些与自旋锁、偏向锁相比影响不是很大，这里就不做介绍。<br>通过上面的介绍可以看出，synchronized的底层实现主要依靠<code>Lock-Free</code>的队列，基本思路是自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。</p>
<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>前文分析了<code>JVM</code>中的<code>synchronized</code>实现，本文继续分析<code>JVM</code>中的另一种锁<code>Lock</code>的实现。与<code>synchronized</code>不同的是，<code>Lock</code>完全用<code>Java</code>写成，在java这个层面是无关<code>JVM</code>实现的。</p>
<p>在<code>java.util.concurrent.locks</code>包中有很多<code>Lock</code>的实现类，常用的有<code>ReentrantLock、ReadWriteLock（实现类ReentrantReadWriteLock）</code>，其实现都依赖<code>java.util.concurrent.AbstractQueuedSynchronizer</code>类，实现思路都大同小异，因此我们以<code>ReentrantLock</code>作为讲解切入点。</p>
<h3 id="ReentrantLock的调用过程"><a href="#ReentrantLock的调用过程" class="headerlink" title="ReentrantLock的调用过程"></a>ReentrantLock的调用过程</h3><p>经过观察ReentrantLock把所有Lock接口的操作都委派到一个Sync类上，该类继承了<code>AbstractQueuedSynchronizer</code>：</p>
<pre><code>       static abstract class Sync extends AbstractQueuedSynchronizer
</code></pre><p><code>Sync</code>又有两个子类：</p>
<pre><code>    final static class NonfairSync extends Sync
    final static class FairSync extends Sync
</code></pre><p>显然是为了支持公平锁和非公平锁而定义，默认情况下为非公平锁。</p>
<p>先理一下<code>Reentrant.lock()</code>方法的调用过程（默认非公平锁）：</p>
<p> <img src="并发之synchronized与加锁机制/ReentrantLock1.jpg" alt="ReentrantLock" title="ReentrantLock"></p>
<p>这些讨厌的Template模式导致很难直观的看到整个调用过程，其实通过上面调用过程及<code>AbstractQueuedSynchronizer</code>的注释可以发现，<code>AbstractQueuedSynchronizer</code>中抽象了绝大多数<code>Lock</code>的功能，而只把<code>tryAcquire</code>方法延迟到子类中实现。<code>tryAcquire</code>方法的语义在于用具体子类判断请求线程是否可以获得锁，无论成功与否<code>AbstractQueuedSynchronizer</code>都将处理后面的流程。</p>
<h3 id="锁实现（加锁）"><a href="#锁实现（加锁）" class="headerlink" title="锁实现（加锁）"></a>锁实现（加锁）</h3><p>简单说来，<code>AbstractQueuedSynchronizer</code>会把所有的请求线程构成一个CLH队列，当一个线程执行完毕（<code>lock.unlock()</code>）时会激活自己的后继节点，但正在执行的线程并不在队列中，而那些等待执行的线程全部处于阻塞状态，经过调查线程的显式阻塞是通过调用<code>LockSupport.park()</code>完成，而<code>LockSupport.park()</code>则调用<code>sun.misc.Unsafe.park()</code>本地方法，再进一步，HotSpot在Linux中中通过调用<code>pthread_mutex_lock</code>函数把线程交给系统内核进行阻塞。</p>
<p>该队列如图：</p>
<p> <img src="并发之synchronized与加锁机制/ReentrantLock2.jpg" alt="ReentrantLock" title="ReentrantLock"></p>
<p>与synchronized相同的是，这也是一个虚拟队列，不存在队列实例，仅存在节点之间的前后关系。令人疑惑的是为什么采用CLH队列呢？原生的CLH队列是用于自旋锁，但Doug Lea把其改造为阻塞锁。</p>
<p>当有线程竞争锁时，该线程会首先尝试获得锁，这对于那些已经在队列中排队的线程来说显得不公平，这也是非公平锁的由来，与synchronized实现类似，这样会极大提高吞吐量。</p>
<p>如果已经存在Running线程，则新的竞争线程会被追加到队尾，具体是采用基于CAS的Lock-Free算法，因为线程并发对Tail调用CAS可能会导致其他线程CAS失败，解决办法是循环CAS直至成功。AbstractQueuedSynchronizer的实现非常精巧，令人叹为观止，不入细节难以完全领会其精髓，下面详细说明实现过程：</p>
<h4 id="Sync-nonfairTryAcquire"><a href="#Sync-nonfairTryAcquire" class="headerlink" title="Sync.nonfairTryAcquire"></a>Sync.nonfairTryAcquire</h4><p><code>nonfairTryAcquire</code>方法将是lock方法间接调用的第一个方法，每次请求锁时都会首先调用该方法。</p>
<pre><code>    final boolean nonfairTryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc &lt; 0) // overflow
                throw new Error(&quot;Maximum lock count exceeded&quot;);
            setState(nextc);
            return true;
        }
        return false;
    }
</code></pre><p>该方法会首先判断当前状态，如果<code>c==0</code>说明没有线程正在竞争该锁，如果不<code>c !=0</code> 说明有线程正拥有了该锁。</p>
<p>如果发现<code>c==0</code>，则通过CAS设置该状态值为<code>acquires,acquires</code>的初始调用值为1，每次线程重入该锁都会+1，每次unlock都会-1，但为0时释放锁。如果CAS设置成功，则可以预计其他任何线程调用CAS都不会再成功，也就认为当前线程得到了该锁，也作为Running线程，很显然这个<code>Running</code>线程并未进入等待队列。</p>
<p>如果<code>c !=0</code>但发现自己已经拥有锁，只是简单地<code>++acquires</code>，并修改status值，但因为没有竞争，所以通过setStatus修改，而非CAS，也就是说这段代码实现了偏向锁的功能，并且实现的非常漂亮。</p>
<h4 id="AbstractQueuedSynchronizer-addWaiter"><a href="#AbstractQueuedSynchronizer-addWaiter" class="headerlink" title="AbstractQueuedSynchronizer.addWaiter"></a>AbstractQueuedSynchronizer.addWaiter</h4><p><code>addWaiter</code>方法负责把当前无法获得锁的线程包装为一个Node添加到队尾：</p>
<pre><code>private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    // Try the fast path of enq; backup to full enq on failure
    Node pred = tail;
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    enq(node);
    return node;
}
</code></pre><p>其中参数mode是独占锁还是共享锁，默认为<code>null</code>，独占锁。追加到队尾的动作分两步：</p>
<p>如果当前队尾已经存在(<code>tail!=null</code>)，则使用CAS把当前线程更新为Tail<br>如果当前Tail为null或则线程调用CAS设置队尾失败，则通过enq方法继续设置Tail<br>下面是enq方法：</p>
<pre><code>private Node enq(final Node node) {
    for (;;) {
        Node t = tail;
        if (t == null) { // Must initialize
            Node h = new Node(); // Dummy header
            h.next = node;
            node.prev = h;
            if (compareAndSetHead(h)) {
                tail = node;
                return h;
            }
        }
        else {
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
</code></pre><p>该方法就是循环调用CAS，即使有高并发的场景，无限循环将会最终成功把当前线程追加到队尾（或设置队头）。总而言之，addWaiter的目的就是通过CAS把当前现在追加到队尾，并返回包装后的Node实例。</p>
<p>把线程要包装为Node对象的主要原因，除了用Node构造供虚拟队列外，还用Node包装了各种线程状态，这些状态被精心设计为一些数字值：</p>
<ul>
<li>SIGNAL(-1) ：线程的后继线程正/已被阻塞，当该线程release或cancel时要重新这个后继线程(unpark)</li>
<li>CANCELLED(1)：因为超时或中断，该线程已经被取消</li>
<li>CONDITION(-2)：表明该线程被处于条件队列，就是因为调用了Condition.await而被阻塞</li>
<li>PROPAGATE(-3)：传播共享锁</li>
<li>0：0代表无状态</li>
</ul>
<h4 id="AbstractQueuedSynchronizer-acquireQueued"><a href="#AbstractQueuedSynchronizer-acquireQueued" class="headerlink" title="AbstractQueuedSynchronizer.acquireQueued"></a>AbstractQueuedSynchronizer.acquireQueued</h4><p><code>acquireQueued</code>的主要作用是把已经追加到队列的线程节点（addWaiter方法返回值）进行阻塞，但阻塞前又通过tryAccquire重试是否能获得锁，如果重试成功能则无需阻塞，直接返回</p>
<pre><code>final boolean acquireQueued(final Node node, int arg) {
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } catch (RuntimeException ex) {
        cancelAcquire(node);
        throw ex;
    }
}
</code></pre><p>仔细看看这个方法是个无限循环，感觉如果<code>p == head &amp;&amp; tryAcquire(arg)</code>条件不满足循环将永远无法结束，当然不会出现死循环，奥秘在于第12行的<code>parkAndCheckInterrupt</code>会把当前线程挂起，从而阻塞住线程的调用栈。</p>
<pre><code>private final boolean parkAndCheckInterrupt() {
    LockSupport.park(this);
    return Thread.interrupted();
}
</code></pre><p>如前面所述，LockSupport.park最终把线程交给系统（Linux）内核进行阻塞。当然也不是马上把请求不到锁的线程进行阻塞，还要检查该线程的状态，比如如果该线程处于Cancel状态则没有必要，具体的检查在<code>shouldParkAfterFailedAcquire</code>中：</p>
<pre><code>private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    if (ws == Node.SIGNAL)
        /*
         * This node has already set status asking a release
         * to signal it, so it can safely park
         */
        return true;
    if (ws &gt; 0) {
        /*
         * Predecessor was cancelled. Skip over predecessors and
         * indicate retry.
         */
    do {
    node.prev = pred = pred.prev;
    } while (pred.waitStatus &gt; 0);
    pred.next = node;
    } else {
        /*
         * waitStatus must be 0 or PROPAGATE. Indicate that we
         * need a signal, but don&#39;t park yet. Caller will need to
         * retry to make sure it cannot acquire before parking. 
         */
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    } 
    return false;
}
</code></pre><p>检查原则在于：</p>
<ul>
<li>规则1：如果前继的节点状态为SIGNAL，表明当前节点需要unpark，则返回成功，此时acquireQueued方法的第12行（parkAndCheckInterrupt）将导致线程阻塞</li>
<li>规则2：如果前继节点状态为CANCELLED(ws&gt;0)，说明前置节点已经被放弃，则回溯到一个非取消的前继节点，返回false，acquireQueued方法的无限循环将递归调用该方法，直至规则1返回true，导致线程阻塞</li>
<li>规则3：如果前继节点状态为非SIGNAL、非CANCELLED，则设置前继的状态为SIGNAL，返回false后进入acquireQueued的无限循环，与规则2同<br>总体看来，<code>shouldParkAfterFailedAcquire</code>就是靠前继节点判断当前线程是否应该被阻塞，如果前继节点处于CANCELLED状态，则顺便删除这些节点重新构造队列。</li>
</ul>
<p>至此，锁住线程的逻辑已经完成，下面讨论解锁的过程。</p>
<h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>请求锁不成功的线程会被挂起在acquireQueued方法的第12行，12行以后的代码必须等线程被解锁锁才能执行，假如被阻塞的线程得到解锁，则执行第13行，即设置interrupted = true，之后又进入无限循环。</p>
<p>从无限循环的代码可以看出，并不是得到解锁的线程一定能获得锁，必须在第6行中调用tryAccquire重新竞争，因为锁是非公平的，有可能被新加入的线程获得，从而导致刚被唤醒的线程再次被阻塞，这个细节充分体现了“非公平”的精髓。通过之后将要介绍的解锁机制会看到，第一个被解锁的线程就是Head，因此p == head的判断基本都会成功。</p>
<p>至此可以看到，把tryAcquire方法延迟到子类中实现的做法非常精妙并具有极强的可扩展性，令人叹为观止！当然精妙的不是这个Templae设计模式，而是Doug Lea对锁结构的精心布局。</p>
<p>解锁代码相对简单，主要体现在<code>AbstractQueuedSynchronizer.release</code>和<code>Sync.tryRelease</code>方法中：</p>
<pre><code>      class AbstractQueuedSynchronizer
        public final boolean release(int arg) {
            if (tryRelease(arg)) {
                Node h = head;
                if (h != null &amp;&amp; h.waitStatus != 0)
                    unparkSuccessor(h);
                return true;
            }
            return false;
        }
</code></pre><p><strong>class Sync</strong></p>
<pre><code>    protected final boolean tryRelease(int releases) {
        int c = getState() - releases;
        if (Thread.currentThread() != getExclusiveOwnerThread())
            throw new IllegalMonitorStateException();
        boolean free = false;
        if (c == 0) {
            free = true;
            setExclusiveOwnerThread(null);
        }
        setState(c);
        return free;
    }
</code></pre><p><code>tryRelease</code>与<code>tryAcquire</code>语义相同，把如何释放的逻辑延迟到子类中。<code>tryRelease</code>语义很明确：如果线程多次锁定，则进行多次释放，直至status==0则真正释放锁，所谓释放锁即设置status为0，因为无竞争所以没有使用CAS。</p>
<p>release的语义在于：如果可以释放锁，则唤醒队列第一个线程（Head），具体唤醒代码如下：</p>
<pre><code>private void unparkSuccessor(Node node) {
    /*
     * If status is negative (i.e., possibly needing signal) try
     * to clear in anticipation of signalling. It is OK if this
     * fails or if status is changed by waiting thread.
     */
    int ws = node.waitStatus;
    if (ws &lt; 0)
        compareAndSetWaitStatus(node, ws, 0); 

    /*
     * Thread to unpark is held in successor, which is normally
     * just the next node.  But if cancelled or apparently null,
     * traverse backwards from tail to find the actual
     * non-cancelled successor.
     */
    Node s = node.next;
    if (s == null || s.waitStatus &gt; 0) {
        s = null;
        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
            if (t.waitStatus &lt;= 0)
                s = t;
    }
    if (s != null)
        LockSupport.unpark(s.thread);
}
</code></pre><p>这段代码的意思在于找出第一个可以unpark的线程，一般说来head.next == head，Head就是第一个线程，但Head.next可能被取消或被置为null，因此比较稳妥的办法是从后往前找第一个可用线程。貌似回溯会导致性能降低，其实这个发生的几率很小，所以不会有性能影响。之后便是通知系统内核继续该线程，在Linux下是通过pthread_mutex_unlock完成。之后，被解锁的线程进入上面所说的重新竞争状态。</p>
<h3 id="Lock-amp-Synchronized"><a href="#Lock-amp-Synchronized" class="headerlink" title="Lock &amp; Synchronized"></a>Lock &amp; Synchronized</h3><p><code>AbstractQueuedSynchronizer</code>通过构造一个基于阻塞的CLH队列容纳所有的阻塞线程，而对该队列的操作均通过<code>Lock-Free（CAS）</code>操作，但对已经获得锁的线程而言，<code>ReentrantLock</code>实现了偏向锁的功能。</p>
<p><code>synchronized</code>的底层也是一个基于CAS操作的等待队列，但JVM实现的更精细，把等待队列分为<code>ContentionList</code>和<code>EntryList</code>，目的是为了降低线程的出列速度；当然也实现了偏向锁，从数据结构来说二者设计没有本质区别。但synchronized还实现了自旋锁，并针对不同的系统和硬件体系进行了优化，而Lock则完全依靠系统阻塞挂起等待线程。</p>
<p>当然<code>Lock</code>比<code>synchronized</code>更适合在应用层扩展，可以继承AbstractQueuedSynchronizer定义各种实现，比如实现读写锁（<code>ReadWriteLock</code>），公平或不公平锁；同时，Lock对应的Condition调用<code>await()</code>、<code>signal()</code>、<code>signAll()</code>这几个方法比<code>notify()</code>、<code>wait()</code>、<code>notifyAll()</code>要方便的多、灵活的多。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../../../../../img/icons/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;synchronized-与-Lock&quot;&gt;&lt;a href=&quot;#synchronized-与-Lock&quot; class=&quot;headerlink&quot; title=&quot;synchronized 与 Lock&quot;&gt;&lt;/a&gt;synchronized 与 Lock&lt;/h1&gt;&lt;p&gt;目前在Java中存在两种锁机制：synchronized和Lock，Lock接口及其实现类是JDK5增加的内容。 &lt;/p&gt;
&lt;p&gt;数据同步需要依赖锁，那锁的同步又依赖谁？synchronized给出的答案是在软件层面依赖JVM，而Lock给出的方案是在硬件层面依赖特殊的CPU指令。&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;特性&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;synchronized&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;volatile&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;原子性&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;true&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;可见性&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;true&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是否阻塞线程&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;true&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;使用级别&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;变量、方法、类&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;用途&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;使用范围&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;a、对变量的写操作不依赖于当前值。b、该变量没有包含在具有其他变量的不变式中。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;特性&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;synchronized&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;ReentrantLock&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是否需要手动释放&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;false&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;等待中的线程是否可以中断等待&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;false&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是否可以主动获得锁&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;false&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;true（投票等方式）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是否支持定时&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;false&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;其他&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;synchronized是在JVM层面上实现的(语言级别)JVM会自动释放锁定&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;lock是通过代码实现的，要保证锁定一定会被释放，就必须将unLock()放到finally{}中&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="java" scheme="http://jethan.bid/categories/java/"/>
    
      <category term="并发编程" scheme="http://jethan.bid/categories/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="synchronized" scheme="http://jethan.bid/tags/synchronized/"/>
    
      <category term="ReentrantLock" scheme="http://jethan.bid/tags/ReentrantLock/"/>
    
  </entry>
  
  <entry>
    <title>jdk8💗特性</title>
    <link href="http://jethan.bid/2017/12/12/jdk8%F0%9F%92%97%E7%89%B9%E6%80%A7/"/>
    <id>http://jethan.bid/2017/12/12/jdk8💗特性/</id>
    <published>2017-12-12T08:11:06.000Z</published>
    <updated>2017-12-12T08:11:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/java.jpg" alt="jdk8" title="jdk8"></p>
<hr>
<blockquote>
<p>本文翻译整理自 <a href="https://github.com/winterbe/java8-tutorial" target="_blank" rel="external">https://github.com/winterbe/java8-tutorial</a></p>
</blockquote>
<p>希望阅读完本文的小伙伴能够熟练掌握和应用 Java8 的各种特性，使其成为在工作中的一门利器。话不多说，让我们一起开启 Java8 新特性之旅吧！</p>
<hr>
<h2 id="接口内允许添加默认实现的方法"><a href="#接口内允许添加默认实现的方法" class="headerlink" title="接口内允许添加默认实现的方法"></a>接口内允许添加默认实现的方法</h2><p>Java 8 允许我们通过 <code>default</code> 关键字对接口中定义的抽象方法提供一个默认的实现。</p>
<p>请看下面示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义一个公式接口</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>&#123;</div><div class="line">    <span class="comment">// 计算</span></div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// 求平方根</span></div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Math.sqrt(a);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面这个接口中，我们除了定义了一个抽象方法 <code>calculate</code>，还定义了一个带有默认实现的方法 <code>sqrt</code>。<br>我们在实现这个接口时，可以只需要实现 <code>calculate</code> 方法，默认方法 <code>sqrt</code> 可以直接调用即可，也就是说我们可以不必强制实现 <code>sqrt</code> 方法。<br><a id="more"></a></p>
<blockquote>
<p>补充：通过 <code>default</code> 关键字这个新特性，可以非常方便地对之前的接口做拓展，而此接口的实现类不必做任何改动。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Formula formula = <span class="keyword">new</span> Formula() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sqrt(a * <span class="number">100</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">formula.calculate(<span class="number">100</span>);     <span class="comment">// 100.0</span></div><div class="line">formula.sqrt(<span class="number">16</span>);           <span class="comment">// 4.0</span></div></pre></td></tr></table></figure>
<p>上面通过匿名对象实现了 <code>Formula</code> 接口。但是即使是这样，我们为了完成一个 <code>sqrt(a * 100)</code> 简单计算，就写了 6 行代码，很是冗余。</p>
<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p><code>Lambda</code>表达式就是一个匿名函数。是Java 为了引入函数式编程而引入的，在Java中，<code>Lambda</code>表达式是有函数式接口实现的。对于函数式接口在第一节简介中有提到，就是只包含一个抽象方法的接口。在Java 8 使用Lambda非常的简单例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt;    a * b                       </div><div class="line">(a, b)          -&gt;   a - b                       </div><div class="line">() -&gt; <span class="number">99</span>                                         </div><div class="line">(String a) -&gt; System.out.println(a)              </div><div class="line">a -&gt; <span class="number">2</span> * a                                       </div><div class="line">c -&gt; &#123; <span class="comment">//some complex statements &#125;</span></div></pre></td></tr></table></figure>
<p>这些都是<code>lambda</code>表达式,编写规则：</p>
<ul>
<li>Lambda 可以有0个或多个参数,多个参数使用括号括起来，并用逗号隔开，如果只有一个参数括号可以省略。   </li>
<li>参数的类型可以明确声明，也可以省略，Lambda会自动推导出参数类型  </li>
<li>Lambda 函数体可以包含一个或多个语句，如果只有一个表达式可以省略大括号。  </li>
</ul>
<p>在学习 <code>Lambda</code> 表达式之前，我们先来看一段老版本的示例代码，其对一个含有字符串的集合进行排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"peter"</span>, <span class="string">"anna"</span>, <span class="string">"mike"</span>, <span class="string">"xenia"</span>);</div><div class="line"></div><div class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> b.compareTo(a);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>Collections</code> 工具类提供了静态方法 <code>sort</code> 方法，入参是一个 <code>List</code> 集合，和一个 <code>Comparator</code> 比较器，以便对给定的 <code>List</code> 集合进行<br>排序。上面的示例代码创建了一个匿名内部类作为入参，这种类似的操作在我们日常的工作中随处可见。</p>
<p>Java 8 中不再推荐这种写法，而是推荐使用 Lambda 表达：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</div><div class="line">    <span class="keyword">return</span> b.compareTo(a);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>正如你看到的，上面这段代码变得简短很多而且易于阅读。但是我们还可以再精炼一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</div></pre></td></tr></table></figure>
<p>对于只包含一行方法的代码块，我们可以省略大括号，直接 <code>return</code> 关键代码即可。追求极致，我们还可以让它再短点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">names.sort((a, b) -&gt; b.compareTo(a));</div></pre></td></tr></table></figure>
<p><code>List</code> 集合现在已经添加了 <code>sort</code> 方法。而且 Java 编译器能够根据<strong>类型推断机制</strong>判断出参数类型，这样，你连入参的类型都可以省略啦，怎么样，是不是感觉很强大呢！</p>
<p><strong>使用Lambda表达式</strong></p>
<p>遍历列表并执行一些操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; pointList = <span class="keyword">new</span> ArrayList();</div><div class="line">pointList.add(<span class="string">"1"</span>);</div><div class="line">pointList.add(<span class="string">"2"</span>);</div><div class="line"> </div><div class="line">pointList.forEach(p -&gt;  &#123;</div><div class="line">                            System.out.println(p);</div><div class="line">                        &#125;</div><div class="line">                 );</div></pre></td></tr></table></figure>
<p>在线程中创建 Runnable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(</div><div class="line">    () -&gt; System.out.println(<span class="string">"My Runnable"</span>);</div><div class="line">).start();</div></pre></td></tr></table></figure>
<p>根据员工的名字排序,这里直接使用了方法引用<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaIntroduction</span> </span>&#123;</div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] ar)</span></span>&#123;</div><div class="line">          Employee[] employees  = &#123;</div><div class="line">              <span class="keyword">new</span> Employee(<span class="string">"David"</span>),</div><div class="line">              <span class="keyword">new</span> Employee(<span class="string">"Naveen"</span>),</div><div class="line">              <span class="keyword">new</span> Employee(<span class="string">"Alex"</span>),</div><div class="line">              <span class="keyword">new</span> Employee(<span class="string">"Richard"</span>)&#125;;</div><div class="line">            </div><div class="line">          System.out.println(<span class="string">"Before Sorting Names: "</span>+Arrays.toString(employees));</div><div class="line">          Arrays.sort(employees, Employee::nameCompare);</div><div class="line">          System.out.println(<span class="string">"After Sorting Names "</span>+Arrays.toString(employees));</div><div class="line">      &#125;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</div><div class="line">  String name;</div><div class="line">  </div><div class="line">  Employee(String name) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nameCompare</span><span class="params">(Employee a1, Employee a2)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> a1.name.compareTo(a2.name);</div><div class="line">  &#125;</div><div class="line">    </div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> name;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对GUI添加实践监听器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">JButton button =  <span class="keyword">new</span> JButton(<span class="string">"Submit"</span>);</div><div class="line">button.addActionListener((e) -&gt; &#123;</div><div class="line">    System.out.println(<span class="string">"Click event triggered !!"</span>);</div><div class="line">&#125;);  )</div></pre></td></tr></table></figure></p>
<p>以上这些都是使用Java 8 lambda表达式的示例。</p>
<h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p><strong>什么是默认方法</strong><br>正如其名，在Java 8中，默认方法就是使用<code>default</code>关键字标记的定义在接口中的方法。如果子类不重写这些方法，那么在子类调用这些方法的时候会直接调用接口中的默认方法。其形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> interfce Moveable&#123;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"move"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>子类继承接口，无需重写这个方法即可调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Moveable</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Animal tiger = <span class="keyword">new</span> Animal();</div><div class="line">        tiger.move();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>Move
</code></pre><p>如果子类想要重写这个默认方法，只需要和普通的重写接口一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Moveable</span></span>&#123;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"I am running"</span>);</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Animal tiger = <span class="keyword">new</span> Animal();</div><div class="line">        tiger.move();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>使用默认方法的好处：</strong></p>
<ul>
<li>定义静态默认方法：在接口中定义静态默认方法，使得其所有继承接口的子类都可以调用这些静态方法，这样可以在接口中集中静态方法，其子类都可以分享，而无需将静态方法分开定义。   </li>
<li>提供兼容性，如果已经发布的接口想要添加新的方法，只需要添加默认方法即可，子类无需做出任何改变。   </li>
</ul>
<p><strong>为什么在Java 8 要引入默认方法</strong></p>
<p>最简单的回单就是，为了支持<code>Lambda</code>表达式。因为<code>Java 8</code>中引入了Lambda表达式，所以很多Java的核心类都需要修改以便使用新的Lambda表达式，但是一些类例如，java.util.List，不仅仅是JDK的类实现，同样被很多第三方的库继承，如果修改了java.util.List 接口，那么其他所有的第三方库都必须重新实现这些方法，最终导致无法兼容。所以就引入了默认方法。例如：java.lang.Iterable，添加的新方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</div><div class="line">    Objects.requireNonNull(action);</div><div class="line">    <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</div><div class="line">        action.accept(t);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"> </div><div class="line">public class Animal implements Moveable&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        List&lt;Animal&gt; list = new ArrayList();</div><div class="line">        list.add(new Animal());</div><div class="line">        list.add(new Animal());</div><div class="line">        list.add(new Animal());</div><div class="line">         </div><div class="line">        //Iterator code reduced to one line</div><div class="line">        list.forEach((Moveable p) -&gt; p.move());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>==添加的默认方法，其所有的子类都默认继承，而无需重写。==</p>
<p>默认方法继承发生冲突如何解决<br>在Java中接口是可以多继承的，当一个类继承多个接口，但是默认方法相同的处理原则是：</p>
<ul>
<li>如果子类覆盖，直接调用子类方法  </li>
<li>如果函数有相同的签名，选择更加明确的默认方法，例如，Moveable和Walkable,Walkable继承于Moveable，那么就选择Walkable中的默认方法。</li>
<li>如果两个接口平级，没有继承关系，编译器报错。这个时候可以通过制定执行某个方法来确定  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Walkable.<span class="keyword">super</span>.move();</div><div class="line"><span class="comment">//or</span></div><div class="line">Moveable.<span class="keyword">super</span>.move();</div></pre></td></tr></table></figure>
<h2 id="函数式接口-Functional-Interface"><a href="#函数式接口-Functional-Interface" class="headerlink" title="函数式接口 Functional Interface"></a>函数式接口 Functional Interface</h2><p>抛出一个疑问：在我们书写一段 Lambda 表达式后，Java 编译器是如何进行类型推断的，它又是怎么知道重写的哪个方法的？</p>
<p>需要说明的是，不是每个接口都可以缩写成 Lambda 表达式。只有那些函数式接口（<code>Functional Interface</code>）才能缩写成 Lambda 表示式。</p>
<p>那么什么是函数式接口（Functional Interface）呢？</p>
<p>所谓函数式接口（Functional Interface）就是只包含一个抽象方法的声明。针对该接口类型的所有 Lambda 表达式都会与这个抽象方法匹配。</p>
<blockquote>
<p>注意：你可能会有疑问，Java 8 中不是允许通过 <code>defualt</code> 关键字来为接口添加默认方法吗？那它算不算抽象方法呢？答案是：不算。因此，你可以毫无顾忌的添加默认方法，它并不违反函数式接口（Functional Interface）的定义。</p>
</blockquote>
<p>总结一下：只要接口中仅仅包含一个抽象方法，我们就可以将其改写为 <code>Lambda</code> 表达式。为了保证一个接口明确的被定义为一个函数式接口（Functional Interface），Java 8添加了<code>@FunctionalInterface</code> 注解提示编译器检查是否是一个函数式接口，==这个注解并不是必须的==，只是起到提示的作用。推荐加上 <code>@FunctionalInterface</code> 来标记这个接口是函数式接口，就可以在编译期间检查错误。 函数式接口只能有一个抽象方法，但是可以添加任意的默认方法。</p>
<p>示例代码：</p>
<pre><code>@FunctionalInterface
interface Converter&lt;F, T&gt; {
    T convert(F from);
}
</code></pre><p>示例代码2：</p>
<pre><code>Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);
Integer converted = converter.convert(&quot;123&quot;);
System.out.println(converted);    // 123
</code></pre><h2 id="引用类的构造器及方法"><a href="#引用类的构造器及方法" class="headerlink" title="引用类的构造器及方法"></a>引用类的构造器及方法</h2><p>在Java 8中可以通过<code>class::methodName</code>的方式引用一个类或者实例的方法。</p>
<p><strong>方法引用的类型</strong></p>
<ul>
<li>引用静态方法：直接引用类的静态方法，例如<code>Math::max</code> 等同于 <code>Math.max(x,y)</code></li>
<li>通过实例引用实例方法：例如：<code>System.out::println</code>等同于<code>System.out.println(x)</code></li>
<li>通过类引用实例方法： 例如<code>String::length</code>等同于 <code>str.length()</code> </li>
<li>引用构造函数：例如<code>ArrayList::new</code>等同于 <code>new ArrayList()</code>       </li>
</ul>
<p>下面详细介绍一下这几种方法引用的形式：</p>
<ol>
<li>引用静态方法<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>);</div><div class="line">Optional&lt;Integer&gt; max = integers.stream().reduce(Math::max);</div><div class="line">max.ifPresent(value - &gt; System.out.println(value));</div></pre></td></tr></table></figure>
</li>
</ol>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">5</div></pre></td></tr></table></figure>
<ol>
<li>通过实例引用实例方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>);</div><div class="line">Optional&lt;Integer&gt; max = integers.stream().reduce(Math::max);</div><div class="line">max.ifPresent(value - &gt; System.out::println);</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">5</div></pre></td></tr></table></figure>
<ol>
<li>通过类引用实例方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; strings = Arrays</div><div class="line">        .asList(<span class="string">"how"</span>, <span class="string">"to"</span>, <span class="string">"do"</span>, <span class="string">"in"</span>, <span class="string">"java"</span>, <span class="string">"dot"</span>, <span class="string">"com"</span>);</div><div class="line"> </div><div class="line">List&lt;String&gt; sorted = strings</div><div class="line">        .stream()</div><div class="line">        .sorted((s1, s2) -&gt; s1.compareTo(s2))</div><div class="line">        .collect(Collectors.toList());</div><div class="line"> </div><div class="line">System.out.println(sorted);</div><div class="line"> </div><div class="line">List&lt;String&gt; sortedAlt = strings</div><div class="line">        .stream()</div><div class="line">        .sorted(String::compareTo)</div><div class="line">        .collect(Collectors.toList());</div><div class="line"> </div><div class="line">System.out.println(sortedAlt);</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[com, do, dot, how, in, java, to]</div><div class="line">[com, do, dot, how, in, java, to]</div></pre></td></tr></table></figure>
<ol>
<li>引用构造函数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; integers = IntStream</div><div class="line">                .range(1, 100)</div><div class="line">                .boxed()</div><div class="line">                .collect(Collectors.toCollection( ArrayList::new ));</div><div class="line"> </div><div class="line">Optional&lt;Integer&gt; max = integers.stream().reduce(Math::max);</div><div class="line"> </div><div class="line">max.ifPresent(System.out::println);</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">99</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</div><div class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</div><div class="line">System.out.println(converted);    <span class="comment">// 123</span></div></pre></td></tr></table></figure>
<p>上面这段代码，通过 Java 8 的新特性，进一步简化上面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</div><div class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</div><div class="line">System.out.println(converted);   <span class="comment">// 123</span></div></pre></td></tr></table></figure>
<p>Java 8 中允许你通过 <code>::</code> 关键字来引用类的方法或构造器。上面的代码简单的示例了如何引用静态方法，当然，除了静态方法，我们还可以引用普通方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">startsWith</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> String.valueOf(s.charAt(<span class="number">0</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Something something = <span class="keyword">new</span> Something();</div><div class="line">Converter&lt;String, String&gt; converter = something::startsWith;</div><div class="line">String converted = converter.convert(<span class="string">"Java"</span>);</div><div class="line">System.out.println(converted);    <span class="comment">// "J"</span></div></pre></td></tr></table></figure>
<p>接下来，我们再来看看如何通过 <code>::</code> 关键字来引用类的构造器。首先，我们先来定义一个示例类，在类中声明两个构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    String firstName;</div><div class="line">    String lastName;</div><div class="line"></div><div class="line">    Person() &#123;&#125;</div><div class="line"></div><div class="line">    Person(String firstName, String lastName) &#123;</div><div class="line">        <span class="keyword">this</span>.firstName = firstName;</div><div class="line">        <span class="keyword">this</span>.lastName = lastName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，我们再定义一个工厂接口，用来生成 <code>Person</code> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Person 工厂</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt; </span>&#123;</div><div class="line">    <span class="function">P <span class="title">create</span><span class="params">(String firstName, String lastName)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以通过 <code>::</code> 关键字来引用 <code>Person</code> 类的构造器，来代替手动去实现这个工厂接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 直接引用 Person 构造器</span></div><div class="line">PersonFactory&lt;Person&gt; personFactory = Person::<span class="keyword">new</span>;</div><div class="line">Person person = personFactory.create(<span class="string">"Peter"</span>, <span class="string">"Parker"</span>);</div></pre></td></tr></table></figure>
<p><code>Person::new</code> 这段代码，能够直接引用 <code>Person</code> 类的构造器。然后 Java 编译器能够根据上下文选中正确的构造器去实现 <code>PersonFactory.create</code> 方法。</p>
<h2 id="Lambda-访问外部变量及接口默认方法"><a href="#Lambda-访问外部变量及接口默认方法" class="headerlink" title="Lambda 访问外部变量及接口默认方法"></a>Lambda 访问外部变量及接口默认方法</h2><p>在本章节中，我们将会讨论如何在 lambda 表达式中访问外部变量（包括：局部变量，成员变量，静态变量，接口的默认方法.），它与匿名内部类访问外部变量很相似。</p>
<h3 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h3><p>在 Lambda 表达式中，我们可以访问外部的 <code>final</code> 类型变量，如下面的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 转换器</span></div><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line"></div><div class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>与匿名内部类不同的是，我们不必显式声明 <code>num</code> 变量为 <code>final</code> 类型，下面这段代码同样有效：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line"></div><div class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>但是 <code>num</code> 变量必须为隐式的 <code>final</code> 类型，何为隐式的 <code>final</code> 呢？就是说到编译期为止，<code>num</code> 对象是不能被改变的，如下面这段代码，就不能被编译通过：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line">num = <span class="number">3</span>;</div></pre></td></tr></table></figure>
<p>在 lambda 表达式内部改变 <code>num</code> 值同样编译不通过，需要注意, 比如下面的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</div><div class="line">Converter&lt;Integer, String&gt; converter = (from) -&gt; &#123;</div><div class="line">	String value = String.valueOf(from + num);</div><div class="line">	num = <span class="number">3</span>;</div><div class="line">	<span class="keyword">return</span> value;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="访问成员变量和静态变量"><a href="#访问成员变量和静态变量" class="headerlink" title="访问成员变量和静态变量"></a>访问成员变量和静态变量</h3><p>上一章节中，了解了如何在 Lambda 表达式中访问局部变量。与局部变量相比，在 Lambda 表达式中对成员变量和静态变量拥有读写权限：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lambda4</span> </span>&#123;</div><div class="line">        <span class="comment">// 静态变量</span></div><div class="line">        <span class="keyword">static</span> <span class="keyword">int</span> outerStaticNum;</div><div class="line">        <span class="comment">// 成员变量</span></div><div class="line">        <span class="keyword">int</span> outerNum;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">testScopes</span><span class="params">()</span> </span>&#123;</div><div class="line">            Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;</div><div class="line">                <span class="comment">// 对成员变量赋值</span></div><div class="line">                outerNum = <span class="number">23</span>;</div><div class="line">                <span class="keyword">return</span> String.valueOf(from);</div><div class="line">            &#125;;</div><div class="line"></div><div class="line">            Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;</div><div class="line">                <span class="comment">// 对静态变量赋值</span></div><div class="line">                outerStaticNum = <span class="number">72</span>;</div><div class="line">                <span class="keyword">return</span> String.valueOf(from);</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="访问接口的默认方法"><a href="#访问接口的默认方法" class="headerlink" title="访问接口的默认方法"></a>访问接口的默认方法</h3><p>还记得第一章节中定义的那个 <code>Formula</code> (公式) 接口吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>&#123;</div><div class="line">	<span class="comment">// 计算</span></div><div class="line">	<span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">// 求平方根</span></div><div class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> Math.sqrt(a);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当时，我们在接口中定义了一个带有默认实现的 <code>sqrt</code> 求平方根方法，在匿名内部类中我们可以很方便的访问此方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Formula formula = <span class="keyword">new</span> Formula() &#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> sqrt(a * <span class="number">100</span>);</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>但是在 lambda 表达式中可不行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Formula formula = (a) -&gt; sqrt(a * <span class="number">100</span>);</div></pre></td></tr></table></figure>
<p>带有默认实现的接口方法，是<strong>不能</strong>在 lambda 表达式中访问的，上面这段代码将无法被编译通过。</p>
<h2 id="内置的函数式接口"><a href="#内置的函数式接口" class="headerlink" title="内置的函数式接口"></a>内置的函数式接口</h2><p>JDK 1.8 API 包含了很多内置的函数式接口。其中就包括我们在老版本中经常见到的 Comparator 和 Runnable，Java 8 为他们都添加了 @FunctionalInterface 注解，以用来支持 Lambda 表达式。</p>
<p>值得一提的是，除了 Comparator 和 Runnable 外，还有一些新的函数式接口，它们很多都借鉴于知名的 <a href="https://github.com/google/guava" target="_blank" rel="external">Google Guava</a> 库。</p>
<p>对于它们，即使你已经非常熟悉了，还是最好了解一下的：</p>
<h3 id="Predicate-断言"><a href="#Predicate-断言" class="headerlink" title="Predicate 断言"></a>Predicate 断言</h3><p><code>Predicate</code> 是一个可以指定入参类型，并返回 boolean 值的函数式接口。它内部提供了一些带有默认实现的方法，可以<br>被用来组合一个复杂的逻辑判断（<code>and</code>, <code>or</code>, <code>negate</code>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; <span class="number">0</span>;</div><div class="line"></div><div class="line">predicate.test(<span class="string">"foo"</span>);              <span class="comment">// true</span></div><div class="line">predicate.negate().test(<span class="string">"foo"</span>);     <span class="comment">// false</span></div><div class="line">predicate.and((s) -&gt; s.contains(<span class="string">"a"</span>)).test(<span class="string">"foo"</span>);  <span class="comment">//false</span></div><div class="line"></div><div class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</div><div class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</div><div class="line"></div><div class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</div><div class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</div></pre></td></tr></table></figure>
<p>例如：在<code>filter</code>中 就会接收一个<code>Predicate</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns a stream consisting of the elements of this stream that match</div><div class="line"> * the given predicate.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;This is an &lt;a href="package-summary.html#StreamOps"&gt;intermediate</div><div class="line"> * operation&lt;/a&gt;.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> predicate a non-interfering stateless predicate to apply to each element to determine if it</div><div class="line"> * should be included in the new returned stream.</div><div class="line"> * <span class="doctag">@return</span> the new stream</div><div class="line"> */</div><div class="line"><span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</div></pre></td></tr></table></figure>
<p>下面来演示一下如何使用<code>Predicate</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> predicateExample;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> lombok.AccessLevel;</div><div class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</div><div class="line"><span class="keyword">import</span> lombok.Builder;</div><div class="line"><span class="keyword">import</span> lombok.Data;</div><div class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.function.Predicate;</div><div class="line"></div><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="meta">@Builder</span></div><div class="line"><span class="meta">@NoArgsConstructor</span></div><div class="line"><span class="meta">@AllArgsConstructor</span>(access = AccessLevel.PUBLIC)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Integer id;</div><div class="line">    <span class="keyword">private</span> Integer age;</div><div class="line">    <span class="keyword">private</span> String gender;</div><div class="line">    <span class="keyword">private</span> String firstName;</div><div class="line">    <span class="keyword">private</span> String lastName;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Predicate&lt;Member&gt; <span class="title">isAdultMale</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> p -&gt; p.getAge() &gt; <span class="number">21</span> &amp;&amp; p.getGender().equalsIgnoreCase(<span class="string">"M"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Predicate&lt;Member&gt; <span class="title">isAdultFemale</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> p -&gt; p.getAge() &gt; <span class="number">18</span> &amp;&amp; p.getGender().equalsIgnoreCase(<span class="string">"F"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Predicate&lt;Member&gt; <span class="title">isAgeMoreThan</span><span class="params">(Integer age)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> p -&gt; p.getAge() &gt; age;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码定义了多个<code>Predicate</code>，分别对应多个筛选条件，下面开始使用这些断言：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> predicateExample;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.function.Predicate;</div><div class="line"><span class="keyword">import</span> java.util.stream.Collectors;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberPredicates</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Predicate&lt;Member&gt; <span class="title">isAdultMale</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> p -&gt; p.getAge() &gt; <span class="number">21</span> &amp;&amp; p.getGender().equalsIgnoreCase(<span class="string">"M"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Predicate&lt;Member&gt; <span class="title">isAdultFemale</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> p -&gt; p.getAge() &gt; <span class="number">18</span> &amp;&amp; p.getGender().equalsIgnoreCase(<span class="string">"F"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Predicate&lt;Member&gt; <span class="title">isAgeMoreThan</span><span class="params">(Integer age)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> p -&gt; p.getAge() &gt; age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">filterMembers</span> <span class="params">(List&lt;Member&gt; employees, Predicate&lt;Member&gt; predicate)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> employees.stream().filter( predicate ).map(Member::getId).collect(Collectors.toList());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">package predicateExample;</div><div class="line"> </div><div class="line">import com.mintbao.eva.dto.admin.Member;</div><div class="line">import com.mintbao.eva.dto.admin.MemberPredicates;</div><div class="line">import lombok.extern.slf4j.Slf4j;</div><div class="line"></div><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.Arrays;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">@Slf4j</div><div class="line">public class TestMemberPredicates &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Member member = new Member(1, 23, &quot;M&quot;, &quot;Rick&quot;, &quot;Beethovan&quot;);</div><div class="line">        Member member1 = new Member(2, 13, &quot;F&quot;, &quot;Martina&quot;, &quot;Hengis&quot;);</div><div class="line">        Member member2 = new Member(3, 43, &quot;M&quot;, &quot;Ricky&quot;, &quot;Martin&quot;);</div><div class="line">        Member member3 = new Member(4, 26, &quot;M&quot;, &quot;Jon&quot;, &quot;Lowman&quot;);</div><div class="line">        Member member4 = new Member(5, 19, &quot;F&quot;, &quot;Cristine&quot;, &quot;Maria&quot;);</div><div class="line">        Member member5 = new Member(6, 15, &quot;M&quot;, &quot;David&quot;, &quot;Feezor&quot;);</div><div class="line">        Member member6 = new Member(7, 68, &quot;F&quot;, &quot;Melissa&quot;, &quot;Roy&quot;);</div><div class="line">        Member member7 = new Member(8, 79, &quot;M&quot;, &quot;Alex&quot;, &quot;Gussin&quot;);</div><div class="line">        Member member8 = new Member(9, 15, &quot;F&quot;, &quot;Neetu&quot;, &quot;Singh&quot;);</div><div class="line">        Member member9 = new Member(10, 45, &quot;M&quot;, &quot;Naveen&quot;, &quot;Jain&quot;);</div><div class="line"></div><div class="line">        List&lt;Member&gt; employees = new ArrayList&lt;&gt;(Arrays.asList(member, member1, member2, member3, member4, member5, member6, member7, member8, member9));</div><div class="line"></div><div class="line">        log.info(&quot;adult and male: &#123;&#125;&quot;, MemberPredicates.filterMembers(employees, MemberPredicates.isAdultMale()));</div><div class="line"></div><div class="line">        log.info(&quot;adult and female: &#123;&#125;&quot;, MemberPredicates.filterMembers(employees, MemberPredicates.isAdultFemale()));</div><div class="line"></div><div class="line">        log.info(&quot;older than: &#123;&#125;&quot;, MemberPredicates.filterMembers(employees, MemberPredicates.isAgeMoreThan(35)));</div><div class="line"></div><div class="line">        log.info(&quot;not older than: &#123;&#125;&quot;, MemberPredicates.filterMembers(employees, MemberPredicates.isAgeMoreThan(35).negate()));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">adult and male: [1, 3, 4, 8, 10]</div><div class="line">adult and female: [5, 7]</div><div class="line">older than: [3, 7, 8, 10]</div><div class="line">not older than: [1, 2, 4, 5, 6, 9]</div></pre></td></tr></table></figure>
<p><strong>正则表达式表示：</strong><br>可以通过<code>Pattern.compile().asPredicate()</code>将正则表达式转换为<code>Predicate</code>。 在Java 8之前，从一个数组中找出符合正则规则的字符串的方法是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.regex.Matcher;</div><div class="line"><span class="keyword">import</span> java.util.regex.Pattern;</div><div class="line"></div><div class="line"><span class="meta">@Slf</span>4j</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMemberPredicates</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EMAIL_PATTERN = <span class="string">"^(.+)@example.com$"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Pattern pattern = Pattern.compile(EMAIL_PATTERN);</div><div class="line"></div><div class="line">        List&lt;String&gt; emails = Arrays.asList(<span class="string">"alex@example.com"</span>, <span class="string">"bob@yahoo.com"</span>,</div><div class="line">                <span class="string">"cat@google.com"</span>, <span class="string">"david@example.com"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (String email : emails) &#123;</div><div class="line">            Matcher matcher = pattern.matcher(email);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (matcher.matches()) &#123;</div><div class="line">                log.info(email);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>转换为Predicat：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.function.Predicate;</div><div class="line"><span class="keyword">import</span> java.util.regex.Pattern;</div><div class="line"><span class="keyword">import</span> java.util.stream.Collectors;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexPredicateExample</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// Compile regex as predicate</span></div><div class="line">        Predicate&lt;String&gt; emailFilter = Pattern</div><div class="line">                .compile(EMAIL_PATTERN)</div><div class="line">                .asPredicate();</div><div class="line"></div><div class="line">        <span class="comment">// Input list</span></div><div class="line">        List&lt;String&gt; emails = Arrays.asList(<span class="string">"alex@example.com"</span>, <span class="string">"bob@yahoo.com"</span>,</div><div class="line">                <span class="string">"cat@google.com"</span>, <span class="string">"david@example.com"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// Apply predicate filter</span></div><div class="line">        List&lt;String&gt; desiredEmails = emails</div><div class="line">                .stream()</div><div class="line">                .filter(emailFilter)</div><div class="line">                .collect(Collectors.toList());</div><div class="line"></div><div class="line">        <span class="comment">// Now perform desired operation</span></div><div class="line">        desiredEmails.forEach(log::info);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p><code>Function</code> 函数式接口的作用是，我们可以为其提供一个原料，他给生产一个最终的产品。通过它提供的默认方法，组合,链行处理(<code>compose</code>, <code>andThen</code>)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</div><div class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</div><div class="line"></div><div class="line">backToString.apply(<span class="string">"123"</span>);     <span class="comment">// "123"</span></div></pre></td></tr></table></figure>
<h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p><code>Optional</code>是Java8提供的为了解决<code>null</code>安全问题的一个API。善用<code>Optional</code>可以使我们代码中很多繁琐、丑陋的设计变得十分优雅。这篇文章是建立在你对Optional的用法有一定了解的基础上的，如果你还不太了解Optional，可以先去看看相关教程，或者查阅Java文档。</p>
<p>使用Optional，我们就可以把下面这样的代码进行改写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName</span><span class="params">(User u)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (u == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="string">"Unknown"</span>;</div><div class="line">    <span class="keyword">return</span> u.name;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过，千万不要这样改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName</span><span class="params">(User u)</span> </span>&#123;</div><div class="line">    Optional&lt;User&gt; user = Optional.ofNullable(u);</div><div class="line">    <span class="keyword">if</span> (!user.isPresent())</div><div class="line">        <span class="keyword">return</span> <span class="string">"Unknown"</span>;</div><div class="line">    <span class="keyword">return</span> user.get().name;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样改写非但不简洁，而且其操作还是和第一段代码一样。无非就是用<code>isPresent</code>方法来替代<code>u==null</code>。这样的改写并不是<code>Optional</code>正确的用法，我们再来改写一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName</span><span class="params">(User u)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Optional.ofNullable(u)</div><div class="line">                    .map(user-&gt;user.name)</div><div class="line">                    .orElse(<span class="string">"Unknown"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样才是正确使用<code>Optional</code>的姿势。那么按照这种思路，我们可以安心的进行==链式调用==，而不是一层层判断了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getChampionName</span><span class="params">(Competition comp)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (comp != <span class="keyword">null</span>) &#123;</div><div class="line">        CompResult result = comp.getResult();</div><div class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</div><div class="line">            User champion = result.getChampion();</div><div class="line">            <span class="keyword">if</span> (champion != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> champion.getName();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The value of param comp isn't available."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于种种原因（比如：比赛还没有产生冠军、方法的非正常调用、某个方法的实现里埋藏的大礼包等等），我们并不能开心的一路<code>comp.getResult().getChampion().getName(</code>到底。而其他语言比如<code>kotlin</code>，就提供了在语法层面的操作符加持：<code>comp?.getResult()?.getChampion()?.getName()</code>。</p>
<p>让我们看看经过Optional加持过后，这些代码会变成什么样子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getChampionName</span><span class="params">(Competition comp)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</div><div class="line">    <span class="keyword">return</span> Optional.ofNullable(comp)</div><div class="line">            .map(c-&gt;c.getResult())</div><div class="line">            .map(r-&gt;r.getChampion())</div><div class="line">            .map(u-&gt;u.getName())</div><div class="line">            .orElseThrow(()-&gt;<span class="keyword">new</span> IllegalArgumentException(<span class="string">"The value of param comp isn't available."</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Optional</code>给了我们一个真正优雅的<code>Java</code>风格的方法来解决<code>null</code>安全问题。虽然没有直接提供一个操作符写起来短，但是代码看起来依然很爽很舒服。更何况?.这样的语法好不好看还见仁见智呢。</p>
<p>还有很多不错的使用姿势，比如为空则不打印可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">string.ifPresent(System.out::println);</div></pre></td></tr></table></figure>
<p><code>Optional</code>的魅力还不止于此，<code>Optional</code>还有一些神奇的用法，比如<code>Optional</code>可以用来检验参数的合法性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = Optional.ofNullable(name).filter(User::isNameValid)</div><div class="line">                        .orElseThrow(()-&gt;<span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid username."</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Optional&lt;Integer&gt; canBeEmpty1 = Optional.of(<span class="number">5</span>);</div><div class="line">canBeEmpty1.isPresent();         <span class="comment">// returns true</span></div><div class="line">canBeEmpty1.get();             <span class="comment">// returns 5</span></div><div class="line"> </div><div class="line">Optional&lt;Integer&gt; canBeEmpty2 = Optional.empty();</div><div class="line">canBeEmpty2.isPresent();         <span class="comment">// returns false</span></div></pre></td></tr></table></figure>
<p>可以将<code>Optional</code>看作单值容器，要么包含一个值，要么不包含。注意，<code>Optional</code>并不能完全替代所有的<code>null</code>引用，它的主要作用是用来设计更易理解的API，==当一个函数返回的是<code>Optional</code>的时候，调用者就会注意需要检测其是否有值才能够调用==。</p>
<p> <strong>创建Optional对象</strong></p>
<p>主要有三种创建Optional对象的方法 </p>
<p> 1).使用 Optional.empty() 创建一个空的Optional</p>
<pre><code>   Optional&lt;Integer&gt; possible = Optional.empty();
</code></pre><p> 2). 使用Optional.of() 创建一个非null的值。</p>
<pre><code>   Optional&lt;Integer&gt; possible = Optional.of(5);
</code></pre><p> 3). 使用<code>Optional.ofNullable()</code> 创建一个可以包含空值的Optional对象，如果参数是null，则返回一个空的Optional</p>
<pre><code>    Optional&lt;Integer&gt; possible = Optional.ofNullable(5);
</code></pre><p><strong>处理Optional的值</strong></p>
<p>当得到一个<code>Optional</code>的值的时候，首先需要检查其是否包含了值</p>
<pre><code>Optional&lt;Integer&gt; possible = Optional.of(5);
possible.ifPresent(System.out::println);
</code></pre><p>当然上面的代码也可以通过下面的方式重写：</p>
<pre><code>if(possible.isPresent()){
    System.out.println(possible.get());
}
</code></pre><p>不过这么做并不推荐，因为这个处理<code>null</code>没啥区别。推荐使用上面的代码返回<code>Optional</code></p>
<p>一般来讲对于方法如果最终需要返回<code>null</code>的时候，都会返回一个默认值以便替换<code>null</code>，使用<code>Optional</code>可以使用如下的方式返回</p>
<pre><code>Optional&lt;Company&gt; companyOptional = Optional.empty();
</code></pre><p>检查Optional，如果有值直接返回，否则返回 <code>new Company()</code>;</p>
<pre><code>Company company = companyOptional.orElse(new Company());
</code></pre><p>检查Optional，如果有值直接返回，否则返回 抛出异常;</p>
<pre><code>Company company  = companyOptional.orElseThrow(IllegalStateException::new);
</code></pre><p>在<code>Filter</code>中使用<code>Optional</code></p>
<p>例如：</p>
<pre><code>Optional&lt;Company&gt; companyOptional = Optional.empty();
companyOptional.filter(department -&gt; &quot;Finance&quot;.equals(department.getName())
                .ifPresent(() -&gt; System.out.println(&quot;Finance is present&quot;));)
</code></pre><p><code>filter</code> 函数接受一个<code>Predicate</code>接口作为参数，如果<code>Optional</code>中存在值，那么就会匹配直接输出。</p>
<p><strong>结论</strong></p>
<p><code>Optional</code>的目的并不是要完全替代<code>null</code>引用，而是为了设计更友好的API而设计的。</p>
<h3 id="Supplier-生产者"><a href="#Supplier-生产者" class="headerlink" title="Supplier 生产者"></a>Supplier 生产者</h3><p><code>Supplier</code> 与 <code>Function</code> 不同，它不接受入参，直接为我们生产一个指定的结果，有点像生产者模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    String firstName;</div><div class="line">    String lastName;</div><div class="line"></div><div class="line">    Person() &#123;&#125;</div><div class="line"></div><div class="line">    Person(String firstName, String lastName) &#123;</div><div class="line">        <span class="keyword">this</span>.firstName = firstName;</div><div class="line">        <span class="keyword">this</span>.lastName = lastName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;</div><div class="line">personSupplier.get();   <span class="comment">// new Person</span></div></pre></td></tr></table></figure>
<h3 id="Consumer-消费者"><a href="#Consumer-消费者" class="headerlink" title="Consumer 消费者"></a>Consumer 消费者</h3><p>对于 <code>Consumer</code>，我们需要提供入参，用来被消费，如下面这段示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    String firstName;</div><div class="line">    String lastName;</div><div class="line"></div><div class="line">    Person() &#123;&#125;</div><div class="line"></div><div class="line">    Person(String firstName, String lastName) &#123;</div><div class="line">        <span class="keyword">this</span>.firstName = firstName;</div><div class="line">        <span class="keyword">this</span>.lastName = lastName;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">```java</div><div class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(<span class="string">"Hello, "</span> + p.firstName);</div><div class="line">greeter.accept(<span class="keyword">new</span> Person(<span class="string">"Luke"</span>, <span class="string">"Skywalker"</span>));</div></pre></td></tr></table></figure>
<h3 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h3><p><code>Comparator</code> 在 Java 8 之前是使用比较普遍的。Java 8 中除了将其升级成了函数式接口，还为它拓展了一些默认方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</div><div class="line"></div><div class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="string">"Doe"</span>);</div><div class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"Alice"</span>, <span class="string">"Wonderland"</span>);</div><div class="line"></div><div class="line">comparator.compare(p1, p2);             <span class="comment">// &gt; 0</span></div><div class="line">comparator.reversed().compare(p1, p2);  <span class="comment">// &lt; 0</span></div></pre></td></tr></table></figure>
<h2 id="Stream-流"><a href="#Stream-流" class="headerlink" title="Stream 流"></a>Stream 流</h2><p>这一章节，我们开始步入学习 <code>Stream</code> 流。</p>
<p><em>什么是 <code>Stream</code> 流？</em></p>
<p>简单来说，我们可以使用 <code>java.util.Stream</code> 对一个包含一个或多个元素的集合做各种操作。这些操作可能是 <em>中间操作</em> 亦或是 <em>终端操作</em>。<br>终端操作会返回一个结果，而中间操作会返回一个 <code>Stream</code> 流。</p>
<p>需要注意的是，你只能对实现了 <code>java.util.Collection</code> 接口的类做流的操作。</p>
<blockquote>
<p><code>Map</code> 不支持 <code>Stream</code> 流。</p>
</blockquote>
<p><code>Stream</code> 流支持同步执行，也支持并发执行。 </p>
<h3 id="Filter-过滤"><a href="#Filter-过滤" class="headerlink" title="Filter 过滤"></a>Filter 过滤</h3><p>首先，我们创建一个 <code>List</code> 集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; stringCollection = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">stringCollection.add(<span class="string">"ddd2"</span>);</div><div class="line">stringCollection.add(<span class="string">"aaa2"</span>);</div><div class="line">stringCollection.add(<span class="string">"bbb1"</span>);</div><div class="line">stringCollection.add(<span class="string">"aaa1"</span>);</div><div class="line">stringCollection.add(<span class="string">"bbb3"</span>);</div><div class="line">stringCollection.add(<span class="string">"ccc"</span>);</div><div class="line">stringCollection.add(<span class="string">"bbb2"</span>);</div><div class="line">stringCollection.add(<span class="string">"ddd1"</span>);</div></pre></td></tr></table></figure>
<p><code>Filter</code> 的入参是一个 <code>Predicate</code>, 上面已经说到，<code>Predicate</code> 是一个断言的中间操作，它能够帮我们筛选出我们需要的集合元素。它的返参同样是一个 <code>Stream</code> 流，我们可以通过 <code>foreach</code> 终端操作，来打印被筛选的元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">stringCollection</div><div class="line">    .stream()</div><div class="line">    .filter((s) -&gt; s.startsWith(<span class="string">"a"</span>))</div><div class="line">    .forEach(System.out::println);</div><div class="line"></div><div class="line"><span class="comment">// "aaa2", "aaa1"</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>foreach</code> 是一个终端操作，它的返参是 <code>void</code>, 我们无法对其再次进行流操作。</p>
</blockquote>
<h3 id="Sorted-排序"><a href="#Sorted-排序" class="headerlink" title="Sorted 排序"></a>Sorted 排序</h3><p><code>Sorted</code> 同样是一个中间操作，它的返参是一个 <code>Stream</code> 流。另外，我们可以传入一个 <code>Comparator</code> 用来自定义排序，如果不传，则使用默认的自然排序。</p>
<p>// resourceDOS是一个List<resourcedo>,实体和list定义省略<br>// 根据修改时间排序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">resourceDOS.stream().sorted(Comparator.comparing(ResourceDO::getUpdateTime()).collect(Collectors.toList());</div><div class="line"></div><div class="line">resourceDOS.stream().sorted(Comparator.comparing(e -&gt; e.getUpdateTime()).collect(Collectors.toList());</div></pre></td></tr></table></figure></resourcedo></p>
<p>// 使用Comparator.reversed()可以反转一个排序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">resourceDOS.stream().sorted(Comparator.comparing(ResourceDO::getUpdateTime().reversed()).collect(Collectors.toList());</div></pre></td></tr></table></figure></p>
<p>// 先根据<code>updateTime</code>排序，再根据<code>createTime</code>排序，使用<code>thenComparing()</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">resourceDOS.stream().sorted(Comparator.comparing(ResourceDO::getUpdateTime().thenComparing(ResourceDO::getCreateTime)).collect(Collectors.toList());</div></pre></td></tr></table></figure></p>
<p>// 自然排序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">stringCollection</div><div class="line">    .stream()</div><div class="line">    .sorted()</div><div class="line">    .filter((s) -&gt; s.startsWith(<span class="string">"a"</span>))</div><div class="line">    .forEach(System.out::println);</div><div class="line"></div><div class="line"><span class="comment">// "aaa1", "aaa2"</span></div></pre></td></tr></table></figure></p>
<h4 id="并行排序-只需要使用-parallelSort-即可进行并行排序。"><a href="#并行排序-只需要使用-parallelSort-即可进行并行排序。" class="headerlink" title="并行排序,只需要使用 parallelSort() 即可进行并行排序。"></a>并行排序,只需要使用 <code>parallelSort()</code> 即可进行并行排序。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Parallel Sorting</span></div><div class="line">ResourceDO[] resourceDOArray = resourceDOS.toArray(<span class="keyword">new</span> ResourceDO[resourceDOS.size()]);</div><div class="line">Arrays.parallelSort(resourceDOArray, Comparator.comparing(ResourceDO::getUpdateTime().thenComparing(ResourceDO::getCreateTime));</div><div class="line">System.out.println(resourceDOArray);</div></pre></td></tr></table></figure>
<p>需要注意，<code>sorted</code> 不会对 <code>stringCollection</code> 做出任何改变，<code>stringCollection</code> 还是原有的那些元素，且顺序不变，需要使用排序后的就得重新赋值或者保存到新的集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(stringCollection);</div><div class="line"><span class="comment">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</span></div></pre></td></tr></table></figure>
<h3 id="count-和-counting-统计数量"><a href="#count-和-counting-统计数量" class="headerlink" title="count() 和 counting() 统计数量"></a>count() 和 counting() 统计数量</h3><p><code>count</code> 是一个终端操作，它能够统计 <code>stream</code> 流中的元素总数，返回值是 <code>long</code> 类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 先对 list 中字符串开头为 b 进行过滤，然后统计数量</span></div><div class="line"><span class="keyword">long</span> startsWithB =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .filter((s) -&gt; s.startsWith(<span class="string">"b"</span>))</div><div class="line">        .count();</div><div class="line"></div><div class="line">System.out.println(startsWithB);    <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>和counting()<code>的区别是，</code>count()<code>是一个终端操作，对</code>Stream<code>计数并返回一个</code>long<code>，</code>counting()<code>则是</code>Collector`的收集方法,用法区别如下：</p>
<p>使用<code>counting()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">long</span> count = Stream.of(<span class="string">"how"</span>,<span class="string">"to"</span>,<span class="string">"do"</span>,<span class="string">"in"</span>,<span class="string">"java"</span>).collect(Collectors.counting());</div><div class="line">    System.out.printf(<span class="string">"There are %d elements in the stream %n"</span>, count);</div><div class="line">     </div><div class="line">    count = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>).collect(Collectors.counting());</div><div class="line">    System.out.printf(<span class="string">"There are %d elements in the stream %n"</span>, count);</div><div class="line">     </div><div class="line">    count = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>).filter(i -&gt; i%<span class="number">2</span> == <span class="number">0</span>).collect(Collectors.counting());</div><div class="line">    System.out.printf(<span class="string">"There are %d elements in the stream %n"</span>, count);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Map-转换-将Stream中的元素从一种形式转化为另一种形式"><a href="#Map-转换-将Stream中的元素从一种形式转化为另一种形式" class="headerlink" title="Map 转换(将Stream中的元素从一种形式转化为另一种形式)"></a>Map 转换(将Stream中的元素从一种形式转化为另一种形式)</h3><p>中间操作 <code>Map</code> 能够帮助我们将 <code>List</code> 中的每一个元素做功能处理。例如下面的示例，通过 <code>map</code> 我们将每一个 <code>string</code> 转成大写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">stringCollection</div><div class="line">    .stream()</div><div class="line">    .map(String::toUpperCase)</div><div class="line">    .sorted((a, b) -&gt; b.compareTo(a))</div><div class="line">    .forEach(System.out::println);</div><div class="line"></div><div class="line"><span class="comment">// "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "AAA2", "AAA1"</span></div></pre></td></tr></table></figure>
<p>另外，我们还可以做对象之间的转换，业务中比较常用的是将 <code>DO</code>（数据库对象） 转换成 <code>VO</code>（表现对象） 。</p>
<h3 id="Match-匹配"><a href="#Match-匹配" class="headerlink" title="Match 匹配"></a>Match 匹配</h3><p>顾名思义，<code>match</code> 用来做匹配操作，它的返回值是一个 <code>boolean</code> 类型。通过 <code>match</code>, 我们可以方便的验证一个 <code>list</code> 中是否存在某个类型的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 验证 list 中 string 是否有以 a 开头的, 匹配到第一个，即返回 true</span></div><div class="line"><span class="keyword">boolean</span> anyStartsWithA =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .anyMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</div><div class="line"></div><div class="line">System.out.println(anyStartsWithA);      <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 验证 list 中 string 是否都是以 a 开头的</span></div><div class="line"><span class="keyword">boolean</span> allStartsWithA =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .allMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</div><div class="line"></div><div class="line">System.out.println(allStartsWithA);      <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="comment">// 验证 list 中 string 是否都不是以 z 开头的,</span></div><div class="line"><span class="keyword">boolean</span> noneStartsWithZ =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .noneMatch((s) -&gt; s.startsWith(<span class="string">"z"</span>));</div><div class="line"></div><div class="line">System.out.println(noneStartsWithZ);      <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="collect-转换为Collection"><a href="#collect-转换为Collection" class="headerlink" title="collect()转换为Collection"></a>collect()转换为Collection</h3><p><code>collect()</code> 收集<code>stream</code>中的元素转化为<code>collection</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; memNamesInUppercase = stringCollection.stream().sorted()</div><div class="line">                            .map(String::toUpperCase)</div><div class="line">                            .collect(Collectors.toList());</div></pre></td></tr></table></figure>
<h4 id="原生类型转换"><a href="#原生类型转换" class="headerlink" title="原生类型转换"></a>原生类型转换</h4><p>对于原生类型不能直接使用这些方法，可以通过使用boxed()方法做中间处理，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; ints = IntStream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</div><div class="line">                .boxed()</div><div class="line">                .collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p>也可以使用<code>mapToLong(),mapToDouble,mapToObj()</code>方法来实现例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; ints = IntStream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</div><div class="line">            .mapToObj(Integer::valueOf)</div><div class="line">            .collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p>对于<code>LongStream和DoubleStream</code>都有相同的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">List&lt;Long&gt; longs = LongStream.of(<span class="number">1l</span>,<span class="number">2l</span>,<span class="number">3l</span>,<span class="number">4l</span>,<span class="number">5l</span>)</div><div class="line">                .boxed()</div><div class="line">                .collect(Collectors.toList());</div><div class="line">                </div><div class="line">List&lt;Double&gt; doubles = DoubleStream.of(<span class="number">1</span>d,<span class="number">2</span>d,<span class="number">3</span>d,<span class="number">4</span>d,<span class="number">5</span>d)</div><div class="line">                .boxed()</div><div class="line">                .collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p>同样可以利用<code>Stream</code>来生成随机数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomNumberExample</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        Random random = <span class="keyword">new</span> Random();</div><div class="line">         </div><div class="line">        <span class="comment">//Five random integers</span></div><div class="line"> </div><div class="line">        random.ints( <span class="number">5</span> ).sorted().forEach( System.out::println );</div><div class="line"> </div><div class="line">        <span class="comment">//Five random doubles between 0 (inclusive) and 0.5 (exclusive)</span></div><div class="line"> </div><div class="line">        random.doubles( <span class="number">5</span>, <span class="number">0</span>, <span class="number">0.5</span> ).sorted().forEach( System.out::println );</div><div class="line"> </div><div class="line">        <span class="comment">//Boxing long to Long so they can be collected</span></div><div class="line"> </div><div class="line">        List&lt;Long&gt; longs = random.longs( <span class="number">5</span> ).boxed().collect( Collectors.toList() );</div><div class="line">        System.out.println(longs);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">-110679835</div><div class="line">156507518</div><div class="line">1493532761</div><div class="line">2054227999</div><div class="line">2086798656</div><div class="line"></div><div class="line">7.724902934355127E-4</div><div class="line">0.2688148659358355</div><div class="line">0.3525387800324165</div><div class="line">0.3947437475521328</div><div class="line">0.4903926740688234</div><div class="line"></div><div class="line">[-2722967875761490425, 5531368074516893531, -8225300378125625898, </div><div class="line">-9067114159502460546, -5286357091370510421]</div></pre></td></tr></table></figure>
<h3 id="toArray-转换为数组"><a href="#toArray-转换为数组" class="headerlink" title="toArray()转换为数组"></a>toArray()转换为数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] intArray = IntStream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).toArray();</div></pre></td></tr></table></figure>
<h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach()"></a>foreach()</h3><p>其作用是遍历<code>stream</code>所有的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">memberNames.forEach(System.out::println);</div></pre></td></tr></table></figure>
<h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><p>中间操作返回的是Stream本身，所以多个中间操作可以作为处理链处理Stream</p>
<h3 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h3><p>终止操作会返回一个特定的类型，而不是返回<code>Stream</code>本身。</p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p><code>Reduce</code> 中文翻译为：<em>减少、缩小</em>。通过入参的 <code>Function</code>，我们能够将 <code>list</code> 归约成一个值。它的返回类型是 <code>Optional</code> 类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Optional&lt;String&gt; reduced =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .sorted()</div><div class="line">        .reduce((s1, s2) -&gt; s1 + <span class="string">"#"</span> + s2);</div><div class="line"></div><div class="line">reduced.ifPresent(System.out::println);</div><div class="line"><span class="comment">// "aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2"</span></div></pre></td></tr></table></figure>
<h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct()"></a>distinct()</h3><p>可以使用<code>Stream.distinct()</code>来过滤相同元素，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Collection&lt;String&gt; list = Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>);</div><div class="line"> </div><div class="line"><span class="comment">// Get collection without duplicated element distinct only</span></div><div class="line">List&lt;String&gt; distinctElements = list.stream().distinct().collect(Collectors.toList());</div><div class="line"> </div><div class="line"><span class="comment">//Let's verify distinct elements</span></div><div class="line">System.out.println(distinctElements);</div></pre></td></tr></table></figure></p>
<p>通过<code>distinct()</code>函数过滤非常的简单容易，但是大多数情况下，处理的对象多会比较复杂，例如包含各种属性等，很少会只处理原生类型和字符串。 我们可以通过定制一个 <code>Predicate</code>的接口来处理复杂对象，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">distinctByKey</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, Object&gt; keyExtractor)</span></span></div><div class="line">&#123;</div><div class="line">    Map&lt;Object, Boolean&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">    <span class="keyword">return</span> t -&gt; map.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法非常的简单，通过<code>ConcurrentHashMap</code>来确定是否包含某个元素，其接受一个函数式对象的引用。下面我们来使用这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.Collection;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</div><div class="line"><span class="keyword">import</span> java.util.function.Function;</div><div class="line"><span class="keyword">import</span> java.util.function.Predicate;</div><div class="line"><span class="keyword">import</span> java.util.stream.Collectors;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaStreamDistinctExamples</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        Person lokesh = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"Lokesh"</span>, <span class="string">"Gupta"</span>);</div><div class="line">        Person brian = <span class="keyword">new</span> Person(<span class="number">2</span>, <span class="string">"Brian"</span>, <span class="string">"Clooney"</span>);</div><div class="line">        Person alex = <span class="keyword">new</span> Person(<span class="number">3</span>, <span class="string">"Alex"</span>, <span class="string">"Kolen"</span>);</div><div class="line">         </div><div class="line">        <span class="comment">//Add some random persons</span></div><div class="line">        Collection&lt;Person&gt; list = Arrays.asList(lokesh,brian,alex,lokesh,brian,lokesh);</div><div class="line"> </div><div class="line">        <span class="comment">// Get distinct only</span></div><div class="line">        List&lt;Person&gt; distinctElements = list.stream().filter(distinctByKey(p -&gt; p.getId())).collect(Collectors.toList());</div><div class="line"> </div><div class="line">        <span class="comment">// Let's verify distinct elements</span></div><div class="line">        System.out.println(distinctElements);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">distinctByKey</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, Object&gt; keyExtractor)</span></span></div><div class="line">    &#123;</div><div class="line">        Map&lt;Object, Boolean&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">        <span class="keyword">return</span> t -&gt; map.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer id, String fname, String lname)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">        <span class="keyword">this</span>.fname = fname;</div><div class="line">        <span class="keyword">this</span>.lname = lname;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">private</span> Integer id;</div><div class="line">    <span class="keyword">private</span> String fname;</div><div class="line">    <span class="keyword">private</span> String lname;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> id;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFname</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> fname;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFname</span><span class="params">(String fname)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.fname = fname;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLname</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> lname;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLname</span><span class="params">(String lname)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.lname = lname;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Person [id="</span> + id + <span class="string">", fname="</span> + fname + <span class="string">", lname="</span> + lname + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="max-和-min"><a href="#max-和-min" class="headerlink" title="max() 和 min()"></a>max() 和 min()</h3><p>对于<code>max和min</code>，只需要给他们传递一个<code>Comparator</code>，就可以进行比较，从而获取最大和最小值。</p>
<p>获取最大，最小得日期<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">LocalDate start = LocalDate.now();</div><div class="line">LocalDate end = LocalDate.now().plusMonths(<span class="number">1</span>).with(TemporalAdjusters.lastDayOfMonth());</div><div class="line">List&lt;LocalDate&gt; dates = Stream.iterate(start, date -&gt; date.plusDays(<span class="number">1</span>))</div><div class="line">                        .limit(ChronoUnit.DAYS.between(start, end))</div><div class="line">                        .collect(Collectors.toList());</div><div class="line"> </div><div class="line"><span class="comment">// Get Min or Max Date</span></div><div class="line">LocalDate maxDate = dates.stream().max( Comparator.comparing( LocalDate::toEpochDay ) ).get();</div><div class="line">LocalDate minDate = dates.stream().min( Comparator.comparing( LocalDate::toEpochDay ) ).get();</div><div class="line"> </div><div class="line">System.out.println(<span class="string">"maxDate = "</span> + maxDate);</div><div class="line">System.out.println(<span class="string">"minDate = "</span> + minDate);</div></pre></td></tr></table></figure></p>
<p>获取最大数和最小数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Integer maxNumber = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</div><div class="line">                    .max(Comparator.comparing(Integer::valueOf)).get();</div><div class="line">Integer minNumber = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</div><div class="line">                    .min(Comparator.comparing(Integer::valueOf)).get();</div><div class="line"> </div><div class="line">System.out.println(<span class="string">"maxNumber = "</span> + maxNumber);</div><div class="line">System.out.println(<span class="string">"minNumber = "</span> + minNumber);</div></pre></td></tr></table></figure>
<p>获取最大的char或者String<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String maxChar = Stream.of(<span class="string">"H"</span>, <span class="string">"T"</span>, <span class="string">"D"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>).max(Comparator.comparing(String::valueOf)).get();</div><div class="line">String minChar = Stream.of(<span class="string">"H"</span>, <span class="string">"T"</span>, <span class="string">"D"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>).min(Comparator.comparing(String::valueOf)).get();</div><div class="line"> </div><div class="line">System.out.println(<span class="string">"maxChar = "</span> + maxChar);</div><div class="line">System.out.println(<span class="string">"minChar = "</span> + minChar);</div></pre></td></tr></table></figure></p>
<p>获取最大和最小的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">List&lt;Employee&gt; emps = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</div><div class="line"> </div><div class="line">emps.add(<span class="keyword">new</span> Employee(<span class="number">1</span>, <span class="string">"Lokesh"</span>, <span class="number">36</span>));</div><div class="line">emps.add(<span class="keyword">new</span> Employee(<span class="number">2</span>, <span class="string">"Alex"</span>, <span class="number">46</span>));</div><div class="line">emps.add(<span class="keyword">new</span> Employee(<span class="number">3</span>, <span class="string">"Brian"</span>, <span class="number">52</span>));</div><div class="line"> </div><div class="line">Comparator&lt;Employee&gt; comparator = Comparator.comparing(Employee::getAge);</div><div class="line"> </div><div class="line"><span class="comment">// Get Min or Max Object</span></div><div class="line">Employee minObject = emps.stream().min(comparator).get();</div><div class="line">Employee maxObject = emps.stream().max(comparator).get();</div><div class="line"> </div><div class="line">System.out.println(<span class="string">"minObject = "</span> + minObject);</div><div class="line">System.out.println(<span class="string">"maxObject = "</span> + maxObject);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> id;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        StringBuilder str = <span class="keyword">null</span>;</div><div class="line">        str = <span class="keyword">new</span> StringBuilder();</div><div class="line">        str.append(<span class="string">"Id:- "</span> + getId() + <span class="string">" Name:- "</span> + getName() + <span class="string">" Age:- "</span> + getAge());</div><div class="line">        <span class="keyword">return</span> str.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Parallel-Streams-并行流"><a href="#Parallel-Streams-并行流" class="headerlink" title="Parallel-Streams 并行流"></a>Parallel-Streams 并行流</h3><p>前面章节我们说过，<code>stream</code> 流是支持<strong>顺序</strong>和<strong>并行</strong>的。顺序流操作是单线程操作，而并行流是通过多线程来处理的，能够充分利用物理机多核 CPU 的优势，同时处理速度更快。</p>
<p>首先，我们创建一个包含 1000000 UUID list 集合。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> max = <span class="number">1000000</span>;</div><div class="line">List&lt;String&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;(max);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</div><div class="line">    UUID uuid = UUID.randomUUID();</div><div class="line">    values.add(uuid.toString());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分别通过顺序流和并行流，对这个 list 进行排序，测算耗时:</p>
<h4 id="顺序流排序"><a href="#顺序流排序" class="headerlink" title="顺序流排序"></a>顺序流排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 纳秒</span></div><div class="line"><span class="keyword">long</span> t0 = System.nanoTime();</div><div class="line"></div><div class="line"><span class="keyword">long</span> count = values.stream().sorted().count();</div><div class="line">System.out.println(count);</div><div class="line"></div><div class="line"><span class="keyword">long</span> t1 = System.nanoTime();</div><div class="line"></div><div class="line"><span class="comment">// 纳秒转微秒</span></div><div class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</div><div class="line">System.out.println(String.format(<span class="string">"顺序流排序耗时: %d ms"</span>, millis));</div><div class="line"></div><div class="line"><span class="comment">// 顺序流排序耗时: 899 ms</span></div></pre></td></tr></table></figure>
<h4 id="并行流排序"><a href="#并行流排序" class="headerlink" title="并行流排序"></a>并行流排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 纳秒</span></div><div class="line"><span class="keyword">long</span> t0 = System.nanoTime();</div><div class="line"></div><div class="line"><span class="keyword">long</span> count = values.parallelStream().sorted().count();</div><div class="line">System.out.println(count);</div><div class="line"></div><div class="line"><span class="keyword">long</span> t1 = System.nanoTime();</div><div class="line"></div><div class="line"><span class="comment">// 纳秒转微秒</span></div><div class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</div><div class="line">System.out.println(String.format(<span class="string">"并行流排序耗时: %d ms"</span>, millis));</div><div class="line"></div><div class="line"><span class="comment">// 并行流排序耗时: 472 ms</span></div></pre></td></tr></table></figure>
<p>正如你所见，同样的逻辑处理，通过并行流，我们的性能提升了近 <strong>50%</strong>。完成这一切，我们需要做的仅仅是将 <code>stream</code> 改成了 <code>parallelStream</code>。</p>
<h2 id="Map-集合"><a href="#Map-集合" class="headerlink" title="Map 集合"></a>Map 集合</h2><p>前面已经提到过 <code>Map</code> 是不支持 <code>Stream</code> 流的，因为 <code>Map</code> 接口并没有像 <code>Collection</code> 接口那样，定义了 <code>stream()</code> 方法。但是，我们可以对其 <code>key</code>, <code>values</code>, <code>entry</code> 使用<br>流操作，如 <code>map.keySet().stream()</code>, <code>map.values().stream()</code> 和 <code>map.entrySet().stream()</code>.</p>
<p>另外, JDK 8 中对 <code>map</code> 提供了一些其他新特性:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    <span class="comment">// 与老版不同的是，putIfAbent() 方法在 put 之前，</span></div><div class="line">    <span class="comment">// 会判断 key 是否已经存在，存在则直接返回 value, 否则 put, 再返回 value</span></div><div class="line">    map.putIfAbsent(i, <span class="string">"val"</span> + i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// forEach 可以很方便地对 map 进行遍历操作</span></div><div class="line">map.forEach((key, value) -&gt; System.out.println(value));</div></pre></td></tr></table></figure>
<p>除了上面的 <code>putIfAbsent()</code> 和 <code>forEach()</code> 外，我们还可以很方便地对某个 <code>key</code> 的值做相关操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// computeIfPresent(), 当 key 存在时，才会做相关处理</span></div><div class="line"><span class="comment">// 如下：对 key 为 3 的值，内部会先判断值是否存在，存在，则做 value + key 的拼接操作</span></div><div class="line">map.computeIfPresent(<span class="number">3</span>, (num, val) -&gt; val + num);</div><div class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></div><div class="line"></div><div class="line"><span class="comment">// 先判断 key 为 9 的元素是否存在，存在，则做删除操作</span></div><div class="line">map.computeIfPresent(<span class="number">9</span>, (num, val) -&gt; <span class="keyword">null</span>);</div><div class="line">map.containsKey(<span class="number">9</span>);     <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="comment">// computeIfAbsent(), 当 key 不存在时，才会做相关处理</span></div><div class="line"><span class="comment">// 如下：先判断 key 为 23 的元素是否存在，不存在，则添加</span></div><div class="line">map.computeIfAbsent(<span class="number">23</span>, num -&gt; <span class="string">"val"</span> + num);</div><div class="line">map.containsKey(<span class="number">23</span>);    <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 先判断 key 为 3 的元素是否存在，存在，则不做任何处理</span></div><div class="line">map.computeIfAbsent(<span class="number">3</span>, num -&gt; <span class="string">"bam"</span>);</div><div class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></div></pre></td></tr></table></figure>
<p>关于删除操作，JDK 8 中提供了能够新的 <code>remove()</code> API:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">map.remove(<span class="number">3</span>, <span class="string">"val3"</span>);</div><div class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></div><div class="line"></div><div class="line">map.remove(<span class="number">3</span>, <span class="string">"val33"</span>);</div><div class="line">map.get(<span class="number">3</span>);             <span class="comment">// null</span></div></pre></td></tr></table></figure>
<p>如上代码，只有当给定的 <code>key</code> 和 <code>value</code> 完全匹配时，才会执行删除操作。</p>
<p>关于添加方法，JDK 8 中提供了带有默认值的 <code>getOrDefault()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 若 key 42 不存在，则返回 not found</span></div><div class="line">map.getOrDefault(<span class="number">42</span>, <span class="string">"not found"</span>);  <span class="comment">// not found</span></div></pre></td></tr></table></figure>
<p>对于 <code>value</code> 的合并操作也变得更加简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// merge 方法，会先判断进行合并的 key 是否存在，不存在，则会添加元素</span></div><div class="line">map.merge(<span class="number">9</span>, <span class="string">"val9"</span>, (value, newValue) -&gt; value.concat(newValue));</div><div class="line">map.get(<span class="number">9</span>);             <span class="comment">// val9</span></div><div class="line"></div><div class="line"><span class="comment">// 若 key 的元素存在，则对 value 执行拼接操作</span></div><div class="line">map.merge(<span class="number">9</span>, <span class="string">"concat"</span>, (value, newValue) -&gt; value.concat(newValue));</div><div class="line">map.get(<span class="number">9</span>);             <span class="comment">// val9concat</span></div></pre></td></tr></table></figure>
<h2 id="新的日期-API"><a href="#新的日期-API" class="headerlink" title="新的日期 API"></a>新的日期 API</h2><p>Java 8 中在包 <code>java.time</code> 下添加了新的日期 API. 它和 <a href="http://www.joda.org/joda-time/" target="_blank" rel="external">Joda-Time</a> 库相似，但又不完全相同。接下来，我会通过一些示例代码介绍一下新 API 中<br>最关键的特性：</p>
<h3 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h3><p><code>Clock</code> 提供对当前日期和时间的访问。我们可以利用它来替代 <code>System.currentTimeMillis()</code> 方法。另外，通过 <code>clock.instant()</code> 能够获取一个 <code>instant</code> 实例，<br>此实例能够方便地转换成老版本中的 <code>java.util.Date</code> 对象。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Clock clock = Clock.systemDefaultZone();</div><div class="line"><span class="keyword">long</span> millis = clock.millis();</div><div class="line"></div><div class="line">Instant instant = clock.instant();</div><div class="line">Date legacyDate = Date.from(instant);   <span class="comment">// 老版本 java.util.Date</span></div></pre></td></tr></table></figure>
<h3 id="Timezones-时区"><a href="#Timezones-时区" class="headerlink" title="Timezones 时区"></a>Timezones 时区</h3><p><code>ZoneId</code> 代表时区类。通过静态工厂方法方便地获取它，入参我们可以传入某个时区编码。另外，时区类还定义了一个偏移量，用来在当前时刻或某时间<br>与目标时区时间之间进行转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">System.out.println(ZoneId.getAvailableZoneIds());</div><div class="line"><span class="comment">// prints all available timezone ids</span></div><div class="line"></div><div class="line">ZoneId zone1 = ZoneId.of(<span class="string">"Europe/Berlin"</span>);</div><div class="line">ZoneId zone2 = ZoneId.of(<span class="string">"Brazil/East"</span>);</div><div class="line">System.out.println(zone1.getRules());</div><div class="line">System.out.println(zone2.getRules());</div><div class="line"></div><div class="line"><span class="comment">// ZoneRules[currentStandardOffset=+01:00]</span></div><div class="line"><span class="comment">// ZoneRules[currentStandardOffset=-03:00]</span></div></pre></td></tr></table></figure>
<h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><p><code>LocalTime</code> 表示一个没有指定时区的时间类，例如，<code>10 p.m</code>.或者 <code>17：30:15</code>，下面示例代码中，将会使用上面创建的<br>时区对象创建两个 <code>LocalTime</code>。然后我们会比较两个时间，并计算它们之间的小时和分钟的不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LocalTime now1 = LocalTime.now(zone1);</div><div class="line">LocalTime now2 = LocalTime.now(zone2);</div><div class="line"></div><div class="line">System.out.println(now1.isBefore(now2));  <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">long</span> hoursBetween = ChronoUnit.HOURS.between(now1, now2);</div><div class="line"><span class="keyword">long</span> minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</div><div class="line"></div><div class="line">System.out.println(hoursBetween);       <span class="comment">// -3</span></div><div class="line">System.out.println(minutesBetween);     <span class="comment">// -239</span></div></pre></td></tr></table></figure>
<p><code>LocalTime</code> 提供多个静态工厂方法，目的是为了简化对时间对象实例的创建和操作，包括对时间字符串进行解析的操作等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LocalTime late = LocalTime.of(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</div><div class="line">System.out.println(late);       <span class="comment">// 23:59:59</span></div><div class="line"></div><div class="line">DateTimeFormatter germanFormatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofLocalizedTime(FormatStyle.SHORT)</div><div class="line">        .withLocale(Locale.GERMAN);</div><div class="line"></div><div class="line">LocalTime leetTime = LocalTime.parse(<span class="string">"13:37"</span>, germanFormatter);</div><div class="line">System.out.println(leetTime);   <span class="comment">// 13:37</span></div></pre></td></tr></table></figure>
<h2 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h2><p><code>LocalDate</code> 是一个日期对象，例如：<code>2014-03-11</code>。它和 <code>LocalTime</code> 一样是个 <code>final</code> 类型对象。下面的例子演示了如何通过加减日，月，年等来计算一个新的日期。</p>
<blockquote>
<p><code>LocalDate</code>, <code>LocalTime</code>, 因为是 <code>final</code> 类型的对象，每一次操作都会返回一个新的时间对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LocalDate today = LocalDate.now();</div><div class="line"><span class="comment">// 今天加一天</span></div><div class="line">LocalDate tomorrow = today.plus(<span class="number">1</span>, ChronoUnit.DAYS);</div><div class="line"><span class="comment">// 明天减两天</span></div><div class="line">LocalDate yesterday = tomorrow.minusDays(<span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">// 2014 年七月的第四天</span></div><div class="line">LocalDate independenceDay = LocalDate.of(<span class="number">2014</span>, Month.JULY, <span class="number">4</span>);</div><div class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</div><div class="line">System.out.println(dayOfWeek);    <span class="comment">// 星期五</span></div></pre></td></tr></table></figure>
<p>也可以直接解析日期字符串，生成 <code>LocalDate</code> 实例。（和 <code>LocalTime</code> 操作一样简单）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">DateTimeFormatter germanFormatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofLocalizedDate(FormatStyle.MEDIUM)</div><div class="line">        .withLocale(Locale.GERMAN);</div><div class="line"></div><div class="line">LocalDate xmas = LocalDate.parse(<span class="string">"24.12.2014"</span>, germanFormatter);</div><div class="line">System.out.println(xmas);   <span class="comment">// 2014-12-24</span></div></pre></td></tr></table></figure>
<h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p><code>LocalDateTime</code> 是一个<strong>日期-时间</strong>对象。你也可以将其看成是 <code>LocalDate</code> 和 <code>LocalTime</code> 的结合体。操作上，也大致相同。</p>
<blockquote>
<p><code>LocalDateTime</code> 同样是一个 <code>final</code> 类型对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">LocalDateTime sylvester = LocalDateTime.of(<span class="number">2014</span>, Month.DECEMBER, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</div><div class="line"></div><div class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</div><div class="line">System.out.println(dayOfWeek);      <span class="comment">// 星期三</span></div><div class="line"></div><div class="line">Month month = sylvester.getMonth();</div><div class="line">System.out.println(month);          <span class="comment">// 十二月</span></div><div class="line"></div><div class="line"><span class="comment">// 获取改时间是该天中的第几分钟</span></div><div class="line"><span class="keyword">long</span> minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</div><div class="line">System.out.println(minuteOfDay);    <span class="comment">// 1439</span></div></pre></td></tr></table></figure>
<p>如果再加上的时区信息，<code>LocalDateTime</code> 还能够被转换成 <code>Instance</code> 实例。<code>Instance</code> 能够被转换成老版本中 <code>java.util.Date</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Instant instant = sylvester</div><div class="line">        .atZone(ZoneId.systemDefault())</div><div class="line">        .toInstant();</div><div class="line"></div><div class="line">Date legacyDate = Date.from(instant);</div><div class="line">System.out.println(legacyDate);     <span class="comment">// Wed Dec 31 23:59:59 CET 2014</span></div></pre></td></tr></table></figure>
<p>格式化 <code>LocalDateTime</code> 对象就和格式化 LocalDate 或者 LocalTime 一样。除了使用预定义的格式以外，也可以自定义格式化输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">DateTimeFormatter formatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofPattern(<span class="string">"MMM dd, yyyy - HH:mm"</span>);</div><div class="line"></div><div class="line">LocalDateTime parsed = LocalDateTime.parse(<span class="string">"Nov 03, 2014 - 07:13"</span>, formatter);</div><div class="line">String string = formatter.format(parsed);</div><div class="line">System.out.println(string);     <span class="comment">// Nov 03, 2014 - 07:13</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：和 <code>java.text.NumberFormat</code> 不同，新的 <code>DateTimeFormatter</code> 类是 <code>final</code> 类型的，同时也是线程安全的。更多细节请查看<a href="http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html" target="_blank" rel="external">这里</a></p>
</blockquote>
<h2 id="Annotations-注解"><a href="#Annotations-注解" class="headerlink" title="Annotations 注解"></a>Annotations 注解</h2><p>在 Java 8 中，注解是可以重复的。让我通过下面的示例代码，来看看到底是咋回事。</p>
<p>首先，我们定义一个包装注解，里面包含了一个有着实际注解的数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@interface</span> Hints &#123;</div><div class="line">    Hint[] value();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Repeatable</span>(Hints.class)</div><div class="line"><span class="meta">@interface</span> Hint &#123;</div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Java 8 中，通过 <code>@Repeatable</code>，允许我们对同一个类使用多重注解：</p>
<p>第一种形态：使用注解容器（老方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Hints</span>(&#123;<span class="meta">@Hint</span>(<span class="string">"hint1"</span>), <span class="meta">@Hint</span>(<span class="string">"hint2"</span>)&#125;)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>第二种形态：使用可重复注解（新方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Hint</span>(<span class="string">"hint1"</span>)</div><div class="line"><span class="meta">@Hint</span>(<span class="string">"hint2"</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>使用第二种形态，Java 编译器能够在内部自动对 <code>@Hint</code> 进行设置。这对于需要通过反射来读取注解信息时，是非常重要的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Hint hint = Person.class.getAnnotation(Hint.class);</div><div class="line">System.out.println(hint);                   <span class="comment">// null</span></div><div class="line"></div><div class="line">Hints hints1 = Person.class.getAnnotation(Hints.class);</div><div class="line">System.out.println(hints1.value().length);  <span class="comment">// 2</span></div><div class="line"></div><div class="line">Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);</div><div class="line">System.out.println(hints2.length);          <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>尽管我们绝对不会在 <code>Person</code> 类上声明 <code>@Hints</code> 注解，但是它的信息仍然是可以通过 <code>getAnnotation(Hints.class)</code> 来读取的。并且，<code>getAnnotationsByType</code> 方法会更方便，因为它赋予了所有 <code>@Hints</code> 注解标注的方法直接的访问权限。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)</div><div class="line"><span class="meta">@interface</span> MyAnnotation &#123;&#125;</div></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Java 8 新特性的编程指南到此就告一段落了。当然，还有很多内容需要进一步研究和说明。这就需要靠读者您来对 <code>JDK 8</code> 进一步探究了，例如：<code>Arrays.parallelSort</code>, <code>StampedLock</code> 和 <code>CompletableFuture</code> 等等，我这里也仅是起到抛砖引玉的作用而已。</p>
<p>最后，我希望这个讲解能够对您有所帮助，也希望您阅读愉快。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/java.jpg&quot; alt=&quot;jdk8&quot; title=&quot;jdk8&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;本文翻译整理自 &lt;a href=&quot;https://github.com/winterbe/java8-tutorial&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/winterbe/java8-tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;希望阅读完本文的小伙伴能够熟练掌握和应用 Java8 的各种特性，使其成为在工作中的一门利器。话不多说，让我们一起开启 Java8 新特性之旅吧！&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;接口内允许添加默认实现的方法&quot;&gt;&lt;a href=&quot;#接口内允许添加默认实现的方法&quot; class=&quot;headerlink&quot; title=&quot;接口内允许添加默认实现的方法&quot;&gt;&lt;/a&gt;接口内允许添加默认实现的方法&lt;/h2&gt;&lt;p&gt;Java 8 允许我们通过 &lt;code&gt;default&lt;/code&gt; 关键字对接口中定义的抽象方法提供一个默认的实现。&lt;/p&gt;
&lt;p&gt;请看下面示例代码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 定义一个公式接口&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Formula&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 计算&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;calculate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 求平方根&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Math.sqrt(a);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在上面这个接口中，我们除了定义了一个抽象方法 &lt;code&gt;calculate&lt;/code&gt;，还定义了一个带有默认实现的方法 &lt;code&gt;sqrt&lt;/code&gt;。&lt;br&gt;我们在实现这个接口时，可以只需要实现 &lt;code&gt;calculate&lt;/code&gt; 方法，默认方法 &lt;code&gt;sqrt&lt;/code&gt; 可以直接调用即可，也就是说我们可以不必强制实现 &lt;code&gt;sqrt&lt;/code&gt; 方法。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://jethan.bid/categories/java/"/>
    
    
      <category term="jdk8" scheme="http://jethan.bid/tags/jdk8/"/>
    
  </entry>
  
  <entry>
    <title>Cron</title>
    <link href="http://jethan.bid/2017/12/05/Cron/"/>
    <id>http://jethan.bid/2017/12/05/Cron/</id>
    <published>2017-12-05T08:11:06.000Z</published>
    <updated>2017-12-05T08:11:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../../../../../../../../../../img/icons/cron.png" alt="cron" title="cron"></p>
<h2 id="cron表达式格式"><a href="#cron表达式格式" class="headerlink" title="cron表达式格式"></a>cron表达式格式</h2><ul>
<li>{秒数} {分钟} {小时} {日期} {月份} {星期} {年份(可为空)}</li>
</ul>
<p>先了解每个位置代表的含义，再了解每个位置允许的范围，以及一些特殊写法，还有常用的案例，足够你掌握<code>cron</code>表达式</p>
<h3 id="每个字段的允许值"><a href="#每个字段的允许值" class="headerlink" title="每个字段的允许值"></a>每个字段的允许值</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字段</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">允许值</th>
<th style="text-align:center">允许的特殊字符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Seconds</td>
<td style="text-align:center">秒</td>
<td style="text-align:center">0-59</td>
<td style="text-align:center">, - * /</td>
</tr>
<tr>
<td style="text-align:center">Minutes</td>
<td style="text-align:center">分</td>
<td style="text-align:center">0-59</td>
<td style="text-align:center">, - * /</td>
</tr>
<tr>
<td style="text-align:center">Hours</td>
<td style="text-align:center">小时</td>
<td style="text-align:center">0-23</td>
<td style="text-align:center">, - * /</td>
</tr>
<tr>
<td style="text-align:center">Day-of-Month</td>
<td style="text-align:center">日期</td>
<td style="text-align:center">1-31</td>
<td style="text-align:center">, - * ? / L W C</td>
</tr>
<tr>
<td style="text-align:center">Month</td>
<td style="text-align:center">月份</td>
<td style="text-align:center">1-12 或者 JAN-DEC</td>
<td style="text-align:center">, - * /</td>
</tr>
<tr>
<td style="text-align:center">Day-of-Week</td>
<td style="text-align:center">星期</td>
<td style="text-align:center">1-7 或者 SUN-SAT</td>
<td style="text-align:center">, - * ? / L C #</td>
</tr>
<tr>
<td style="text-align:center">Year</td>
<td style="text-align:center">年（可选）</td>
<td style="text-align:center">留空, 1970-2099</td>
<td style="text-align:center">, - * /</td>
</tr>
</tbody>
</table>
</div>
<a id="more"></a>
<h4 id="秒"><a href="#秒" class="headerlink" title="秒"></a>秒</h4><p>允许值范围: 0~59 ,不允许为空值，若值不合法，调度器将抛出<code>SchedulerException</code>异常</p>
<ul>
<li><code>*</code> 代表每隔1秒钟触发</li>
<li><code>,</code> 代表在指定的秒数触发，比如”0,15,45”代表0秒、15秒和45秒时触发任务</li>
<li><code>-</code>  代表在指定的范围内触发，比如”25-45”代表从25秒开始触发到45秒结束触发，每隔1秒触发1次</li>
<li><code>/</code> 代表触发步进(step)，”/“前面的值代表初始值(“*“等同”0”)，后面的值代表偏移量，比如”0/20”或者”*/20”代表从0秒钟开始，每隔20秒钟触发1次，即0秒触发1次，20秒触发1次，40秒触发1次；”5/20”代表5秒触发1次，25秒触发1次，45秒触发1次；”10-45/20”代表在[10,45]内步进20秒命中的时间点触发，即10秒触发1次，30秒触发1次</li>
</ul>
<h4 id="分钟"><a href="#分钟" class="headerlink" title="分钟"></a>分钟</h4><p>允许值范围: 0~59 ,不允许为空值，若值不合法，调度器将抛出<code>SchedulerException</code>异常</p>
<ul>
<li><code>*</code> 代表每隔1分钟触发</li>
<li><code>,</code> 代表在指定的分钟触发，比如”10,20,40”代表10分钟、20分钟和40分钟时触发任务</li>
<li><code>-</code>代表在指定的范围内触发，比如”5-30”代表从5分钟开始触发到30分钟结束触 发，每隔1分钟触发</li>
<li><code>/</code>代表触发步进(step)，”/“前面的值代表初始值(“<em>“等同”0”)，后面的值代表偏移量，比如”0/25”或者”</em>/25”代表从0分钟开始，每隔25分钟触发1次，即0分钟触发1次，第25分钟触发1次，第50分钟触发1次；”5/25”代表5分钟触发1次，30分钟触发1次，55分钟触发1次；”10-45/20”代表在[10,45]内步进20分钟命中的时间点触发，即10分钟触发1次，30分钟触发1次</li>
</ul>
<h4 id="小时"><a href="#小时" class="headerlink" title="小时"></a>小时</h4><p>允许值范围: 0~23 ,不允许为空值，若值不合法，调度器将抛出<code>SchedulerException</code>异常</p>
<ul>
<li><code>*</code> 代表每隔1小时触发</li>
<li><code>,</code> 代表在指定的时间点触发，比如”10,20,23”代表10点钟、20点钟和23点触发任务</li>
<li><code>-</code> 代表在指定的时间段内触发，比如”20-23”代表从20点开始触发到23点结束触发，每隔1小时触发</li>
<li><code>/</code> 代表触发步进(step)，”/“前面的值代表初始值(“<em>“等同”0”)，后面的值代表偏移量，比如”0/1”或者”</em>/1”代表从0点开始触发，每隔1小时触发1次；”1/2”代表从1点开始触发，以后每隔2小时触发一次</li>
</ul>
<h4 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h4><p>允许值范围: 1~12 (JAN-DEC),不允许为空值，若值不合法，调度器将抛出<code>SchedulerException</code>异常</p>
<ul>
<li><code>*</code> 代表每个月都触发</li>
<li><code>,</code> 代表在指定的月份触发，比如”1,6,12”代表1月份、6月份和12月份触发任务</li>
<li><code>-</code> 代表在指定的月份范围内触发，比如”1-6”代表从1月份开始触发到6月份结束触发，每隔1个月触发</li>
<li><code>/</code> 代表触发步进(step)，”/“前面的值代表初始值(“<em>“等同”1”)，后面的值代表偏移量，比如”1/2”或者”</em>/2”代表从1月份开始触发，每隔2个月触发1次；”6/6”代表从6月份开始触发，以后每隔6个月触发一次；”1-6/12”表达式意味着每年1月份触发</li>
</ul>
<h4 id="星期"><a href="#星期" class="headerlink" title="星期"></a>星期</h4><p>允许值范围: 1~7 (SUN-SAT),1代表星期天(一星期的第一天)，以此类推，7代表星期六(一星期的最后一天)，不允许为空值，若值不合法，调度器将抛出<code>SchedulerException</code>异常</p>
<ul>
<li><code>*</code> 代表每星期都触发；</li>
<li><code>?</code> 与{日期}互斥，即意味着若明确指定{日期}触发，则表示{星期}无意义，以免引起冲突和混乱</li>
<li><code>,</code> 代表在指定的星期约定触发，比如”1,3,5”代表星期天、星期二和星期四触发</li>
<li><code>-</code> 代表在指定的星期范围内触发，比如”2-4”代表从星期一开始触发到星期三结束触发，每隔1天触发</li>
<li><code>/</code> 代表触发步进(step)，”/“前面的值代表初始值(“<em>“等同”1”)，后面的值代表偏移量，比如”1/3”或者”</em>/3”代表从星期天开始触发，每隔3天触发1次；”1-5/2”表达式意味着在[1,5]范围内，每隔2天触发，即星期天、星期二、星期四触发</li>
<li><code>L</code> 如果{星期}占位符如果是”L”，即意味着星期的的最后一天触发，即星期六触发，L= 7或者 L = SAT，因此，”5L”意味着一个月的最后一个星期四触发</li>
<li><code>#</code> 用来指定具体的周数，”#”前面代表星期，”#”后面代表本月第几周，比如”2#2”表示本月第二周的星期一，”5#3”表示本月第三周的星期四，因此，”5L”这种形式只不过是”#”的特殊形式而已</li>
</ul>
<h4 id="年份"><a href="#年份" class="headerlink" title="年份"></a>年份</h4><p>允许值范围: 1970~2099 ,允许为空，若值不合法，调度器将抛出<code>SchedulerException</code>异常</p>
<ul>
<li><code>*</code> 代表每年都触发</li>
<li><code>,</code> 代表在指定的年份才触发，比如”2011,2012,2013”代表2011年、2012年和2013年触发任务</li>
<li><code>-</code> 代表在指定的年份范围内触发，比如”2011-2020”代表从2011年开始触发到2020年结束触发，每隔1年触发</li>
<li><code>/</code> 代表触发步进(step)，”/“前面的值代表初始值(“<em>“等同”1970”)，后面的值代表偏移量，比如”2011/2”或者”</em>/2”代表从2011年开始触发，每隔2年触发1次</li>
</ul>
<p><strong>注意：</strong> 除了{日期}和{星期}可以使用”?”来实现互斥，表达无意义的信息之外，其他占位符都要具有具体的时间含义，且依赖关系为：年-&gt;月-&gt;日期(星期)-&gt;小时-&gt;分钟-&gt;秒数</p>
<h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h4><h5 id=""><a href="#" class="headerlink" title="*"></a>*</h5><p><code>*</code> 字符被用来指定所有的值。如：”*”在分钟的字段域里表示“每分钟”。</p>
<h5 id="-1"><a href="#-1" class="headerlink" title="?"></a>?</h5><p><code>?</code> 字符只在日期域和星期域中使用。它被用来指定“非明确的值”。当你需要通过在这两个域中的一个来指定一些东西的时候，它是有用的。看下面的例子你就会明白。 月份中的日期和星期中的日期这两个元素时互斥的一起应该通过设置一个问号来表明不想设置那个字段。</p>
<h5 id="-2"><a href="#-2" class="headerlink" title="-"></a>-</h5><p><code>-</code> 字符被用来指定一个范围。如：“10-12”在小时域意味着“10点、11点、12点”。</p>
<h5 id="-3"><a href="#-3" class="headerlink" title=","></a>,</h5><p><code>,</code> 字符被用来指定另外的值。如：“MON,WED,FRI”在星期域里表示”星期一、星期三、星期五”。</p>
<h5 id="-4"><a href="#-4" class="headerlink" title="/"></a>/</h5><p><code>/</code> 字符用于指定增量。如：“0/15”在秒域意思是每分钟的0，15，30和45秒。“5/15”在分钟域表示每小时的5，20，35和50。符号“<em>”在“/”前面（如：</em>/10）等价于0在“/”前面（如：0/10）。记住一条本质：表达式的每个数值域都是一个有最大值和最小值的集合，如：秒域和分钟域的集合是0-59，日期域是1-31，月份域是1-12。字符“/”可以帮助你在每个字符域中取相应的数值。如：“7/6”在月份域的时候只有当7月的时候才会触发，并不是表示每个6月。</p>
<h5 id="L"><a href="#L" class="headerlink" title="L"></a>L</h5><p><code>L</code> 是‘last’的省略写法可以表示day-of-month和day-of-week域，但在两个字段中的意思不同，例如day-of-month域中表示一个月的最后一天。如果在day-of-week域表示‘7’或者‘SAT’，如果在day-of-week域中前面加上数字，它表示一个月的最后几天，例如‘6L’就表示一个月的最后一个星期五。</p>
<h5 id="W"><a href="#W" class="headerlink" title="W"></a>W</h5><p><code>W</code> 字符“W”只允许日期域出现。这个字符用于指定日期的最近工作日。例如：如果你在日期域中写 “15W”，表示：这个月15号最近的工作日。所以，如果15号是周六，则任务会在14号触发。如果15好是周日，则任务会在周一也就是16号触发。如果是在日期域填写“1W”即使1号是周六，那么任务也只会在下周一，也就是3号触发，“W”字符指定的最近工作日是不能够跨月份的。字符“W”只能配合一个单独的数值使用，不能够是一个数字段，如：1-15W是错误的。</p>
<p><code>L</code>和<code>W</code>可以在日期域中联合使用，LW表示这个月最后一周的工作日。</p>
<h5 id="-5"><a href="#-5" class="headerlink" title="\"></a>\</h5><p><code>#</code> 字符“#”只允许在星期域中出现。这个字符用于指定本月的某某天。例如：“6#3”表示本月第三周的星期五（6表示星期五，3表示第三周）。“2#1”表示本月第一周的星期一。“4#5”表示第五周的星期三。</p>
<h5 id="C"><a href="#C" class="headerlink" title="C"></a>C</h5><p><code>C</code> 字符“C”允许在日期域和星期域出现。这个字符依靠一个指定的“日历”。也就是说这个表达式的值依赖于相关的“日历”的计算结果，如果没有“日历”关联，则等价于所有包含的“日历”。如：日期域是“5C”表示关联“日历”中第一天，或者这个月开始的第一天的后5天。星期域是“1C”表示关联“日历”中第一天，或者星期的第一天的后1天，也就是周日的后一天（周一）。</p>
<h4 id="一些cron表达式案例"><a href="#一些cron表达式案例" class="headerlink" title="一些cron表达式案例"></a>一些cron表达式案例</h4><ul>
<li><em>/5 </em> <em> </em> * ? 每隔5秒执行一次</li>
<li>0 <em>/1 </em> <em> </em> ? 每隔1分钟执行一次</li>
<li>0 0 5-15 <em> </em> ? 每天5-15点整点触发</li>
<li>0 0/3 <em> </em> * ? 每三分钟触发一次</li>
<li>0 0-5 14 <em> </em> ? 在每天下午2点到下午2:05期间的每1分钟触发 </li>
<li>0 0/5 14 <em> </em> ? 在每天下午2点到下午2:55期间的每5分钟触发</li>
<li>0 0/5 14,18 <em> </em> ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发</li>
<li>0 0/30 9-17 <em> </em> ? 朝九晚五工作时间内每半小时</li>
<li>0 0 10,14,16 <em> </em> ? 每天上午10点，下午2点，4点 </li>
<li>0 0 12 ? * WED 表示每个星期三中午12点</li>
<li>0 0 17 ? * TUES,THUR,SAT 每周二、四、六下午五点</li>
<li>0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 </li>
<li>0 15 10 ? * MON-FRI 周一至周五的上午10:15触发</li>
<li>0 0 23 L * ? 每月最后一天23点执行一次</li>
<li>0 15 10 L * ? 每月最后一日的上午10:15触发 </li>
<li>0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发 </li>
<li>0 15 10 <em> </em> ? 2005 2005年的每天上午10:15触发 </li>
<li>0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发 </li>
<li>0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发</li>
<li>“30 <em> </em> <em> </em> ?” 每半分钟触发任务</li>
<li>“30 10 <em> </em> * ?” 每小时的10分30秒触发任务</li>
<li>“30 10 1 <em> </em> ?” 每天1点10分30秒触发任务</li>
<li>“30 10 1 20 * ?” 每月20号1点10分30秒触发任务</li>
<li>“30 10 1 20 10 ? *” 每年10月20号1点10分30秒触发任务</li>
<li>“30 10 1 20 10 ? 2011” 2011年10月20号1点10分30秒触发任务</li>
<li>“30 10 1 ? 10 * 2011” 2011年10月每天1点10分30秒触发任务</li>
<li>“30 10 1 ? 10 SUN 2011” 2011年10月每周日1点10分30秒触发任务</li>
<li>“15,30,45 <em> </em> <em> </em> ?” 每15秒，30秒，45秒时触发任务</li>
<li>“15-45 <em> </em> <em> </em> ?” 15到45秒内，每秒都触发任务</li>
<li>“15/5 <em> </em> <em> </em> ?” 每分钟的每15秒开始触发，每隔5秒触发一次</li>
<li>“15-30/5 <em> </em> <em> </em> ?” 每分钟的15秒到30秒之间开始触发，每隔5秒触发一次</li>
<li>“0 0/3 <em> </em> * ?” 每小时的第0分0秒开始，每三分钟触发一次</li>
<li>“0 15 10 ? * MON-FRI” 星期一到星期五的10点15分0秒触发任务</li>
<li>“0 15 10 L * ?” 每个月最后一天的10点15分0秒触发任务</li>
<li>“0 15 10 LW * ?” 每个月最后一个工作日的10点15分0秒触发任务</li>
<li>“0 15 10 ? * 5L” 每个月最后一个星期四的10点15分0秒触发任务</li>
<li>“0 15 10 ? * 5#3” 每个月第三周的星期四的10点15分0秒触发任务</li>
</ul>
<h3 id="表达式生成器"><a href="#表达式生成器" class="headerlink" title="表达式生成器"></a>表达式生成器</h3><p>有很多的cron表达式在线生成器，这里给大家推荐几款<br><a href="http://www.bejson.com/othertools/cron/" target="_blank" rel="external">http://www.bejson.com/othertools/cron/</a><br><a href="http://cron.qqe2.com/" target="_blank" rel="external">http://cron.qqe2.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../../../../../../../../../../img/icons/cron.png&quot; alt=&quot;cron&quot; title=&quot;cron&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;cron表达式格式&quot;&gt;&lt;a href=&quot;#cron表达式格式&quot; class=&quot;headerlink&quot; title=&quot;cron表达式格式&quot;&gt;&lt;/a&gt;cron表达式格式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;{秒数} {分钟} {小时} {日期} {月份} {星期} {年份(可为空)}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先了解每个位置代表的含义，再了解每个位置允许的范围，以及一些特殊写法，还有常用的案例，足够你掌握&lt;code&gt;cron&lt;/code&gt;表达式&lt;/p&gt;
&lt;h3 id=&quot;每个字段的允许值&quot;&gt;&lt;a href=&quot;#每个字段的允许值&quot; class=&quot;headerlink&quot; title=&quot;每个字段的允许值&quot;&gt;&lt;/a&gt;每个字段的允许值&lt;/h3&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;字段&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;描述&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;允许值&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;允许的特殊字符&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Seconds&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;秒&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0-59&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;, - * /&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Minutes&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;分&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0-59&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;, - * /&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Hours&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;小时&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0-23&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;, - * /&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Day-of-Month&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;日期&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1-31&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;, - * ? / L W C&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Month&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;月份&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1-12 或者 JAN-DEC&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;, - * /&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Day-of-Week&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;星期&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1-7 或者 SUN-SAT&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;, - * ? / L C #&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Year&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;年（可选）&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;留空, 1970-2099&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;, - * /&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="cron" scheme="http://jethan.bid/categories/cron/"/>
    
      <category term="定时" scheme="http://jethan.bid/categories/cron/%E5%AE%9A%E6%97%B6/"/>
    
    
      <category term="quartz" scheme="http://jethan.bid/tags/quartz/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis-MapperScannerConfigurer</title>
    <link href="http://jethan.bid/2017/11/30/Mybatis-MapperScannerConfigurer/"/>
    <id>http://jethan.bid/2017/11/30/Mybatis-MapperScannerConfigurer/</id>
    <published>2017-11-30T06:30:37.000Z</published>
    <updated>2017-11-30T06:30:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../../../../../../../img/icons/mybatis.png" alt="mybatis" title="mybatis"></p>
<p> 每个现象背后都有其缘由，越离奇的bug越是由不起眼的细节引发，每个bug背后都有框架或代码运行的原理和机制所在，解决bug，不仅仅需要去网上查询，还需要对其背后的原理进行了解和总结。  同事大佬最近在学习并使用Mybatis，他使用Mybatis的MapperScannerConfigurer来进行相关配置，并希望通过yml配置来指定basePackage，mappers等属性。为此，编写了自定义的配置类 <code>StarterAutoConfiguration</code>和自定义属性类 <code>TkProperties</code>，并在初始化 <code>MapperScannerConfigurer</code>时使用 <code>TkProperties</code>中的属性。但是，事与愿违，在初始化 <code>MapperScannerConfigurer</code>时， <code>TkProperties</code>实例中的属性死活都是未初始化状态。</p>
<p> 为此，我们花了大量时间探查缘由，最后不得不询问了另一位大佬，才发现这个离奇问题的背后竟然有着这样的缘由。  我们首先来看一下大佬关于 <code>MapperScannerConfigurer</code>的自定义配置实现。他首先定义了自定义配置类 <code>BkStarterAutoConfiguration</code>，使用 <code>@EnableConfigurationProperties</code>注解将 <code>TkProperties</code>声明为配置属性类。</p>
 <a id="more"></a>
<h2 id="MapperScannerConfigurer"><a href="#MapperScannerConfigurer" class="headerlink" title="MapperScannerConfigurer"></a>MapperScannerConfigurer</h2><pre><code>@Configuration
@EnableConfigurationProperties({TkProperties.class})
@AutoConfigureBefore(MybatisAutoConfiguration.class)`
public  class  BkStarterAutoConfiguration  {
    @Bean
    @ConditionalOnMissingBean
    @Order(Ordered.HIGHEST_PRECEDENCE)
    public  TkProperties tkProperties()  {
    return  new  TkProperties();`
    }
}
</code></pre><p> 下面是 <code>TkProperties</code>的定义，使用 <code>@ConfigurationProperties</code>注解声明了该属性配置的前缀，两个属性名称为 <code>basePackage</code>和 <code>mappers</code>。</p>
<pre><code>        @Data
        @ConfigurationProperties(prefix =  &quot;tk&quot;)
        public  class  TkProperties  {
            private  String basePackage;
            private  String mappers;
        }
</code></pre><p>  <code>MapperConfig</code>是声明并配置 <code>MapperScannerConfigurer</code>实例的配置类，使用被 <code>@Bean</code>注解修饰的 <code>mapperScannerConfigurer</code>方法来初始化，其方法参数为 <code>TkProperties</code>。</p>
<pre><code>@Configuration
public  class  MapperConfig  {
@Bean
public  MapperScannerConfigurer mapperScannerConfigurer(TkProperties tkProperties)  {
    MapperScannerConfigurer mapperScannerConfigurer =  new  MapperScannerConfigurer();
    mapperScannerConfigurer.setSqlSessionFactoryBeanName(&quot;sqlSessionFactory&quot;);
    //使用TkProperties的成员变量来配置mapperScannerConfigurer
    mapperScannerConfigurer.setBasePackage(tkProperties.getBasePackage());
    Properties properties =  new  Properties();
     properties.setProperty(&quot;mappers&quot;, tkProperties.getMappers());
     mapperScannerConfigurer.setProperties(properties);
     return mapperScannerConfigurer;
     }
}
</code></pre><p> yml配置文件如下所示。</p>
<pre><code>tk:
  basePackage: cn.remcarpediem.mybatis.dao
  mappers: cn.remcarpediem.mappers.BaseDao
</code></pre><p> 代码乍看起来一定问题都没有，但是运行时，在初始化MapperScannerConfigurer实例时，TkProperties实例的属性死活就是没有初始化成功。</p>
<p> <img src="Mybatis相关/mybatis1.png" alt="mybatis" title="mybatis"></p>
<p> 一定有很多见多识广的读者已经知道这个现象背后的原因。“凶手”就是 <code>MapperScannerConfigurer</code>实现的接口 <code>BeanDefinitionRegistryPostProcessor</code>。具体原因我们还需要慢慢来解释，因为它涉及了Spring Boot的很多原理。</p>
<p> 首先， <code>BeanDefinitionRegistryPostProcessor</code>接口继承了 <code>BeanFactoryPostProcessor</code>接口，大家一般都对 <code>BeanFactoryPostProcessor</code>较为熟悉，它是实例工厂(BeanFactory)的后处理器(PostProcessor)，与之类似的还有实例的后处理器(BeanPostProcessor)。 <code>BeanFactoryPostProcessor</code>中只定义了一个方法，其将会在 <code>ApplicationContext</code>内部的 <code>BeanFactory</code>加载完 <code>BeanDefinition</code>后，但是在Bean实例化之前进行。所以通常我们可以通过实现该接口来对实例化之前的 <code>BeanDefinition</code>进行修改。比如说 <code>PropertySourcesPlaceholderConfigurer</code>就实现 <code>BeanFactoryPostProcessor</code>接口，用于处理实例中被 <code>@Value</code>注解修饰的变量，修改其数值。</p>
<pre><code>  public  interface  BeanFactoryPostProcessor  {
   void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)  throws  BeansException;
 }
</code></pre><p> 而 <code>BeanDefinitionRegistryPostProcessor</code>接口扩展自 <code>BeanFactoryPostProcessor</code>，它是 <code>BeanDefinitionRegistry</code>的后处理器，它可以在 <code>BeanFactoryPostProcessor</code>检测之前注册一些特殊的 <code>BeanDefinition</code>，比如说可以注册用来定义 <code>BeanFactoryPostProcessor</code>的 <code>BeanDefintion</code>，比如说我们之前提到的 <code>MapperScannerConfigurer</code>和 <code>ConfigurationClassPostProcessor</code>。</p>
<pre><code> public  interface  BeanDefinitionRegistryPostProcessor  extends  BeanFactoryPostProcessor  {
   void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)  throws  BeansException;
 }
</code></pre><p>  <code>MapperScannerConfigurer</code>的 <code>postProcessBeanDefinitionRegistry</code>主要用来 <code>ClassPathMapperScanner</code>来扫描 <code>Mybatis</code>的 <code>Mapper</code>。 <code>ClassPathMapperScanner</code>继承了 <code>ClassPathBeanDefinitionScanner</code>，在 <code>doScan</code>方法中获取了 <code>basePackage</code>指定的包路径下的所有 <code>Mapper</code>的 <code>BeanDefinition</code>，然后进行注册。</p>
<p> 而 <code>BeanPostProcessor</code>就是Bean实例的后处理器。每个Bean实例在进行初始化前会调用其 <code>postProcessBeforeInitialization</code>方法和初始化之后调用其 <code>postProcessAfterInitialization</code>方法。 <code>ConfigurationPropertiesBindingPostProcessor</code>实现了 <code>BeanPostProcessor</code>接口，用于处理被 <code>@ConfigurationProperties</code>修饰的实例。</p>
<pre><code>  public  interface  BeanPostProcessor  {
   Object postProcessBeforeInitialization(Object bean,  String beanName)  throws  BeansException;
   Object postProcessAfterInitialization(Object bean,  String beanName)  throws  BeansException;
  }
</code></pre><p> 我们可以总结一下 <code>BeanDefinitionRegistryPostProcessor</code>， <code>BeanFactoryPostProcessor</code>和 <code>BeanPostProcessor</code>三个后处理器发挥作用的次序和时机。</p>
<p>  <img src="Mybatis相关/mybatis2.png" alt="mybatis" title="mybatis"></p>
<p> <strong>由此，我们也能够理解为什么 <code>MapperScannerConfigurer</code>初始化时， <code>TkProperties</code>还没有初始化，那是因为 <code>ConfigurationPropertiesBindingPostProcessor</code>还没有初始化，并且也没有对 <code>TkProperties</code>进行处理</strong>。</p>
<p> 遇到问题和bug，不要百度一下解决方案处理就结束了，而是要深入了解一下背后的机制和原理，希望大家都能够多多探索更加深入的原理，获得更多的知识。</p>
<h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="$和#的区别"></a>$和#的区别</h2><p><code>#</code>相当于对数据 加上 双引号，<code>$</code>相当于直接显示数据</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">#</th>
<th style="text-align:center">$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">相当于对数据加上双引号</td>
<td style="text-align:center">相当于直接显示数据</td>
</tr>
<tr>
<td style="text-align:center">很大程度上防止SQL注入</td>
<td style="text-align:center">无法防止SQL注入</td>
</tr>
<tr>
<td style="text-align:center">#{xxx},使用的是PreparedStatement,会有类型转换，比较安全</td>
<td style="text-align:center">${xxx}，使用字符串拼接，容易SQL注入</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>使用#{参数}传入会加上单引号，sql语句解析是会加上””    </li>
</ul>
<p>比如  <code>select * from table where name = #{name}</code> ,传入的name为小李，那么最后打印出来的就是</p>
<p><code>select * from table where name = ‘小李’</code>，就是会当成字符串来解析，这样相比于$的好处是比较明显对的吧，#{}传参能防止sql注入，如果你传入的参数为 单引号’，那么如果使用${},这种方式 那么是会报错的，</p>
<ul>
<li>${}   </li>
</ul>
<p>另外一种场景是，如果你要做动态的排序，比如  <code>order by   column</code>，这个时候务必要用${},</p>
<p>因为如果你使用了#{},那么打印出来的将会是  <code>select * from table order by  &#39;name&#39;</code>  ,这样是没用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../../../../../../../img/icons/mybatis.png&quot; alt=&quot;mybatis&quot; title=&quot;mybatis&quot;&gt;&lt;/p&gt;
&lt;p&gt; 每个现象背后都有其缘由，越离奇的bug越是由不起眼的细节引发，每个bug背后都有框架或代码运行的原理和机制所在，解决bug，不仅仅需要去网上查询，还需要对其背后的原理进行了解和总结。  同事大佬最近在学习并使用Mybatis，他使用Mybatis的MapperScannerConfigurer来进行相关配置，并希望通过yml配置来指定basePackage，mappers等属性。为此，编写了自定义的配置类 &lt;code&gt;StarterAutoConfiguration&lt;/code&gt;和自定义属性类 &lt;code&gt;TkProperties&lt;/code&gt;，并在初始化 &lt;code&gt;MapperScannerConfigurer&lt;/code&gt;时使用 &lt;code&gt;TkProperties&lt;/code&gt;中的属性。但是，事与愿违，在初始化 &lt;code&gt;MapperScannerConfigurer&lt;/code&gt;时， &lt;code&gt;TkProperties&lt;/code&gt;实例中的属性死活都是未初始化状态。&lt;/p&gt;
&lt;p&gt; 为此，我们花了大量时间探查缘由，最后不得不询问了另一位大佬，才发现这个离奇问题的背后竟然有着这样的缘由。  我们首先来看一下大佬关于 &lt;code&gt;MapperScannerConfigurer&lt;/code&gt;的自定义配置实现。他首先定义了自定义配置类 &lt;code&gt;BkStarterAutoConfiguration&lt;/code&gt;，使用 &lt;code&gt;@EnableConfigurationProperties&lt;/code&gt;注解将 &lt;code&gt;TkProperties&lt;/code&gt;声明为配置属性类。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://jethan.bid/categories/java/"/>
    
      <category term="mybatis" scheme="http://jethan.bid/categories/java/mybatis/"/>
    
    
      <category term="MapperScannerConfigurer" scheme="http://jethan.bid/tags/MapperScannerConfigurer/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-SQL语句执行</title>
    <link href="http://jethan.bid/2017/11/28/Mysql-SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C/"/>
    <id>http://jethan.bid/2017/11/28/Mysql-SQL语句执行/</id>
    <published>2017-11-28T10:41:59.000Z</published>
    <updated>2017-11-28T10:41:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/mysql.jpg" alt="mysql" title="mysql"></p>
<p>昔日庖丁解牛，未见全牛，所赖者是其对牛内部骨架结构的了解，对于MySQL亦是如此，只有更加全面地了解SQL语句执行的每个过程，才能更好的进行SQL的设计和优化。<br> 当希望MySQL能够以更高的性能运行查询时，最好的办法就是弄清楚MySQL是如何优化和执行查询的。一旦理解了这一点，很多查询优化工作实际上就是遵循一些原则能够按照预想的合理的方式运行。<br> 如下图所示，当向MySQL发送一个请求的时候，MySQL到底做了什么：</p>
<ul>
<li>客户端发送一条查询给服务器。</li>
<li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。</li>
<li>服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。</li>
<li>MySQL根据优化器生成的执行计划，再调用存储引擎的API来执行查询。</li>
<li>将结果返回给客户端。</li>
</ul>
<a id="more"></a>
<p><img src="Mysql-SQL语句执行/execute1.png" alt="mysql" title="mysql"></p>
<h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p> MySQL查询缓存保存查询返回的完整结构。当查询命中该缓存时，MySQL会立刻返回结果，跳过了解析、优化和执行阶段。<br> 查询缓存系统会跟踪查询中涉及的每个表，如果这些表发生了变化，那么和这个表相关的所有缓存数据都将失效。<br> MySQL将缓存存放在一个引用表中，通过一个哈希值引用，这个哈希值包括了以下因素，即查询本身、当前要查询的数据库、客户端协议的版本等一些其他可能影响返回结果的信息。<br> 当判断缓存是否命中时，MySQL不会进行解析查询语句，而是直接使用SQL语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中。<br> 当查询语句中有一些不确定的数据时，则不会被缓存。例如包含函数NOW()或者CURRENT_DATE()的查询不会缓存。包含任何用户自定义函数，存储函数，用户变量，临时表，mysql数据库中的系统表或者包含任何列级别权限的表，都不会被缓存。<br> 有一点需要注意，MySQL并不是会因为查询中包含一个不确定的函数而不检查查询缓存，因为检查查询缓存之前，MySQL不会解析查询语句，所以也无法知道语句中是否有不确定的函数。<br> 事实则是，如果查询语句中包含任何的不确定的函数，那么其查询结果不会被缓存，因为查询缓存中也无法找到对应的缓存结果。<br> 有关查询缓存的配置如下所示。  </p>
<ul>
<li>query_cache_type:是否打开查询缓存。可以设置为OFF、ON和DEMAND。DEMAND表示只有在查询语句中明确写明SQL_CACHE的语句才会放入查询缓存。</li>
<li>query_cache_size:查询缓存使用的总内存空间。</li>
<li>query_cache_min_res_unit:在查询缓存中分配内存块时的最小单元。较小的该值可以减少碎片导致的内存空间浪费，但是会导致更频繁的内存块操作。</li>
<li>query_cache_limit:MySQL能够查询的最大查询结果。如果查询结果大于这个值，则不会被缓存。因为查询缓存在数据生成的时候就开始尝试缓存数据，所以当结果全部返回后，MySQL才知道查询结果是否超出限制。超出之后，才会将结果从查询缓存中删除。</li>
</ul>
<p>对查询缓存的优化是数据库性能优化的重要一环。判断流程大致如下图所示。</p>
<p><img src="Mysql-SQL语句执行/execute2.png" alt="mysql" title="mysql"></p>
<p>缓存命中率可以通过如下公式计算：Qcache_hits/(Qcache_hits + Com_select)来计算。</p>
<h2 id="解析和预处理"><a href="#解析和预处理" class="headerlink" title="解析和预处理"></a>解析和预处理</h2><p> 解析器通过关键字将SQL语句进行解析，并生成对应的解析树。MySQL解析器将使用MySQL语法规则验证和解析查询。<br> 预处理器则根据一些MySQL规则进行进一步检查解析书是否合法，例如检查数据表和数据列是否存在，还会解析名字和别名，看看它们是否有歧义。</p>
<h2 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h2><p> 查询优化器会将解析树转化成执行计划。一条查询可以有多种执行方法，最后都是返回相同结果。优化器的作用就是找到这其中最好的执行计划。<br> 生成执行计划的过程会消耗较多的时间，特别是存在许多可选的执行计划时。如果在一条SQL语句执行的过程中将该语句对应的最终执行计划进行缓存，当相似的语句再次被输入服务器时，就可以直接使用已缓存的执行计划，从而跳过SQL语句生成执行计划的整个过程，进而可以提高语句的执行速度。</p>
<p><img src="Mysql-SQL语句执行/execute3.png" alt="mysql" title="mysql"></p>
<p> MySQL使用基于成本的查询优化器(Cost-Based Optimizer，CBO)。它会尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最少的一个。<br> 优化器会根据优化规则对关系表达式进行转换，这里的转换是说一个关系表达式经过优化规则后会生成另外一个关系表达式，同时原有表达式也会保留，经过一系列转换后会生成多个执行计划，然后CBO会根据统计信息和代价模型(Cost Model)计算每个执行计划的Cost，从中挑选Cost最小的执行计划。由上可知，CBO中有两个依赖：统计信息和代价模型。统计信息的准确与否、代价模型的合理与否都会影响CBO选择最优计划。<br> 有关优化器的原理十分复杂，这里就不进行详细讲解了，大家可以自行学习。</p>
<h2 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h2><p> 在解析和优化阶段，MySQL将生成查询对应的执行计划，MySQL的查询执行引擎根据这个执行计划来完成整个查询。这里执行计划是一个数据结构，而不是和其他的关系型数据库那样生成对应的字节码。</p>
<h2 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h2><p> 如果查询可以被缓存，那么MySQL在这个阶段页会将结果存放到查询缓存中。<br> MySQL将结果集返回给客户端是一个增量、逐步返回的过程。在查询生成第一条结果时，MySQL就可以开始向客户端逐步返回结果集了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>SQL优化器原理——查询优化器综述 <a href="https://zhuanlan.zhihu.com/p/40478975" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/40478975</a></li>
<li>《高性能MySQL》</li>
<li>《MySQL技术内幕-InnoDB存储引擎》</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/mysql.jpg&quot; alt=&quot;mysql&quot; title=&quot;mysql&quot;&gt;&lt;/p&gt;
&lt;p&gt;昔日庖丁解牛，未见全牛，所赖者是其对牛内部骨架结构的了解，对于MySQL亦是如此，只有更加全面地了解SQL语句执行的每个过程，才能更好的进行SQL的设计和优化。&lt;br&gt; 当希望MySQL能够以更高的性能运行查询时，最好的办法就是弄清楚MySQL是如何优化和执行查询的。一旦理解了这一点，很多查询优化工作实际上就是遵循一些原则能够按照预想的合理的方式运行。&lt;br&gt; 如下图所示，当向MySQL发送一个请求的时候，MySQL到底做了什么：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端发送一条查询给服务器。&lt;/li&gt;
&lt;li&gt;服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。&lt;/li&gt;
&lt;li&gt;服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。&lt;/li&gt;
&lt;li&gt;MySQL根据优化器生成的执行计划，再调用存储引擎的API来执行查询。&lt;/li&gt;
&lt;li&gt;将结果返回给客户端。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="database" scheme="http://jethan.bid/categories/database/"/>
    
      <category term="mysql" scheme="http://jethan.bid/categories/database/mysql/"/>
    
    
      <category term="语句执行" scheme="http://jethan.bid/tags/%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-B-Tree索引</title>
    <link href="http://jethan.bid/2017/11/28/Mysql-B-Tree%E7%B4%A2%E5%BC%95/"/>
    <id>http://jethan.bid/2017/11/28/Mysql-B-Tree索引/</id>
    <published>2017-11-28T06:13:59.000Z</published>
    <updated>2017-11-28T06:13:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/mysql.jpg" alt="mysql" title="mysql"></p>
<p>MySQL是目前业界最为流行的关系型数据库之一，而索引的优化也是数据库性能优化的关键之一。所以，充分地了解MySQL索引有助于提升开发人员对MySQL数据库的使用优化能力。</p>
<p>MySQL的索引有很多种类型，可以为不同的场景提供更好的性能。而B-Tree索引是最为常见的MySQL索引类型，一般谈论MySQL索引时，如果没有特别说明，就是指B-Tree索引。本文就详细讲解一下B-Tree索引的的底层结构，使用原则和特性。</p>
<p>主要内容如下：</p>
<ul>
<li>B-Tree索引的底层结构</li>
<li>B-Tree索引的使用规则</li>
<li>聚簇索引</li>
<li>InnoDB和MyISAM引擎索引的差异</li>
<li>松散索引</li>
<li>覆盖索引</li>
</ul>
<a id="more"></a>
<h2 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h2><p>B-Tree索引使用B-Tree来存储数据，当然不同存储引擎的实现方式不同。B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同，下图展示了B-Tree索引的抽象表示，由此可以看出MySQL的B-Tree索引的大致工作机制。</p>
<p>B-Tree索引的底层数据结构一般是B+树，其具体数据结构和优势这里就不作详细描述，下图展示了B-树索引的抽象表示，大致反应了MyISAM索引是如何工作的，而InnoDB使用的结构有所不同。</p>
<p><img src="Mysql-B-Tree索引/b-tree1.png" alt="mysql" title="mysql"></p>
<p>MySQL可以在单独一列上添加B-Tree索引，也可以在多列数据上添加B-Tree索引，多列的数据按照添加索引声明的顺序组合起来，存储在B-Tree的页中。假设有如下数据表：</p>
<p><img src="Mysql-B-Tree索引/b-tree2.png" alt="mysql" title="mysql"></p>
<p>  对于表中的每一行数据，索引中包含了last_name，first_name和birthday列的值，下图展示了该索引是如何组织数据的存储的。</p>
<p><img src="Mysql-B-Tree索引/b-tree3.png" alt="mysql" title="mysql">  </p>
<p>B-Tree索引使用B-Tree作为其存储数据的数据结构，其使用的查询规则也由此决定。一般来说，B-Tree索引适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于根据最左前缀查找。B-Tree索引支持的查询原则如下所示：</p>
<ul>
<li>全值匹配：全值匹配指的是和索引中的所有列进行匹配。</li>
<li>匹配最左前缀：前边提到的索引可以用于查找所有姓Allen的人，即只使用索引中的第一列。</li>
<li>匹配列前缀：也可以只匹配某一列的值的开头部分。例如前面提到的索引可用于查找所有以J开头的姓的人。这里也只用到了索引的第一列。</li>
<li>匹配范围值：例如前边提到的索引可用于查找姓在Allen和Barrymore之间的人。这里也只使用了索引的第一列。</li>
<li>精确匹配某一列并范围匹配另外一列：前边提到的索引也可用于查找所有姓为Allen，并且名字是字母K开头(比如Kim,Karl等)的人。即第一列last_name全匹配，第二列first_name范围匹配。</li>
</ul>
<p>因为索引树的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的ORDER BY操作(按顺序查找)，如果ORDER BY子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。</p>
<p>下面是一些关于B-Tree索引的限制：</p>
<ul>
<li>如果不是按照索引的最左列开始查找，则无法使用索引。例如上面例子中的索引无法查找名字为Bill的人，也无法查找某个特定生日的日，因为这两列都不是最左数据列。</li>
<li>如果查询中有某个列的范围查询，则其右侧所有列都无法使用索引优化查找。</li>
</ul>
<h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体的细节依赖于其实现方式，但是InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。</p>
<p>当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中，这也就是说数据行和相邻的键值紧凑地存储在一起。</p>
<p>下图展示了聚簇索引中的记录是如何存放的。注意到，叶子页包含了行的全部数据行，但是节点页只包含了索引列。</p>
<p><img src="Mysql-B-Tree索引/b-tree4.png" alt="mysql" title="mysql">  </p>
<p>聚簇索引可能对性能有帮助，但也可能导致严重的性能问题。聚簇的数据是有一些重要的优点：</p>
<ul>
<li>数据访问更快，聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</li>
</ul>
<p>如果在设计表和查询时能充分利用上面的优点，那么就能极大地提升性能。同时，聚簇索引也有一些缺点：</p>
<ul>
<li>插入顺序严重依赖插入顺序。按照主键的顺序插入是向InnoDB表中插入数据速度最快的方式，需要避免主键键值随机的(不连续且值得分布范围非常大)聚簇索引，比如使用UUID作为主键，而应该使用类似AUTO_INCREMENT的自增列。</li>
<li>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动位置到新的位置。</li>
<li>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行时，可能面临“页分裂”的问题。当行的主键值要求必须将这行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间。</li>
<li>二级索引可能比想象的更大，因为在二级索引中的叶节点包含了引用行的主键列。</li>
<li>二级索引访问需要两次索引查找，而不是一次。</li>
</ul>
<h3 id="InnoDB和MyISAM的索引区别"><a href="#InnoDB和MyISAM的索引区别" class="headerlink" title="InnoDB和MyISAM的索引区别"></a>InnoDB和MyISAM的索引区别</h3><p>聚簇索引和非聚簇索引的数据分布有区别，以及对应的主键索引和二级索引的数据分布也有区别，通常会让人感到困惑和意外。下图展示了MyISAM和InnoDB的不同索引和数据存储方式。</p>
<p>MyISAM的数据分布非常简单，按照数据插入的顺序存储在磁盘上，主键索引和二级索引的叶节点存储着指针，指向对应的数据行。InnoDB中，聚簇索引“就是”表，所以不会像MyISAM那样需要独立的行存储。聚簇索引的每个叶节点都包含了主键值和所有的剩余列(在此例中是col2)。</p>
<p>InnoDB的二级索引和聚簇索引很不同。InnoDB二级索引的叶节点中存储的不是“行指针”，而是主键值，并以此作为指向行的“指针”。</p>
<p><img src="Mysql-B-Tree索引/b-tree5.png" alt="mysql" title="mysql">  </p>
<h2 id="松散索引扫描"><a href="#松散索引扫描" class="headerlink" title="松散索引扫描"></a>松散索引扫描</h2><p>MySQL并不支持松散索引扫描，也就是无法按照不连续的方式扫描一个索引。通常，MySQL的索引扫描需要先定义一个起点和终点，即使需要的数据只是这段索引中很少数的几个，MySQL仍然需要扫描这段索引中的每个条目。</p>
<p>下面，我们通过一个示例说明这点，假设我们有如下索引(a,b)，有下面的查询：</p>
<p>因为索引的前导字段是列a，但是在查询中只指定了字段b，MySQL无法使用这个索引，从而只能通过全表扫描找到匹配的行，如下图所示。</p>
<p><img src="Mysql-B-Tree索引/b-tree6.png" alt="mysql" title="mysql">  </p>
<p>了解索引的物理结构的话，不难发现还可以有一个更快的办法执行上面的查询。索引的物理结构(不是存储引擎的API)是的可以先扫描a列第一个值对应的b列的范围，然后再跳到a列第二个不不同值扫描对应的b列的范围。下图展示了如果由MySQL来实现这个过程会怎样。</p>
<p><img src="Mysql-B-Tree索引/b-tree7.png" alt="mysql" title="mysql"> </p>
<p>注意到，这时就无须再使用WHERE子句过滤，因为松散索引扫描已经跳过了所有不需要的记录。</p>
<p><img src="Mysql-B-Tree索引/b-tree8.png" alt="mysql" title="mysql"> </p>
<p>MySQL 5.0之后的版本，在某些特殊的场景下是可以使用松散索引扫描的，例如，在一个分组查询中需要找到分组的最大值和最小值：</p>
<p>在EXPLAIN中的Extra字段显示”Using index for group-by”，表示这里将使用松散索引扫描。</p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>索引除了是一种查找数据的高效方式之外，也是一种列数据的直接获取方式。MySQL可以使用索引来直接获取列的数据，这样就不需要读取数据行。如果一个索引包含所有需要查询的字段的值，我们就称之为“覆盖索引”。</p>
<p>覆盖索引是非常有用的工具，能够极大地提高性能。SQL查询只需要扫描索引而无需回表，会带来很多好处：</p>
<ul>
<li>索引条目数量和大小通常远小于数据行的条目和大小，所以如果只需要读取索引，那么MySQL就会极大地减少数据访问量。</li>
<li>因为索引是按照列顺序存储的，所以对于I/O密集型的范围查找会比随机从磁盘读取每一行数据的I/O要少的多。</li>
<li>由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点中保存了行的主键，索引如果二级主键能够覆盖查询，则避免对主键索引的第二次查询。</li>
</ul>
<p>当发起一个被覆盖索引的查询(也叫索引覆盖查询)时，在EXPLAIN的Extra列可以看到”Using Index”的信息。例如，表sakila.inventory有一个多列索引(store_id, film_id)。MySQL如果只需要访问这两列，就可以使用这个索引做覆盖索引，如下所示：</p>
<p><img src="Mysql-B-Tree索引/b-tree9.png" alt="mysql" title="mysql"> </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>MySQL索引背后的数据结构及算法原理 blog.codinglabs.org</li>
<li>《高性能MySQL》</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/mysql.jpg&quot; alt=&quot;mysql&quot; title=&quot;mysql&quot;&gt;&lt;/p&gt;
&lt;p&gt;MySQL是目前业界最为流行的关系型数据库之一，而索引的优化也是数据库性能优化的关键之一。所以，充分地了解MySQL索引有助于提升开发人员对MySQL数据库的使用优化能力。&lt;/p&gt;
&lt;p&gt;MySQL的索引有很多种类型，可以为不同的场景提供更好的性能。而B-Tree索引是最为常见的MySQL索引类型，一般谈论MySQL索引时，如果没有特别说明，就是指B-Tree索引。本文就详细讲解一下B-Tree索引的的底层结构，使用原则和特性。&lt;/p&gt;
&lt;p&gt;主要内容如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B-Tree索引的底层结构&lt;/li&gt;
&lt;li&gt;B-Tree索引的使用规则&lt;/li&gt;
&lt;li&gt;聚簇索引&lt;/li&gt;
&lt;li&gt;InnoDB和MyISAM引擎索引的差异&lt;/li&gt;
&lt;li&gt;松散索引&lt;/li&gt;
&lt;li&gt;覆盖索引&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="database" scheme="http://jethan.bid/categories/database/"/>
    
      <category term="mysql" scheme="http://jethan.bid/categories/database/mysql/"/>
    
    
      <category term="B-Tree索引" scheme="http://jethan.bid/tags/B-Tree%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之CountDownLatch、CyclicBarrier和Semaphore</title>
    <link href="http://jethan.bid/2017/10/18/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCountDownLatch%E3%80%81CyclicBarrier%E5%92%8CSemaphore/"/>
    <id>http://jethan.bid/2017/10/18/并发编程之CountDownLatch、CyclicBarrier和Semaphore/</id>
    <published>2017-10-18T08:31:58.000Z</published>
    <updated>2017-10-18T08:31:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../../../../../img/icons/java.jpg" alt="java" title="java"></p>
<p><code>CountDownLatch</code>，<code>CyclicBarrier</code>和信号量<code>Semaphore</code>都是<code>java</code>并发包<code>concurrent</code>下提供的并发工具类，是比<code>synchrorized</code>关键字更高效的同步结构。</p>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。</p>
<p><code>CountDownLatch</code>类只提供了一个构造器：</p>
<pre><code>public CountDownLatch(int count) {  };  //参数count为计数值
</code></pre><p>然后下面这3个方法是CountDownLatch类中最重要的方法：</p>
<pre><code>public void await() throws InterruptedException { };   //调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行
public boolean await(long timeout, TimeUnit unit) throws InterruptedException { };  //和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行
public void countDown() { };  //将count值减1
</code></pre><p>下面看一个例子大家就清楚<code>CountDownLatch</code>的用法了：<br><a id="more"></a> </p>
<pre><code>public class Test {
     public static void main(String[] args) {   
         final CountDownLatch latch = new CountDownLatch(2);

         new Thread(){
             public void run() {
                 try {
                     System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;正在执行&quot;);
                    Thread.sleep(3000);
                    System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;执行完毕&quot;);
                    latch.countDown();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
             };
         }.start();

         new Thread(){
             public void run() {
                 try {
                     System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;正在执行&quot;);
                     Thread.sleep(3000);
                     System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;执行完毕&quot;);
                     latch.countDown();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
             };
         }.start();

         try {
             System.out.println(&quot;等待2个子线程执行完毕...&quot;);
            latch.await();
            System.out.println(&quot;2个子线程已经执行完毕&quot;);
            System.out.println(&quot;继续执行主线程&quot;);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
     }
}
</code></pre><p>执行结果：</p>
<pre><code>线程Thread-0正在执行
线程Thread-1正在执行
等待2个子线程执行完毕...
线程Thread-0执行完毕
线程Thread-1执行完毕
2个子线程已经执行完毕
继续执行主线程
</code></pre><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>　字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。</p>
<p>　　<code>CyclicBarrier</code>类位于<code>java.util.concurrent</code>包下，CyclicBarrier提供2个构造器：</p>
<pre><code>  public CyclicBarrier(int parties, Runnable barrierAction) {
  }

  public CyclicBarrier(int parties) {
  }
</code></pre><p>　　参数<code>parties</code>指让多少个线程或者任务等待至barrier状态；参数<code>barrierAction</code>为当这些线程都达到barrier状态时会执行的内容。</p>
<p>　　然后<code>CyclicBarrier</code>中最重要的方法就是await方法，它有2个重载版本：</p>
<pre><code>  public int await() throws InterruptedException, BrokenBarrierException { };
  public int await(long timeout, TimeUnit unit)throws InterruptedException,BrokenBarrierException,TimeoutException { };
</code></pre><p> 　　第一个版本比较常用，用来挂起当前线程，直至所有线程都到达barrier状态再同时执行后续任务；</p>
<p>　　第二个版本是让这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务。</p>
<p>　　下面举几个例子就明白了：</p>
<p>　　假若有若干个线程都要进行写数据操作，并且只有所有线程都完成写数据操作之后，这些线程才能继续做后面的事情，此时就可以利用CyclicBarrier了：</p>
<pre><code>  public class Test {
      public static void main(String[] args) {
          int N = 4;
          CyclicBarrier barrier  = new CyclicBarrier(N);
          for(int i=0;i&lt;N;i++)
              new Writer(barrier).start();
      }
      static class Writer extends Thread{
          private CyclicBarrier cyclicBarrier;
          public Writer(CyclicBarrier cyclicBarrier) {
              this.cyclicBarrier = cyclicBarrier;
          }

          @Override
          public void run() {
              System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;正在写入数据...&quot;);
              try {
                  Thread.sleep(5000);      //以睡眠来模拟写入数据操作
                  System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;写入数据完毕，等待其他线程写入完毕&quot;);
                  cyclicBarrier.await();
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }catch(BrokenBarrierException e){
                  e.printStackTrace();
              }
              System.out.println(&quot;所有线程写入完毕，继续处理其他任务...&quot;);
          }
      }
  }
</code></pre><p>执行结果：</p>
<pre><code>线程Thread-0正在写入数据...
线程Thread-3正在写入数据...
线程Thread-2正在写入数据...
线程Thread-1正在写入数据...
线程Thread-2写入数据完毕，等待其他线程写入完毕
线程Thread-0写入数据完毕，等待其他线程写入完毕
线程Thread-3写入数据完毕，等待其他线程写入完毕
线程Thread-1写入数据完毕，等待其他线程写入完毕
所有线程写入完毕，继续处理其他任务...
所有线程写入完毕，继续处理其他任务...
所有线程写入完毕，继续处理其他任务...
所有线程写入完毕，继续处理其他任务...
</code></pre><p>　从上面输出结果可以看出，每个写入线程执行完写数据操作之后，就在等待其他线程写入操作完毕。</p>
<p>　　当所有线程线程写入操作完毕之后，所有线程就继续进行后续的操作了。</p>
<p>　　如果说想在所有线程写入操作完之后，进行额外的其他操作可以为<code>CyclicBarrier</code>提供Runnable参数：</p>
<pre><code>  public class Test {
      public static void main(String[] args) {
          int N = 4;
          CyclicBarrier barrier  = new CyclicBarrier(N,new Runnable() {
              @Override
              public void run() {
                  System.out.println(&quot;当前线程&quot;+Thread.currentThread().getName());   
              }
          });

          for(int i=0;i&lt;N;i++)
              new Writer(barrier).start();
      }
      static class Writer extends Thread{
          private CyclicBarrier cyclicBarrier;
          public Writer(CyclicBarrier cyclicBarrier) {
              this.cyclicBarrier = cyclicBarrier;
          }

          @Override
          public void run() {
              System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;正在写入数据...&quot;);
              try {
                  Thread.sleep(5000);      //以睡眠来模拟写入数据操作
                  System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;写入数据完毕，等待其他线程写入完毕&quot;);
                  cyclicBarrier.await();
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }catch(BrokenBarrierException e){
                  e.printStackTrace();
              }
              System.out.println(&quot;所有线程写入完毕，继续处理其他任务...&quot;);
          }
      }
  }
</code></pre><p> 　　运行结果：</p>
<pre><code>    线程Thread-0正在写入数据...
    线程Thread-1正在写入数据...
    线程Thread-2正在写入数据...
    线程Thread-3正在写入数据...
    线程Thread-0写入数据完毕，等待其他线程写入完毕
    线程Thread-1写入数据完毕，等待其他线程写入完毕
    线程Thread-2写入数据完毕，等待其他线程写入完毕
    线程Thread-3写入数据完毕，等待其他线程写入完毕
    当前线程Thread-3
    所有线程写入完毕，继续处理其他任务...
    所有线程写入完毕，继续处理其他任务...
    所有线程写入完毕，继续处理其他任务...
    所有线程写入完毕，继续处理其他任务...
</code></pre><p>　　从结果可以看出，当四个线程都到达barrier状态后，最后执行完任务达到 barrier的线程去执行Runnable。</p>
<p> 下面看一下为await指定时间的效果：</p>
<pre><code>    public class Test {
        public static void main(String[] args) {
            int N = 4;
            CyclicBarrier barrier  = new CyclicBarrier(N);

            for(int i=0;i&lt;N;i++) {
                if(i&lt;N-1)
                    new Writer(barrier).start();
                else {
                    try {
                        Thread.sleep(5000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    new Writer(barrier).start();
                }
            }
        }
        static class Writer extends Thread{
            private CyclicBarrier cyclicBarrier;
            public Writer(CyclicBarrier cyclicBarrier) {
                this.cyclicBarrier = cyclicBarrier;
            }

            @Override
            public void run() {
                System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;正在写入数据...&quot;);
                try {
                    Thread.sleep(5000);      //以睡眠来模拟写入数据操作
                    System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;写入数据完毕，等待其他线程写入完毕&quot;);
                    try {
                        cyclicBarrier.await(2000, TimeUnit.MILLISECONDS);
                    } catch (TimeoutException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }catch(BrokenBarrierException e){
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName()+&quot;所有线程写入完毕，继续处理其他任务...&quot;);
            }
        }
    }
</code></pre><p>执行结果：</p>
<pre><code>线程Thread-0正在写入数据...
线程Thread-2正在写入数据...
线程Thread-1正在写入数据...
线程Thread-2写入数据完毕，等待其他线程写入完毕
线程Thread-0写入数据完毕，等待其他线程写入完毕
线程Thread-1写入数据完毕，等待其他线程写入完毕
线程Thread-3正在写入数据...
java.util.concurrent.TimeoutException
Thread-1所有线程写入完毕，继续处理其他任务...
Thread-0所有线程写入完毕，继续处理其他任务...
    at java.util.concurrent.CyclicBarrier.dowait(Unknown Source)
    at java.util.concurrent.CyclicBarrier.await(Unknown Source)
    at com.cxh.test1.Test$Writer.run(Test.java:58)
java.util.concurrent.BrokenBarrierException
    at java.util.concurrent.CyclicBarrier.dowait(Unknown Source)
    at java.util.concurrent.CyclicBarrier.await(Unknown Source)
    at com.cxh.test1.Test$Writer.run(Test.java:58)
java.util.concurrent.BrokenBarrierException
    at java.util.concurrent.CyclicBarrier.dowait(Unknown Source)
    at java.util.concurrent.CyclicBarrier.await(Unknown Source)
    at com.cxh.test1.Test$Writer.run(Test.java:58)
Thread-2所有线程写入完毕，继续处理其他任务...
java.util.concurrent.BrokenBarrierException
线程Thread-3写入数据完毕，等待其他线程写入完毕
    at java.util.concurrent.CyclicBarrier.dowait(Unknown Source)
    at java.util.concurrent.CyclicBarrier.await(Unknown Source)
    at com.cxh.test1.Test$Writer.run(Test.java:58)
</code></pre><p>Thread-3所有线程写入完毕，继续处理其他任务…</p>
<p>　　上面的代码在main方法的for循环中，故意让最后一个线程启动延迟，因为在前面三个线程都达到barrier之后，等待了指定的时间发现第四个线程还没有达到barrier，就抛出异常并继续执行后面的任务。</p>
<p>另外<code>CyclicBarrier</code>是可以重用的，看下面这个例子：</p>
<pre><code>  public class Test {
      public static void main(String[] args) {
          int N = 4;
          CyclicBarrier barrier  = new CyclicBarrier(N);

          for(int i=0;i&lt;N;i++) {
              new Writer(barrier).start();
          }

          try {
              Thread.sleep(25000);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }

          System.out.println(&quot;CyclicBarrier重用&quot;);

          for(int i=0;i&lt;N;i++) {
              new Writer(barrier).start();
          }
      }
      static class Writer extends Thread{
          private CyclicBarrier cyclicBarrier;
          public Writer(CyclicBarrier cyclicBarrier) {
              this.cyclicBarrier = cyclicBarrier;
          }

          @Override
          public void run() {
              System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;正在写入数据...&quot;);
              try {
                  Thread.sleep(5000);      //以睡眠来模拟写入数据操作
                  System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;写入数据完毕，等待其他线程写入完毕&quot;);

                  cyclicBarrier.await();
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }catch(BrokenBarrierException e){
                  e.printStackTrace();
              }
              System.out.println(Thread.currentThread().getName()+&quot;所有线程写入完毕，继续处理其他任务...&quot;);
          }
      }
  }
</code></pre><p>执行结果：</p>
<pre><code>    线程Thread-0正在写入数据...
    线程Thread-1正在写入数据...
    线程Thread-3正在写入数据...
    线程Thread-2正在写入数据...
    线程Thread-1写入数据完毕，等待其他线程写入完毕
    线程Thread-3写入数据完毕，等待其他线程写入完毕
    线程Thread-2写入数据完毕，等待其他线程写入完毕
    线程Thread-0写入数据完毕，等待其他线程写入完毕
    Thread-0所有线程写入完毕，继续处理其他任务...
    Thread-3所有线程写入完毕，继续处理其他任务...
    Thread-1所有线程写入完毕，继续处理其他任务...
    Thread-2所有线程写入完毕，继续处理其他任务...
    CyclicBarrier重用
    线程Thread-4正在写入数据...
    线程Thread-5正在写入数据...
    线程Thread-6正在写入数据...
    线程Thread-7正在写入数据...
    线程Thread-7写入数据完毕，等待其他线程写入完毕
    线程Thread-5写入数据完毕，等待其他线程写入完毕
    线程Thread-6写入数据完毕，等待其他线程写入完毕
    线程Thread-4写入数据完毕，等待其他线程写入完毕
    Thread-4所有线程写入完毕，继续处理其他任务...
    Thread-5所有线程写入完毕，继续处理其他任务...
    Thread-6所有线程写入完毕，继续处理其他任务...
    Thread-7所有线程写入完毕，继续处理其他任务...
</code></pre><p>　　从执行结果可以看出，在初次的4个线程越过barrier状态后，又可以用来进行新一轮的使用。而CountDownLatch无法进行重复使用。</p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><code>Semaphore</code>翻译成字面意思为 信号量，Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。</p>
<p><code>Semaphore</code>类位于<code>java.util.concurrent</code>包下，它提供了2个构造器：</p>
<pre><code>public Semaphore(int permits) {          //参数permits表示许可数目，即同时可以允许多少线程进行访问
    sync = new NonfairSync(permits);
}
public Semaphore(int permits, boolean fair) {    //这个多了一个参数fair表示是否是公平的，即等待时间越久的越先获取许可
    sync = (fair)? new FairSync(permits) : new NonfairSync(permits);
}
</code></pre><p> 下面说一下<code>Semaphore</code>类中比较重要的几个方法，首先是<code>acquire()</code>、<code>release()</code>方法：</p>
<pre><code>    public void acquire() throws InterruptedException {  }     //获取一个许可
    public void acquire(int permits) throws InterruptedException { }    //获取permits个许可
    public void release() { }          //释放一个许可
    public void release(int permits) { }    //释放permits个许可
</code></pre><p><code>acquire()</code>用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。</p>
<p><code>release()</code>用来释放许可。注意，在释放许可之前，必须先获获得许可。否则直接release，permit数目可能会大于设置的最大数。</p>
<p>这4个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法：</p>
<pre><code>    public boolean tryAcquire() { };    //尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false
    public boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException { };  //尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false
    public boolean tryAcquire(int permits) { }; //尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false
    public boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException { }; //尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false
</code></pre><p>另外还可以通过<code>availablePermits()</code>方法得到可用的许可数目。</p>
<p>下面通过一个例子来看一下<code>Semaphore</code>的具体使用：</p>
<p>假若一个工厂有5台机器，但是有8个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过Semaphore来实现：</p>
<pre><code>  public class Test {
      public static void main(String[] args) {
          int N = 8;            //工人数
          Semaphore semaphore = new Semaphore(5); //机器数目
          for(int i=0;i&lt;N;i++)
              new Worker(i,semaphore).start();
      }

      static class Worker extends Thread{
          private int num;
          private Semaphore semaphore;
          public Worker(int num,Semaphore semaphore){
              this.num = num;
              this.semaphore = semaphore;
          }

          @Override
          public void run() {
              try {
                  semaphore.acquire();
                  System.out.println(&quot;工人&quot;+this.num+&quot;占用一个机器在生产...&quot;);
                  Thread.sleep(2000);
                  System.out.println(&quot;工人&quot;+this.num+&quot;释放出机器&quot;);
                  semaphore.release();           
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }
      }
  }
</code></pre><p>执行结果：</p>
<pre><code>    工人0占用一个机器在生产...
    工人1占用一个机器在生产...
    工人2占用一个机器在生产...
    工人4占用一个机器在生产...
    工人5占用一个机器在生产...
    工人0释放出机器
    工人2释放出机器
    工人3占用一个机器在生产...
    工人7占用一个机器在生产...
    工人4释放出机器
    工人5释放出机器
    工人1释放出机器
    工人6占用一个机器在生产...
    工人3释放出机器
    工人7释放出机器
    工人6释放出机器
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>CountDownLatch</code>和<code>CyclicBarrier</code>都能够实现线程之间的等待，只不过它们侧重点不同：</li>
</ul>
<p>　　　　<code>CountDownLatch</code>一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；</p>
<p>　　　　而<code>CyclicBarrier</code>一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；</p>
<p>　　　　另外，<code>CountDownLatch</code>是不能够重用的，而<code>CyclicBarrier</code>是可以重用的。</p>
<ul>
<li><code>Semaphore</code>其实和锁有点类似，它一般用于控制对某组资源的访问权限。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../../../../../img/icons/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;，&lt;code&gt;CyclicBarrier&lt;/code&gt;和信号量&lt;code&gt;Semaphore&lt;/code&gt;都是&lt;code&gt;java&lt;/code&gt;并发包&lt;code&gt;concurrent&lt;/code&gt;下提供的并发工具类，是比&lt;code&gt;synchrorized&lt;/code&gt;关键字更高效的同步结构。&lt;/p&gt;
&lt;h2 id=&quot;CountDownLatch&quot;&gt;&lt;a href=&quot;#CountDownLatch&quot; class=&quot;headerlink&quot; title=&quot;CountDownLatch&quot;&gt;&lt;/a&gt;CountDownLatch&lt;/h2&gt;&lt;p&gt;CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;类只提供了一个构造器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public CountDownLatch(int count) {  };  //参数count为计数值
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后下面这3个方法是CountDownLatch类中最重要的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void await() throws InterruptedException { };   //调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行
public boolean await(long timeout, TimeUnit unit) throws InterruptedException { };  //和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行
public void countDown() { };  //将count值减1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面看一个例子大家就清楚&lt;code&gt;CountDownLatch&lt;/code&gt;的用法了：&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://jethan.bid/categories/java/"/>
    
      <category term="并发编程" scheme="http://jethan.bid/categories/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="CountDownLatch" scheme="http://jethan.bid/tags/CountDownLatch/"/>
    
      <category term="CyclicBarrier" scheme="http://jethan.bid/tags/CyclicBarrier/"/>
    
      <category term="Semaphore" scheme="http://jethan.bid/tags/Semaphore/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://jethan.bid/2017/10/14/Docker/"/>
    <id>http://jethan.bid/2017/10/14/Docker/</id>
    <published>2017-10-14T09:44:28.000Z</published>
    <updated>2019-10-29T05:51:59.883Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../../../../../img/icons/docker.jpg" alt="java" title="docker"></p>
<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。</p>
<p>在微服务的大背景下，一台物理机或者云主机可能要运行很多应用。应用必须依赖于开发环境。当我们遇到拓展物理机、云主机、应用迁移等场景，必然要重新搭建开发环境。这时，虚拟化技术就很好地保证环境一致、配置一致，并且让你更高效地迁移应用。</p>
<p>Docker正是应对这种场景的虚拟化技术。例如java，只要机器上安装了JVM，一份代码到处运行。应用好比java，只要机器上安装docker，我们事先保存的镜像可以到处运行。这些镜像可以是nginx、php、mysql、数据仓库等，无论你的主机从ubuntu迁移到centos，还是windows迁移linux，只要主机安装了docker，就能迅速地部署好新环境，并且保持环境、配置一致。</p>
<p>一个完整的Docker有以下几个部分组成：</p>
<ul>
<li>dockerClient客户端  </li>
<li>Docker Daemon 守护进程  </li>
<li>Docker Image 镜像  </li>
<li>DockerContainer 容器   </li>
<li>Docker Repository 仓库</li>
</ul>
<p><strong>Docker 镜像</strong><br>我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:14.04 就包含了完整的一套 Ubuntu 14.04 最小系统的 root 文件系统。<br>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。<br><strong><em>分层存储</em></strong><br>因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。<br>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。<br>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<p><strong>Docker 容器</strong><br>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。<br>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会把容器和虚拟机搞混。<br>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。<br>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。<br>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。<br>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器可以随意删除、重新 run，数据却不会丢失。</p>
<p><strong>Docker Registry</strong><br>镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href="https://docs.docker.com/registry/" target="_blank" rel="external">Docker Registry </a>就是这样的服务。<br>一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。<br>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。<br>以 <a href="https://hub.docker.com/_/ubuntu/" target="_blank" rel="external">Ubuntu</a> 镜像 为例，ubuntu 是仓库的名字，其内包含有不同的版本标签，如，14.04, 16.04。我们可以通过 ubuntu:14.04，或者 ubuntu:16.04 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 ubuntu:latest。<br>仓库名经常以 两段式路径 形式出现，比如 jwilder/nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p>
<p><strong><em>Docker Registry 公开服务</em></strong><br>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。<br>最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a>，这也是默认的 Registry，并拥有大量的高质量的官方镜像。除此以外，还有<a href="https://coreos.com/" target="_blank" rel="external"> CoreOS</a> 的 <a href="https://quay.io/repository/" target="_blank" rel="external">Quay.io</a>，CoreOS 相关的镜像存储在这里；Google 的 <a href="https://cloud.google.com/container-registry/" target="_blank" rel="external">Google Container Registry</a>，<a href="https://kubernetes.io/" target="_blank" rel="external">Kubernetes</a> 的镜像使用的就是这个服务。<br>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（Registry Mirror），这些镜像服务被称为加速器。常见的有 <a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="external">阿里云加速器</a>、<a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="external">DaoCloud 加速器</a>、<a href="http://docs.alauda.cn/feature/accelerator.html" target="_blank" rel="external">灵雀云加速器</a>等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从官方网站下载速度会提高很多。在后面的章节中会有进一步如何配置加速器的讲解。<br>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://hub.tenxcloud.com/" target="_blank" rel="external">时速云镜像仓库</a>、<a href="https://c.163.com/hub#/m/library/" target="_blank" rel="external">网易云镜像服务</a>、<a href="https://hub.daocloud.io/" target="_blank" rel="external">DaoCloud镜像市场</a> 、<a href="https://cr.console.aliyun.com/" target="_blank" rel="external">阿里云镜像库</a>等。</p>
<p><strong><em>私有 Docker Registry</em></strong><br>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a href="https://hub.docker.com/_/registry/" target="_blank" rel="external">Docker Registry 镜像</a>，可以直接使用做为私有 Registry 服务。在后续的相关章节中，会有进一步的搭建私有 Registry 服务的讲解。<br>开源的 Docker Registry 镜像只提供了 <a href="https://docs.docker.com/registry/spec/api/" target="_blank" rel="external">Docker Registry API</a> 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 <a href="https://docs.docker.com/datacenter/dtr/2.0/" target="_blank" rel="external">Docker Trusted Registry </a>中，提供了这些高级功能。<br>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，VMWare Harbor 和 <a href="https://www.sonatype.com/docker" target="_blank" rel="external">Sonatype Nexus</a>。</p>
<h2 id="为什么要使用-Docker"><a href="#为什么要使用-Docker" class="headerlink" title="为什么要使用 Docker"></a>为什么要使用 Docker</h2><p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。</p>
<p><strong>更高效的利用系统资源</strong></p>
<p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p>
<p><strong>更快速的启动时间</strong></p>
<p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p>
<p><strong>一致的运行环境</strong><br>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题。</p>
<p><strong>持续交付和部署</strong><br>对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。<br>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。</p>
<p>而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。<br>更轻松的迁移</p>
<p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>
<p><strong>更轻松的维护和扩展</strong></p>
<p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p>
<p><strong>对比</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">容器</th>
<th style="text-align:center">格式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">启动</td>
<td style="text-align:center">秒级</td>
<td style="text-align:center">分钟级</td>
</tr>
<tr>
<td style="text-align:center">硬盘使用</td>
<td style="text-align:center">一般为 MB</td>
<td style="text-align:center">一般为 GB</td>
</tr>
<tr>
<td style="text-align:center">性能</td>
<td style="text-align:center">接近原生</td>
<td style="text-align:center">弱于</td>
</tr>
<tr>
<td style="text-align:center">系统支持量</td>
<td style="text-align:center">单机支持上千个容器</td>
<td style="text-align:center">一般几十个</td>
</tr>
</tbody>
</table>
</div>
<h2 id="不同终端如何安装docker"><a href="#不同终端如何安装docker" class="headerlink" title="不同终端如何安装docker"></a>不同终端如何安装docker</h2><h3 id="Ubuntu、Debian-系列"><a href="#Ubuntu、Debian-系列" class="headerlink" title="Ubuntu、Debian 系列"></a>Ubuntu、Debian 系列</h3><p>系统要求<br>Docker 支持以下版本的 <a href="https://www.ubuntu.com/server" target="_blank" rel="external">Ubuntu</a> 和 <a href="https://www.debian.org/intro/about" target="_blank" rel="external">Debian</a> 操作系统：</p>
<ul>
<li>Ubuntu Xenial 16.04 (LTS)</li>
<li>Ubuntu Trusty 14.04 (LTS)</li>
<li>Ubuntu Precise 12.04 (LTS)</li>
<li>Debian testing stretch (64-bit)</li>
<li>Debian 8 Jessie (64-bit)</li>
<li>Debian 7 Wheezy (64-bit)（必须启用 backports)</li>
</ul>
<p>Ubuntu 发行版中，LTS（Long-Term-Support）长期支持版本，会获得 5 年的升级维护支持，这样的版本会更稳定，因此在生产环境中推荐使用 LTS 版本。<br>Docker 目前支持的 Ubuntu 版本最低为 12.04 LTS，但从稳定性上考虑，推荐使用 14.04 LTS 或更高的版本。<br>Docker 需要安装在 64 位的 x86 平台或 ARM 平台上（如<a href="https://www.raspberrypi.org/" target="_blank" rel="external">树莓派</a>），并且要求内核版本不低于 3.10。但实际上内核越新越好，过低的内核版本可能会出现部分功能无法使用，或者不稳定。<br>用户可以通过如下命令检查自己的内核版本详细信息：</p>
<pre><code>$ uname -a
Linux device 4.4.0-45-generic #66~14.04.1-Ubuntu SMP Wed Oct 19 15:05:38 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux
</code></pre><p><strong>升级内核</strong><br>如果内核版本过低，可以用下面的命令升级系统内核。</p>
<p>Ubuntu 12.04 LTS</p>
<pre><code>sudo apt-get install -y --install-recommends linux-generic-lts-trusty
</code></pre><p>Ubuntu 14.04 LTS</p>
<pre><code>sudo apt-get install -y --install-recommends linux-generic-lts-xenial
</code></pre><p>Debian 7 Wheezy<br>Debian 7 的内核默认为 3.2，为了满足 Docker 的需求，应该安装 backports 的内核。<br>执行下面的命令添加 backports 源：</p>
<pre><code>$ echo &quot;deb http://http.debian.net/debian wheezy-backports main&quot; | sudo tee /etc/apt/sources.list.d/backports.list
</code></pre><p>升级到 backports 内核：</p>
<pre><code>$ sudo apt-get update
$ sudo apt-get -t wheezy-backports install linux-image-amd64
</code></pre><p><strong>Debian 8 Jessie</strong><br>Debian 8 的内核默认为 3.16，满足基本的 Docker 运行条件。但是如果打算使用 overlay2 存储层驱动，或某些功能不够稳定希望升级到较新版本的内核，可以添加 backports 源，升级到新版本的内核。<br>执行下面的命令添加 backports 源：</p>
<pre><code>$ echo &quot;deb http://http.debian.net/debian jessie-backports main&quot; | sudo tee /etc/apt/sources.list.d/backports.list
</code></pre><p>升级到 backports 内核：</p>
<pre><code>$ sudo apt-get update
$ sudo apt-get -t jessie-backports install linux-image-amd64
</code></pre><p>需要注意的是，升级到 backports 的内核之后，会因为 AUFS 内核模块不可用，而使用默认的 devicemapper 驱动，并且配置为 loop-lvm，这是不推荐的。因此，不要忘记安装 Docker 后，配置 overlay2 存储层驱动。<br><strong>配置 GRUB 引导参数</strong><br>在 Docker 使用期间，或者在 docker info 信息中，可能会看到下面的警告信息：</p>
<pre><code>    WARNING: Your kernel does not support cgroup swap limit. WARNING: Your
    kernel does not support swap limit capabilities. Limitation discarded.
</code></pre><p>或者</p>
<pre><code>    WARNING: No memory limit support
    WARNING: No swap limit support
    WARNING: No oom kill disable support
</code></pre><p>如果需要这些功能，就需要修改 GRUB 的配置文件<code>/etc/default/grub</code>，在 <code>GRUB_CMDLINE_LINUX</code>中添加内核引导参数 <code>cgroup_enable=memory swapaccount=1</code>。<br>然后不要忘记了更新 GRUB：</p>
<pre><code>$ sudo update-grub
$ sudo reboot
</code></pre><p>使用脚本自动安装<br>Docker 官方为了简化安装流程，提供了一套安装脚本，Ubuntu 和 Debian 系统可以使用这套脚本安装：</p>
<pre><code>curl -sSL https://get.docker.com/ | sh
</code></pre><p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 安装在系统中。<br>不过，由于伟大的墙的原因，在国内使用这个脚本可能会出现某些下载出现错误的情况。国内的一些云服务商提供了这个脚本的修改版本，使其使用国内的 Docker 软件源镜像安装，这样就避免了墙的干扰。</p>
<p><strong>阿里云的安装脚本</strong></p>
<pre><code>curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -
</code></pre><p><strong>DaoCloud 的安装脚本</strong></p>
<pre><code>curl -sSL https://get.daocloud.io/docker | sh
</code></pre><p><strong>手动安装</strong><br><strong><em>安装所需的软件包</em></strong><br><strong><strong>可选内核模块</strong></strong><br>从 Ubuntu 14.04 开始，一部分内核模块移到了可选内核模块包(<code>linux-image-extra-*</code>)，以减少内核软件包的体积。正常安装的系统应该会包含可选内核模块包，而一些裁剪后的系统可能会将其精简掉。AUFS 内核驱动属于可选内核模块的一部分，作为推荐的 Docker 存储层驱动，一般建议安装可选内核模块包以使用 AUFS。<br>如果系统没有安装可选内核模块的话，可以执行下面的命令来安装可选内核模块包：</p>
<pre><code>$ sudo apt-get install linux-image-extra-$(uname -r) linux-image-extra-virtual
</code></pre><p><strong><strong>12.04 LTS 图形界面</strong></strong><br>在 Ubuntu 12.04 桌面环境下，需要一些额外的软件包，可以用下面的命令安装。</p>
<pre><code>$ sudo apt-get install xserver-xorg-lts-trusty libgl1-mesa-glx-lts-trusty
</code></pre><p><strong><em>添加 APT 镜像源</em></strong><br>虽然 Ubuntu 系统软件源中有 Docker，名为 docker.io，但是不应该使用系统源中的这个版本，它的版本太旧。我们需要使用 Docker 官方提供的软件源，因此，我们需要添加 APT 软件源。<br>由于官方源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。<br>国内的一些软件源镜像（比如阿里云）不是太在意系统安全上的细节，可能依旧使用不安全的 HTTP，对于这些源可以不执行这一步。</p>
<pre><code>$ sudo apt-get update
$ sudo apt-get install apt-transport-https ca-certificates
</code></pre><p>为了确认所下载软件包的合法性，需要添加 Docker 官方软件源的 GPG 密钥。</p>
<pre><code>8118E89F3A912897C070ADBF76221572C52609D
</code></pre><p>然后，我们需要向 source.list 中添加 Docker 软件源，下表列出了不同的 Ubuntu 和 Debian 版本对应的 APT 源。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作系统版本</th>
<th style="text-align:center">REPO</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Precise 12.04 (LTS)</td>
<td style="text-align:center">deb <a href="https://apt.dockerproject.org/repo" target="_blank" rel="external">https://apt.dockerproject.org/repo</a> ubuntu-precise main</td>
</tr>
<tr>
<td style="text-align:center">Trusty 14.04 (LTS)</td>
<td style="text-align:center">deb <a href="https://apt.dockerproject.org/repo" target="_blank" rel="external">https://apt.dockerproject.org/repo</a> ubuntu-trusty main</td>
</tr>
<tr>
<td style="text-align:center">Xenial 16.04 (LTS)</td>
<td style="text-align:center">deb <a href="https://apt.dockerproject.org/repo" target="_blank" rel="external">https://apt.dockerproject.org/repo</a> ubuntu-xenial main</td>
</tr>
<tr>
<td style="text-align:center">Debian 7 Wheezy</td>
<td style="text-align:center">deb <a href="https://apt.dockerproject.org/repo" target="_blank" rel="external">https://apt.dockerproject.org/repo</a> debian-wheezy main</td>
</tr>
<tr>
<td style="text-align:center">Debian 8 Jessie</td>
<td style="text-align:center">deb <a href="https://apt.dockerproject.org/repo" target="_blank" rel="external">https://apt.dockerproject.org/repo</a> debian-jessie main</td>
</tr>
<tr>
<td style="text-align:center">Debian Stretch/Sid</td>
<td style="text-align:center">deb <a href="https://apt.dockerproject.org/repo" target="_blank" rel="external">https://apt.dockerproject.org/repo</a> debian-stretch main</td>
</tr>
</tbody>
</table>
</div>
<p>用下面的命令将 APT 源添加到 <code>source.list</code>（将其中的 <code>&lt;REPO&gt;</code> 替换为上表的值）：</p>
<pre><code>$ echo &quot;&lt;REPO&gt;&quot; | sudo tee /etc/apt/sources.list.d/docker.list
</code></pre><p>添加成功后，更新 apt 软件包缓存。</p>
<pre><code>$ sudo apt-get update
</code></pre><p>安装 Docker<br>在一切准备就绪后，就可以安装最新版本的 Docker 了，软件包名称为 <code>docker-engine</code>。</p>
<pre><code>$ sudo apt-get install docker-engine
</code></pre><p>如果系统中存在旧版本的 Docker （<code>lxc-docker</code>, <code>docker.io</code>），会提示是否先删除，选择是即可。</p>
<p><strong>启动 Docker 引擎</strong></p>
<p><strong><em>Ubuntu 12.04/14.04、Debian 7 Wheezy</em></strong></p>
<pre><code>$ sudo service docker start
</code></pre><p><strong><em>Ubuntu 16.04、Debian 8 Jessie/Stretch</em></strong></p>
<pre><code>$ sudo systemctl enable docker
$ sudo systemctl start docker
</code></pre><p><strong>建立 docker 用户组</strong></p>
<p>默认情况下，<code>docker</code> 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。</p>
<p>建立 <code>docker</code>组：</p>
<pre><code>$ sudo groupadd docker
</code></pre><p>将当前用户加入 <code>docker</code> 组：</p>
<pre><code>$ sudo usermod -aG docker $USER
</code></pre><h3 id="CentOS-操作系统安装"><a href="#CentOS-操作系统安装" class="headerlink" title="CentOS 操作系统安装"></a>CentOS 操作系统安装</h3><p>系统要求<br>Docker 最低支持 CentOS 7。<br>Docker 需要安装在 64 位的平台，并且内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 overlay2 存储层驱动）无法使用，并且部分功能可能不太稳定。<br>使用脚本自动安装<br>Docker 官方为了简化安装流程，提供了一套安装脚本，CentOS 系统上可以使用这套脚本安装：<br>curl -sSL <a href="https://get.docker.com/" target="_blank" rel="external">https://get.docker.com/</a> | sh<br>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 安装在系统中。<br>不过，由于伟大的墙的原因，在国内使用这个脚本可能会出现某些下载出现错误的情况。国内的一些云服务商提供了这个脚本的修改版本，使其使用国内的 Docker 软件源镜像安装，这样就避免了墙的干扰。<br>阿里云的安装脚本<br>curl -sSL <a href="http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet" target="_blank" rel="external">http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet</a> | sh -<br>DaoCloud 的安装脚本<br>curl -sSL <a href="https://get.daocloud.io/docker" target="_blank" rel="external">https://get.daocloud.io/docker</a> | sh<br>手动安装<br>添加内核参数<br>默认配置下，在 CentOS 使用 Docker 可能会碰到下面的这些警告信息：<br>WARNING: bridge-nf-call-iptables is disabled<br>WARNING: bridge-nf-call-ip6tables is disabled<br>添加内核配置参数以启用这些功能。<br>$ sudo tee -a /etc/sysctl.conf &lt;&lt;-EOF<br>net.bridge.bridge-nf-call-ip6tables = 1<br>net.bridge.bridge-nf-call-iptables = 1<br>EOF<br>然后重新加载 sysctl.conf 即可<br>$ sudo sysctl -p<br>添加 yum 源<br>虽然 CentOS 软件源 Extras 中有 Docker，名为 docker，但是不建议使用系统源中的这个版本，它的版本相对比较陈旧，而且并非 Docker 官方维护的版本。因此，我们需要使用 Docker 官方提供的 CentOS 软件源。<br>执行下面的命令添加 yum 软件源。<br>$ sudo tee /etc/yum.repos.d/docker.repo &lt;&lt;-‘EOF’<br>[dockerrepo]<br>name=Docker Repository<br>baseurl=<a href="https://yum.dockerproject.org/repo/main/centos/7/" target="_blank" rel="external">https://yum.dockerproject.org/repo/main/centos/7/</a><br>enabled=1<br>gpgcheck=1<br>gpgkey=<a href="https://yum.dockerproject.org/gpg" target="_blank" rel="external">https://yum.dockerproject.org/gpg</a><br>EOF<br>安装 Docker<br>更新 yum 软件源缓存，并安装 docker-engine。<br>$ sudo yum update<br>$ sudo yum install docker-engine<br>启动 Docker 引擎</p>
<pre><code>$ sudo systemctl enable docker
$ sudo systemctl start docker
</code></pre><p>建立 docker 用户组<br>默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。<br>建立 docker 组：</p>
<pre><code>$ sudo groupadd docker
</code></pre><p>将当前用户加入 docker 组：</p>
<pre><code>$ sudo usermod -aG docker $USER
</code></pre><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>之前提到过，<a href="https://hub.docker.com/explore/" target="_blank" rel="external">Docker Hub</a> 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。</p>
<p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</div></pre></td></tr></table></figure>
<p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，这里我们说一下镜像名称的格式。</p>
<ul>
<li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub。</li>
<li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li>
</ul>
<p>比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ docker pull ubuntu:18.04</div><div class="line">18.04: Pulling from library/ubuntu</div><div class="line">bf5d46315322: Pull complete</div><div class="line">9f13e0ac480c: Pull complete</div><div class="line">e8988b5b3097: Pull complete</div><div class="line">40af181810e7: Pull complete</div><div class="line">e6f7c7e5c03e: Pull complete</div><div class="line">Digest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe</div><div class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:18.04</div></pre></td></tr></table></figure>
<p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 <code>ubuntu:18.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>18.04</code> 的镜像。</p>
<p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 <code>sha256</code> 的摘要，以确保下载一致性。</p>
<p>在使用上面命令的时候，你可能会发现，你所看到的层 ID 以及 <code>sha256</code> 的摘要和这里的不一样。这是因为官方镜像是一直在维护的，有任何新的 bug，或者版本更新，都会进行修复再以原来的标签发布，这样可以确保任何使用这个标签的用户可以获得更安全、更稳定的镜像。</p>
<p><em>如果从 Docker Hub 下载镜像非常缓慢，可以参照 <a href="/install/mirror.md">镜像加速器</a> 一节配置加速器。</em></p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 <code>ubuntu:18.04</code> 为例，如果我们打算启动里面的 <code>bash</code> 并且进行交互式操作的话，可以执行下面的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ docker run -it --rm \</div><div class="line">    ubuntu:18.04 \</div><div class="line">    bash</div><div class="line"></div><div class="line">root@e7009c6ce357:/<span class="comment"># cat /etc/os-release</span></div><div class="line">NAME=<span class="string">"Ubuntu"</span></div><div class="line">VERSION=<span class="string">"18.04.1 LTS (Bionic Beaver)"</span></div><div class="line">ID=ubuntu</div><div class="line">ID_LIKE=debian</div><div class="line">PRETTY_NAME=<span class="string">"Ubuntu 18.04.1 LTS"</span></div><div class="line">VERSION_ID=<span class="string">"18.04"</span></div><div class="line">HOME_URL=<span class="string">"https://www.ubuntu.com/"</span></div><div class="line">SUPPORT_URL=<span class="string">"https://help.ubuntu.com/"</span></div><div class="line">BUG_REPORT_URL=<span class="string">"https://bugs.launchpad.net/ubuntu/"</span></div><div class="line">PRIVACY_POLICY_URL=<span class="string">"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"</span></div><div class="line">VERSION_CODENAME=bionic</div><div class="line">UBUNTU_CODENAME=bionic</div></pre></td></tr></table></figure>
<p><code>docker run</code> 就是运行容器的命令，具体格式我们会在 <a href="../container">容器</a> 一节进行详细讲解，我们这里简要的说明一下上面用到的参数。</p>
<ul>
<li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li>
<li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li>
<li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li>
<li><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li>
</ul>
<p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <code>Ubuntu 18.04.1 LTS</code> 系统。</p>
<p>最后我们通过 <code>exit</code> 退出了这个容器。</p>
<h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ docker image ls</div><div class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">redis                latest              5f515359c7f8        5 days ago          183 MB</div><div class="line">nginx                latest              05a60462f8ba        5 days ago          181 MB</div><div class="line">mongo                3.2                 fe9198c04d62        5 days ago          342 MB</div><div class="line">&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB</div><div class="line">ubuntu               18.04               f753707788c5        4 weeks ago         127 MB</div><div class="line">ubuntu               latest              f753707788c5        4 weeks ago         127 MB</div></pre></td></tr></table></figure>
<p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p>
<p>其中仓库名、标签在之前的基础概念章节已经介绍过了。<strong>镜像 ID</strong> 则是镜像的唯一标识，一个镜像可以对应多个 <strong>标签</strong>。因此，在上面的例子中，我们可以看到 <code>ubuntu:18.04</code> 和 <code>ubuntu:latest</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p>
<h3 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h3><p>如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，<code>ubuntu:18.04</code> 镜像大小，在这里是 <code>127 MB</code>，但是在 <a href="https://hub.docker.com/r/library/ubuntu/tags/" target="_blank" rel="external">Docker Hub</a> 显示的却是 <code>50 MB</code>。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 <code>docker image ls</code> 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。</p>
<p>另外一个需要注意的问题是，<code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p>
<p>你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ docker system df</div><div class="line"></div><div class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</div><div class="line">Images              24                  0                   1.992GB             1.992GB (100%)</div><div class="line">Containers          1                   0                   62.82MB             62.82MB (100%)</div><div class="line">Local Volumes       9                   0                   652.2MB             652.2MB (100%)</div><div class="line">Build Cache                                                 0B                  0B</div></pre></td></tr></table></figure>
<h3 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h3><p>上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code>。：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB</div></pre></td></tr></table></figure>
<p>这个镜像原本是有镜像名和标签的，原来为 <code>mongo:3.2</code>，随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时，<code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>&lt;none&gt;</code>。除了 <code>docker pull</code> 可能导致这种情况，<code>docker build</code> 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像。这类无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> ，可以用下面的命令专门显示这类镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ docker image ls -f dangling=<span class="literal">true</span></div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">&lt;none&gt;              &lt;none&gt;              00285df0df87        5 days ago          342 MB</div></pre></td></tr></table></figure>
<p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker image prune</div></pre></td></tr></table></figure>
<h3 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h3><p>为了加速镜像构建、重复利用资源，Docker 会利用 <strong>中间层镜像</strong>。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 <code>docker image ls</code> 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker image ls -a</div></pre></td></tr></table></figure>
<p>这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</p>
<h3 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h3><p>不加任何参数的情况下，<code>docker image ls</code> 会列出所有顶级镜像，但是有时候我们只希望列出部分镜像。<code>docker image ls</code> 有好几个参数可以帮助做到这个事情。</p>
<p>根据仓库名列出镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker image ls ubuntu</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">ubuntu              18.04               f753707788c5        4 weeks ago         127 MB</div><div class="line">ubuntu              latest              f753707788c5        4 weeks ago         127 MB</div></pre></td></tr></table></figure>
<p>列出特定的某个镜像，也就是说指定仓库名和标签</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ docker image ls ubuntu:18.04</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">ubuntu              18.04               f753707788c5        4 weeks ago         127 MB</div></pre></td></tr></table></figure>
<p>除此以外，<code>docker image ls</code> 还支持强大的过滤器参数 <code>--filter</code>，或者简写 <code>-f</code>。之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 <code>mongo:3.2</code> 之后建立的镜像，可以用下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker image ls -f since=mongo:3.2</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">redis               latest              5f515359c7f8        5 days ago          183 MB</div><div class="line">nginx               latest              05a60462f8ba        5 days ago          181 MB</div></pre></td></tr></table></figure>
<p>想查看某个位置之前的镜像也可以，只需要把 <code>since</code> 换成 <code>before</code> 即可。</p>
<p>此外，如果镜像构建时，定义了 <code>LABEL</code>，还可以通过 <code>LABEL</code> 来过滤。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker image ls -f label=com.example.version=0.1</div><div class="line">...</div></pre></td></tr></table></figure>
<h3 id="以特定格式显示"><a href="#以特定格式显示" class="headerlink" title="以特定格式显示"></a>以特定格式显示</h3><p>默认情况下，<code>docker image ls</code> 会输出一个完整的表格，但是我们并非所有时候都会需要这些内容。比如，刚才删除虚悬镜像的时候，我们需要利用 <code>docker image ls</code> 把所有的虚悬镜像的 ID 列出来，然后才可以交给 <code>docker image rm</code> 命令作为参数来删除指定的这些镜像，这个时候就用到了 <code>-q</code> 参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ docker image ls -q</div><div class="line">5f515359c7f8</div><div class="line">05a60462f8ba</div><div class="line">fe9198c04d62</div><div class="line">00285df0df87</div><div class="line">f753707788c5</div><div class="line">f753707788c5</div><div class="line">1e0c3dd64ccd</div></pre></td></tr></table></figure>
<p><code>--filter</code> 配合 <code>-q</code> 产生出指定范围的 ID 列表，然后送给另一个 <code>docker</code> 命令作为参数，从而针对这组实体成批的进行某种操作的做法在 Docker 命令行使用过程中非常常见，不仅仅是镜像，将来我们会在各个命令中看到这类搭配以完成很强大的功能。因此每次在文档看到过滤器后，可以多注意一下它们的用法。</p>
<p>另外一些时候，我们可能只是对表格的结构不满意，希望自己组织列；或者不希望有标题，这样方便其它程序解析结果等，这就用到了 <a href="https://gohugo.io/templates/go-templates/" target="_blank" rel="external">Go 的模板语法</a>。</p>
<p>比如，下面的命令会直接列出镜像结果，并且只包含镜像ID和仓库名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ docker image ls --format <span class="string">"&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;"</span></div><div class="line">5f515359c7f8: redis</div><div class="line">05a60462f8ba: nginx</div><div class="line">fe9198c04d62: mongo</div><div class="line">00285df0df87: &lt;none&gt;</div><div class="line">f753707788c5: ubuntu</div><div class="line">f753707788c5: ubuntu</div><div class="line">1e0c3dd64ccd: ubuntu</div></pre></td></tr></table></figure>
<p>或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ docker image ls --format <span class="string">"table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;"</span></div><div class="line">IMAGE ID            REPOSITORY          TAG</div><div class="line">5f515359c7f8        redis               latest</div><div class="line">05a60462f8ba        nginx               latest</div><div class="line">fe9198c04d62        mongo               3.2</div><div class="line">00285df0df87        &lt;none&gt;              &lt;none&gt;</div><div class="line">f753707788c5        ubuntu              18.04</div><div class="line">f753707788c5        ubuntu              latest</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果您是初学者，您可以暂时跳过后面的内容，直接学习容器。</p>
</blockquote>
<h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</div></pre></td></tr></table></figure>
<h3 id="用-ID、镜像名、摘要删除镜像"><a href="#用-ID、镜像名、摘要删除镜像" class="headerlink" title="用 ID、镜像名、摘要删除镜像"></a>用 ID、镜像名、摘要删除镜像</h3><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p>
<p>比如我们有这么一些镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ docker image ls</div><div class="line">REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">centos                      latest              0584b3d2cf6d        3 weeks ago         196.5 MB</div><div class="line">redis                       alpine              501ad78535f0        3 weeks ago         21.03 MB</div><div class="line">docker                      latest              cf693ec9b5c7        3 weeks ago         105.1 MB</div><div class="line">nginx                       latest              e43d811ce2f4        5 weeks ago         181.5 MB</div></pre></td></tr></table></figure>
<p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。<code>docker image ls</code> 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p>
<p>比如这里，如果我们要删除 <code>redis:alpine</code> 镜像，可以执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ docker image rm 501</div><div class="line">Untagged: redis:alpine</div><div class="line">Untagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86d</div><div class="line">Deleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7</div><div class="line">Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899b</div><div class="line">Deleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23</div><div class="line">Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2fa</div><div class="line">Deleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3</div><div class="line">Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7</div></pre></td></tr></table></figure>
<p>我们也可以用<code>镜像名</code>，也就是 <code>&lt;仓库名&gt;:&lt;标签&gt;</code>，来删除镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ docker image rm centos</div><div class="line">Untagged: centos:latest</div><div class="line">Untagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c</div><div class="line">Deleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a</div><div class="line">Deleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38</div></pre></td></tr></table></figure>
<p>当然，更精确的是使用 <code>镜像摘要</code> 删除镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ docker image ls --digests</div><div class="line">REPOSITORY                  TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE</div><div class="line">node                        slim                sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228   6e0c4c8e3913        3 weeks ago         214 MB</div><div class="line"></div><div class="line">$ docker image rm node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</div><div class="line">Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</div></pre></td></tr></table></figure>
<h3 id="Untagged-和-Deleted"><a href="#Untagged-和-Deleted" class="headerlink" title="Untagged 和 Deleted"></a>Untagged 和 Deleted</h3><p>如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 <code>Untagged</code>，另一类是 <code>Deleted</code>。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。</p>
<p>因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 <code>Untagged</code> 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 <code>Delete</code> 行为就不会发生。所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p>
<p>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变动非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 <code>docker pull</code> 看到的层数不一样的源。</p>
<p>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</p>
<h3 id="用-docker-image-ls-命令来配合"><a href="#用-docker-image-ls-命令来配合" class="headerlink" title="用 docker image ls 命令来配合"></a>用 docker image ls 命令来配合</h3><p>像其它可以承接多个实体的命令一样，可以使用 <code>docker image ls -q</code> 来配合使用 <code>docker image rm</code>，这样可以成批的删除希望删除的镜像。我们在“镜像列表”章节介绍过很多过滤镜像列表的方式都可以拿过来使用。</p>
<p>比如，我们需要删除所有仓库名为 <code>redis</code> 的镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker image rm $(docker image ls -q redis)</div></pre></td></tr></table></figure>
<p>或者删除所有在 <code>mongo:3.2</code> 之前的镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker image rm $(docker image ls -q -f before=mongo:3.2)</div></pre></td></tr></table></figure>
<p>充分利用你的想象力和 Linux 命令行的强大，你可以完成很多非常赞的功能。</p>
<h3 id="CentOS-RHEL-的用户需要注意的事项"><a href="#CentOS-RHEL-的用户需要注意的事项" class="headerlink" title="CentOS/RHEL 的用户需要注意的事项"></a>CentOS/RHEL 的用户需要注意的事项</h3><blockquote>
<p>以下内容仅适用于 Docker CE 18.09 以下版本，在 Docker CE 18.09 版本中默认使用的是 <code>overlay2</code> 驱动。</p>
</blockquote>
<p><del>在 Ubuntu/Debian 上有 <code>UnionFS</code> 可以使用，如 <code>aufs</code> 或者 <code>overlay2</code>，而 CentOS 和 RHEL 的内核中没有相关驱动。因此对于这类系统，一般使用 <code>devicemapper</code> 驱动利用 LVM 的一些机制来模拟分层存储。这样的做法除了性能比较差外，稳定性一般也不好，而且配置相对复杂。Docker 安装在 CentOS/RHEL 上后，会默认选择 <code>devicemapper</code>，但是为了简化配置，其 <code>devicemapper</code> 是跑在一个稀疏文件模拟的块设备上，也被称为 <code>loop-lvm</code>。这样的选择是因为不需要额外配置就可以运行 Docker，这是自动配置唯一能做到的事情。但是 <code>loop-lvm</code> 的做法非常不好，其稳定性、性能更差，无论是日志还是 <code>docker info</code> 中都会看到警告信息。官方文档有明确的文章讲解了如何配置块设备给 <code>devicemapper</code> 驱动做存储层的做法，这类做法也被称为配置 <code>direct-lvm</code>。</del></p>
<p><del>除了前面说到的问题外，<code>devicemapper</code> + <code>loop-lvm</code> 还有一个缺陷，因为它是稀疏文件，所以它会不断增长。用户在使用过程中会注意到 <code>/var/lib/docker/devicemapper/devicemapper/data</code> 不断增长，而且无法控制。很多人会希望删除镜像或者可以解决这个问题，结果发现效果并不明显。原因就是这个稀疏文件的空间释放后基本不进行垃圾回收的问题。因此往往会出现即使删除了文件内容，空间却无法回收，随着使用这个稀疏文件一直在不断增长。</del></p>
<p><del>所以对于 CentOS/RHEL 的用户来说，在没有办法使用 <code>UnionFS</code> 的情况下，一定要配置 <code>direct-lvm</code> 给 <code>devicemapper</code>，无论是为了性能、稳定性还是空间利用率。</del></p>
<p><del><em>或许有人注意到了 CentOS 7 中存在被 backports 回来的 <code>overlay</code> 驱动，不过 CentOS 里的这个驱动达不到生产环境使用的稳定程度，所以不推荐使用。</em></del></p>
<h2 id="利用-commit-理解镜像构成"><a href="#利用-commit-理解镜像构成" class="headerlink" title="利用 commit 理解镜像构成"></a>利用 commit 理解镜像构成</h2><p>注意： <code>docker commit</code> 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 <code>docker commit</code> 定制镜像，定制镜像应该使用 <code>Dockerfile</code> 来完成。如果你想要定制镜像请查看下一小节。</p>
<p>镜像是容器的基础，每次执行 <code>docker run</code> 的时候都会指定哪个镜像作为容器运行的基础。在之前的例子中，我们所使用的都是来自于 Docker Hub 的镜像。直接使用这些镜像是可以满足一定的需求，而当这些镜像无法直接满足需求时，我们就需要定制这些镜像。接下来的几节就将讲解如何定制镜像。</p>
<p>回顾一下之前我们学到的知识，镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。</p>
<p>现在让我们以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run --name webserver -d -p 80:80 nginx</div></pre></td></tr></table></figure>
<p>这条命令会用 <code>nginx</code> 镜像启动一个容器，命名为 <code>webserver</code>，并且映射了 80 端口，这样我们可以用浏览器去访问这个 <code>nginx</code> 服务器。</p>
<p>  如果是在 Linux 本机运行的 Docker，或者如果使用的是 Docker for Mac、Docker for Windows，那么可以直接访问：<a href="http://localhost" target="_blank" rel="external">http://localhost</a>；如果使用的是 Docker Toolbox，或者是在虚拟机、云服务器上安装的 Docker，则需要将 <code>localhost</code> 换为虚拟机地址或者实际云服务器地址。</p>
<p>直接用浏览器访问的话，我们会看到默认的 Nginx 欢迎页面。</p>
<p><img src="_images/images-mac-example-nginx.png" width="80%"></p>
<p>现在，假设我们非常不喜欢这个欢迎页面，我们希望改成欢迎 Docker 的文字，我们可以使用 <code>docker exec</code> 命令进入容器，修改其内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker <span class="built_in">exec</span> -it webserver bash</div><div class="line">root@3729b97e8226:/<span class="comment"># echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</span></div><div class="line">root@3729b97e8226:/<span class="comment"># exit</span></div><div class="line"><span class="built_in">exit</span></div></pre></td></tr></table></figure>
<p>我们以交互式终端方式进入 <code>webserver</code> 容器，并执行了 <code>bash</code> 命令，也就是获得一个可操作的 Shell。</p>
<p>然后，我们用 <code>&lt;h1&gt;Hello, Docker!&lt;/h1&gt;</code> 覆盖了 <code>/usr/share/nginx/html/index.html</code> 的内容。</p>
<p>现在我们再刷新浏览器的话，会发现内容被改变了。</p>
<p><img src="_images/images-create-nginx-docker.png" width="80%"></p>
<p>我们修改了容器的文件，也就是改动了容器的存储层。我们可以通过 <code>docker diff</code> 命令看到具体的改动。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ docker diff webserver</div><div class="line">C /root</div><div class="line">A /root/.bash_history</div><div class="line">C /run</div><div class="line">C /usr</div><div class="line">C /usr/share</div><div class="line">C /usr/share/nginx</div><div class="line">C /usr/share/nginx/html</div><div class="line">C /usr/share/nginx/html/index.html</div><div class="line">C /var</div><div class="line">C /var/cache</div><div class="line">C /var/cache/nginx</div><div class="line">A /var/cache/nginx/client_temp</div><div class="line">A /var/cache/nginx/fastcgi_temp</div><div class="line">A /var/cache/nginx/proxy_temp</div><div class="line">A /var/cache/nginx/scgi_temp</div><div class="line">A /var/cache/nginx/uwsgi_temp</div></pre></td></tr></table></figure>
<p>现在我们定制好了变化，我们希望能将其保存下来形成镜像。</p>
<p>要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p>
<p><code>docker commit</code> 的语法格式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</div></pre></td></tr></table></figure>
<p>我们可以用下面的命令将容器保存为镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ docker commit \</div><div class="line">    --author <span class="string">"Tao Wang &lt;twang2218@gmail.com&gt;"</span> \</div><div class="line">    --message <span class="string">"修改了默认网页"</span> \</div><div class="line">    webserver \</div><div class="line">    nginx:v2</div><div class="line">sha256:07e33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214</div></pre></td></tr></table></figure>
<p>其中 <code>--author</code> 是指定修改的作者，而 <code>--message</code> 则是记录本次修改的内容。这点和 <code>git</code> 版本控制相似，不过这里这些信息可以省略留空。</p>
<p>我们可以在 <code>docker image ls</code> 中看到这个新定制的镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ docker image ls nginx</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">nginx               v2                  07e334659748        9 seconds ago       181.5 MB</div><div class="line">nginx               1.11                05a60462f8ba        12 days ago         181.5 MB</div><div class="line">nginx               latest              e43d811ce2f4        4 weeks ago         181.5 MB</div></pre></td></tr></table></figure>
<p>我们还可以用 <code>docker history</code> 具体查看镜像内的历史记录，如果比较 <code>nginx:latest</code> 的历史记录，我们会发现新增了我们刚刚提交的这一层。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ docker <span class="built_in">history</span> nginx:v2</div><div class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</div><div class="line">07e334659748        54 seconds ago      nginx -g daemon off;                            95 B                修改了默认网页</div><div class="line">e43d811ce2f4        4 weeks ago         /bin/sh -c <span class="comment">#(nop)  CMD ["nginx" "-g" "daemon    0 B</span></div><div class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="comment">#(nop)  EXPOSE 443/tcp 80/tcp        0 B</span></div><div class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c ln -sf /dev/stdout /var/<span class="built_in">log</span>/nginx/   22 B</div><div class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c apt-key adv --keyserver hkp://pgp.   58.46 MB</div><div class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="comment">#(nop)  ENV NGINX_VERSION=1.11.5-1   0 B</span></div><div class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="comment">#(nop)  MAINTAINER NGINX Docker Ma   0 B</span></div><div class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="comment">#(nop)  CMD ["/bin/bash"]            0 B</span></div><div class="line">&lt;missing&gt;           4 weeks ago         /bin/sh -c <span class="comment">#(nop) ADD file:23aa4f893e3288698c   123 MB</span></div></pre></td></tr></table></figure>
<p>新的镜像定制好后，我们可以来运行这个镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --name web2 -d -p 81:80 nginx:v2</div></pre></td></tr></table></figure>
<p>这里我们命名为新的服务为 <code>web2</code>，并且映射到 <code>81</code> 端口。如果是 Docker for Mac/Windows 或 Linux 桌面的话，我们就可以直接访问 <a href="http://localhost:81" target="_blank" rel="external">http://localhost:81</a> 看到结果，其内容应该和之前修改后的 <code>webserver</code> 一样。</p>
<p>至此，我们第一次完成了定制镜像，使用的是 <code>docker commit</code> 命令，手动操作给旧的镜像添加了新的一层，形成新的镜像，对镜像多层存储应该有了更直观的感觉。</p>
<h3 id="慎用-docker-commit"><a href="#慎用-docker-commit" class="headerlink" title="慎用 docker commit"></a>慎用 <code>docker commit</code></h3><p>使用 <code>docker commit</code> 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。</p>
<p>首先，如果仔细观察之前的 <code>docker diff webserver</code> 的结果，你会发现除了真正想要修改的 <code>/usr/share/nginx/html/index.html</code> 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心清理，将会导致镜像极为臃肿。</p>
<p>此外，使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为 <strong>黑箱镜像</strong>，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体在操作的。虽然 <code>docker diff</code> 或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。</p>
<p>而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 <code>docker commit</code> 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。</p>
<h2 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h2><p>从刚才的 <code>docker commit</code> 的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p>
<p>Dockerfile 是一个文本文件，其内包含了一条条的 <strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<p>还以之前定制 <code>nginx</code> 镜像为例，这次我们使用 Dockerfile 来定制。</p>
<p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ mkdir mynginx</div><div class="line">$ <span class="built_in">cd</span> mynginx</div><div class="line">$ touch Dockerfile</div></pre></td></tr></table></figure>
<p>其内容为：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> nginx</div><div class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span></div></pre></td></tr></table></figure>
<p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code>。</p>
<h3 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h3><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定 <strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p>
<p>在 <a href="https://hub.docker.com/search?q=&amp;type=image&amp;image_filter=official" target="_blank" rel="external">Docker Hub</a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <a href="https://hub.docker.com/_/nginx/" target="_blank" rel="external"><code>nginx</code></a>、<a href="https://hub.docker.com/_/redis/" target="_blank" rel="external"><code>redis</code></a>、<a href="https://hub.docker.com/_/mongo/" target="_blank" rel="external"><code>mongo</code></a>、<a href="https://hub.docker.com/_/mysql/" target="_blank" rel="external"><code>mysql</code></a>、<a href="https://hub.docker.com/_/httpd/" target="_blank" rel="external"><code>httpd</code></a>、<a href="https://hub.docker.com/_/php/" target="_blank" rel="external"><code>php</code></a>、<a href="https://hub.docker.com/_/tomcat/" target="_blank" rel="external"><code>tomcat</code></a> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <a href="https://hub.docker.com/_/node" target="_blank" rel="external"><code>node</code></a>、<a href="https://hub.docker.com/_/openjdk/" target="_blank" rel="external"><code>openjdk</code></a>、<a href="https://hub.docker.com/_/python/" target="_blank" rel="external"><code>python</code></a>、<a href="https://hub.docker.com/_/ruby/" target="_blank" rel="external"><code>ruby</code></a>、<a href="https://hub.docker.com/_/golang/" target="_blank" rel="external"><code>golang</code></a> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p>
<p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <a href="https://hub.docker.com/_/ubuntu/" target="_blank" rel="external"><code>ubuntu</code></a>、<a href="https://hub.docker.com/_/debian/" target="_blank" rel="external"><code>debian</code></a>、<a href="https://hub.docker.com/_/centos/" target="_blank" rel="external"><code>centos</code></a>、<a href="https://hub.docker.com/_/fedora/" target="_blank" rel="external"><code>fedora</code></a>、<a href="https://hub.docker.com/_/alpine/" target="_blank" rel="external"><code>alpine</code></a> 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p>
<p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> scratch</div><div class="line">...</div></pre></td></tr></table></figure>
<p>如果你以 <code>scratch</code> 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p>
<p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 <a href="https://hub.docker.com/_/swarm/" target="_blank" rel="external"><code>swarm</code></a>、<a href="https://quay.io/repository/coreos/etcd" target="_blank" rel="external"><code>coreos/etcd</code></a>。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。使用 <a href="https://golang.org/" target="_blank" rel="external">Go 语言</a> 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p>
<h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h3><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p>
<ul>
<li><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span></div></pre></td></tr></table></figure>
<ul>
<li><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li>
</ul>
<p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> debian:stretch</div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y gcc libc6-dev make wget</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span></span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /usr/src/redis</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> make -C /usr/src/redis</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> make -C /usr/src/redis install</span></div></pre></td></tr></table></figure>
<p>之前说过，Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p>
<p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。<br>这是很多初学 Docker 的人常犯的一个错误。</p>
<p><em>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</em></p>
<p>上面的 <code>Dockerfile</code> 正确的写法应该是这样：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> debian:stretch</div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> buildDeps=<span class="string">'gcc libc6-dev make wget'</span> \</span></div><div class="line">    &amp;&amp; apt-get update \</div><div class="line">    &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</div><div class="line">    &amp;&amp; wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span> \</div><div class="line">    &amp;&amp; mkdir -p /usr/src/redis \</div><div class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</div><div class="line">    &amp;&amp; make -C /usr/src/redis \</div><div class="line">    &amp;&amp; make -C /usr/src/redis install \</div><div class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</div><div class="line">    &amp;&amp; rm redis.tar.gz \</div><div class="line">    &amp;&amp; rm -r /usr/src/redis \</div><div class="line">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></div></pre></td></tr></table></figure>
<p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 <code>RUN</code> 对一一对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p>
<p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p>
<p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
<p>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p>
<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p>
<p>在 <code>Dockerfile</code> 文件所在目录执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ docker build -t nginx:v3 .</div><div class="line">Sending build context to Docker daemon 2.048 kB</div><div class="line">Step 1 : FROM nginx</div><div class="line"> ---&gt; e43d811ce2f4</div><div class="line">Step 2 : RUN <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</div><div class="line"> ---&gt; Running <span class="keyword">in</span> 9cdc27646c7b</div><div class="line"> ---&gt; 44aa4490ce2c</div><div class="line">Removing intermediate container 9cdc27646c7b</div><div class="line">Successfully built 44aa4490ce2c</div></pre></td></tr></table></figure>
<p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <code>Step 2</code> 中，如同我们之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>9cdc27646c7b</code>，执行了所要求的命令，并最后提交了这一层 <code>44aa4490ce2c</code>，随后删除了所用到的这个容器 <code>9cdc27646c7b</code>。</p>
<p>这里我们使用了 <code>docker build</code> 命令进行镜像构建。其格式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build [选项] &lt;上下文路径/URL/-&gt;</div></pre></td></tr></table></figure>
<p>在这里我们指定了最终镜像的名称 <code>-t nginx:v3</code>，构建成功后，我们可以像之前运行 <code>nginx:v2</code> 那样来运行这个镜像，其结果会和 <code>nginx:v2</code> 一样。</p>
<h3 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h3><p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，因此不少初学者以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 <strong>上下文路径</strong>。那么什么是上下文呢？</p>
<p>首先我们要理解 <code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="external">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p>
<p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p>
<p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<p>如果在 <code>Dockerfile</code> 中这么写：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">COPY</span><span class="bash"> ./package.json /app/</span></div></pre></td></tr></table></figure>
<p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>。</p>
<p>因此，<code>COPY</code> 这类指令中的源文件的路径都是<em>相对路径</em>。这也是初学者经常会问的为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p>
<p>现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p>
<p>如果观察 <code>docker build</code> 输出，我们其实已经看到了这个发送上下文的过程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ docker build -t nginx:v3 .</div><div class="line">Sending build context to Docker daemon 2.048 kB</div><div class="line">...</div></pre></td></tr></table></figure>
<p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p>
<p>一般来说，应该会将 <code>Dockerfile</code> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p>
<p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p>
<p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p>
<p>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p>
<h3 id="其它-docker-build-的用法"><a href="#其它-docker-build-的用法" class="headerlink" title="其它 docker build 的用法"></a>其它 <code>docker build</code> 的用法</h3><h4 id="直接用-Git-repo-进行构建"><a href="#直接用-Git-repo-进行构建" class="headerlink" title="直接用 Git repo 进行构建"></a>直接用 Git repo 进行构建</h4><p>或许你已经注意到了，<code>docker build</code> 还支持从 URL 构建，比如可以直接从 Git repo 中构建：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ docker build https://github.com/twang2218/gitlab-ce-zh.git<span class="comment">#:11.1</span></div><div class="line"></div><div class="line">Sending build context to Docker daemon 2.048 kB</div><div class="line">Step 1 : FROM gitlab/gitlab-ce:11.1.0-ce.0</div><div class="line">11.1.0-ce.0: Pulling from gitlab/gitlab-ce</div><div class="line">aed15891ba52: Already exists</div><div class="line">773ae8583d14: Already exists</div><div class="line">...</div></pre></td></tr></table></figure>
<p>这行命令指定了构建所需的 Git repo，并且指定默认的 <code>master</code> 分支，构建目录为 <code>/11.1/</code>，然后 Docker 就会自己去 <code>git clone</code> 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p>
<h4 id="用给定的-tar-压缩包构建"><a href="#用给定的-tar-压缩包构建" class="headerlink" title="用给定的 tar 压缩包构建"></a>用给定的 tar 压缩包构建</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker build http://server/context.tar.gz</div></pre></td></tr></table></figure>
<p>如果所给出的 URL 不是个 Git repo，而是个 <code>tar</code> 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</p>
<h4 id="从标准输入中读取-Dockerfile-进行构建"><a href="#从标准输入中读取-Dockerfile-进行构建" class="headerlink" title="从标准输入中读取 Dockerfile 进行构建"></a>从标准输入中读取 Dockerfile 进行构建</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build - &lt; Dockerfile</div></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat Dockerfile | docker build -</div></pre></td></tr></table></figure>
<p>如果标准输入传入的是文本文件，则将其视为 <code>Dockerfile</code>，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 <code>COPY</code> 进镜像之类的事情。</p>
<h4 id="从标准输入中读取上下文压缩包进行构建"><a href="#从标准输入中读取上下文压缩包进行构建" class="headerlink" title="从标准输入中读取上下文压缩包进行构建"></a>从标准输入中读取上下文压缩包进行构建</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker build - &lt; context.tar.gz</div></pre></td></tr></table></figure>
<p>如果发现标准输入的文件格式是 <code>gzip</code>、<code>bzip2</code> 以及 <code>xz</code> 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p>
<h2 id="Dokerfile指令详解"><a href="#Dokerfile指令详解" class="headerlink" title="Dokerfile指令详解"></a>Dokerfile指令详解</h2><h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h3><p>格式：</p>
<ul>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li>
</ul>
<p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p>
<p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">COPY</span><span class="bash"> package.json /usr/src/app/</span></div></pre></td></tr></table></figure>
<p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a href="https://golang.org/pkg/path/filepath/#Match" target="_blank" rel="external"><code>filepath.Match</code></a> 规则，如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">COPY</span><span class="bash"> hom* /mydir/</span></div><div class="line"><span class="keyword">COPY</span><span class="bash"> hom?.txt /mydir/</span></div></pre></td></tr></table></figure>
<p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p>
<p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">COPY</span><span class="bash"> --chown=55:mygroup files* /mydir/</span></div><div class="line"><span class="keyword">COPY</span><span class="bash"> --chown=bin files* /mydir/</span></div><div class="line"><span class="keyword">COPY</span><span class="bash"> --chown=1 files* /mydir/</span></div><div class="line"><span class="keyword">COPY</span><span class="bash"> --chown=10:11 files* /mydir/</span></div></pre></td></tr></table></figure>
<h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h3><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p>
<p>比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。下载后的文件权限自动设置为 <code>600</code>，如果这并不是想要的权限，那么还需要增加额外的一层 <code>RUN</code> 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <code>RUN</code> 指令进行解压缩。所以不如直接使用 <code>RUN</code> 指令，然后使用 <code>wget</code> 或者 <code>curl</code> 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p>
<p>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。</p>
<p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> scratch</div><div class="line"><span class="keyword">ADD</span><span class="bash"> ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 <code>ADD</code> 命令了。</p>
<p>在 Docker 官方的 <a href="../../appendix/best_practices.md">Dockerfile 最佳实践文档</a> 中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</p>
<p>另外需要注意的是，<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p>
<p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</p>
<p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ADD</span><span class="bash"> --chown=55:mygroup files* /mydir/</span></div><div class="line"><span class="keyword">ADD</span><span class="bash"> --chown=bin files* /mydir/</span></div><div class="line"><span class="keyword">ADD</span><span class="bash"> --chown=1 files* /mydir/</span></div><div class="line"><span class="keyword">ADD</span><span class="bash"> --chown=10:11 files* /mydir/</span></div></pre></td></tr></table></figure>
<h3 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h3><p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p>
<ul>
<li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li>
<li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li>
<li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li>
</ul>
<p>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。</p>
<p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p>
<p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>&quot;</code>，而不要使用单引号。</p>
<p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$HOME</span></span></div></pre></td></tr></table></figure>
<p>在实际执行中，会将其变更为：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo <span class="variable">$HOME</span>"</span> ]</span></div></pre></td></tr></table></figure>
<p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p>
<p>提到 <code>CMD</code> 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。</p>
<p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 <code>systemd</code> 去启动后台服务，容器内没有后台服务的概念。</p>
<p>一些初学者将 <code>CMD</code> 写为：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CMD</span><span class="bash"> service nginx start</span></div></pre></td></tr></table></figure>
<p>然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p>
<p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<p>而使用 <code>service nginx start</code> 命令，则是希望 upstart 来以后台守护进程形式启动 <code>nginx</code> 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>，因此主进程实际上是 <code>sh</code>。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。</p>
<p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"nginx"</span>, <span class="string">"-g"</span>, <span class="string">"daemon off;"</span>]</span></div></pre></td></tr></table></figure>
<h3 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h3><p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。</p>
<p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。</p>
<p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;ENTRYPOINT&gt; <span class="string">"&lt;CMD&gt;"</span></div></pre></td></tr></table></figure>
<p>那么有了 <code>CMD</code> 后，为什么还要有 <code>ENTRYPOINT</code> 呢？这种 <code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code> 有什么好处么？让我们来看几个场景。</p>
<h4 id="场景一：让镜像变成像命令一样使用"><a href="#场景一：让镜像变成像命令一样使用" class="headerlink" title="场景一：让镜像变成像命令一样使用"></a>场景一：让镜像变成像命令一样使用</h4><p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 <code>CMD</code> 来实现：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update \</span></div><div class="line">    &amp;&amp; apt-get install -y curl \</div><div class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</div><div class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"curl"</span>, <span class="string">"-s"</span>, <span class="string">"https://ip.cn"</span> ]</span></div></pre></td></tr></table></figure>
<p>假如我们使用 <code>docker build -t myip .</code> 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker run myip</div><div class="line">当前 IP：61.148.226.66 来自：北京市 联通</div></pre></td></tr></table></figure>
<p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 <code>CMD</code> 中可以看到实质的命令是 <code>curl</code>，那么如果我们希望显示 HTTP 头信息，就需要加上 <code>-i</code> 参数。那么我们可以直接加 <code>-i</code> 参数给 <code>docker run myip</code> 么？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker run myip -i</div><div class="line">docker: Error response from daemon: invalid header field value <span class="string">"oci runtime error: container_linux.go:247: starting container process caused \"exec: \\\"-i\\\": executable file not found in <span class="variable">$PATH</span>\"\n"</span>.</div></pre></td></tr></table></figure>
<p>我们可以看到可执行文件找不到的报错，<code>executable file not found</code>。之前我们说过，跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code>，而不是添加在原来的 <code>curl -s https://ip.cn</code> 后面。而 <code>-i</code> 根本不是命令，所以自然找不到。</p>
<p>那么如果我们希望加入 <code>-i</code> 这参数，我们就必须重新完整的输入这个命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run myip curl -s https://ip.cn -i</div></pre></td></tr></table></figure>
<p>这显然不是很好的解决方案，而使用 <code>ENTRYPOINT</code> 就可以解决这个问题。现在我们重新用 <code>ENTRYPOINT</code> 来实现这个镜像：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update \</span></div><div class="line">    &amp;&amp; apt-get install -y curl \</div><div class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</div><div class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [ <span class="string">"curl"</span>, <span class="string">"-s"</span>, <span class="string">"https://ip.cn"</span> ]</span></div></pre></td></tr></table></figure>
<p>这次我们再来尝试直接使用 <code>docker run myip -i</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">$ docker run myip</div><div class="line">当前 IP：61.148.226.66 来自：北京市 联通</div><div class="line"></div><div class="line">$ docker run myip -i</div><div class="line">HTTP/1.1 200 OK</div><div class="line">Server: nginx/1.8.0</div><div class="line">Date: Tue, 22 Nov 2016 05:12:40 GMT</div><div class="line">Content-Type: text/html; charset=UTF-8</div><div class="line">Vary: Accept-Encoding</div><div class="line">X-Powered-By: PHP/5.6.24-1~dotdeb+7.1</div><div class="line">X-Cache: MISS from cache-2</div><div class="line">X-Cache-Lookup: MISS from cache-2:80</div><div class="line">X-Cache: MISS from proxy-2_6</div><div class="line">Transfer-Encoding: chunked</div><div class="line">Via: 1.1 cache-2:80, 1.1 proxy-2_6:8006</div><div class="line">Connection: keep-alive</div><div class="line"></div><div class="line">当前 IP：61.148.226.66 来自：北京市 联通</div></pre></td></tr></table></figure>
<p>可以看到，这次成功了。这是因为当存在 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的内容将会作为参数传给 <code>ENTRYPOINT</code>，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl</code>，从而达到了我们预期的效果。</p>
<h4 id="场景二：应用运行前的准备工作"><a href="#场景二：应用运行前的准备工作" class="headerlink" title="场景二：应用运行前的准备工作"></a>场景二：应用运行前的准备工作</h4><p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p>
<p>比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</p>
<p>此外，可能希望避免使用 <code>root</code> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 <code>root</code> 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 <code>root</code> 身份执行，方便调试等。</p>
<p>这些准备工作是和容器 <code>CMD</code> 无关的，无论 <code>CMD</code> 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 <code>ENTRYPOINT</code> 中去执行，而这个脚本会将接到的参数（也就是 <code>&lt;CMD&gt;</code>）作为命令，在脚本最后执行。比如官方镜像 <code>redis</code> 中就是这么做的：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.4</span></div><div class="line">...</div><div class="line"><span class="keyword">RUN</span><span class="bash"> addgroup -S redis &amp;&amp; adduser -S -G redis redis</span></div><div class="line">...</div><div class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"docker-entrypoint.sh"</span>]</span></div><div class="line"></div><div class="line"><span class="keyword">EXPOSE</span> <span class="number">6379</span></div><div class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"redis-server"</span> ]</span></div></pre></td></tr></table></figure>
<p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 <code>ENTRYPOINT</code> 为 <code>docker-entrypoint.sh</code> 脚本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line">...</div><div class="line"><span class="comment"># allow the container to be started with `--user`</span></div><div class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">'redis-server'</span> -a <span class="string">"<span class="variable">$(id -u)</span>"</span> = <span class="string">'0'</span> ]; <span class="keyword">then</span></div><div class="line">	chown -R redis .</div><div class="line">	<span class="built_in">exec</span> su-exec redis <span class="string">"<span class="variable">$0</span>"</span> <span class="string">"<span class="variable">$@</span>"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></div></pre></td></tr></table></figure>
<p>该脚本的内容就是根据 <code>CMD</code> 的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务器，否则依旧使用 <code>root</code> 身份执行。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker run -it redis id</div><div class="line">uid=0(root) gid=0(root) groups=0(root)</div></pre></td></tr></table></figure>
<h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>格式有两种：</p>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul>
<p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ENV VERSION=1.0 DEBUG=on \</div><div class="line">    NAME=&quot;Happy Feet&quot;</div></pre></td></tr></table></figure>
<p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p>
<p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 <code>node</code> 镜像 <code>Dockerfile</code> 中，就有类似这样的代码：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ENV</span> NODE_VERSION <span class="number">7.2</span>.<span class="number">0</span></div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> curl -SLO <span class="string">"https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz"</span> \</span></div><div class="line">  &amp;&amp; curl -SLO <span class="string">"https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/SHASUMS256.txt.asc"</span> \</div><div class="line">  &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \</div><div class="line">  &amp;&amp; grep <span class="string">" node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz\$"</span> SHASUMS256.txt | sha256sum -c - \</div><div class="line">  &amp;&amp; tar -xJf <span class="string">"node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz"</span> -C /usr/<span class="built_in">local</span> --strip-components=1 \</div><div class="line">  &amp;&amp; rm <span class="string">"node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz"</span> SHASUMS256.txt.asc SHASUMS256.txt \</div><div class="line">  &amp;&amp; ln -s /usr/<span class="built_in">local</span>/bin/node /usr/<span class="built_in">local</span>/bin/nodejs</div></pre></td></tr></table></figure>
<p>在这里先定义了环境变量 <code>NODE_VERSION</code>，其后的 <code>RUN</code> 这层里，多次使用 <code>$NODE_VERSION</code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <code>7.2.0</code> 即可，<code>Dockerfile</code> 构建维护变得更轻松了。</p>
<p>下列指令可以支持环境变量展开： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>。</p>
<p>可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 <code>Dockerfile</code> 制作更多的镜像，只需使用不同的环境变量即可。</p>
<h3 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h3><p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p>
<p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p>
<p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p>
<p>在 1.13 之前的版本，要求 <code>--build-arg</code> 中的参数名，必须在 <code>Dockerfile</code> 中用 <code>ARG</code> 定义过了，换句话说，就是 <code>--build-arg</code> 指定的参数，必须在 <code>Dockerfile</code> 中使用了。如果对应参数没有被使用，则会报错退出构建。从 1.13 开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用 CI 系统，用同样的构建流程构建不同的 <code>Dockerfile</code> 的时候比较有帮助，避免构建命令必须根据每个 Dockerfile 的内容修改。</p>
<h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>格式为：</p>
<ul>
<li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li>
<li><code>VOLUME &lt;路径&gt;</code></li>
</ul>
<p>之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">VOLUME</span><span class="bash"> /data</span></div></pre></td></tr></table></figure>
<p>这里的 <code>/data</code> 目录就会在运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -v mydata:/data xxxx</div></pre></td></tr></table></figure>
<p>在这行命令中，就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置。</p>
<h3 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h3><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p>
<p><code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p>
<p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
<h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h3><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p>
<p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p>
<p>之前提到一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /app</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"hello"</span> &gt; world.txt</span></div></pre></td></tr></table></figure>
<p>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 <code>Dockerfile</code> 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 <code>Dockerfile</code> 构建分层存储的概念不了解所导致的错误。</p>
<p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p>
<p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p>
<h3 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h3><p>格式：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p>
<p><code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。</p>
<p>当然，和 <code>WORKDIR</code> 一样，<code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">RUN</span><span class="bash"> groupadd -r redis &amp;&amp; useradd -r -g redis redis</span></div><div class="line"><span class="keyword">USER</span> redis</div><div class="line"><span class="keyword">RUN</span><span class="bash"> [ <span class="string">"redis-server"</span> ]</span></div></pre></td></tr></table></figure>
<p>如果以 <code>root</code> 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 <code>su</code> 或者 <code>sudo</code>，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 <a href="https://github.com/tianon/gosu" target="_blank" rel="external"><code>gosu</code></a>。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> groupadd -r redis &amp;&amp; useradd -r -g redis redis</span></div><div class="line"><span class="comment"># 下载 gosu</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> wget -O /usr/<span class="built_in">local</span>/bin/gosu <span class="string">"https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64"</span> \</span></div><div class="line">    &amp;&amp; chmod +x /usr/<span class="built_in">local</span>/bin/gosu \</div><div class="line">    &amp;&amp; gosu nobody <span class="literal">true</span></div><div class="line"><span class="comment"># 设置 CMD，并以另外的用户执行</span></div><div class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"exec"</span>, <span class="string">"gosu"</span>, <span class="string">"redis"</span>, <span class="string">"redis-server"</span> ]</span></div></pre></td></tr></table></figure>
<h3 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h3><p>格式：</p>
<ul>
<li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令</li>
<li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li>
</ul>
<p><code>HEALTHCHECK</code> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。</p>
<p>在没有 <code>HEALTHCHECK</code> 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</p>
<p>而自 1.12 之后，Docker 提供了 <code>HEALTHCHECK</code> 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。</p>
<p>当在一个镜像指定了 <code>HEALTHCHECK</code> 指令后，用其启动容器，初始状态会为 <code>starting</code>，在 <code>HEALTHCHECK</code> 指令检查成功后变为 <code>healthy</code>，如果连续一定次数失败，则会变为 <code>unhealthy</code>。</p>
<p><code>HEALTHCHECK</code> 支持下列选项：</p>
<ul>
<li><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</li>
<li><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li>
<li><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</li>
</ul>
<p>和 <code>CMD</code>, <code>ENTRYPOINT</code> 一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。</p>
<p>在 <code>HEALTHCHECK [选项] CMD</code> 后面的命令，格式和 <code>ENTRYPOINT</code> 一样，分为 <code>shell</code> 格式，和 <code>exec</code> 格式。命令的返回值决定了该次健康检查的成功与否：<code>0</code>：成功；<code>1</code>：失败；<code>2</code>：保留，不要使用这个值。</p>
<p>假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 <code>curl</code> 来帮助判断，其 <code>Dockerfile</code> 的 <code>HEALTHCHECK</code> 可以这么写：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> nginx</div><div class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*</span></div><div class="line"><span class="keyword">HEALTHCHECK</span><span class="bash"> --interval=5s --timeout=3s \</span></div><div class="line">  CMD curl -fs http://localhost/ || <span class="built_in">exit</span> 1</div></pre></td></tr></table></figure>
<p>这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 <code>curl -fs http://localhost/ || exit 1</code> 作为健康检查命令。</p>
<p>使用 <code>docker build</code> 来构建这个镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker build -t myweb:v1 .</div></pre></td></tr></table></figure>
<p>构建好了后，我们启动一个容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -d --name web -p 80:80 myweb:v1</div></pre></td></tr></table></figure>
<p>当运行该镜像后，可以通过 <code>docker container ls</code> 看到最初的状态为 <code>(health: starting)</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ docker container ls</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                            PORTS               NAMES</div><div class="line">03e28eb00bd0        myweb:v1            <span class="string">"nginx -g 'daemon off"</span>   3 seconds ago       Up 2 seconds (health: starting)   80/tcp, 443/tcp     web</div></pre></td></tr></table></figure>
<p>在等待几秒钟后，再次 <code>docker container ls</code>，就会看到健康状态变化为了 <code>(healthy)</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ docker container ls</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                    PORTS               NAMES</div><div class="line">03e28eb00bd0        myweb:v1            <span class="string">"nginx -g 'daemon off"</span>   18 seconds ago      Up 16 seconds (healthy)   80/tcp, 443/tcp     web</div></pre></td></tr></table></figure>
<p>如果健康检查连续失败超过了重试次数，状态就会变为 <code>(unhealthy)</code>。</p>
<p>为了帮助排障，健康检查命令的输出（包括 <code>stdout</code> 以及 <code>stderr</code>）都会被存储于健康状态里，可以用 <code>docker inspect</code> 来查看。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ docker inspect --format <span class="string">'&#123;&#123;json .State.Health&#125;&#125;'</span> web | python -m json.tool</div><div class="line">&#123;</div><div class="line">    <span class="string">"FailingStreak"</span>: 0,</div><div class="line">    <span class="string">"Log"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="string">"End"</span>: <span class="string">"2016-11-25T14:35:37.940957051Z"</span>,</div><div class="line">            <span class="string">"ExitCode"</span>: 0,</div><div class="line">            <span class="string">"Output"</span>: <span class="string">"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n&lt;style&gt;\n    body &#123;\n        width: 35em;\n        margin: 0 auto;\n        font-family: Tahoma, Verdana, Arial, sans-serif;\n    &#125;\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;\n&lt;p&gt;If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.&lt;/p&gt;\n\n&lt;p&gt;For online documentation and support please refer to\n&lt;a href=\"http://nginx.org/\"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;\nCommercial support is available at\n&lt;a href=\"http://nginx.com/\"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n"</span>,</div><div class="line">            <span class="string">"Start"</span>: <span class="string">"2016-11-25T14:35:37.780192565Z"</span></div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    <span class="string">"Status"</span>: <span class="string">"healthy"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ONBUILD-为他人做嫁衣裳"><a href="#ONBUILD-为他人做嫁衣裳" class="headerlink" title="ONBUILD 为他人做嫁衣裳"></a>ONBUILD 为他人做嫁衣裳</h3><p>格式：<code>ONBUILD &lt;其它指令&gt;</code>。</p>
<p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code>, <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p>
<p><code>Dockerfile</code> 中的其它指令都是为了定制当前镜像而准备的，唯有 <code>ONBUILD</code> 是为了帮助别人定制自己而准备的。</p>
<p>假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 <code>npm</code> 进行包管理，所有依赖、配置、启动信息等会放到 <code>package.json</code> 文件里。在拿到程序代码后，需要先进行 <code>npm install</code> 才可以获得所有需要的依赖。然后就可以通过 <code>npm start</code> 来启动应用。因此，一般来说会这样写 <code>Dockerfile</code>：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> node:slim</div><div class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /app</span></div><div class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></div><div class="line"><span class="keyword">COPY</span><span class="bash"> ./package.json /app</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"install"</span> ]</span></div><div class="line"><span class="keyword">COPY</span><span class="bash"> . /app/</span></div><div class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span></div></pre></td></tr></table></figure>
<p>把这个 <code>Dockerfile</code> 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 <code>Dockerfile</code> 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。</p>
<p>如果第一个 Node.js 项目在开发过程中，发现这个 <code>Dockerfile</code> 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 <code>Dockerfile</code>，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初 <code>Dockerfile</code> 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 <code>Dockerfile</code>，而第二个项目的 <code>Dockerfile</code> 就会被自动修复。</p>
<p>那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 <code>Dockerfile</code> 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 <code>Dockerfile</code> 就会变为：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> node:slim</div><div class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /app</span></div><div class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></div><div class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span></div></pre></td></tr></table></figure>
<p>这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 <code>my-node</code> 的话，各个项目内的自己的 <code>Dockerfile</code> 就变为：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> my-node</div><div class="line"><span class="keyword">COPY</span><span class="bash"> ./package.json /app</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"install"</span> ]</span></div><div class="line"><span class="keyword">COPY</span><span class="bash"> . /app/</span></div></pre></td></tr></table></figure>
<p>基础镜像变化后，各个项目都用这个 <code>Dockerfile</code> 重新构建镜像，会继承基础镜像的更新。</p>
<p>那么，问题解决了么？没有。准确说，只解决了一半。如果这个 <code>Dockerfile</code> 里面有些东西需要调整呢？比如 <code>npm install</code> 都需要加一些参数，那怎么办？这一行 <code>RUN</code> 是不可能放入基础镜像的，因为涉及到了当前项目的 <code>./package.json</code>，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 <code>Dockerfile</code> 的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。</p>
<p><code>ONBUILD</code> 可以解决这个问题。让我们用 <code>ONBUILD</code> 重新写一下基础镜像的 <code>Dockerfile</code>:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> node:slim</div><div class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /app</span></div><div class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></div><div class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="bash"> ./package.json /app</span></div><div class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"install"</span> ]</span></div><div class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="bash"> . /app/</span></div><div class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span></div></pre></td></tr></table></figure>
<p>这次我们回到原始的 <code>Dockerfile</code>，但是这次将项目相关的指令加上 <code>ONBUILD</code>，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 <code>Dockerfile</code> 就变成了简单地：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> my-node</div></pre></td></tr></table></figure>
<p>是的，只有这么一行。当在各个项目目录中，用这个只有一行的 <code>Dockerfile</code> 构建镜像时，之前基础镜像的那三行 <code>ONBUILD</code> 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 <code>npm install</code>，生成应用镜像。</p>
<h2 id="多阶段构建"><a href="#多阶段构建" class="headerlink" title="多阶段构建"></a>多阶段构建</h2><h3 id="之前的做法"><a href="#之前的做法" class="headerlink" title="之前的做法"></a>之前的做法</h3><p>在 Docker 17.05 版本之前，我们构建 Docker 镜像时，通常会采用两种方式：</p>
<h4 id="全部放入一个-Dockerfile"><a href="#全部放入一个-Dockerfile" class="headerlink" title="全部放入一个 Dockerfile"></a>全部放入一个 Dockerfile</h4><p>一种方式是将所有的构建过程编包含在一个 <code>Dockerfile</code> 中，包括项目及其依赖库的编译、测试、打包等流程，这里可能会带来的一些问题：</p>
<ul>
<li><p>镜像层次多，镜像体积较大，部署时间变长</p>
</li>
<li><p>源代码存在泄露的风险</p>
</li>
</ul>
<p>例如，编写 <code>app.go</code> 文件，该程序输出 <code>Hello World!</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    fmt.Printf(<span class="string">"Hello World!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编写 <code>Dockerfile.one</code> 文件</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> golang:<span class="number">1.9</span>-alpine</div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> apk --no-cache add git ca-certificates</span></div><div class="line"></div><div class="line"><span class="keyword">WORKDIR</span><span class="bash"> /go/src/github.com/go/helloworld/</span></div><div class="line"></div><div class="line"><span class="keyword">COPY</span><span class="bash"> app.go .</span></div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> go get -d -v github.com/go-sql-driver/mysql \</span></div><div class="line">  &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . \</div><div class="line">  &amp;&amp; cp /go/src/github.com/go/helloworld/app /root</div><div class="line"></div><div class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root/</span></div><div class="line"></div><div class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"./app"</span>]</span></div></pre></td></tr></table></figure>
<p>构建镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker build -t go/helloworld:1 -f Dockerfile.one .</div></pre></td></tr></table></figure>
<h4 id="分散到多个-Dockerfile"><a href="#分散到多个-Dockerfile" class="headerlink" title="分散到多个 Dockerfile"></a>分散到多个 Dockerfile</h4><p>另一种方式，就是我们事先在一个 <code>Dockerfile</code> 将项目及其依赖库编译测试打包好后，再将其拷贝到运行环境中，这种方式需要我们编写两个 <code>Dockerfile</code> 和一些编译脚本才能将其两个阶段自动整合起来，这种方式虽然可以很好地规避第一种方式存在的风险，但明显部署过程较复杂。</p>
<p>例如，编写 <code>Dockerfile.build</code> 文件</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> golang:<span class="number">1.9</span>-alpine</div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> apk --no-cache add git</span></div><div class="line"></div><div class="line"><span class="keyword">WORKDIR</span><span class="bash"> /go/src/github.com/go/helloworld</span></div><div class="line"></div><div class="line"><span class="keyword">COPY</span><span class="bash"> app.go .</span></div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> go get -d -v github.com/go-sql-driver/mysql \</span></div><div class="line">  &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</div></pre></td></tr></table></figure>
<p>编写 <code>Dockerfile.copy</code> 文件</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> alpine:latest</div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> apk --no-cache add ca-certificates</span></div><div class="line"></div><div class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root/</span></div><div class="line"></div><div class="line"><span class="keyword">COPY</span><span class="bash"> app .</span></div><div class="line"></div><div class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"./app"</span>]</span></div></pre></td></tr></table></figure>
<p>新建 <code>build.sh</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"><span class="built_in">echo</span> Building go/helloworld:build</div><div class="line"></div><div class="line">docker build -t go/helloworld:build . -f Dockerfile.build</div><div class="line"></div><div class="line">docker create --name extract go/helloworld:build</div><div class="line">docker cp extract:/go/src/github.com/go/helloworld/app ./app</div><div class="line">docker rm -f extract</div><div class="line"></div><div class="line"><span class="built_in">echo</span> Building go/helloworld:2</div><div class="line"></div><div class="line">docker build --no-cache -t go/helloworld:2 . -f Dockerfile.copy</div><div class="line">rm ./app</div></pre></td></tr></table></figure>
<p>现在运行脚本即可构建镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ chmod +x build.sh</div><div class="line"></div><div class="line">$ ./build.sh</div></pre></td></tr></table></figure>
<p>对比两种方式生成的镜像大小</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ docker image ls</div><div class="line"></div><div class="line">REPOSITORY      TAG    IMAGE ID        CREATED         SIZE</div><div class="line">go/helloworld   2      f7cf3465432c    22 seconds ago  6.47MB</div><div class="line">go/helloworld   1      f55d3e16affc    2 minutes ago   295MB</div></pre></td></tr></table></figure>
<h3 id="使用多阶段构建"><a href="#使用多阶段构建" class="headerlink" title="使用多阶段构建"></a>使用多阶段构建</h3><p>为解决以上问题，Docker v17.05 开始支持多阶段构建 (<code>multistage builds</code>)。使用多阶段构建我们就可以很容易解决前面提到的问题，并且只需要编写一个 <code>Dockerfile</code>：</p>
<p>例如，编写 <code>Dockerfile</code> 文件</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> golang:<span class="number">1.9</span>-alpine as builder</div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> apk --no-cache add git</span></div><div class="line"></div><div class="line"><span class="keyword">WORKDIR</span><span class="bash"> /go/src/github.com/go/helloworld/</span></div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> go get -d -v github.com/go-sql-driver/mysql</span></div><div class="line"></div><div class="line"><span class="keyword">COPY</span><span class="bash"> app.go .</span></div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></div><div class="line"></div><div class="line"><span class="keyword">FROM</span> alpine:latest as prod</div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> apk --no-cache add ca-certificates</span></div><div class="line"></div><div class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root/</span></div><div class="line"></div><div class="line"><span class="keyword">COPY</span><span class="bash"> --from=0 /go/src/github.com/go/helloworld/app .</span></div><div class="line"></div><div class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"./app"</span>]</span></div></pre></td></tr></table></figure>
<p>构建镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker build -t go/helloworld:3 .</div></pre></td></tr></table></figure>
<p>对比三个镜像大小</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ docker image ls</div><div class="line"></div><div class="line">REPOSITORY        TAG   IMAGE ID         CREATED            SIZE</div><div class="line">go/helloworld     3     d6911ed9c846     7 seconds ago      6.47MB</div><div class="line">go/helloworld     2     f7cf3465432c     22 seconds ago     6.47MB</div><div class="line">go/helloworld     1     f55d3e16affc     2 minutes ago      295MB</div></pre></td></tr></table></figure>
<p>很明显使用多阶段构建的镜像体积小，同时也完美解决了上边提到的问题。</p>
<h4 id="只构建某一阶段的镜像"><a href="#只构建某一阶段的镜像" class="headerlink" title="只构建某一阶段的镜像"></a>只构建某一阶段的镜像</h4><p>我们可以使用 <code>as</code> 来为某一阶段命名，例如</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> golang:<span class="number">1.9</span>-alpine as builder</div></pre></td></tr></table></figure>
<p>例如当我们只想构建 <code>builder</code> 阶段的镜像时，增加 <code>--target=builder</code> 参数即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker build --target builder -t username/imagename:tag .</div></pre></td></tr></table></figure>
<h4 id="构建时从其他镜像复制文件"><a href="#构建时从其他镜像复制文件" class="headerlink" title="构建时从其他镜像复制文件"></a>构建时从其他镜像复制文件</h4><p>上面例子中我们使用 <code>COPY --from=0 /go/src/github.com/go/helloworld/app .</code> 从上一阶段的镜像中复制文件，我们也可以复制任意镜像中的文件。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">COPY</span><span class="bash"> --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf</span></div></pre></td></tr></table></figure>
<h2 id="实战多阶段构建-Laravel-镜像"><a href="#实战多阶段构建-Laravel-镜像" class="headerlink" title="实战多阶段构建 Laravel 镜像"></a>实战多阶段构建 Laravel 镜像</h2><blockquote>
<p>本节适用于 PHP 开发者阅读。</p>
</blockquote>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>新建一个 <code>Laravel</code> 项目或在已有的 <code>Laravel</code> 项目根目录下新建 <code>Dockerfile</code> <code>.dockerignore</code> <code>laravel.conf</code> 文件。</p>
<p>在 <code>.dockerignore</code> 文件中写入以下内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.idea/</div><div class="line">.git/</div><div class="line">vendor/</div><div class="line">node_modules/</div><div class="line">public/js/</div><div class="line">public/css/</div><div class="line">yarn-error.log</div><div class="line"></div><div class="line">bootstrap/cache/*</div><div class="line">storage/</div><div class="line"></div><div class="line"><span class="comment"># 自行添加其他需要排除的文件，例如 .env.* 文件</span></div></pre></td></tr></table></figure>
<p>在 <code>laravel.conf</code> 文件中写入 nginx 配置。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="section">server</span> &#123;</div><div class="line">  <span class="attribute">listen</span> <span class="number">80</span> default_server;</div><div class="line">  <span class="attribute">root</span> /app/laravel/public;</div><div class="line">  <span class="attribute">index</span> index.php index.html;</div><div class="line"></div><div class="line">  <span class="attribute">location</span> / &#123;</div><div class="line">      <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.php?<span class="variable">$query_string</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="attribute">location</span> <span class="regexp">~ .*\.php(\/.*)*$</span> &#123;</div><div class="line">    <span class="attribute">fastcgi_pass</span>   laravel:<span class="number">9000</span>;</div><div class="line">    <span class="attribute">include</span>        fastcgi.conf;</div><div class="line"></div><div class="line">    <span class="comment"># fastcgi_connect_timeout 300;</span></div><div class="line">    <span class="comment"># fastcgi_send_timeout 300;</span></div><div class="line">    <span class="comment"># fastcgi_read_timeout 300;</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="前端构建"><a href="#前端构建" class="headerlink" title="前端构建"></a>前端构建</h3><p>第一阶段进行前端构建。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> node:alpine as frontend</div><div class="line"></div><div class="line"><span class="keyword">COPY</span><span class="bash"> package.json /app/</span></div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /app \</span></div><div class="line">      &amp;&amp; npm install --registry=https://registry.npm.taobao.org</div><div class="line"></div><div class="line"><span class="keyword">COPY</span><span class="bash"> webpack.mix.js /app/</span></div><div class="line"><span class="keyword">COPY</span><span class="bash"> resources/assets/ /app/resources/assets/</span></div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /app \</span></div><div class="line">      &amp;&amp; npm run production</div></pre></td></tr></table></figure>
<h3 id="安装-Composer-依赖"><a href="#安装-Composer-依赖" class="headerlink" title="安装 Composer 依赖"></a>安装 Composer 依赖</h3><p>第二阶段安装 Composer 依赖。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> composer as composer</div><div class="line"></div><div class="line"><span class="keyword">COPY</span><span class="bash"> database/ /app/database/</span></div><div class="line"><span class="keyword">COPY</span><span class="bash"> composer.json composer.lock /app/</span></div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /app \</span></div><div class="line">      &amp;&amp; composer config -g repo.packagist composer https://packagist.laravel-china.org \</div><div class="line">      &amp;&amp; composer install \</div><div class="line">           --ignore-platform-reqs \</div><div class="line">           --no-interaction \</div><div class="line">           --no-plugins \</div><div class="line">           --no-scripts \</div><div class="line">           --prefer-dist</div></pre></td></tr></table></figure>
<h3 id="整合以上阶段所生成的文件"><a href="#整合以上阶段所生成的文件" class="headerlink" title="整合以上阶段所生成的文件"></a>整合以上阶段所生成的文件</h3><p>第三阶段对以上阶段生成的文件进行整合。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> php:<span class="number">7.2</span>-fpm-alpine as laravel</div><div class="line"></div><div class="line"><span class="keyword">ARG</span> LARAVEL_PATH=/app/laravel</div><div class="line"></div><div class="line"><span class="keyword">COPY</span><span class="bash"> --from=composer /app/vendor/ <span class="variable">$&#123;LARAVEL_PATH&#125;</span>/vendor/</span></div><div class="line"><span class="keyword">COPY</span><span class="bash"> . <span class="variable">$&#123;LARAVEL_PATH&#125;</span></span></div><div class="line"><span class="keyword">COPY</span><span class="bash"> --from=frontend /app/public/js/ <span class="variable">$&#123;LARAVEL_PATH&#125;</span>/public/js/</span></div><div class="line"><span class="keyword">COPY</span><span class="bash"> --from=frontend /app/public/css/ <span class="variable">$&#123;LARAVEL_PATH&#125;</span>/public/css/</span></div><div class="line"><span class="keyword">COPY</span><span class="bash"> --from=frontend /app/mix-manifest.json <span class="variable">$&#123;LARAVEL_PATH&#125;</span>/mix-manifest.json</span></div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$&#123;LARAVEL_PATH&#125;</span> \</span></div><div class="line">      &amp;&amp; php artisan package:discover \</div><div class="line">      &amp;&amp; mkdir -p storage \</div><div class="line">      &amp;&amp; mkdir -p storage/framework/cache \</div><div class="line">      &amp;&amp; mkdir -p storage/framework/sessions \</div><div class="line">      &amp;&amp; mkdir -p storage/framework/testing \</div><div class="line">      &amp;&amp; mkdir -p storage/framework/views \</div><div class="line">      &amp;&amp; mkdir -p storage/logs \</div><div class="line">      &amp;&amp; chmod -R 777 storage</div></pre></td></tr></table></figure>
<h3 id="最后一个阶段构建-NGINX-镜像"><a href="#最后一个阶段构建-NGINX-镜像" class="headerlink" title="最后一个阶段构建 NGINX 镜像"></a>最后一个阶段构建 NGINX 镜像</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> nginx:alpine as nginx</div><div class="line"></div><div class="line"><span class="keyword">ARG</span> LARAVEL_PATH=/app/laravel</div><div class="line"></div><div class="line"><span class="keyword">COPY</span><span class="bash"> laravel.conf /etc/nginx/conf.d/</span></div><div class="line"><span class="keyword">COPY</span><span class="bash"> --from=laravel <span class="variable">$&#123;LARAVEL_PATH&#125;</span>/public <span class="variable">$&#123;LARAVEL_PATH&#125;</span>/public</span></div></pre></td></tr></table></figure>
<h3 id="构建-Laravel-及-Nginx-镜像"><a href="#构建-Laravel-及-Nginx-镜像" class="headerlink" title="构建 Laravel 及 Nginx 镜像"></a>构建 Laravel 及 Nginx 镜像</h3><p>使用 <code>docker build</code> 命令构建镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ docker build -t my/laravel --target=laravel .</div><div class="line"></div><div class="line">$ docker build -t my/nginx --target=nginx .</div></pre></td></tr></table></figure>
<h3 id="启动容器并测试"><a href="#启动容器并测试" class="headerlink" title="启动容器并测试"></a>启动容器并测试</h3><p>新建 Docker 网络</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker network create laravel</div></pre></td></tr></table></figure>
<p>启动 laravel 容器， <code>--name=laravel</code> 参数设定的名字必须与 <code>nginx</code> 配置文件中的 <code>fastcgi_pass   laravel:9000;</code> 一致</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -it --rm --name=laravel --network=laravel my/laravel</div></pre></td></tr></table></figure>
<p>启动 nginx 容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -it --rm --network=laravel -p 8080:80 my/nginx</div></pre></td></tr></table></figure>
<p>浏览器访问 <code>127.0.0.1:8080</code> 可以看到 Laravel 项目首页。</p>
<blockquote>
<p>也许 Laravel 项目依赖其他外部服务，例如 redis、MySQL，请自行启动这些服务之后再进行测试，本小节不再赘述。</p>
</blockquote>
<h3 id="生产环境优化"><a href="#生产环境优化" class="headerlink" title="生产环境优化"></a>生产环境优化</h3><p>本小节内容为了方便测试，将配置文件直接放到了镜像中，实际在使用时 <strong>建议</strong> 将配置文件作为 <code>config</code> 或 <code>secret</code> 挂载到容器中，请读者自行学习 <code>Swarm mode</code> 或 <code>Kubernetes</code> 的相关内容。</p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>完整的 <code>Dockerfile</code> 文件如下。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> node:alpine as frontend</div><div class="line"></div><div class="line"><span class="keyword">COPY</span><span class="bash"> package.json /app/</span></div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /app \</span></div><div class="line">      &amp;&amp; npm install --registry=https://registry.npm.taobao.org</div><div class="line"></div><div class="line"><span class="keyword">COPY</span><span class="bash"> webpack.mix.js /app/</span></div><div class="line"><span class="keyword">COPY</span><span class="bash"> resources/assets/ /app/resources/assets/</span></div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /app \</span></div><div class="line">      &amp;&amp; npm run production</div><div class="line"></div><div class="line"><span class="keyword">FROM</span> composer as composer</div><div class="line"></div><div class="line"><span class="keyword">COPY</span><span class="bash"> database/ /app/database/</span></div><div class="line"><span class="keyword">COPY</span><span class="bash"> composer.json /app/</span></div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /app \</span></div><div class="line">      &amp;&amp; composer config -g repo.packagist composer https://packagist.laravel-china.org \</div><div class="line">      &amp;&amp; composer install \</div><div class="line">           --ignore-platform-reqs \</div><div class="line">           --no-interaction \</div><div class="line">           --no-plugins \</div><div class="line">           --no-scripts \</div><div class="line">           --prefer-dist</div><div class="line"></div><div class="line"><span class="keyword">FROM</span> php:<span class="number">7.2</span>-fpm-alpine as laravel</div><div class="line"></div><div class="line"><span class="keyword">ARG</span> LARAVEL_PATH=/app/laravel</div><div class="line"></div><div class="line"><span class="keyword">COPY</span><span class="bash"> --from=composer /app/vendor/ <span class="variable">$&#123;LARAVEL_PATH&#125;</span>/vendor/</span></div><div class="line"><span class="keyword">COPY</span><span class="bash"> . <span class="variable">$&#123;LARAVEL_PATH&#125;</span></span></div><div class="line"><span class="keyword">COPY</span><span class="bash"> --from=frontend /app/public/js/ <span class="variable">$&#123;LARAVEL_PATH&#125;</span>/public/js/</span></div><div class="line"><span class="keyword">COPY</span><span class="bash"> --from=frontend /app/public/css/ <span class="variable">$&#123;LARAVEL_PATH&#125;</span>/public/css/</span></div><div class="line"><span class="keyword">COPY</span><span class="bash"> --from=frontend /app/mix-manifest.json <span class="variable">$&#123;LARAVEL_PATH&#125;</span>/mix-manifest.json</span></div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$&#123;LARAVEL_PATH&#125;</span> \</span></div><div class="line">      &amp;&amp; php artisan package:discover \</div><div class="line">      &amp;&amp; mkdir -p storage \</div><div class="line">      &amp;&amp; mkdir -p storage/framework/cache \</div><div class="line">      &amp;&amp; mkdir -p storage/framework/sessions \</div><div class="line">      &amp;&amp; mkdir -p storage/framework/testing \</div><div class="line">      &amp;&amp; mkdir -p storage/framework/views \</div><div class="line">      &amp;&amp; mkdir -p storage/logs \</div><div class="line">      &amp;&amp; chmod -R 777 storage</div><div class="line"></div><div class="line"><span class="keyword">FROM</span> nginx:alpine as nginx</div><div class="line"></div><div class="line"><span class="keyword">ARG</span> LARAVEL_PATH=/app/laravel</div><div class="line"></div><div class="line"><span class="keyword">COPY</span><span class="bash"> laravel.conf /etc/nginx/conf.d/</span></div><div class="line"><span class="keyword">COPY</span><span class="bash"> --from=laravel <span class="variable">$&#123;LARAVEL_PATH&#125;</span>/public <span class="variable">$&#123;LARAVEL_PATH&#125;</span>/public</span></div></pre></td></tr></table></figure>
<h2 id="其它制作镜像的方式"><a href="#其它制作镜像的方式" class="headerlink" title="其它制作镜像的方式"></a>其它制作镜像的方式</h2><p>除了标准的使用 <code>Dockerfile</code> 生成镜像的方法外，由于各种特殊需求和历史原因，还提供了一些其它方法用以生成镜像。</p>
<h3 id="从-rootfs-压缩包导入"><a href="#从-rootfs-压缩包导入" class="headerlink" title="从 rootfs 压缩包导入"></a>从 rootfs 压缩包导入</h3><p>格式：<code>docker import [选项] &lt;文件&gt;|&lt;URL&gt;|- [&lt;仓库名&gt;[:&lt;标签&gt;]]</code></p>
<p>压缩包可以是本地文件、远程 Web 文件，甚至是从标准输入中得到。压缩包将会在镜像 <code>/</code> 目录展开，并直接作为镜像第一层提交。</p>
<p>比如我们想要创建一个 <a href="https://openvz.org" target="_blank" rel="external">OpenVZ</a> 的 Ubuntu 14.04 <a href="https://openvz.org/Download/template/precreated" target="_blank" rel="external">模板</a>的镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ docker import \</div><div class="line">    http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz \</div><div class="line">    openvz/ubuntu:14.04</div><div class="line">Downloading from http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz</div><div class="line">sha256:f477a6e18e989839d25223f301ef738b69621c4877600ae6467c4e5289822a79B/78.42 MB</div></pre></td></tr></table></figure>
<p>这条命令自动下载了 <code>ubuntu-14.04-x86_64-minimal.tar.gz</code> 文件，并且作为根文件系统展开导入，并保存为镜像 <code>openvz/ubuntu:14.04</code>。</p>
<p>导入成功后，我们可以用 <code>docker image ls</code> 看到这个导入的镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ docker image ls openvz/ubuntu</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">openvz/ubuntu       14.04               f477a6e18e98        55 seconds ago      214.9 MB</div></pre></td></tr></table></figure>
<p>如果我们查看其历史的话，会看到描述中有导入的文件链接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ docker <span class="built_in">history</span> openvz/ubuntu:14.04</div><div class="line">IMAGE               CREATED              CREATED BY          SIZE                COMMENT</div><div class="line">f477a6e18e98        About a minute ago                       214.9 MB            Imported from http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz</div></pre></td></tr></table></figure>
<h3 id="docker-save-和-docker-load"><a href="#docker-save-和-docker-load" class="headerlink" title="docker save 和 docker load"></a><code>docker save</code> 和 <code>docker load</code></h3><p>Docker 还提供了 <code>docker save</code> 和 <code>docker load</code> 命令，用以将镜像保存为一个文件，然后传输到另一个位置上，再加载进来。这是在没有 Docker Registry 时的做法，现在已经不推荐，镜像迁移应该直接使用 Docker Registry，无论是直接使用 Docker Hub 还是使用内网私有 Registry 都可以。</p>
<h4 id="保存镜像"><a href="#保存镜像" class="headerlink" title="保存镜像"></a>保存镜像</h4><p>使用 <code>docker save</code> 命令可以将镜像保存为归档文件。</p>
<p>比如我们希望保存这个 <code>alpine</code> 镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ docker image ls alpine</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">alpine              latest              baa5d63471ea        5 weeks ago         4.803 MB</div></pre></td></tr></table></figure>
<p>保存镜像的命令为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ docker save alpine -o filename</div><div class="line">$ file filename</div><div class="line">filename: POSIX tar archive</div></pre></td></tr></table></figure>
<p>这里的 filename 可以为任意名称甚至任意后缀名，但文件的本质都是归档文件</p>
<p><strong>注意：如果同名则会覆盖（没有警告）</strong></p>
<p>若使用 <code>gzip</code> 压缩：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker save alpine | gzip &gt; alpine-latest.tar.gz</div></pre></td></tr></table></figure>
<p>然后我们将 <code>alpine-latest.tar.gz</code> 文件复制到了到了另一个机器上，可以用下面这个命令加载镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker load -i alpine-latest.tar.gz</div><div class="line">Loaded image: alpine:latest</div></pre></td></tr></table></figure>
<p>如果我们结合这两个命令以及 <code>ssh</code> 甚至 <code>pv</code> 的话，利用 Linux 强大的管道，我们可以写一个命令完成从一个机器将镜像迁移到另一个机器，并且带进度条的功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker save &lt;镜像名&gt; | bzip2 | pv | ssh &lt;用户名&gt;@&lt;主机名&gt; <span class="string">'cat | docker load'</span></div></pre></td></tr></table></figure>
<h2 id="Docker-命令查询"><a href="#Docker-命令查询" class="headerlink" title="Docker 命令查询"></a>Docker 命令查询</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>Docker 命令有两大类，客户端命令和服务端命令。前者是主要的操作接口，后者用来启动 Docker Daemon。</p>
<ul>
<li><p>客户端命令：基本命令格式为 <code>docker [OPTIONS] COMMAND [arg...]</code>；</p>
</li>
<li><p>服务端命令：基本命令格式为 <code>dockerd [OPTIONS]</code>。</p>
</li>
</ul>
<p>可以通过 <code>man docker</code> 或 <code>docker help</code> 来查看这些命令。</p>
<h3 id="客户端命令选项"><a href="#客户端命令选项" class="headerlink" title="客户端命令选项"></a>客户端命令选项</h3><ul>
<li><code>--config=&quot;&quot;</code>：指定客户端配置文件，默认为 <code>~/.docker</code>；</li>
<li><code>-D=true|false</code>：是否使用 debug 模式。默认不开启；</li>
<li><code>-H, --host=[]</code>：指定命令对应 Docker 守护进程的监听接口，可以为 unix 套接字 <code>unix:///path/to/socket</code>，文件句柄 <code>fd://socketfd</code> 或 tcp 套接字 <code>tcp://[host[:port]]</code>，默认为 <code>unix:///var/run/docker.sock</code>；</li>
<li><code>-l, --log-level=&quot;debug|info|warn|error|fatal&quot;</code>：指定日志输出级别；</li>
<li><code>--tls=true|false</code>：是否对 Docker 守护进程启用 TLS 安全机制，默认为否；</li>
<li><code>--tlscacert=/.docker/ca.pem</code>：TLS CA 签名的可信证书文件路径；</li>
<li><code>--tlscert=/.docker/cert.pem</code>：TLS 可信证书文件路径；</li>
<li><code>--tlscert=/.docker/key.pem</code>：TLS 密钥文件路径；</li>
<li><code>--tlsverify=true|false</code>：启用 TLS 校验，默认为否。</li>
</ul>
<h3 id="dockerd-命令选项"><a href="#dockerd-命令选项" class="headerlink" title="dockerd 命令选项"></a>dockerd 命令选项</h3><ul>
<li><code>--api-cors-header=&quot;&quot;</code>：CORS 头部域，默认不允许 CORS，要允许任意的跨域访问，可以指定为 “*”；</li>
<li><code>--authorization-plugin=&quot;&quot;</code>：载入认证的插件；</li>
<li><code>-b=&quot;&quot;</code>：将容器挂载到一个已存在的网桥上。指定为 <code>none</code> 时则禁用容器的网络，与 <code>--bip</code> 选项互斥；</li>
<li><code>--bip=&quot;&quot;</code>：让动态创建的 <code>docker0</code> 网桥采用给定的 CIDR 地址; 与 <code>-b</code> 选项互斥；</li>
<li><code>--cgroup-parent=&quot;&quot;</code>：指定 cgroup 的父组，默认 fs cgroup 驱动为 <code>/docker</code>，systemd cgroup 驱动为 <code>system.slice</code>；</li>
<li><code>--cluster-store=&quot;&quot;</code>：构成集群（如 <code>Swarm</code>）时，集群键值数据库服务地址；</li>
<li><code>--cluster-advertise=&quot;&quot;</code>：构成集群时，自身的被访问地址，可以为 <code>host:port</code> 或 <code>interface:port</code>；</li>
<li><code>--cluster-store-opt=&quot;&quot;</code>：构成集群时，键值数据库的配置选项；</li>
<li><code>--config-file=&quot;/etc/docker/daemon.json&quot;</code>：daemon 配置文件路径；</li>
<li><code>--containerd=&quot;&quot;</code>：containerd 文件的路径；</li>
<li><code>-D, --debug=true|false</code>：是否使用 Debug 模式。缺省为 false；</li>
<li><code>--default-gateway=&quot;&quot;</code>：容器的 IPv4 网关地址，必须在网桥的子网段内；</li>
<li><code>--default-gateway-v6=&quot;&quot;</code>：容器的 IPv6 网关地址；</li>
<li><code>--default-ulimit=[]</code>：默认的 ulimit 值；</li>
<li><code>--disable-legacy-registry=true|false</code>：是否允许访问旧版本的镜像仓库服务器；</li>
<li><code>--dns=&quot;&quot;</code>：指定容器使用的 DNS 服务器地址；</li>
<li><code>--dns-opt=&quot;&quot;</code>：DNS 选项；</li>
<li><code>--dns-search=[]</code>：DNS 搜索域；</li>
<li><code>--exec-opt=[]</code>：运行时的执行选项；</li>
<li><code>--exec-root=&quot;&quot;</code>：容器执行状态文件的根路径，默认为 <code>/var/run/docker</code>；</li>
<li><code>--fixed-cidr=&quot;&quot;</code>：限定分配 IPv4 地址范围；</li>
<li><code>--fixed-cidr-v6=&quot;&quot;</code>：限定分配 IPv6 地址范围；</li>
<li><code>-G, --group=&quot;&quot;</code>：分配给 unix 套接字的组，默认为 <code>docker</code>；</li>
<li><code>-g, --graph=&quot;&quot;</code>：Docker 运行时的根路径，默认为 <code>/var/lib/docker</code>；</li>
<li><code>-H, --host=[]</code>：指定命令对应 Docker daemon 的监听接口，可以为 unix 套接字 <code>unix:///path/to/socket</code>，文件句柄 <code>fd://socketfd</code> 或 tcp 套接字 <code>tcp://[host[:port]]</code>，默认为 <code>unix:///var/run/docker.sock</code>；</li>
<li><code>--icc=true|false</code>：是否启用容器间以及跟 daemon 所在主机的通信。默认为 true。</li>
<li><code>--insecure-registry=[]</code>：允许访问给定的非安全仓库服务；</li>
<li><code>--ip=&quot;&quot;</code>：绑定容器端口时候的默认 IP 地址。缺省为 <code>0.0.0.0</code>；</li>
<li><code>--ip-forward=true|false</code>：是否检查启动在 Docker 主机上的启用 IP 转发服务，默认开启。注意关闭该选项将不对系统转发能力进行任何检查修改；</li>
<li><code>--ip-masq=true|false</code>：是否进行地址伪装，用于容器访问外部网络，默认开启；</li>
<li><code>--iptables=true|false</code>：是否允许 Docker 添加 iptables 规则。缺省为 true；</li>
<li><code>--ipv6=true|false</code>：是否启用 IPv6 支持，默认关闭；</li>
<li><code>-l, --log-level=&quot;debug|info|warn|error|fatal&quot;</code>：指定日志输出级别；</li>
<li><code>--label=&quot;[]&quot;</code>：添加指定的键值对标注；</li>
<li><code>--log-driver=&quot;json-file|syslog|journald|gelf|fluentd|awslogs|splunk|etwlogs|gcplogs|none&quot;</code>：指定日志后端驱动，默认为 <code>json-file</code>；</li>
<li><code>--log-opt=[]</code>：日志后端的选项；</li>
<li><code>--mtu=VALUE</code>：指定容器网络的 <code>mtu</code>；</li>
<li><code>-p=&quot;&quot;</code>：指定 daemon 的 PID 文件路径。缺省为 <code>/var/run/docker.pid</code>；</li>
<li><code>--raw-logs</code>：输出原始，未加色彩的日志信息；</li>
<li><code>--registry-mirror=&lt;scheme&gt;://&lt;host&gt;</code>：指定 <code>docker pull</code> 时使用的注册服务器镜像地址；</li>
<li><code>-s, --storage-driver=&quot;&quot;</code>：指定使用给定的存储后端；</li>
<li><code>--selinux-enabled=true|false</code>：是否启用 SELinux 支持。缺省值为 false。SELinux 目前尚不支持 overlay 存储驱动；</li>
<li><code>--storage-opt=[]</code>：驱动后端选项；</li>
<li><code>--tls=true|false</code>：是否对 Docker daemon 启用 TLS 安全机制，默认为否；</li>
<li><code>--tlscacert=/.docker/ca.pem</code>：TLS CA 签名的可信证书文件路径；</li>
<li><code>--tlscert=/.docker/cert.pem</code>：TLS 可信证书文件路径；</li>
<li><code>--tlscert=/.docker/key.pem</code>：TLS 密钥文件路径；</li>
<li><code>--tlsverify=true|false</code>：启用 TLS 校验，默认为否；</li>
<li><code>--userland-proxy=true|false</code>：是否使用用户态代理来实现容器间和出容器的回环通信，默认为 true；</li>
<li><code>--userns-remap=default|uid:gid|user:group|user|uid</code>：指定容器的用户命名空间，默认是创建新的 UID 和 GID 映射到容器内进程。</li>
</ul>
<h3 id="客户端命令"><a href="#客户端命令" class="headerlink" title="客户端命令"></a>客户端命令</h3><p>可以通过 <code>docker COMMAND --help</code> 来查看这些命令的具体用法。</p>
<ul>
<li><code>attach</code>：依附到一个正在运行的容器中；</li>
<li><code>build</code>：从一个 Dockerfile 创建一个镜像；</li>
<li><code>commit</code>：从一个容器的修改中创建一个新的镜像；</li>
<li><code>cp</code>：在容器和本地宿主系统之间复制文件中；</li>
<li><code>create</code>：创建一个新容器，但并不运行它；</li>
<li><code>diff</code>：检查一个容器内文件系统的修改，包括修改和增加；</li>
<li><code>events</code>：从服务端获取实时的事件；</li>
<li><code>exec</code>：在运行的容器内执行命令；</li>
<li><code>export</code>：导出容器内容为一个 <code>tar</code> 包；</li>
<li><code>history</code>：显示一个镜像的历史信息；</li>
<li><code>images</code>：列出存在的镜像；</li>
<li><code>import</code>：导入一个文件（典型为 <code>tar</code> 包）路径或目录来创建一个本地镜像；</li>
<li><code>info</code>：显示一些相关的系统信息；</li>
<li><code>inspect</code>：显示一个容器的具体配置信息；</li>
<li><code>kill</code>：关闭一个运行中的容器 (包括进程和所有相关资源)；</li>
<li><code>load</code>：从一个 tar 包中加载一个镜像；</li>
<li><code>login</code>：注册或登录到一个 Docker 的仓库服务器；</li>
<li><code>logout</code>：从 Docker 的仓库服务器登出；</li>
<li><code>logs</code>：获取容器的 log 信息；</li>
<li><code>network</code>：管理 Docker 的网络，包括查看、创建、删除、挂载、卸载等；</li>
<li><code>node</code>：管理 swarm 集群中的节点，包括查看、更新、删除、提升/取消管理节点等；</li>
<li><code>pause</code>：暂停一个容器中的所有进程；</li>
<li><code>port</code>：查找一个 nat 到一个私有网口的公共口；</li>
<li><code>ps</code>：列出主机上的容器；</li>
<li><code>pull</code>：从一个Docker的仓库服务器下拉一个镜像或仓库；</li>
<li><code>push</code>：将一个镜像或者仓库推送到一个 Docker 的注册服务器；</li>
<li><code>rename</code>：重命名一个容器；</li>
<li><code>restart</code>：重启一个运行中的容器；</li>
<li><code>rm</code>：删除给定的若干个容器；</li>
<li><code>rmi</code>：删除给定的若干个镜像；</li>
<li><code>run</code>：创建一个新容器，并在其中运行给定命令；</li>
<li><code>save</code>：保存一个镜像为 tar 包文件；</li>
<li><code>search</code>：在 Docker index 中搜索一个镜像；</li>
<li><code>service</code>：管理 Docker 所启动的应用服务，包括创建、更新、删除等；</li>
<li><code>start</code>：启动一个容器；</li>
<li><code>stats</code>：输出（一个或多个）容器的资源使用统计信息；</li>
<li><code>stop</code>：终止一个运行中的容器；</li>
<li><code>swarm</code>：管理 Docker swarm 集群，包括创建、加入、退出、更新等；</li>
<li><code>tag</code>：为一个镜像打标签；</li>
<li><code>top</code>：查看一个容器中的正在运行的进程信息；</li>
<li><code>unpause</code>：将一个容器内所有的进程从暂停状态中恢复；</li>
<li><code>update</code>：更新指定的若干容器的配置信息；</li>
<li><code>version</code>：输出 Docker 的版本信息；</li>
<li><code>volume</code>：管理 Docker volume，包括查看、创建、删除等；</li>
<li><code>wait</code>：阻塞直到一个容器终止，然后输出它的退出符。</li>
</ul>
<h3 id="一张图总结-Docker-的命令"><a href="#一张图总结-Docker-的命令" class="headerlink" title="一张图总结 Docker 的命令"></a>一张图总结 Docker 的命令</h3><p><img src="Docker/cmd_logic.png" alt="Docker 命令总结" title="docker命令"></p>
<h1 id="Dockerfile-最佳实践"><a href="#Dockerfile-最佳实践" class="headerlink" title="Dockerfile 最佳实践"></a>Dockerfile 最佳实践</h1><p>本附录是笔者对 Docker 官方文档中 <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank" rel="external">Best practices for writing Dockerfiles</a> 的理解与翻译。</p>
<h2 id="一般性的指南和建议"><a href="#一般性的指南和建议" class="headerlink" title="一般性的指南和建议"></a>一般性的指南和建议</h2><h3 id="容器应该是短暂的"><a href="#容器应该是短暂的" class="headerlink" title="容器应该是短暂的"></a>容器应该是短暂的</h3><p>通过 <code>Dockerfile</code> 构建的镜像所启动的容器应该尽可能短暂（生命周期短）。「短暂」意味着可以停止和销毁容器，并且创建一个新容器并部署好所需的设置和配置工作量应该是极小的。</p>
<h4 id="使用-dockerignore-文件"><a href="#使用-dockerignore-文件" class="headerlink" title="使用 .dockerignore 文件"></a>使用 <code>.dockerignore</code> 文件</h4><p>使用 <code>Dockerfile</code> 构建镜像时最好是将 <code>Dockerfile</code> 放置在一个新建的空目录下。然后将构建镜像所需要的文件添加到该目录中。为了提高构建镜像的效率，你可以在目录下新建一个 <code>.dockerignore</code> 文件来指定要忽略的文件和目录。<code>.dockerignore</code> 文件的排除模式语法和 Git 的 <code>.gitignore</code> 文件相似。</p>
<h4 id="使用多阶段构建-1"><a href="#使用多阶段构建-1" class="headerlink" title="使用多阶段构建"></a>使用多阶段构建</h4><p>在 <code>Docker 17.05</code> 以上版本中，你可以使用 <a href="../image/multistage-builds.md">多阶段构建</a> 来减少所构建镜像的大小。</p>
<h4 id="避免安装不必要的包"><a href="#避免安装不必要的包" class="headerlink" title="避免安装不必要的包"></a>避免安装不必要的包</h4><p>为了降低复杂性、减少依赖、减小文件大小、节约构建时间，你应该避免安装任何不必要的包。例如，不要在数据库镜像中包含一个文本编辑器。</p>
<h4 id="一个容器只运行一个进程"><a href="#一个容器只运行一个进程" class="headerlink" title="一个容器只运行一个进程"></a>一个容器只运行一个进程</h4><p>应该保证在一个容器中只运行一个进程。将多个应用解耦到不同容器中，保证了容器的横向扩展和复用。例如 web 应用应该包含三个容器：web应用、数据库、缓存。</p>
<p>如果容器互相依赖，你可以使用 <a href="../network/linking.md">Docker 自定义网络</a> 来把这些容器连接起来。</p>
<h4 id="镜像层数尽可能少"><a href="#镜像层数尽可能少" class="headerlink" title="镜像层数尽可能少"></a>镜像层数尽可能少</h4><p>你需要在 <code>Dockerfile</code> 可读性（也包括长期的可维护性）和减少层数之间做一个平衡。</p>
<h4 id="将多行参数排序"><a href="#将多行参数排序" class="headerlink" title="将多行参数排序"></a>将多行参数排序</h4><p>将多行参数按字母顺序排序（比如要安装多个包时）。这可以帮助你避免重复包含同一个包，更新包列表时也更容易。也便于 <code>PRs</code> 阅读和审查。建议在反斜杠符号 <code>\</code> 之前添加一个空格，以增加可读性。</p>
<p>下面是来自 <code>buildpack-deps</code> 镜像的例子：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y \</span></div><div class="line">  bzr \</div><div class="line">  cvs \</div><div class="line">  git \</div><div class="line">  mercurial \</div><div class="line">  subversion</div></pre></td></tr></table></figure>
<h4 id="构建缓存"><a href="#构建缓存" class="headerlink" title="构建缓存"></a>构建缓存</h4><p>在镜像的构建过程中，Docker 会遍历 <code>Dockerfile</code> 文件中的指令，然后按顺序执行。在执行每条指令之前，Docker 都会在缓存中查找是否已经存在可重用的镜像，如果有就使用现存的镜像，不再重复创建。如果你不想在构建过程中使用缓存，你可以在 <code>docker build</code> 命令中使用 <code>--no-cache=true</code> 选项。</p>
<p>但是，如果你想在构建的过程中使用缓存，你得明白什么时候会，什么时候不会找到匹配的镜像，遵循的基本规则如下：</p>
<ul>
<li>从一个基础镜像开始（<code>FROM</code> 指令指定），下一条指令将和该基础镜像的所有子镜像进行匹配，检查这些子镜像被创建时使用的指令是否和被检查的指令完全一样。如果不是，则缓存失效。</li>
<li>在大多数情况下，只需要简单地对比 <code>Dockerfile</code> 中的指令和子镜像。然而，有些指令需要更多的检查和解释。</li>
<li>对于 <code>ADD</code> 和 <code>COPY</code> 指令，镜像中对应文件的内容也会被检查，每个文件都会计算出一个校验和。文件的最后修改时间和最后访问时间不会纳入校验。在缓存的查找过程中，会将这些校验和和已存在镜像中的文件校验和进行对比。如果文件有任何改变，比如内容和元数据，则缓存失效。</li>
<li>除了 <code>ADD</code> 和 <code>COPY</code> 指令，缓存匹配过程不会查看临时容器中的文件来决定缓存是否匹配。例如，当执行完 <code>RUN apt-get -y update</code> 指令后，容器中一些文件被更新，但 Docker 不会检查这些文件。这种情况下，只有指令字符串本身被用来匹配缓存。</li>
</ul>
<p>一旦缓存失效，所有后续的 <code>Dockerfile</code> 指令都将产生新的镜像，缓存不会被使用。</p>
<h3 id="Dockerfile-指令"><a href="#Dockerfile-指令" class="headerlink" title="Dockerfile 指令"></a>Dockerfile 指令</h3><p>下面针对 <code>Dockerfile</code> 中各种指令的最佳编写方式给出建议。</p>
<h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p>尽可能使用当前官方仓库作为你构建镜像的基础。推荐使用 <a href="https://hub.docker.com/_/alpine/" target="_blank" rel="external">Alpine</a> 镜像，因为它被严格控制并保持最小尺寸（目前小于 5 MB），但它仍然是一个完整的发行版。</p>
<h4 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h4><p>你可以给镜像添加标签来帮助组织镜像、记录许可信息、辅助自动化构建等。每个标签一行，由 <code>LABEL</code> 开头加上一个或多个标签对。下面的示例展示了各种不同的可能格式。<code>#</code> 开头的行是注释内容。</p>
<blockquote>
<p>注意：如果你的字符串中包含空格，必须将字符串放入引号中或者对空格使用转义。如果字符串内容本身就包含引号，必须对引号使用转义。</p>
</blockquote>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Set one or more individual labels</span></div><div class="line"><span class="keyword">LABEL</span><span class="bash"> com.example.version=<span class="string">"0.0.1-beta"</span></span></div><div class="line"></div><div class="line"><span class="keyword">LABEL</span><span class="bash"> vendor=<span class="string">"ACME Incorporated"</span></span></div><div class="line"></div><div class="line"><span class="keyword">LABEL</span><span class="bash"> com.example.release-date=<span class="string">"2015-02-12"</span></span></div><div class="line"></div><div class="line"><span class="keyword">LABEL</span><span class="bash"> com.example.version.is-production=<span class="string">""</span></span></div></pre></td></tr></table></figure>
<p>一个镜像可以包含多个标签，但建议将多个标签放入到一个 <code>LABEL</code> 指令中。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Set multiple labels at once, using line-continuation characters to break long lines</span></div><div class="line"><span class="keyword">LABEL</span><span class="bash"> vendor=ACME\ Incorporated \</span></div><div class="line">      com.example.is-beta= \</div><div class="line">      com.example.is-production=<span class="string">""</span> \</div><div class="line">      com.example.version=<span class="string">"0.0.1-beta"</span> \</div><div class="line">      com.example.release-date=<span class="string">"2015-02-12"</span></div></pre></td></tr></table></figure>
<p>关于标签可以接受的键值对，参考 <a href="https://docs.docker.com/config/labels-custom-metadata/" target="_blank" rel="external">Understanding object labels</a>。关于查询标签信息，参考 <a href="https://docs.docker.com/config/labels-custom-metadata/" target="_blank" rel="external">Managing labels on objects</a>。</p>
<h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><p>为了保持 <code>Dockerfile</code> 文件的可读性，可理解性，以及可维护性，建议将长的或复杂的 <code>RUN</code> 指令用反斜杠 <code>\</code> 分割成多行。</p>
<h5 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h5><p><code>RUN</code> 指令最常见的用法是安装包用的 <code>apt-get</code>。因为 <code>RUN apt-get</code> 指令会安装包，所以有几个问题需要注意。</p>
<p>不要使用 <code>RUN apt-get upgrade</code> 或 <code>dist-upgrade</code>，因为许多基础镜像中的「必须」包不会在一个非特权容器中升级。如果基础镜像中的某个包过时了，你应该联系它的维护者。如果你确定某个特定的包，比如 <code>foo</code>，需要升级，使用 <code>apt-get install -y foo</code> 就行，该指令会自动升级 <code>foo</code> 包。</p>
<p>永远将 <code>RUN apt-get update</code> 和 <code>apt-get install</code> 组合成一条 <code>RUN</code> 声明，例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y \</span></div><div class="line">        package-bar \</div><div class="line">        package-baz \</div><div class="line">        package-foo</div></pre></td></tr></table></figure>
<p>将 <code>apt-get update</code> 放在一条单独的 <code>RUN</code> 声明中会导致缓存问题以及后续的 <code>apt-get install</code> 失败。比如，假设你有一个 <code>Dockerfile</code> 文件：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y curl</span></div></pre></td></tr></table></figure>
<p>构建镜像后，所有的层都在 Docker 的缓存中。假设你后来又修改了其中的 <code>apt-get install</code> 添加了一个包：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y curl nginx</span></div></pre></td></tr></table></figure>
<p>Docker 发现修改后的 <code>RUN apt-get update</code> 指令和之前的完全一样。所以，<code>apt-get update</code> 不会执行，而是使用之前的缓存镜像。因为 <code>apt-get update</code> 没有运行，后面的 <code>apt-get install</code> 可能安装的是过时的 <code>curl</code> 和 <code>nginx</code> 版本。</p>
<p>使用 <code>RUN apt-get update &amp;&amp; apt-get install -y</code> 可以确保你的 Dockerfiles 每次安装的都是包的最新的版本，而且这个过程不需要进一步的编码或额外干预。这项技术叫作 <code>cache busting</code>。你也可以显示指定一个包的版本号来达到 <code>cache-busting</code>，这就是所谓的固定版本，例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y \</span></div><div class="line">    package-bar \</div><div class="line">    package-baz \</div><div class="line">    package-foo=1.3.*</div></pre></td></tr></table></figure>
<p>固定版本会迫使构建过程检索特定的版本，而不管缓存中有什么。这项技术也可以减少因所需包中未预料到的变化而导致的失败。</p>
<p>下面是一个 <code>RUN</code> 指令的示例模板，展示了所有关于 <code>apt-get</code> 的建议。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y \</span></div><div class="line">    aufs-tools \</div><div class="line">    automake \</div><div class="line">    build-essential \</div><div class="line">    curl \</div><div class="line">    dpkg-sig \</div><div class="line">    libcap-dev \</div><div class="line">    libsqlite3-dev \</div><div class="line">    mercurial \</div><div class="line">    reprepro \</div><div class="line">    ruby1.9.1 \</div><div class="line">    ruby1.9.1-dev \</div><div class="line">    s3cmd=1.1.* \</div><div class="line"> &amp;&amp; rm -rf /var/lib/apt/lists/*</div></pre></td></tr></table></figure>
<p>其中 <code>s3cmd</code> 指令指定了一个版本号 <code>1.1.*</code>。如果之前的镜像使用的是更旧的版本，指定新的版本会导致 <code>apt-get udpate</code> 缓存失效并确保安装的是新版本。</p>
<p>另外，清理掉 apt 缓存 <code>var/lib/apt/lists</code> 可以减小镜像大小。因为 <code>RUN</code> 指令的开头为 <code>apt-get udpate</code>，包缓存总是会在 <code>apt-get install</code> 之前刷新。</p>
<blockquote>
<p>注意：官方的 Debian 和 Ubuntu 镜像会自动运行 apt-get clean，所以不需要显式的调用 apt-get clean。</p>
</blockquote>
<h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p><code>CMD</code> 指令用于执行目标镜像中包含的软件，可以包含参数。<code>CMD</code> 大多数情况下都应该以 <code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;...]</code> 的形式使用。因此，如果创建镜像的目的是为了部署某个服务(比如 <code>Apache</code>)，你可能会执行类似于 <code>CMD [&quot;apache2&quot;, &quot;-DFOREGROUND&quot;]</code> 形式的命令。我们建议任何服务镜像都使用这种形式的命令。</p>
<p>多数情况下，<code>CMD</code> 都需要一个交互式的 <code>shell</code> (bash, Python, perl 等)，例如 <code>CMD [&quot;perl&quot;, &quot;-de0&quot;]</code>，或者 <code>CMD [&quot;PHP&quot;, &quot;-a&quot;]</code>。使用这种形式意味着，当你执行类似 <code>docker run -it python</code> 时，你会进入一个准备好的 <code>shell</code> 中。<code>CMD</code> 应该在极少的情况下才能以 <code>CMD [&quot;param&quot;, &quot;param&quot;]</code> 的形式与 <code>ENTRYPOINT</code> 协同使用，除非你和你的镜像使用者都对 <code>ENTRYPOINT</code> 的工作方式十分熟悉。</p>
<h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><p><code>EXPOSE</code> 指令用于指定容器将要监听的端口。因此，你应该为你的应用程序使用常见的端口。例如，提供 <code>Apache</code> web 服务的镜像应该使用 <code>EXPOSE 80</code>，而提供 <code>MongoDB</code> 服务的镜像使用 <code>EXPOSE 27017</code>。</p>
<p>对于外部访问，用户可以在执行 <code>docker run</code> 时使用一个标志来指示如何将指定的端口映射到所选择的端口。</p>
<h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><p>为了方便新程序运行，你可以使用 <code>ENV</code> 来为容器中安装的程序更新 <code>PATH</code> 环境变量。例如使用 <code>ENV PATH /usr/local/nginx/bin:$PATH</code> 来确保 <code>CMD [&quot;nginx&quot;]</code> 能正确运行。</p>
<p><code>ENV</code> 指令也可用于为你想要容器化的服务提供必要的环境变量，比如 Postgres 需要的 <code>PGDATA</code>。</p>
<p>最后，<code>ENV</code> 也能用于设置常见的版本号，比如下面的示例：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ENV</span> PG_MAJOR <span class="number">9.3</span></div><div class="line"></div><div class="line"><span class="keyword">ENV</span> PG_VERSION <span class="number">9.3</span>.<span class="number">4</span></div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> curl -SL http://example.com/postgres-<span class="variable">$PG_VERSION</span>.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …</span></div><div class="line"></div><div class="line"><span class="keyword">ENV</span> PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH</div></pre></td></tr></table></figure>
<p>类似于程序中的常量，这种方法可以让你只需改变 <code>ENV</code> 指令来自动的改变容器中的软件版本。</p>
<h4 id="ADD-和-COPY"><a href="#ADD-和-COPY" class="headerlink" title="ADD 和 COPY"></a>ADD 和 COPY</h4><p>虽然 <code>ADD</code> 和 <code>COPY</code> 功能类似，但一般优先使用 <code>COPY</code>。因为它比 <code>ADD</code> 更透明。<code>COPY</code> 只支持简单将本地文件拷贝到容器中，而 <code>ADD</code> 有一些并不明显的功能（比如本地 tar 提取和远程 URL 支持）。因此，<code>ADD</code> 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 <code>ADD rootfs.tar.xz</code>。</p>
<p>如果你的 <code>Dockerfile</code> 有多个步骤需要使用上下文中不同的文件。单独 <code>COPY</code> 每个文件，而不是一次性的 <code>COPY</code> 所有文件，这将保证每个步骤的构建缓存只在特定的文件变化时失效。例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">COPY</span><span class="bash"> requirements.txt /tmp/</span></div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> pip install --requirement /tmp/requirements.txt</span></div><div class="line"></div><div class="line"><span class="keyword">COPY</span><span class="bash"> . /tmp/</span></div></pre></td></tr></table></figure>
<p>如果将 <code>COPY . /tmp/</code> 放置在 <code>RUN</code> 指令之前，只要 <code>.</code> 目录中任何一个文件变化，都会导致后续指令的缓存失效。</p>
<p>为了让镜像尽量小，最好不要使用 <code>ADD</code> 指令从远程 URL 获取包，而是使用 <code>curl</code> 和 <code>wget</code>。这样你可以在文件提取完之后删掉不再需要的文件来避免在镜像中额外添加一层。比如尽量避免下面的用法：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ADD</span><span class="bash"> http://example.com/big.tar.xz /usr/src/things/</span></div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things</span></div><div class="line"></div><div class="line"><span class="keyword">RUN</span><span class="bash"> make -C /usr/src/things all</span></div></pre></td></tr></table></figure>
<p>而是应该使用下面这种方法：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /usr/src/things \</span></div><div class="line">    &amp;&amp; curl -SL http://example.com/big.tar.xz \</div><div class="line">    | tar -xJC /usr/src/things \</div><div class="line">    &amp;&amp; make -C /usr/src/things all</div></pre></td></tr></table></figure>
<p>上面使用的管道操作，所以没有中间文件需要删除。</p>
<p>对于其他不需要 <code>ADD</code> 的自动提取功能的文件或目录，你应该使用 <code>COPY</code>。</p>
<h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p><code>ENTRYPOINT</code> 的最佳用处是设置镜像的主命令，允许将镜像当成命令本身来运行（用 <code>CMD</code> 提供默认选项）。</p>
<p>例如，下面的示例镜像提供了命令行工具 <code>s3cmd</code>:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"s3cmd"</span>]</span></div><div class="line"></div><div class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"--help"</span>]</span></div></pre></td></tr></table></figure>
<p>现在直接运行该镜像创建的容器会显示命令帮助：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run s3cmd</div></pre></td></tr></table></figure>
<p>或者提供正确的参数来执行某个命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run s3cmd ls s3://mybucket</div></pre></td></tr></table></figure>
<p>这样镜像名可以当成命令行的参考。</p>
<p><code>ENTRYPOINT</code> 指令也可以结合一个辅助脚本使用，和前面命令行风格类似，即使启动工具需要不止一个步骤。</p>
<p>例如，<code>Postgres</code> 官方镜像使用下面的脚本作为 <code>ENTRYPOINT</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="built_in">set</span> -e</div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">'postgres'</span> ]; <span class="keyword">then</span></div><div class="line">    chown -R postgres <span class="string">"<span class="variable">$PGDATA</span>"</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$(ls -A "$PGDATA")</span>"</span> ]; <span class="keyword">then</span></div><div class="line">        gosu postgres initdb</div><div class="line">    <span class="keyword">fi</span></div><div class="line"></div><div class="line">    <span class="built_in">exec</span> gosu postgres <span class="string">"<span class="variable">$@</span>"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：该脚本使用了 Bash 的内置命令 exec，所以最后运行的进程就是容器的 PID 为 1 的进程。这样，进程就可以接收到任何发送给容器的 Unix 信号了。</p>
</blockquote>
<p>该辅助脚本被拷贝到容器，并在容器启动时通过 <code>ENTRYPOINT</code> 执行：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">COPY</span><span class="bash"> ./docker-entrypoint.sh /</span></div><div class="line"></div><div class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/docker-entrypoint.sh"</span>]</span></div></pre></td></tr></table></figure>
<p>该脚本可以让用户用几种不同的方式和 <code>Postgres</code> 交互。</p>
<p>你可以很简单地启动 <code>Postgres</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run postgres</div></pre></td></tr></table></figure>
<p>也可以执行 <code>Postgres</code> 并传递参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run postgres postgres --<span class="built_in">help</span></div></pre></td></tr></table></figure>
<p>最后，你还可以启动另外一个完全不同的工具，比如 <code>Bash</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run --rm -it postgres bash</div></pre></td></tr></table></figure>
<h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><p><code>VOLUME</code> 指令用于暴露任何数据库存储文件，配置文件，或容器创建的文件和目录。强烈建议使用 <code>VOLUME</code> 来管理镜像中的可变部分和用户可以改变的部分。</p>
<h4 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h4><p>如果某个服务不需要特权执行，建议使用 <code>USER</code> 指令切换到非 root 用户。先在 <code>Dockerfile</code> 中使用类似 <code>RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</code> 的指令创建用户和用户组。</p>
<blockquote>
<p>注意：在镜像中，用户和用户组每次被分配的 UID/GID 都是不确定的，下次重新构建镜像时被分配到的 UID/GID 可能会不一样。如果要依赖确定的 UID/GID，你应该显示的指定一个 UID/GID。</p>
</blockquote>
<p>你应该避免使用 <code>sudo</code>，因为它不可预期的 TTY 和信号转发行为可能造成的问题比它能解决的问题还多。如果你真的需要和 <code>sudo</code> 类似的功能（例如，以 root 权限初始化某个守护进程，以非 root 权限执行它），你可以使用 <a href="https://github.com/tianon/gosu" target="_blank" rel="external">gosu</a>。</p>
<p>最后，为了减少层数和复杂度，避免频繁地使用 <code>USER</code> 来回切换用户。</p>
<h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p>为了清晰性和可靠性，你应该总是在 <code>WORKDIR</code> 中使用绝对路径。另外，你应该使用 <code>WORKDIR</code> 来替代类似于 <code>RUN cd ... &amp;&amp; do-something</code> 的指令，后者难以阅读、排错和维护。</p>
<h3 id="官方镜像示例"><a href="#官方镜像示例" class="headerlink" title="官方镜像示例"></a>官方镜像示例</h3><p>这些官方镜像的 Dockerfile 都是参考典范：<a href="https://github.com/docker-library/docs" target="_blank" rel="external">https://github.com/docker-library/docs</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../../../../../img/icons/docker.jpg&quot; alt=&quot;java&quot; title=&quot;docker&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;docker&quot;&gt;&lt;a href=&quot;#docker&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
    
      <category term="容器" scheme="http://jethan.bid/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Spring中bean的生命周期</title>
    <link href="http://jethan.bid/2017/09/13/Spring%E4%B8%ADbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://jethan.bid/2017/09/13/Spring中bean的生命周期/</id>
    <published>2017-09-13T09:58:54.000Z</published>
    <updated>2017-09-13T09:58:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring中bean的生命周期"><a href="#Spring中bean的生命周期" class="headerlink" title="Spring中bean的生命周期"></a>Spring中bean的生命周期</h1><p><img src="Spring中bean的生命周期/spring.jpg" alt="spring" title="spring"></p>
<p>一分钟掌握Spring中bean的生命周期！<br>在spring中，从BeanFactory或ApplicationContext取得的实例为Singleton，也就是预设为每一个Bean的别名只能维持一个实例.</p>
<p>在spring中，从BeanFactory或ApplicationContext取得的实例为Singleton，也就是预设为每一个Bean的别名只能维持一个实例，而不是每次都产生一个新的对象使用Singleton模式产生单一实例，对单线程的程序说并不会有什么问题，但对于多线程的程序，就必须注意安全(Thread-safe)的议题，防止多个线程同时存取共享资源所引发的数据不同步问题。</p>
<p>然而在spring中 可以设定每次从BeanFactory或ApplicationContext指定别名并取得Bean时都产生一个新的实例：例如：</p>
<p>在spring中，singleton属性默认是true，只有设定为false，则每次指定别名取得的Bean时都会产生一个新的实例</p>
<p>一个Bean从创建到销毁，如果是用BeanFactory来生成,管理Bean的话，会经历几个执行阶段(如图)：</p>
<a id="more"></a>
<p><img src="Spring单例模式与线程安全/spring-bean-1.png" alt="spring-bean生命周期"></p>
<ul>
<li>Bean的建立：</li>
</ul>
<p>容器寻找Bean的定义信息并将其实例化。</p>
<ul>
<li>属性注入：</li>
</ul>
<p>使用依赖注入，Spring按照Bean定义信息配置Bean所有属性</p>
<ul>
<li>BeanNameAware的setBeanName()：</li>
</ul>
<p>如果Bean类有实现org.springframework.beans.BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的ID。</p>
<ul>
<li>BeanFactoryAware的setBeanFactory()：</li>
</ul>
<p>如果Bean类有实现org.springframework.beans.factory.BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身。</p>
<ul>
<li>BeanPostProcessors的ProcessBeforeInitialization()</li>
</ul>
<p>如果有org.springframework.beans.factory.config.BeanPostProcessors和Bean关联，那么其postProcessBeforeInitialization()方法将被将被调用。</p>
<ul>
<li>initializingBean的afterPropertiesSet()：</li>
</ul>
<p>如果Bean类已实现org.springframework.beans.factory.InitializingBean接口，则执行他的afterProPertiesSet()方法</p>
<ul>
<li>Bean定义文件中定义init-method：</li>
</ul>
<p>可以在Bean定义文件中使用”init-method”属性设定方法名称例如：</p>
<p>如果有以上设置的话，则执行到这个阶段，就会执行initBean()方法</p>
<ul>
<li>BeanPostProcessors的ProcessaAfterInitialization()</li>
</ul>
<p>如果有任何的BeanPostProcessors实例与Bean实例关联，则执行BeanPostProcessors实例的ProcessaAfterInitialization()方法</p>
<p>此时，Bean已经可以被应用系统使用，并且将保留在BeanFactory中知道它不在被使用。有两种方法可以将其从BeanFactory中删除掉(如图):</p>
<p><img src="Spring单例模式与线程安全/spring-bean-2.png" alt="spring-bean生命周期"></p>
<ul>
<li>DisposableBean的destroy()</li>
</ul>
<p>在容器关闭时，如果Bean类有实现org.springframework.beans.factory.DisposableBean接口，则执行他的destroy()方法</p>
<ul>
<li>Bean定义文件中定义destroy-method</li>
</ul>
<p>在容器关闭时，可以在Bean定义文件中使用”destroy-method”属性设定方法名称，例如：</p>
<p>如果有以上设定的话，则进行至这个阶段时，就会执行destroy()方法，如果是使用ApplicationContext来生成并管理Bean的话则稍有不同，使用ApplicationContext来生成及管理Bean实例的话，在执行BeanFactoryAware的setBeanFactory()阶段后，若Bean类上有实现org.springframework.context.ApplicationContextAware接口，则执行其setApplicationContext()方法，接着才执行BeanPostProcessors的ProcessBeforeInitialization()及之后的流程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring中bean的生命周期&quot;&gt;&lt;a href=&quot;#Spring中bean的生命周期&quot; class=&quot;headerlink&quot; title=&quot;Spring中bean的生命周期&quot;&gt;&lt;/a&gt;Spring中bean的生命周期&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;Spring中bean的生命周期/spring.jpg&quot; alt=&quot;spring&quot; title=&quot;spring&quot;&gt;&lt;/p&gt;
&lt;p&gt;一分钟掌握Spring中bean的生命周期！&lt;br&gt;在spring中，从BeanFactory或ApplicationContext取得的实例为Singleton，也就是预设为每一个Bean的别名只能维持一个实例.&lt;/p&gt;
&lt;p&gt;在spring中，从BeanFactory或ApplicationContext取得的实例为Singleton，也就是预设为每一个Bean的别名只能维持一个实例，而不是每次都产生一个新的对象使用Singleton模式产生单一实例，对单线程的程序说并不会有什么问题，但对于多线程的程序，就必须注意安全(Thread-safe)的议题，防止多个线程同时存取共享资源所引发的数据不同步问题。&lt;/p&gt;
&lt;p&gt;然而在spring中 可以设定每次从BeanFactory或ApplicationContext指定别名并取得Bean时都产生一个新的实例：例如：&lt;/p&gt;
&lt;p&gt;在spring中，singleton属性默认是true，只有设定为false，则每次指定别名取得的Bean时都会产生一个新的实例&lt;/p&gt;
&lt;p&gt;一个Bean从创建到销毁，如果是用BeanFactory来生成,管理Bean的话，会经历几个执行阶段(如图)：&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://jethan.bid/categories/java/"/>
    
      <category term="spring" scheme="http://jethan.bid/categories/java/spring/"/>
    
    
      <category term="Bean的生命周期" scheme="http://jethan.bid/tags/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>时间复杂度计算方式</title>
    <link href="http://jethan.bid/2017/09/04/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F/"/>
    <id>http://jethan.bid/2017/09/04/时间复杂度计算方式/</id>
    <published>2017-09-04T10:48:26.000Z</published>
    <updated>2019-11-14T07:43:46.206Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/java.jpg" alt="java" title="java"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>时间复杂度是总运算次数表达式中受n的变化影响最大的那一项(不含系数)<br>比如：一般总运算次数表达式类似于这样:<br>a*2<sup>n</sup>+b*n<sup>3</sup>+c*n<sup>2</sup>+d*n*lgn+e*n+f<br>a ！ =0时，时间复杂度就O(2<sup>n</sup>);<br>a=0,b&lt;&gt;0 时间复杂度就是O(n<sup>3</sup>);<br>a,b=0,c&lt;&gt;0 时间复杂度就是O(n<sup>2</sup>)依此类推<br><a id="more"></a></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>循环了n*n次，当然是O(n<sup>2</sup>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(i=1;i&lt;=n;i++)   </div><div class="line">  for(j=1;j&lt;=n;j++)</div><div class="line">    s++;</div></pre></td></tr></table></figure></p>
<p>循环了(n+n-1+n-2+…+1)≈(n<sup>2</sup>)/2，因为时间复杂度是不考虑系数的，所以也是O(n<sup>2</sup>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(i=1;i&lt;=n;i++)</div><div class="line">  for(j=i;j&lt;=n;j++)</div><div class="line">    s++;</div></pre></td></tr></table></figure></p>
<p>循环了(1+2+3+…+n)≈(n<sup>2</sup>)/2,当然也是O(n<sup>2</sup>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(i=1;i&lt;=n;i++)</div><div class="line">  for(j=1;j&lt;=i;j++)</div><div class="line">   s++;</div></pre></td></tr></table></figure></p>
<p>循环了<code>n-1≈n</code>次，所以是<code>O(n)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">i=1;k=0;</div><div class="line">while(i&lt;=n-1)&#123;</div><div class="line">  k+=10*i;</div><div class="line">  i++;     </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>循环了(1<sup>2</sup>+2<sup>2</sup>+3<sup>2</sup>+…+n<sup>2</sup>)=n(n+1)(2n+1)/6(这个公式要记住哦)≈(n<sup>3</sup>)/3，不考虑系数，自然是O(n<sup>3</sup>)<br>另外，在时间复杂度中，log<sub>2</sub>n与lg(n)是等价的，因为对数换底公式：<br>log<sub>a</sub>b=log<sub>c</sub>b/log<sub>c</sub>a<br>所以log<sub>2</sub>n=lgn*lg2  忽略掉系数，二者当然是等价的 </p>
<pre><code>for(i=1;i&lt;=n;i++)
  for(j=1;j&lt;=i;j++)
    for(k=1;k&lt;=j;k++)
      x=x+1;
</code></pre><h2 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h2><p>1.一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。<br>一个算法中的语句执行次数称为语句频度或时间频度。记为<code>T(n)</code>。<br>2.一般情况下，算法的基本操作重复执行的次数是模块n的某一个函数<code>f（n）</code>，因此，算法的时间复杂度记做：<code>T（n）=O（f（n））</code>。随着模块n的增大，算法执行的时间的增长率和<code>f（n）</code>的增长率成正比，所以<code>f（n）</code>越小，算法的时间复杂度越低，算法的效率越高。<br>在计算时间复杂度的时候，先找出算法的基本操作，然后根据相应的各语句确定它的执行次数，再找出<code>T（n）</code>的同数量级（它的同数量级有以下：1，Log<sub>2</sub>n ，n ，nLog<sub>2</sub>n ，n<sup>2</sup>，n<sup>3</sup>，2<sup>n</sup>，n！），找出后，f（n）=该数量级，若T(n)/f(n)求极限可得到一常数c，则时间复杂度<code>T（n）=O（f（n））</code>。<br>3.常见的时间复杂度<br>按数量级递增排列，常见的时间复杂度有：<br>常数阶O(1),  对数阶O(log2n),  线性阶O(n),  线性对数阶O(nlog<sub>2</sub>n),  平方阶O(n<sup>2</sup>)， 立方阶O(n<sup>3</sup>),…， k次方阶O(n<sup>k</sup>), 指数阶O(2<sup>n</sup>) 。<br>其中</p>
<ol>
<li>O(n)，O(n<sup>2</sup>)， 立方阶O(n<sup>3</sup>),…， k次方阶O(n<sup>k</sup>) 为多项式阶时间复杂度，分别称为一阶时间复杂度，二阶时间复杂度… </li>
<li>O(2<sup>n</sup>)，指数阶时间复杂度，该种不实用  </li>
<li>对数阶O(log<sub>2</sub>n),   线性对数阶O(nlog<sub>2</sub>n)，除了常数阶以外，该种效率最高 </li>
</ol>
<p>例：算法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">for（i=1;i&lt;=n;++i）</div><div class="line">&#123;</div><div class="line">   for(j=1;j&lt;=n;++j)</div><div class="line">   &#123;</div><div class="line">       c[ i ][ j ]=0; //该步骤属于基本操作</div><div class="line">        for(k=1;k&lt;=n;++k)</div><div class="line">             c[ i ][ j ]+=a[ i ][ k ]*b[ k ][ j ]; //该步骤属于基本操作</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>c[ i ][ j ]=0;</code> //该步骤属于基本操作 执行次数：n<sup>2</sup><br><code>c[ i ][ j ]+=a[ i ][ k ]*b[ k ][ j ];</code> //该步骤属于基本操作 执行次数：n<sup>3</sup></p>
<p>则有 T（n）= n<sup>2</sup>+n<sup>3</sup>，根据上面括号里的同数量级，我们可以确定 n<sup>3</sup>为<code>T（n）</code>的同数量级</p>
<p>则有f（n）= n<sup>3</sup>，然后根据<code>T（n）/f（n）</code>求极限可得到常数<code>c</code><br>则该算法的 时间复杂度：T（n）=O（n<sup>3</sup>)</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>如果一个问题的规模是<code>n</code>，解这一问题的某一算法所需要的时间为<code>T(n)</code>，它是<code>n</code>的某一函数<br> <code>T(n)</code>称为这一算法的<strong>“时间复杂性”</strong>。</p>
<p>当输入量<code>n</code>逐渐加大时，时间复杂性的极限情形称为算法的<strong>“渐近时间复杂性”</strong>。</p>
<p>我们常用大O表示法表示时间复杂性，注意它是某一个算法的时间复杂性。大O表示只是说有上界，由定义如果f(n)=O(n)，那显然成立f(n)=O(n<sup>2</sup>)，它给你一个上界，但并不是上确界，但人们在表示的时候一般都习惯表示前者。</p>
<p>此外，一个问题本身也有它的复杂性，如果某个算法的复杂性到达了这个问题复杂性的下界，那就称这样的算法是<strong>最佳算法</strong>。</p>
<p>“大O记法”：在这种描述中使用的基本参数是<br> n，即问题实例的规模，把复杂性或运行时间表达为n的函数。这里的“O”表示量级 (order)，比如说“二分检索是 <code>O(logn)</code>的”,也就是说它需要“通过logn量级的步骤去检索一个规模为n的数组”记法 <code>O ( f(n) )</code>表示当 <code>n</code>增大时，运行时间至多将以正比于 <code>f(n)</code>的速度增长。</p>
<p>这种渐进估计对算法的理论分析和大致比较是非常有价值的，但在实践中细节也可能造成差异。例如，一个低附加代价的<code>O(n2)</code>算法在<code>n</code>较小的情况下可能比一个高附加代价的 <code>O(nlogn)</code>算法运行得更快。当然，随着<code>n</code>足够大以后，具有较慢上升函数的算法必然工作得更快。</p>
<p>示例</p>
<h3 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Temp=i;i=j;j=temp;</div></pre></td></tr></table></figure>
<p>以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是<code>O(1)</code>。</p>
<h3 id="O-n2"><a href="#O-n2" class="headerlink" title="O(n2)"></a>O(n<sup>2</sup>)</h3><p>交换i和j的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sum=0；                 （一次）</div><div class="line">for(i=1;i&lt;=n;i++)       （n次 ）</div><div class="line">   for(j=1;j&lt;=n;j++)  （n^2次 ）</div><div class="line">    sum++；       （n^2次 ）</div></pre></td></tr></table></figure></p>
<p>解：T(n)=2n<sup>2</sup>+n+1 =O(n<sup>2</sup>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (i=1;i&lt;n;i++)</div><div class="line">&#123;</div><div class="line">    y=y+1;          ①   </div><div class="line">    for(j=0;j&lt;=(2*n);j++)    </div><div class="line">       x++;        ②      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解：<br> 语句1的频度是<code>n-1</code><br> 语句2的频度是(n-1)*(2n+1)=2n<sup>2</sup>-n-1<br> f(n)=2n<sup>2</sup>-n-1+(n-1)=2n<sup>2</sup>-2<br> 该程序的时间复杂度T(n)=O(n<sup>2</sup>).           </p>
<h3 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a>O(n)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">a=0;</div><div class="line">b=1;            ①</div><div class="line">for(i=1;i&lt;=n;i++) ②</div><div class="line">  &#123;  </div><div class="line">     s=a+b;　　　　③</div><div class="line">     b=a;　　　　　④  </div><div class="line">     a=s;　　　　　⑤</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>解：语句1的频度：2,<br>语句2的频度：n,<br>语句3的频度： n-1,<br>语句4的频度：n-1,<br>语句5的频度：n-1,<br>T(n)=2+n+3(n-1)=4n-1=O(n).</p>
<h3 id="O-log2n"><a href="#O-log2n" class="headerlink" title="O(log2n)"></a>O(log<sub>2</sub>n)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> i=1;       ①</div><div class="line">while (i&lt;=n)</div><div class="line">   i=i*2; ②</div></pre></td></tr></table></figure>
<p>解： 语句1的频度是1,<br>    设语句2的频度是f(n),   则：2<sup>f(n)</sup>&lt;=n;f(n)&lt;=log<sub>2</sub>n<br>    取最大值f(n)=log<sub>2</sub>n,<br>    T(n)=O(log<sub>2</sub>n )</p>
<h3 id="O-n3"><a href="#O-n3" class="headerlink" title="O(n3)"></a>O(n<sup>3</sup>)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">for(i=0;i&lt;n;i++)</div><div class="line">&#123;  </div><div class="line">   for(j=0;j&lt;i;j++)  </div><div class="line">   &#123;</div><div class="line">      for(k=0;k&lt;j;k++)</div><div class="line">         x=x+2;  </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解：当i=m,<br> j=k的时候,内层循环的次数为k<br> 当i=m时, j可以取 0,1,…,m-1 , 所以这里最内循环共进行了0+1+…+m-1=(m-1)m/2次所以,i从0取到n, 则循环共进行了: 0+(1-1)*1/2+…+(n-1)n/2=n(n+1)(n-1)/6所以时间复杂度为O(n^3).</p>
<p>我们还应该区分算法的最坏情况的行为和期望行为。如快速排序的最<br> 坏情况运行时间是 O(n<sup>2</sup>)，但期望时间是 O(nlogn)。通过每次都仔细 地选择基准值，我们有可能把平方情况 (即O(n<sup>2</sup>)情况)的概率减小到几乎等于 0。在实际中，精心实现的快速排序一般都能以 (O(nlogn)时间运行。<br>下面是一些常用的记法：</p>
<p>访问数组中的元素是常数时间操作，或说<code>O(1)</code>操作。一个算法如果能在每个步骤去掉一半数据元素，如二分检索，通常它就取 O(logn)时间。用strcmp比较两个具有n个字符的串需要O(n)时间。常规的矩阵乘算法是O(n<sup>3</sup>)，因为算出每个元素都需要将n对元素相乘并加到一起，所有元素的个数是n<sup>2</sup>。<br>指数时间算法通常来源于需要求出所有可能结果。例如，n个元素的集合共有2n个子集,所以要求出所有子集的算法将是O(2n)的。指数算法一般说来是太复杂了，除非n的值非常小，因为，在 这个问题中增加一个元素就导致运行时间加倍。不幸的是，确实有许多问题 (如著名的“巡回售货员问题” )，到目前为止找到的算法都是指数的。如果我们真的遇到这种情况，通常应该用寻找近似最佳结果的算法替代之。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;时间复杂度是总运算次数表达式中受n的变化影响最大的那一项(不含系数)&lt;br&gt;比如：一般总运算次数表达式类似于这样:&lt;br&gt;a*2&lt;sup&gt;n&lt;/sup&gt;+b*n&lt;sup&gt;3&lt;/sup&gt;+c*n&lt;sup&gt;2&lt;/sup&gt;+d*n*lgn+e*n+f&lt;br&gt;a ！ =0时，时间复杂度就O(2&lt;sup&gt;n&lt;/sup&gt;);&lt;br&gt;a=0,b&amp;lt;&amp;gt;0 时间复杂度就是O(n&lt;sup&gt;3&lt;/sup&gt;);&lt;br&gt;a,b=0,c&amp;lt;&amp;gt;0 时间复杂度就是O(n&lt;sup&gt;2&lt;/sup&gt;)依此类推&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://jethan.bid/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://jethan.bid/2017/08/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jethan.bid/2017/08/08/设计模式/</id>
    <published>2017-08-08T06:34:34.000Z</published>
    <updated>2017-08-08T06:34:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="设计模式/java.jpg" alt="java" title="java"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>设计模式简介</strong><br>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 </p>
<p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。<br><a id="more"></a><br><strong>什么是 GOF（四人帮，全拼 Gang of Four）？</strong><br>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。<br>四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。<br>对接口编程而不是对实现编程。<br>优先使用对象组合而不是继承。<br><strong>设计模式的使用</strong><br>设计模式在软件开发中的两个主要用途。<br><strong>开发人员的共同平台</strong><br>设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。<br><strong>最佳的实践</strong><br>设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。<br><strong>设计模式的类型</strong><br>根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th>模式&amp;描述</th>
<th>包含</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td><strong>创建型模式</strong><br>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑<br>的方式，而不是使用 new 运算符直接实例化对象。这<br>使得程序在判断针对某个给定实例需要创建哪些对象时<br>更加灵活。</td>
<td>工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td><strong>结构型模式</strong><br>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td>
<td>适配器模式（Adapter Pattern）<br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td><strong>行为型模式</strong><br>这些设计模式特别关注对象之间的通信。</td>
<td>责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td><strong>J2EE 模式</strong><br>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</td>
<td>MVC 模式（MVC Pattern）<br>业务代表模式（Business Delegate Pattern）<br>组合实体模式（Composite Entity Pattern）<br>数据访问对象模式（Data Access Object Pattern）<br>前端控制器模式（Front Controller Pattern）<br>拦截过滤器模式（Intercepting Filter Pattern）<br>服务定位器模式（Service Locator Pattern）<br>传输对象模式（Transfer Object Pattern）</td>
</tr>
</tbody>
</table>
</div>
<p>下面用一个图片来整体描述一下设计模式之间的关系：<br><img src="设计模式/design-patterns.jpg" alt="design-patterns" title="design-patterns"></p>
<p><strong>设计模式的六大原则</strong>  </p>
<ol>
<li><strong>开闭原则（Open Close Principle）</strong><br>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。  </li>
<li><strong>里氏代换原则（Liskov Substitution Principle）</strong><br>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。  </li>
<li><strong>依赖倒转原则（Dependence Inversion Principle）</strong><br>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。  </li>
<li><strong>接口隔离原则（Interface Segregation Principle）</strong><br>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。  </li>
<li><strong>迪米特法则，又称最少知道原则（Demeter Principle）</strong><br>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</li>
<li><strong>合成复用原则（Composite Reuse Principle）</strong><br>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</li>
</ol>
<h2 id="java常用设计模式"><a href="#java常用设计模式" class="headerlink" title="java常用设计模式"></a>java常用设计模式</h2><p>通俗一点讲就是：<br>一个程序员对设计模式的理解:<br>“不懂”为什么要把很简单的东西搞得那么复杂。后来随着软件开发经验的增加才开始明白我所看到的“复杂”恰恰就是设计模式的精髓所在，我所理解的“简单”就是一把钥匙开一把锁的模式，目的仅仅是着眼于解决现在的问题，而设计模式的“复杂”就在于它是要构造一个“万能钥匙”，目的是提出一种对所有锁的开锁方案。在真正理解设计模式之前我一直在编写“简单”的代码.<br>这个“简单”不是功能的简单，而是设计的简单。简单的设计意味着缺少灵活性，代码很钢硬，只在这个项目里有用，拿到其它的项目中就是垃圾，我将其称之为“一次性代码”。</p>
<p>要使代码可被反复使用,请用’设计模式’对你的代码进行设计。 </p>
<p>很多我所认识的程序员在接触到设计模式之后，都有一种相见恨晚的感觉，有人形容学习了设计模式之后感觉自己好像已经脱胎换骨，达到了新的境界，还有人甚至把是否了解设计模式作为程序员划分水平的标准。<br>我们也不能陷入模式的陷阱，为了使用模式而去套模式，那样会陷入形式主义。我们在使用模式的时候，一定要注意模式的意图（intent），而不要过多的去关注模式的实现细节，因为这些实现细节在特定情况下，可能会发生一些改变。不要顽固地认为设计模式一书中的类图或实现代码就代表了模式本身。  </p>
<p>设计原则：(重要)</p>
<ol>
<li>逻辑代码独立到单独的方法中，注重封装性—易读，易复用。<br>不要在一个方法中，写下上百行的逻辑代码。把各小逻辑代码独立出来，写于其它方法中，易读其可重复调用。</li>
<li>写类，写方法，写功能时，应考虑其移植性，复用性：防止一次性代码！<br>是否可以拿到其它同类事物中应该？是否可以拿到其它系统中应该？</li>
<li>熟练运用继承的思想：<br>找出应用中相同之处，且不容易发生变化的东西，把它们抽取到抽象类中，让子类去继承它们；<br>继承的思想，也方便将自己的逻辑建立于别人的成果之上。如ImageField extends JTextField；<br>熟练运用接口的思想：<br>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li>
</ol>
<p><strong>把很简单的东西搞得那么复杂，一次性代码，设计模式优势的实例说明：（策略模式）</strong><br>说明：<br>模拟鸭子游戏的应用程序，要求：游戏中会出现各种颜色外形的鸭子，一边游泳戏水，一边呱呱叫。<br><strong>1、 一次性代码 </strong><br>直接编写出各种鸭子的类：MallardDuck//野鸭，RedheadDuck//红头鸭，各类有三个方法：<br>quack()：叫的方法<br>swim()：游水的方法<br>display()：外形的方法<br><strong>2、运用继承的特性，将其中共同的部分提升出来，避免重复编程。</strong><br>即：设计一个鸭子的超类（Superclass）,并让各种鸭子继承这个超类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Duck&#123;</div><div class="line">     public void quack()&#123;  //呱呱叫</div><div class="line">              System.out.println(&quot;呱呱叫&quot;);</div><div class="line">      &#125;</div><div class="line">     public void swim()&#123;   //游泳</div><div class="line">            System.out.println(&quot; 游泳&quot;);</div><div class="line">      &#125;    </div><div class="line">     public  abstratact void display(); /*因为外观不一样，让子类自己去决定了。*/</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于它的子类只需简单的继承就可以了，并实现自己的display()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//野鸭</div><div class="line"> public class MallardDuck extends Duck&#123;</div><div class="line">     public void display()&#123;</div><div class="line">          System.out.println(&quot;野鸭的颜色...&quot;);</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line">//红头鸭</div><div class="line"> public class RedheadDuck extends Duck&#123;</div><div class="line">     public void display()&#123;</div><div class="line">          System.out.println(&quot;红头鸭的颜色...&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不幸的是，现在客户又提出了新的需求，想让鸭子飞起来。这个对于我们OO程序员，在简单不过了，在超类中在加一个方法就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Duck&#123;</div><div class="line">   public void quack()&#123;  //呱呱叫</div><div class="line">      System.out.println(&quot;呱呱叫&quot;);</div><div class="line">     &#125;</div><div class="line">   public void swim()&#123;   //游泳</div><div class="line">      System.out.println(&quot; 游泳&quot;);</div><div class="line">   &#125;    </div><div class="line">   public  abstract void display(); /*因为外观不一样，让子类自己去决定了。*/</div><div class="line">   public void fly()&#123;</div><div class="line">      System.out.println(&quot;飞吧！鸭子&quot;); </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于不能飞的鸭子，在子类中只需简单的覆盖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//残废鸭</div><div class="line"> public class DisabledDuck extends Duck&#123;</div><div class="line">    public void display()&#123;</div><div class="line">       System.out.println(&quot;残废鸭的颜色...&quot;);</div><div class="line">   &#125;</div><div class="line">   public void fly()&#123;</div><div class="line">    //覆盖，变成什么事都不做。 </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其它会飞的鸭子不用覆盖。<br>这样所有的继承这个超类的鸭子都会fly了。但是问题又出来了，客户又提出有的鸭子会飞，有的不能飞。</p>
<p><strong>对于上面的设计，你可能发现一些弊端，如果超类有新的特性，子类都必须变动，这是我们开发最不喜欢看到的，一个类变让另一个类也跟着变，这有点不符合OO设计了。这样很显然的耦合了一起。利用继承—&gt;耦合度太高了.</strong></p>
<p><strong>3、用接口改进</strong><br>我们把容易引起变化的部分提取出来并封装之，来应付以后的变法。虽然代码量加大了，但可用性提高了，耦合度也降低了。<br>我们把Duck中的fly方法和quack提取出来。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> public interface Flyable&#123;</div><div class="line">    public void fly(); </div><div class="line">&#125;</div><div class="line"> public interface Quackable&#123;</div><div class="line">   public void quack();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  最后Duck的设计成为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class Duck&#123;</div><div class="line">     public void swim()&#123;   //游泳</div><div class="line">            System.out.println(&quot; 游泳&quot;);</div><div class="line">    &#125;    </div><div class="line">    public  abstract void display(); /*因为外观不一样，让子类自 己去决定了。*/</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 而MallardDuck,RedheadDuck,DisabledDuck 就可以写成为：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">//野鸭</div><div class="line"> public class MallardDuck extends Duck implements Flyable,Quackable&#123;</div><div class="line">     public void display()&#123;</div><div class="line">          System.out.println(&quot;野鸭的颜色...&quot;);</div><div class="line">   &#125;</div><div class="line">   public void fly()&#123;</div><div class="line">    //实现该方法</div><div class="line">  &#125;</div><div class="line">   public void quack()&#123;</div><div class="line">    //实现该方法</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line">//红头鸭</div><div class="line"> public class RedheadDuck extends Duck implements Flyable,Quackable&#123;</div><div class="line">     public void display()&#123;</div><div class="line">          System.out.println(&quot;红头鸭的颜色...&quot;);</div><div class="line">   &#125;</div><div class="line">   public void fly()&#123;</div><div class="line">    //实现该方法</div><div class="line">  &#125;</div><div class="line">   public void quack()&#123;</div><div class="line">    //实现该方法</div><div class="line">  &#125;</div><div class="line">&#125; </div><div class="line">//残废鸭 只实现Quackable（能叫不能飞）</div><div class="line"> public class DisabledDuck extends Duck implements Quackable&#123;</div><div class="line">     public void display()&#123;</div><div class="line">          System.out.println(&quot;残废鸭的颜色...&quot;);</div><div class="line">   &#125;</div><div class="line">   public void quack()&#123;</div><div class="line">    //实现该方法</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好处:<br>这样已设计，我们的程序就降低了它们之间的耦合。<br>不足:<br>Flyable和 Quackable接口一开始似乎还挺不错的，解决了问题（只有会飞到鸭子才实现 Flyable），但是Java接口不具有实现代码，所以<strong>实现接口无法达到代码的复用</strong>。</p>
<p><strong>继承的好处:</strong>让共同部分,可以复用.避免重复编程.<br><strong>继承的不好:</strong>耦合性高.一旦超类添加一个新方法,子类都继承,拥有此方法,若子类相当部分不实现此方法,则要进行大批量修改.继承时,子类就不可继承其它类了.<br><strong>接口的好处:</strong>解决了继承耦合性高的问题,且可让实现类,继承或实现其它类或接口.<br><strong>接口的不好:</strong>不能真正实现代码的复用.可用以下的策略模式来解决.</p>
<h2 id="strategy-策略模式"><a href="#strategy-策略模式" class="headerlink" title="strategy(策略模式)"></a>strategy(策略模式)</h2><p>我们有一个设计原则：<br>找出应用中相同之处，且不容易发生变化的东西，把它们抽取到抽象类中，让子类去继承它们；<br>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。   </p>
<p>现在，为了要分开“变化和不变化的部分”，我们准备建立两组类（完全远离Duck类），一个是”fly”相关的，另一个是“quack”相关的，每一组类将实现各自的动作。比方说，我们可能有一个类实现“呱呱叫”，另一个类实现“吱吱叫”，还有一个类实现“安静”。<br>首先写两个接口。<br>FlyBehavior(飞行行为)和QuackBehavior（叫的行为）.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public interface FlyBehavior&#123;</div><div class="line">   public void fly();     </div><div class="line">&#125;</div><div class="line">public interface QuackBehavior&#123;</div><div class="line">   public void quack();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在定义一些针对FlyBehavior的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class FlyWithWings implements FlyBehavior&#123;</div><div class="line">   public void  fly()&#123;</div><div class="line">     //实现了所有有翅膀的鸭子飞行行为。</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line">public class FlyNoWay implements FlyBehavior&#123;</div><div class="line">   public void  fly()&#123;</div><div class="line">      //什么都不做，不会飞</div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>针对QuackBehavior的几种具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Quack implements QuackBehavior&#123;</div><div class="line">   public void quack()&#123;</div><div class="line">      //实现呱呱叫的鸭子</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public class Squeak implements QuackBehavior&#123;</div><div class="line">   public void quack()&#123;</div><div class="line">      //实现吱吱叫的鸭子 </div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public class MuteQuack implements QuackBehavior&#123;</div><div class="line">   public void quack()&#123;</div><div class="line">      //什么都不做，不会叫</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>点评一:<br>这样的设计，可以让飞行和呱呱叫的动作被其他的对象复用，因为这些行为已经与鸭子类无关了。而我们增加一些新的行为，不会影响到既有的行为类，也不会影响“使用”到飞行行为的鸭子类。<br>最后我们看看Duck 如何设计。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Duck&#123;        ---------&gt;在抽象类中,声明各接口,定义各接口对应的方法.</div><div class="line">   FlyBehavior flyBehavior;//接口</div><div class="line">   QuackBehavior quackBehavior;//接口</div><div class="line">   public Duck()&#123;&#125;</div><div class="line">   public abstract void display();</div><div class="line">   public void swim()&#123;</div><div class="line">     //实现游泳的行为</div><div class="line">   &#125;</div><div class="line">   public void performFly()&#123;</div><div class="line">      flyBehavior.fly();  --&gt;由于是接口,会根据继承类实现的方式,而调用相应的方法.</div><div class="line">   &#125;</div><div class="line">   public void performQuack()&#123;</div><div class="line">      quackBehavior.quack();();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看看MallardDuck如何实现<br>通过构造方法,生成’飞’,’叫’具体实现类的实例,从而指定’飞’,’叫’的具体属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class MallardDuck extends Duck&#123;</div><div class="line">   public MallardDuck &#123;       </div><div class="line">      flyBehavior = new FlyWithWings ();</div><div class="line">      quackBehavior = new Quack(); </div><div class="line">     //因为MallardDuck 继承了Duck，所有具有flyBehavior 与quackBehavior 实例变量</div><div class="line">  &#125;</div><div class="line">   public void display()&#123;</div><div class="line">    //实现</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就满足了即可以飞，又可以叫，同时展现自己的颜色了。<br>这样的设计我们可以看到是把flyBehavior ，quackBehavior 的实例化写在子类了。我们还可以动态的来决定。<br>我们只需在Duck中加上两个方法。</p>
<p>在构造方法中对属性进行赋值与用属性的setter的区别：<br><strong>构造方法中对属性进行赋值：固定，不可变；<br>用属性的setter，可以在实例化对象后，动态的变化，比较灵活。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Duck&#123;</div><div class="line">   FlyBehavior flyBehavior;//接口</div><div class="line">   QuackBehavior quackBehavior;//接口</div><div class="line">   public void setFlyBehavior(FlyBehavior flyBehavior)&#123;</div><div class="line">      this.flyBehavior = flyBehavior;</div><div class="line">   &#125;</div><div class="line">   public void setQuackBehavior(QuackBehavior quackBehavior  &#123;</div><div class="line">      this.quackBehavior= quackBehavior;</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。<br><strong>意图：</strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。<br><strong>主要解决：</strong>主要解决接口选择的问题。<br><strong>何时使用：</strong>我们明确地计划不同条件下创建不同实例时。<br><strong>如何解决：</strong>让其子类实现工厂接口，返回的也是一个抽象的产品。<br><strong>关键代码：</strong>创建过程在其子类执行。<br><strong>应用实例：</strong> 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。<br><strong>优点：</strong> 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。<br><strong>缺点：</strong>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。<br><strong>注意事项：</strong>作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。<br><strong>实现</strong><br>我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。<br>FactoryPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。<br><img src="设计模式/factory_pattern_uml_diagram.jpg" alt="factory_pattern" title="factory_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口:</p>
<p>Shape.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Shape &#123;</div><div class="line">   void draw();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类:  </p>
<p>Rectangle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Rectangle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Square.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Square implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Square::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Circle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Circle::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建一个工厂，生成基于给定信息的实体类的对象:</p>
<p>ShapeFactory.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class ShapeFactory &#123;</div><div class="line">	</div><div class="line">   //使用 getShape 方法获取形状类型的对象</div><div class="line">   public Shape getShape(String shapeType)&#123;</div><div class="line">      if(shapeType == null)&#123;</div><div class="line">         return null;</div><div class="line">      &#125;		</div><div class="line">      if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123;</div><div class="line">         return new Circle();</div><div class="line">      &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123;</div><div class="line">         return new Rectangle();</div><div class="line">      &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123;</div><div class="line">         return new Square();</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用该工厂，通过传递类型信息来获取实体类的对象:</p>
<p>FactoryPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class FactoryPatternDemo &#123;</div><div class="line"></div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      ShapeFactory shapeFactory = new ShapeFactory();</div><div class="line"></div><div class="line">      //获取 Circle 的对象，并调用它的 draw 方法</div><div class="line">      Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);</div><div class="line"></div><div class="line">      //调用 Circle 的 draw 方法</div><div class="line">      shape1.draw();</div><div class="line"></div><div class="line">      //获取 Rectangle 的对象，并调用它的 draw 方法</div><div class="line">      Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);</div><div class="line"></div><div class="line">      //调用 Rectangle 的 draw 方法</div><div class="line">      shape2.draw();</div><div class="line"></div><div class="line">      //获取 Square 的对象，并调用它的 draw 方法</div><div class="line">      Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);</div><div class="line"></div><div class="line">      //调用 Square 的 draw 方法</div><div class="line">      shape3.draw();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Inside Circle::draw() method.</div><div class="line">Inside Rectangle::draw() method.</div><div class="line">Inside Square::draw() method.</div></pre></td></tr></table></figure>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。<br>介绍<br>意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br>主要解决：主要解决接口选择的问题。<br>何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。<br>如何解决：在一个产品族里面，定义多个产品。<br>关键代码：在一个工厂里聚合多个同类产品。<br>应用实例：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。<br>优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。<br>缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。<br>使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。<br>注意事项：产品族难扩展，产品等级易扩展。<br>实现<br>我们将创建 Shape 和 Color 接口和实现这些接口的实体类。下一步是创建抽象工厂类 AbstractFactory。接着定义工厂类 ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory。然后创建一个工厂创造器/生成器类 FactoryProducer。<br>AbstractFactoryPatternDemo，我们的演示类使用 FactoryProducer 来获取 AbstractFactory 对象。它将向 AbstractFactory 传递形状信息 Shape（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。同时它还向 AbstractFactory 传递颜色信息 Color（RED / GREEN / BLUE），以便获取它所需对象的类型。<br><img src="设计模式/abstractfactory_pattern_uml_diagram.jpg" alt="abstractfactory_pattern" title="abstractfactory_pattern"></p>
<p><strong>步骤 1</strong> </p>
<p>为形状创建一个接口。</p>
<p>Shape.java</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Shape &#123;</div><div class="line">   void draw();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>Rectangle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Rectangle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Square.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Square implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Square::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Circle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Circle::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>为颜色创建一个接口。</p>
<p>Color.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Color &#123;</div><div class="line">   void fill();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤4</strong> </p>
<p>创建实现接口的实体类。  </p>
<p>Red.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Red implements Color &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void fill() &#123;</div><div class="line">      System.out.println(&quot;Inside Red::fill() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Green.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Green implements Color &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void fill() &#123;</div><div class="line">      System.out.println(&quot;Inside Green::fill() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Blue.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Blue implements Color &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void fill() &#123;</div><div class="line">      System.out.println(&quot;Inside Blue::fill() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong>  </p>
<p>为 Color 和 Shape 对象创建抽象类来获取工厂。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">AbstractFactory.java</div><div class="line">public abstract class AbstractFactory &#123;</div><div class="line">   abstract Color getColor(String color);</div><div class="line">   abstract Shape getShape(String shape) ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。</p>
<p>ShapeFactory.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class ShapeFactory extends AbstractFactory &#123;</div><div class="line">	</div><div class="line">   @Override</div><div class="line">   public Shape getShape(String shapeType)&#123;</div><div class="line">      if(shapeType == null)&#123;</div><div class="line">         return null;</div><div class="line">      &#125;		</div><div class="line">      if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123;</div><div class="line">         return new Circle();</div><div class="line">      &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123;</div><div class="line">         return new Rectangle();</div><div class="line">      &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123;</div><div class="line">         return new Square();</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @Override</div><div class="line">   Color getColor(String color) &#123;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ColorFactory.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class ColorFactory extends AbstractFactory &#123;</div><div class="line">	</div><div class="line">   @Override</div><div class="line">   public Shape getShape(String shapeType)&#123;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @Override</div><div class="line">   Color getColor(String color) &#123;</div><div class="line">      if(color == null)&#123;</div><div class="line">         return null;</div><div class="line">      &#125;		</div><div class="line">      if(color.equalsIgnoreCase(&quot;RED&quot;))&#123;</div><div class="line">         return new Red();</div><div class="line">      &#125; else if(color.equalsIgnoreCase(&quot;GREEN&quot;))&#123;</div><div class="line">         return new Green();</div><div class="line">      &#125; else if(color.equalsIgnoreCase(&quot;BLUE&quot;))&#123;</div><div class="line">         return new Blue();</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 7</strong>  </p>
<p>创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。</p>
<p>FactoryProducer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class FactoryProducer &#123;</div><div class="line">   public static AbstractFactory getFactory(String choice)&#123;</div><div class="line">      if(choice.equalsIgnoreCase(&quot;SHAPE&quot;))&#123;</div><div class="line">         return new ShapeFactory();</div><div class="line">      &#125; else if(choice.equalsIgnoreCase(&quot;COLOR&quot;))&#123;</div><div class="line">         return new ColorFactory();</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 8</strong></p>
<p>使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。  </p>
<p>AbstractFactoryPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class AbstractFactoryPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      //获取形状工厂</div><div class="line">      AbstractFactory shapeFactory = FactoryProducer.getFactory(&quot;SHAPE&quot;);</div><div class="line"></div><div class="line">      //获取形状为 Circle 的对象</div><div class="line">      Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);</div><div class="line"></div><div class="line">      //调用 Circle 的 draw 方法</div><div class="line">      shape1.draw();</div><div class="line"></div><div class="line">      //获取形状为 Rectangle 的对象</div><div class="line">      Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);</div><div class="line"></div><div class="line">      //调用 Rectangle 的 draw 方法</div><div class="line">      shape2.draw();</div><div class="line">      </div><div class="line">      //获取形状为 Square 的对象</div><div class="line">      Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);</div><div class="line"></div><div class="line">      //调用 Square 的 draw 方法</div><div class="line">      shape3.draw();</div><div class="line"></div><div class="line">      //获取颜色工厂</div><div class="line">      AbstractFactory colorFactory = FactoryProducer.getFactory(&quot;COLOR&quot;);</div><div class="line"></div><div class="line">      //获取颜色为 Red 的对象</div><div class="line">      Color color1 = colorFactory.getColor(&quot;RED&quot;);</div><div class="line"></div><div class="line">      //调用 Red 的 fill 方法</div><div class="line">      color1.fill();</div><div class="line"></div><div class="line">      //获取颜色为 Green 的对象</div><div class="line">      Color color2 = colorFactory.getColor(&quot;Green&quot;);</div><div class="line"></div><div class="line">      //调用 Green 的 fill 方法</div><div class="line">      color2.fill();</div><div class="line"></div><div class="line">      //获取颜色为 Blue 的对象</div><div class="line">      Color color3 = colorFactory.getColor(&quot;BLUE&quot;);</div><div class="line"></div><div class="line">      //调用 Blue 的 fill 方法</div><div class="line">      color3.fill();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 9</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Inside Circle::draw() method.</div><div class="line">Inside Rectangle::draw() method.</div><div class="line">Inside Square::draw() method.</div><div class="line">Inside Red::fill() method.</div><div class="line">Inside Green::fill() method.</div><div class="line">Inside Blue::fill() method.</div></pre></td></tr></table></figure>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。<br>注意：<br>1、单例类只能有一个实例。<br>2、单例类必须自己创建自己的唯一实例。<br>3、单例类必须给所有其他对象提供这一实例。<br><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。<br><strong>何时使用：</strong>当您想控制实例数目，节省系统资源的时候。<br><strong>如何解决：</strong>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。<br><strong>关键代码：</strong>构造函数是私有的。<br><strong>优点： </strong>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。<br><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。<br><strong>使用场景：</strong> 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。<br><strong>注意事项：</strong>getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。<br><strong>实现</strong><br>我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。<br>SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。<br><img src="设计模式/singleton_pattern_uml_diagram.jpg" alt="singleton_pattern" title="singleton_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个 Singleton 类。</p>
<p>SingleObject.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class SingleObject &#123;</div><div class="line"></div><div class="line">   //创建 SingleObject 的一个对象</div><div class="line">   private static SingleObject instance = new SingleObject();</div><div class="line"></div><div class="line">   //让构造函数为 private，这样该类就不会被实例化</div><div class="line">   private SingleObject()&#123;&#125;</div><div class="line"></div><div class="line">   //获取唯一可用的对象</div><div class="line">   public static SingleObject getInstance()&#123;</div><div class="line">      return instance;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void showMessage()&#123;</div><div class="line">      System.out.println(&quot;Hello World!&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>从 singleton 类获取唯一的对象。</p>
<p>SingletonPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class SingletonPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      //不合法的构造函数</div><div class="line">      //编译时错误：构造函数 SingleObject() 是不可见的</div><div class="line">      //SingleObject object = new SingleObject();</div><div class="line"></div><div class="line">      //获取唯一可用的对象</div><div class="line">      SingleObject object = SingleObject.getInstance();</div><div class="line"></div><div class="line">      //显示消息</div><div class="line">      object.showMessage();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello World!</div></pre></td></tr></table></figure>
<p><strong>单例模式的几种实现方式</strong><br>单例模式的实现有多种方式，如下所示：<br><strong>1、懒汉式，线程不安全</strong><br><strong>是否 Lazy 初始化</strong>：是<br><strong>是否多线程安全：</strong>否<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。<br>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。<br><strong>代码实例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">    private static Singleton instance;  </div><div class="line">    private Singleton ()&#123;&#125;  </div><div class="line">  </div><div class="line">    public static Singleton getInstance() &#123;  </div><div class="line">    if (instance == null) &#123;  </div><div class="line">        instance = new Singleton();  </div><div class="line">    &#125;  </div><div class="line">    return instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。  </p>
<p><strong>2、懒汉式，线程安全</strong><br><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。<br><strong>优点：</strong>第一次调用才初始化，避免内存浪费。<br><strong>缺点：</strong>必须加锁 synchronized 才能保证单例，但加锁会影响效率。<br>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。<br><strong>代码实例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">    private static Singleton instance;  </div><div class="line">    private Singleton ()&#123;&#125;  </div><div class="line">    public static synchronized Singleton getInstance() &#123;  </div><div class="line">    if (instance == null) &#123;  </div><div class="line">        instance = new Singleton();  </div><div class="line">    &#125;  </div><div class="line">    return instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>3、饿汉式</strong><br><strong>是否 Lazy 初始化：</strong>否<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种方式比较常用，但容易产生垃圾对象。<br><strong>优点：</strong>没有加锁，执行效率会提高。<br><strong>缺点：</strong>类加载时就初始化，浪费内存。<br>它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。<br><strong>代码实例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">    private static Singleton instance = new Singleton();  </div><div class="line">    private Singleton ()&#123;&#125;  </div><div class="line">    public static Singleton getInstance() &#123;  </div><div class="line">    return instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>4、双检锁/双重校验锁（DCL，即 double-checked locking）</strong><br><strong>JDK 版本：</strong>JDK1.5 起<br><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>较复杂<br><strong>描述：</strong>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance() 的性能对应用程序很关键。<br><strong>代码实例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">    private volatile static Singleton singleton;  </div><div class="line">    private Singleton ()&#123;&#125;  </div><div class="line">    public static Singleton getSingleton() &#123;  </div><div class="line">    if (singleton == null) &#123;  </div><div class="line">        synchronized (Singleton.class) &#123;  </div><div class="line">        if (singleton == null) &#123;  </div><div class="line">            singleton = new Singleton();  </div><div class="line">        &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    return singleton;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>5、登记式/静态内部类</strong><br><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全</strong>：是<br><strong>实现难度：</strong>一般<br><strong>描述：</strong>这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<br>这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有显示通过调用 getInstance 方法时，才会显示装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。<br><strong>代码实例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">    private static class SingletonHolder &#123;  </div><div class="line">    private static final Singleton INSTANCE = new Singleton();  </div><div class="line">    &#125;  </div><div class="line">    private Singleton ()&#123;&#125;  </div><div class="line">    public static final Singleton getInstance() &#123;  </div><div class="line">    return SingletonHolder.INSTANCE;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>6、枚举</strong><br><strong>JDK 版本：</strong>JDK1.5 起<br><strong>是否 Lazy 初始化：</strong>否<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。<br>不能通过 reflection attack 来调用私有构造方法。<br><strong>代码实例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public enum Singleton &#123;  </div><div class="line">    INSTANCE;  </div><div class="line">    public void whateverMethod() &#123;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>经验之谈：</strong>一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。   </p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。<br>意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br><strong>主要解决：</strong>主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。<br><strong>何时使用：</strong>一些基本部件不会变，而其组合经常变化的时候。<br><strong>如何解决：</strong>将变与不变分离开。<br><strong>关键代码：</strong>建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。<br><strong>应用实例：</strong> 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。 2、JAVA 中的 StringBuilder。<br><strong>优点：</strong> 1、建造者独立，易扩展。 2、便于控制细节风险。<br><strong>缺点：</strong> 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。<br><strong>使用场景：</strong> 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。<br><strong>注意事项：</strong>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。<br><strong>实现</strong><br>我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。<br>我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。<br>然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo，我们的演示类使用 MealBuilder 来创建一个 Meal。<br><img src="设计模式/builder_pattern_uml_diagram.jpg" alt="builder_pattern" title="builder_pattern"></p>
<p><strong>步骤 1</strong>  </p>
<p>创建一个表示食物条目和食物包装的接口。</p>
<p>Item.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface Item &#123;</div><div class="line">   public String name();</div><div class="line">   public Packing packing();</div><div class="line">   public float price();	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Packing.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Packing &#123;</div><div class="line">   public String pack();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现 Packing 接口的实体类。</p>
<p>Wrapper.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Wrapper implements Packing &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String pack() &#123;</div><div class="line">      return &quot;Wrapper&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Bottle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Bottle implements Packing &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String pack() &#123;</div><div class="line">      return &quot;Bottle&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实现 Item 接口的抽象类，该类提供了默认的功能。</p>
<p>Burger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public abstract class Burger implements Item &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public Packing packing() &#123;</div><div class="line">      return new Wrapper();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public abstract float price();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ColdDrink.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public abstract class ColdDrink implements Item &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Packing packing() &#123;</div><div class="line">       return new Bottle();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public abstract float price();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建扩展了 Burger 和 ColdDrink 的实体类。</p>
<p>VegBurger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class VegBurger extends Burger &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public float price() &#123;</div><div class="line">      return 25.0f;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String name() &#123;</div><div class="line">      return &quot;Veg Burger&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ChickenBurger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class ChickenBurger extends Burger &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public float price() &#123;</div><div class="line">      return 50.5f;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String name() &#123;</div><div class="line">      return &quot;Chicken Burger&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Coke.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Coke extends ColdDrink &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public float price() &#123;</div><div class="line">      return 30.0f;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String name() &#123;</div><div class="line">      return &quot;Coke&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Pepsi.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Pepsi extends ColdDrink &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public float price() &#123;</div><div class="line">      return 35.0f;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String name() &#123;</div><div class="line">      return &quot;Pepsi&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>创建一个 Meal 类，带有上面定义的 Item 对象。</p>
<p>Meal.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class Meal &#123;</div><div class="line">   private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;();	</div><div class="line"></div><div class="line">   public void addItem(Item item)&#123;</div><div class="line">      items.add(item);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public float getCost()&#123;</div><div class="line">      float cost = 0.0f;</div><div class="line">      for (Item item : items) &#123;</div><div class="line">         cost += item.price();</div><div class="line">      &#125;		</div><div class="line">      return cost;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void showItems()&#123;</div><div class="line">      for (Item item : items) &#123;</div><div class="line">         System.out.print(&quot;Item : &quot;+item.name());</div><div class="line">         System.out.print(&quot;, Packing : &quot;+item.packing().pack());</div><div class="line">         System.out.println(&quot;, Price : &quot;+item.price());</div><div class="line">      &#125;		</div><div class="line">   &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。</p>
<p>MealBuilder.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class MealBuilder &#123;</div><div class="line"></div><div class="line">   public Meal prepareVegMeal ()&#123;</div><div class="line">      Meal meal = new Meal();</div><div class="line">      meal.addItem(new VegBurger());</div><div class="line">      meal.addItem(new Coke());</div><div class="line">      return meal;</div><div class="line">   &#125;   </div><div class="line"></div><div class="line">   public Meal prepareNonVegMeal ()&#123;</div><div class="line">      Meal meal = new Meal();</div><div class="line">      meal.addItem(new ChickenBurger());</div><div class="line">      meal.addItem(new Pepsi());</div><div class="line">      return meal;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 7</strong></p>
<p>BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern）。</p>
<p>BuilderPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class BuilderPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      MealBuilder mealBuilder = new MealBuilder();</div><div class="line"></div><div class="line">      Meal vegMeal = mealBuilder.prepareVegMeal();</div><div class="line">      System.out.println(&quot;Veg Meal&quot;);</div><div class="line">      vegMeal.showItems();</div><div class="line">      System.out.println(&quot;Total Cost: &quot; +vegMeal.getCost());</div><div class="line"></div><div class="line">      Meal nonVegMeal = mealBuilder.prepareNonVegMeal();</div><div class="line">      System.out.println(&quot;\n\nNon-Veg Meal&quot;);</div><div class="line">      nonVegMeal.showItems();</div><div class="line">      System.out.println(&quot;Total Cost: &quot; +nonVegMeal.getCost());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 8</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Veg Meal</div><div class="line">Item : Veg Burger, Packing : Wrapper, Price : 25.0</div><div class="line">Item : Coke, Packing : Bottle, Price : 30.0</div><div class="line">Total Cost: 55.0</div><div class="line"></div><div class="line">Non-Veg Meal</div><div class="line">Item : Chicken Burger, Packing : Wrapper, Price : 50.5</div><div class="line">Item : Pepsi, Packing : Bottle, Price : 35.0</div><div class="line">Total Cost: 85.5</div></pre></td></tr></table></figure>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。<br><strong>意图：</strong>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br><strong>主要解决：</strong>在运行期建立和删除原型。<br><strong>何时使用：</strong> 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。<br><strong>如何解决：</strong>利用已有的一个原型对象，快速地生成和原型对象一样的实例。<br><strong>关键代码：</strong> 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口。<br><strong>应用实例：</strong> 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。<br><strong>优点：</strong> 1、性能提高。 2、逃避构造函数的约束。<br><strong>缺点：</strong> 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。 3、逃避构造函数的约束。<br><strong>使用场景：</strong> 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。   5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。<br>注意事项：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。<br><strong>实现 </strong><br>我们将创建一个抽象类 Shape 和扩展了 Shape 类的实体类。下一步是定义类 ShapeCache，该类把 shape 对象存储在一个 Hashtable 中，并在请求的时候返回它们的克隆。<br>PrototypPatternDemo，我们的演示类使用 ShapeCache 类来获取 Shape 对象<br><img src="设计模式/prototype_pattern_uml_diagram.jpg" alt="prototype_pattern" title="prototype_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个实现了 Clonable 接口的抽象类。</p>
<p>Shape.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public abstract class Shape implements Cloneable &#123;</div><div class="line">   </div><div class="line">   private String id;</div><div class="line">   protected String type;</div><div class="line">   </div><div class="line">   abstract void draw();</div><div class="line">   </div><div class="line">   public String getType()&#123;</div><div class="line">      return type;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   public String getId() &#123;</div><div class="line">      return id;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   public void setId(String id) &#123;</div><div class="line">      this.id = id;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   public Object clone() &#123;</div><div class="line">      Object clone = null;</div><div class="line">      try &#123;</div><div class="line">         clone = super.clone();</div><div class="line">      &#125; catch (CloneNotSupportedException e) &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">      return clone;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建扩展了上面抽象类的实体类。</p>
<p>Rectangle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Rectangle extends Shape &#123;</div><div class="line"></div><div class="line">   public Rectangle()&#123;</div><div class="line">     type = &quot;Rectangle&quot;;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Square.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Square extends Shape &#123;</div><div class="line"></div><div class="line">   public Square()&#123;</div><div class="line">     type = &quot;Square&quot;;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Square::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Circle extends Shape &#123;</div><div class="line"></div><div class="line">   public Circle()&#123;</div><div class="line">     type = &quot;Circle&quot;;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Circle::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建一个类，从数据库获取实体类，并把它们存储在一个 Hashtable 中。</p>
<p>ShapeCache.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">import java.util.Hashtable;</div><div class="line"></div><div class="line">public class ShapeCache &#123;</div><div class="line">	</div><div class="line">   private static Hashtable&lt;String, Shape&gt; shapeMap </div><div class="line">      = new Hashtable&lt;String, Shape&gt;();</div><div class="line"></div><div class="line">   public static Shape getShape(String shapeId) &#123;</div><div class="line">      Shape cachedShape = shapeMap.get(shapeId);</div><div class="line">      return (Shape) cachedShape.clone();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // 对每种形状都运行数据库查询，并创建该形状</div><div class="line">   // shapeMap.put(shapeKey, shape);</div><div class="line">   // 例如，我们要添加三种形状</div><div class="line">   public static void loadCache() &#123;</div><div class="line">      Circle circle = new Circle();</div><div class="line">      circle.setId(&quot;1&quot;);</div><div class="line">      shapeMap.put(circle.getId(),circle);</div><div class="line"></div><div class="line">      Square square = new Square();</div><div class="line">      square.setId(&quot;2&quot;);</div><div class="line">      shapeMap.put(square.getId(),square);</div><div class="line"></div><div class="line">      Rectangle rectangle = new Rectangle();</div><div class="line">      rectangle.setId(&quot;3&quot;);</div><div class="line">      shapeMap.put(rectangle.getId(),rectangle);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>PrototypePatternDemo 使用 ShapeCache 类来获取存储在 Hashtable 中的形状的克隆。</p>
<p>PrototypePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class PrototypePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      ShapeCache.loadCache();</div><div class="line"></div><div class="line">      Shape clonedShape = (Shape) ShapeCache.getShape(&quot;1&quot;);</div><div class="line">      System.out.println(&quot;Shape : &quot; + clonedShape.getType());		</div><div class="line"></div><div class="line">      Shape clonedShape2 = (Shape) ShapeCache.getShape(&quot;2&quot;);</div><div class="line">      System.out.println(&quot;Shape : &quot; + clonedShape2.getType());		</div><div class="line"></div><div class="line">      Shape clonedShape3 = (Shape) ShapeCache.getShape(&quot;3&quot;);</div><div class="line">      System.out.println(&quot;Shape : &quot; + clonedShape3.getType());		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Shape : Circle</div><div class="line">Shape : Square</div><div class="line">Shape : Rectangle</div></pre></td></tr></table></figure>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。<br>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。<br>我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。<br><strong>意图：</strong>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>主要解决：主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。<br><strong>何时使用：</strong> 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）<br><strong>如何解决：</strong>继承或依赖（推荐）。<br><strong>关键代码：</strong>适配器继承或依赖已有的对象，实现想要的目标接口。<br><strong>应用实例：</strong> 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。<br><strong>优点：</strong> 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。<br><strong>缺点：</strong> 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。<br><strong>使用场景：</strong>有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。<br><strong>注意事项：</strong>适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。<br><strong>实现</strong><br>我们有一个 MediaPlayer 接口和一个实现了 MediaPlayer 接口的实体类 AudioPlayer。默认情况下，AudioPlayer 可以播放 mp3 格式的音频文件。<br>我们还有另一个接口 AdvancedMediaPlayer 和实现了 AdvancedMediaPlayer 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。<br>我们想要让 AudioPlayer 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 MediaPlayer 接口的适配器类 MediaAdapter，并使用 AdvancedMediaPlayer 对象来播放所需的格式。<br>AudioPlayer 使用适配器类 MediaAdapter 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。AdapterPatternDemo，我们的演示类使用 AudioPlayer 类来播放各种格式。<br><img src="设计模式/adapter_pattern_uml_diagram.jpg" alt="adapter_pattern" title="adapter_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>为媒体播放器和更高级的媒体播放器创建接口。</p>
<p>MediaPlayer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public interface MediaPlayer &#123;</div><div class="line">   public void play(String audioType, String fileName);</div><div class="line">&#125;</div><div class="line">AdvancedMediaPlayer.java</div><div class="line">public interface AdvancedMediaPlayer &#123;	</div><div class="line">   public void playVlc(String fileName);</div><div class="line">   public void playMp4(String fileName);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现了 AdvancedMediaPlayer 接口的实体类。</p>
<p>VlcPlayer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class VlcPlayer implements AdvancedMediaPlayer&#123;</div><div class="line">   @Override</div><div class="line">   public void playVlc(String fileName) &#123;</div><div class="line">      System.out.println(&quot;Playing vlc file. Name: &quot;+ fileName);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void playMp4(String fileName) &#123;</div><div class="line">      //什么也不做</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Mp4Player.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Mp4Player implements AdvancedMediaPlayer&#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void playVlc(String fileName) &#123;</div><div class="line">      //什么也不做</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void playMp4(String fileName) &#123;</div><div class="line">      System.out.println(&quot;Playing mp4 file. Name: &quot;+ fileName);		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实现了 MediaPlayer 接口的适配器类。</p>
<p>MediaAdapter.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class MediaAdapter implements MediaPlayer &#123;</div><div class="line"></div><div class="line">   AdvancedMediaPlayer advancedMusicPlayer;</div><div class="line"></div><div class="line">   public MediaAdapter(String audioType)&#123;</div><div class="line">      if(audioType.equalsIgnoreCase(&quot;vlc&quot;) )&#123;</div><div class="line">         advancedMusicPlayer = new VlcPlayer();			</div><div class="line">      &#125; else if (audioType.equalsIgnoreCase(&quot;mp4&quot;))&#123;</div><div class="line">         advancedMusicPlayer = new Mp4Player();</div><div class="line">      &#125;	</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void play(String audioType, String fileName) &#123;</div><div class="line">      if(audioType.equalsIgnoreCase(&quot;vlc&quot;))&#123;</div><div class="line">         advancedMusicPlayer.playVlc(fileName);</div><div class="line">      &#125;else if(audioType.equalsIgnoreCase(&quot;mp4&quot;))&#123;</div><div class="line">         advancedMusicPlayer.playMp4(fileName);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建实现了 MediaPlayer 接口的实体类。</p>
<p>AudioPlayer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class AudioPlayer implements MediaPlayer &#123;</div><div class="line">   MediaAdapter mediaAdapter; </div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void play(String audioType, String fileName) &#123;		</div><div class="line"></div><div class="line">      //播放 mp3 音乐文件的内置支持</div><div class="line">      if(audioType.equalsIgnoreCase(&quot;mp3&quot;))&#123;</div><div class="line">         System.out.println(&quot;Playing mp3 file. Name: &quot;+ fileName);			</div><div class="line">      &#125; </div><div class="line">      //mediaAdapter 提供了播放其他文件格式的支持</div><div class="line">      else if(audioType.equalsIgnoreCase(&quot;vlc&quot;) </div><div class="line">         || audioType.equalsIgnoreCase(&quot;mp4&quot;))&#123;</div><div class="line">         mediaAdapter = new MediaAdapter(audioType);</div><div class="line">         mediaAdapter.play(audioType, fileName);</div><div class="line">      &#125;</div><div class="line">      else&#123;</div><div class="line">         System.out.println(&quot;Invalid media. &quot;+</div><div class="line">            audioType + &quot; format not supported&quot;);</div><div class="line">      &#125;</div><div class="line">   &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>使用 AudioPlayer 来播放不同类型的音频格式。</p>
<p>AdapterPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class AdapterPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      AudioPlayer audioPlayer = new AudioPlayer();</div><div class="line"></div><div class="line">      audioPlayer.play(&quot;mp3&quot;, &quot;beyond the horizon.mp3&quot;);</div><div class="line">      audioPlayer.play(&quot;mp4&quot;, &quot;alone.mp4&quot;);</div><div class="line">      audioPlayer.play(&quot;vlc&quot;, &quot;far far away.vlc&quot;);</div><div class="line">      audioPlayer.play(&quot;avi&quot;, &quot;mind me.avi&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Playing mp3 file. Name: beyond the horizon.mp3</div><div class="line">Playing mp4 file. Name: alone.mp4</div><div class="line">Playing vlc file. Name: far far away.vlc</div><div class="line">Invalid media. avi format not supported</div></pre></td></tr></table></figure>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。<br>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。<br>我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。<br><strong>意图：</strong>将抽象部分与实现部分分离，使它们都可以独立的变化。<br><strong>主要解决：</strong>在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。<br><strong>何时使用：</strong>实现系统可能有多个角度分类，每一种角度都可能变化。<br><strong>如何解决：</strong>把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。<br><strong>关键代码：</strong>抽象类依赖实现类。<br><strong>应用实例：</strong> 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。<br><strong>优点：</strong> 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。<br><strong>缺点：</strong>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。<br><strong>使用场景：</strong> 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。<br><strong>注意事项：</strong>对于两个独立变化的维度，使用桥接模式再适合不过了。<br><strong>实现 </strong><br>我们有一个作为桥接实现的 DrawAPI 接口和实现了 DrawAPI 接口的实体类 RedCircle、GreenCircle。Shape 是一个抽象类，将使用 DrawAPI 的对象。BridgePatternDemo，我们的演示类使用 Shape 类来画出不同颜色的圆。<br><img src="设计模式/bridge_pattern_uml_diagram.jpg" alt="bridge_pattern" title="bridge_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建桥接实现接口。</p>
<p>DrawAPI.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface DrawAPI &#123;</div><div class="line">   public void drawCircle(int radius, int x, int y);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现了 DrawAPI 接口的实体桥接实现类。</p>
<p>RedCircle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class RedCircle implements DrawAPI &#123;</div><div class="line">   @Override</div><div class="line">   public void drawCircle(int radius, int x, int y) &#123;</div><div class="line">      System.out.println(&quot;Drawing Circle[ color: red, radius: &quot;</div><div class="line">         + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>GreenCircle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class GreenCircle implements DrawAPI &#123;</div><div class="line">   @Override</div><div class="line">   public void drawCircle(int radius, int x, int y) &#123;</div><div class="line">      System.out.println(&quot;Drawing Circle[ color: green, radius: &quot;</div><div class="line">         + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>使用 DrawAPI 接口创建抽象类 Shape。</p>
<p>Shape.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public abstract class Shape &#123;</div><div class="line">   protected DrawAPI drawAPI;</div><div class="line">   protected Shape(DrawAPI drawAPI)&#123;</div><div class="line">      this.drawAPI = drawAPI;</div><div class="line">   &#125;</div><div class="line">   public abstract void draw();	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建实现了 Shape 接口的实体类。</p>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Circle extends Shape &#123;</div><div class="line">   private int x, y, radius;</div><div class="line"></div><div class="line">   public Circle(int x, int y, int radius, DrawAPI drawAPI) &#123;</div><div class="line">      super(drawAPI);</div><div class="line">      this.x = x;  </div><div class="line">      this.y = y;  </div><div class="line">      this.radius = radius;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void draw() &#123;</div><div class="line">      drawAPI.drawCircle(radius,x,y);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>使用 Shape 和 DrawAPI 类画出不同颜色的圆。</p>
<p>BridgePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class BridgePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Shape redCircle = new Circle(100,100, 10, new RedCircle());</div><div class="line">      Shape greenCircle = new Circle(100,100, 10, new GreenCircle());</div><div class="line"></div><div class="line">      redCircle.draw();</div><div class="line">      greenCircle.draw();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Drawing Circle[ color: red, radius: 10, x: 100, 100]</div><div class="line">Drawing Circle[  color: green, radius: 10, x: 100, 100]</div></pre></td></tr></table></figure>
<h2 id="过滤器模式"><a href="#过滤器模式" class="headerlink" title="过滤器模式"></a>过滤器模式</h2><p>过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。<br><strong>实现</strong><br>我们将创建一个 Person 对象、Criteria 接口和实现了该接口的实体类，来过滤 Person 对象的列表。CriteriaPatternDemo，我们的演示类使用 Criteria 对象，基于各种标准和它们的结合来过滤 Person 对象的列表。<br><img src="设计模式/filter_pattern_uml_diagram.jpg" alt="filter_pattern" title="filter_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个类，在该类上应用标准。</p>
<p>Person.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Person &#123;</div><div class="line">	</div><div class="line">   private String name;</div><div class="line">   private String gender;</div><div class="line">   private String maritalStatus;</div><div class="line"></div><div class="line">   public Person(String name,String gender,String maritalStatus)&#123;</div><div class="line">      this.name = name;</div><div class="line">      this.gender = gender;</div><div class="line">      this.maritalStatus = maritalStatus;		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getName() &#123;</div><div class="line">      return name;</div><div class="line">   &#125;</div><div class="line">   public String getGender() &#123;</div><div class="line">      return gender;</div><div class="line">   &#125;</div><div class="line">   public String getMaritalStatus() &#123;</div><div class="line">      return maritalStatus;</div><div class="line">   &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>为标准（Criteria）创建一个接口。</p>
<p>Criteria.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public interface Criteria &#123;</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实现了 Criteria 接口的实体类。</p>
<p>CriteriaMale.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class CriteriaMale implements Criteria &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123;</div><div class="line">      List&lt;Person&gt; malePersons = new ArrayList&lt;Person&gt;(); </div><div class="line">      for (Person person : persons) &#123;</div><div class="line">         if(person.getGender().equalsIgnoreCase(&quot;MALE&quot;))&#123;</div><div class="line">            malePersons.add(person);</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      return malePersons;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CriteriaFemale.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class CriteriaFemale implements Criteria &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123;</div><div class="line">      List&lt;Person&gt; femalePersons = new ArrayList&lt;Person&gt;(); </div><div class="line">      for (Person person : persons) &#123;</div><div class="line">         if(person.getGender().equalsIgnoreCase(&quot;FEMALE&quot;))&#123;</div><div class="line">            femalePersons.add(person);</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      return femalePersons;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CriteriaSingle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class CriteriaSingle implements Criteria &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123;</div><div class="line">      List&lt;Person&gt; singlePersons = new ArrayList&lt;Person&gt;(); </div><div class="line">      for (Person person : persons) &#123;</div><div class="line">         if(person.getMaritalStatus().equalsIgnoreCase(&quot;SINGLE&quot;))&#123;</div><div class="line">            singlePersons.add(person);</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      return singlePersons;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AndCriteria.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class AndCriteria implements Criteria &#123;</div><div class="line"></div><div class="line">   private Criteria criteria;</div><div class="line">   private Criteria otherCriteria;</div><div class="line"></div><div class="line">   public AndCriteria(Criteria criteria, Criteria otherCriteria) &#123;</div><div class="line">      this.criteria = criteria;</div><div class="line">      this.otherCriteria = otherCriteria; </div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123;</div><div class="line">      List&lt;Person&gt; firstCriteriaPersons = criteria.meetCriteria(persons);		</div><div class="line">      return otherCriteria.meetCriteria(firstCriteriaPersons);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OrCriteria.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class OrCriteria implements Criteria &#123;</div><div class="line"></div><div class="line">   private Criteria criteria;</div><div class="line">   private Criteria otherCriteria;</div><div class="line"></div><div class="line">   public OrCriteria(Criteria criteria, Criteria otherCriteria) &#123;</div><div class="line">      this.criteria = criteria;</div><div class="line">      this.otherCriteria = otherCriteria; </div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123;</div><div class="line">      List&lt;Person&gt; firstCriteriaItems = criteria.meetCriteria(persons);</div><div class="line">      List&lt;Person&gt; otherCriteriaItems = otherCriteria.meetCriteria(persons);</div><div class="line"></div><div class="line">      for (Person person : otherCriteriaItems) &#123;</div><div class="line">         if(!firstCriteriaItems.contains(person))&#123;</div><div class="line">	        firstCriteriaItems.add(person);</div><div class="line">         &#125;</div><div class="line">      &#125;	</div><div class="line">      return firstCriteriaItems;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤4</strong></p>
<p>使用不同的标准（Criteria）和它们的结合来过滤 Person 对象的列表。</p>
<p>CriteriaPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList; </div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class CriteriaPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;();</div><div class="line"></div><div class="line">      persons.add(new Person(&quot;Robert&quot;,&quot;Male&quot;, &quot;Single&quot;));</div><div class="line">      persons.add(new Person(&quot;John&quot;,&quot;Male&quot;, &quot;Married&quot;));</div><div class="line">      persons.add(new Person(&quot;Laura&quot;,&quot;Female&quot;, &quot;Married&quot;));</div><div class="line">      persons.add(new Person(&quot;Diana&quot;,&quot;Female&quot;, &quot;Single&quot;));</div><div class="line">      persons.add(new Person(&quot;Mike&quot;,&quot;Male&quot;, &quot;Single&quot;));</div><div class="line">      persons.add(new Person(&quot;Bobby&quot;,&quot;Male&quot;, &quot;Single&quot;));</div><div class="line"></div><div class="line">      Criteria male = new CriteriaMale();</div><div class="line">      Criteria female = new CriteriaFemale();</div><div class="line">      Criteria single = new CriteriaSingle();</div><div class="line">      Criteria singleMale = new AndCriteria(single, male);</div><div class="line">      Criteria singleOrFemale = new OrCriteria(single, female);</div><div class="line"></div><div class="line">      System.out.println(&quot;Males: &quot;);</div><div class="line">      printPersons(male.meetCriteria(persons));</div><div class="line"></div><div class="line">      System.out.println(&quot;\nFemales: &quot;);</div><div class="line">      printPersons(female.meetCriteria(persons));</div><div class="line"></div><div class="line">      System.out.println(&quot;\nSingle Males: &quot;);</div><div class="line">      printPersons(singleMale.meetCriteria(persons));</div><div class="line"></div><div class="line">      System.out.println(&quot;\nSingle Or Females: &quot;);</div><div class="line">      printPersons(singleOrFemale.meetCriteria(persons));</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public static void printPersons(List&lt;Person&gt; persons)&#123;</div><div class="line">      for (Person person : persons) &#123;</div><div class="line">         System.out.println(&quot;Person : [ Name : &quot; + person.getName() </div><div class="line">            +&quot;, Gender : &quot; + person.getGender() </div><div class="line">            +&quot;, Marital Status : &quot; + person.getMaritalStatus()</div><div class="line">            +&quot; ]&quot;);</div><div class="line">      &#125;</div><div class="line">   &#125;      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Males: </div><div class="line">Person : [ Name : Robert, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : John, Gender : Male, Marital Status : Married ]</div><div class="line">Person : [ Name : Mike, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]</div><div class="line"></div><div class="line">Females: </div><div class="line">Person : [ Name : Laura, Gender : Female, Marital Status : Married ]</div><div class="line">Person : [ Name : Diana, Gender : Female, Marital Status : Single ]</div><div class="line"></div><div class="line">Single Males: </div><div class="line">Person : [ Name : Robert, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Mike, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]</div><div class="line"></div><div class="line">Single Or Females: </div><div class="line">Person : [ Name : Robert, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Diana, Gender : Female, Marital Status : Single ]</div><div class="line">Person : [ Name : Mike, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Laura, Gender : Female, Marital Status : Married ]</div></pre></td></tr></table></figure>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。<br>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。<br>我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。<br>意图：将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。<br><strong>主要解决：</strong>它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。<br><strong>何时使用：</strong> 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。<br><strong>如何解决：</strong>树枝和叶子实现统一接口，树枝内部组合该接口。<br>关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。<br><strong>应用实例：</strong> 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作树、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。<br><strong>优点：</strong> 1、高层模块调用简单。 2、节点自由增加。<br><strong>缺点：</strong>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。<br><strong>使用场景：</strong>部分、整体场景，如树形菜单，文件、文件夹的管理。<br><strong>注意事项：</strong>定义时为具体类。<br><strong>实现</strong><br>我们有一个类 Employee，该类被当作组合模型类。CompositePatternDemo，我们的演示类使用 Employee 类来添加部门层次结构，并打印所有员工。<br><img src="设计模式/composite_pattern_uml_diagram.jpg" alt="composite_pattern" title="composite_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建 Employee 类，该类带有 Employee 对象的列表。</p>
<p>Employee.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class Employee &#123;</div><div class="line">   private String name;</div><div class="line">   private String dept;</div><div class="line">   private int salary;</div><div class="line">   private List&lt;Employee&gt; subordinates;</div><div class="line"></div><div class="line">   //构造函数</div><div class="line">   public Employee(String name,String dept, int sal) &#123;</div><div class="line">      this.name = name;</div><div class="line">      this.dept = dept;</div><div class="line">      this.salary = sal;</div><div class="line">      subordinates = new ArrayList&lt;Employee&gt;();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void add(Employee e) &#123;</div><div class="line">      subordinates.add(e);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void remove(Employee e) &#123;</div><div class="line">      subordinates.remove(e);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public List&lt;Employee&gt; getSubordinates()&#123;</div><div class="line">     return subordinates;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String toString()&#123;</div><div class="line">      return (&quot;Employee :[ Name : &quot;+ name </div><div class="line">      +&quot;, dept : &quot;+ dept + &quot;, salary :&quot;</div><div class="line">      + salary+&quot; ]&quot;);</div><div class="line">   &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>使用 Employee 类来创建和打印员工的层次结构。</p>
<p>CompositePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class CompositePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Employee CEO = new Employee(&quot;John&quot;,&quot;CEO&quot;, 30000);</div><div class="line"></div><div class="line">      Employee headSales = new Employee(&quot;Robert&quot;,&quot;Head Sales&quot;, 20000);</div><div class="line"></div><div class="line">      Employee headMarketing = new Employee(&quot;Michel&quot;,&quot;Head Marketing&quot;, 20000);</div><div class="line"></div><div class="line">      Employee clerk1 = new Employee(&quot;Laura&quot;,&quot;Marketing&quot;, 10000);</div><div class="line">      Employee clerk2 = new Employee(&quot;Bob&quot;,&quot;Marketing&quot;, 10000);</div><div class="line"></div><div class="line">      Employee salesExecutive1 = new Employee(&quot;Richard&quot;,&quot;Sales&quot;, 10000);</div><div class="line">      Employee salesExecutive2 = new Employee(&quot;Rob&quot;,&quot;Sales&quot;, 10000);</div><div class="line"></div><div class="line">      CEO.add(headSales);</div><div class="line">      CEO.add(headMarketing);</div><div class="line"></div><div class="line">      headSales.add(salesExecutive1);</div><div class="line">      headSales.add(salesExecutive2);</div><div class="line"></div><div class="line">      headMarketing.add(clerk1);</div><div class="line">      headMarketing.add(clerk2);</div><div class="line"></div><div class="line">      //打印该组织的所有员工</div><div class="line">      System.out.println(CEO); </div><div class="line">      for (Employee headEmployee : CEO.getSubordinates()) &#123;</div><div class="line">         System.out.println(headEmployee);</div><div class="line">         for (Employee employee : headEmployee.getSubordinates()) &#123;</div><div class="line">            System.out.println(employee);</div><div class="line">         &#125;</div><div class="line">      &#125;		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Employee :[ Name : John, dept : CEO, salary :30000 ]</div><div class="line">Employee :[ Name : Robert, dept : Head Sales, salary :20000 ]</div><div class="line">Employee :[ Name : Richard, dept : Sales, salary :10000 ]</div><div class="line">Employee :[ Name : Rob, dept : Sales, salary :10000 ]</div><div class="line">Employee :[ Name : Michel, dept : Head Marketing, salary :20000 ]</div><div class="line">Employee :[ Name : Laura, dept : Marketing, salary :10000 ]</div><div class="line">Employee :[ Name : Bob, dept : Marketing, salary :10000 ]</div></pre></td></tr></table></figure>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。<br>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。<br>我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。<br><strong>意图：</strong>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。<br>主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。<br><strong>何时使用：</strong>在不想增加很多子类的情况下扩展类。<br><strong>如何解决：</strong>将具体功能职责划分，同时继承装饰者模式。<br><strong>关键代码：</strong> 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。<br><strong>应用实例：</strong> 1、孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。<br><strong>优点：</strong>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。<br><strong>缺点：</strong>多层装饰比较复杂。<br><strong>使用场景：</strong> 1、扩展一个类的功能。 2、动态增加功能，动态撤销。<br><strong>注意事项：</strong>可代替继承。<br><strong>实现</strong><br>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。<br>RedShapeDecorator 是实现了 ShapeDecorator 的实体类。<br>DecoratorPatternDemo，我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象<br><img src="设计模式/decorator_pattern_uml_diagram.jpg" alt="decorator_pattern" title="decorator_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口。</p>
<p>Shape.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Shape &#123;</div><div class="line">   void draw();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>Rectangle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Rectangle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Shape: Rectangle&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Circle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Shape: Circle&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实现了 Shape 接口的抽象装饰类。</p>
<p>ShapeDecorator.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public abstract class ShapeDecorator implements Shape &#123;</div><div class="line">   protected Shape decoratedShape;</div><div class="line"></div><div class="line">   public ShapeDecorator(Shape decoratedShape)&#123;</div><div class="line">      this.decoratedShape = decoratedShape;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void draw()&#123;</div><div class="line">      decoratedShape.draw();</div><div class="line">   &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建扩展了 ShapeDecorator 类的实体装饰类。</p>
<p>RedShapeDecorator.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class RedShapeDecorator extends ShapeDecorator &#123;</div><div class="line"></div><div class="line">   public RedShapeDecorator(Shape decoratedShape) &#123;</div><div class="line">      super(decoratedShape);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      decoratedShape.draw();	       </div><div class="line">      setRedBorder(decoratedShape);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private void setRedBorder(Shape decoratedShape)&#123;</div><div class="line">      System.out.println(&quot;Border Color: Red&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>使用 RedShapeDecorator 来装饰 Shape 对象。</p>
<p>DecoratorPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class DecoratorPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      Shape circle = new Circle();</div><div class="line"></div><div class="line">      Shape redCircle = new RedShapeDecorator(new Circle());</div><div class="line"></div><div class="line">      Shape redRectangle = new RedShapeDecorator(new Rectangle());</div><div class="line">      System.out.println(&quot;Circle with normal border&quot;);</div><div class="line">      circle.draw();</div><div class="line"></div><div class="line">      System.out.println(&quot;\nCircle of red border&quot;);</div><div class="line">      redCircle.draw();</div><div class="line"></div><div class="line">      System.out.println(&quot;\nRectangle of red border&quot;);</div><div class="line">      redRectangle.draw();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Circle with normal border</div><div class="line">Shape: Circle</div><div class="line"></div><div class="line">Circle of red border</div><div class="line">Shape: Circle</div><div class="line">Border Color: Red</div><div class="line"></div><div class="line">Rectangle of red border</div><div class="line">Shape: Rectangle</div><div class="line">Border Color: Red</div></pre></td></tr></table></figure>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。<br>这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。<br><strong>意图：</strong>为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br><strong>主要解决：</strong>降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。<br><strong>何时使用：</strong> 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。 2、定义系统的入口。<br><strong>如何解决：</strong>客户端不与系统耦合，外观类与系统耦合。<br><strong>关键代码：</strong>在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。<br><strong>应用实例：</strong> 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、JAVA 的三层开发模式。<br><strong>优点：</strong> 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。<br><strong>缺点：</strong>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。<br><strong>使用场景： </strong>1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。<br><strong>注意事项：</strong>在层次化结构中，可以使用外观模式定义系统中每一层的入口。<br><strong>实现</strong><br>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。下一步是定义一个外观类 ShapeMaker。<br>ShapeMaker 类使用实体类来代表用户对这些类的调用。FacadePatternDemo，我们的演示类使用 ShapeMaker 类来显示结果。<br><img src="设计模式/facade_pattern_uml_diagram.jpg" alt="facade_pattern" title="facade_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口。</p>
<p>Shape.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Shape &#123;</div><div class="line">   void draw();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>Rectangle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Rectangle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Rectangle::draw()&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Square.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Square implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Square::draw()&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Circle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Circle::draw()&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建一个外观类。</p>
<p>ShapeMaker.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class ShapeMaker &#123;</div><div class="line">   private Shape circle;</div><div class="line">   private Shape rectangle;</div><div class="line">   private Shape square;</div><div class="line"></div><div class="line">   public ShapeMaker() &#123;</div><div class="line">      circle = new Circle();</div><div class="line">      rectangle = new Rectangle();</div><div class="line">      square = new Square();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void drawCircle()&#123;</div><div class="line">      circle.draw();</div><div class="line">   &#125;</div><div class="line">   public void drawRectangle()&#123;</div><div class="line">      rectangle.draw();</div><div class="line">   &#125;</div><div class="line">   public void drawSquare()&#123;</div><div class="line">      square.draw();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用该外观类画出各种类型的形状。</p>
<p>FacadePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class FacadePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      ShapeMaker shapeMaker = new ShapeMaker();</div><div class="line"></div><div class="line">      shapeMaker.drawCircle();</div><div class="line">      shapeMaker.drawRectangle();</div><div class="line">      shapeMaker.drawSquare();		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Circle::draw()</div><div class="line">Rectangle::draw()</div><div class="line">Square::draw()</div></pre></td></tr></table></figure>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。<br>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对象。<br><strong>意图：</strong>运用共享技术有效地支持大量细粒度的对象。<br>主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。<br><strong>何时使用：</strong> 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。<br><strong>如何解决：</strong>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。<br><strong>关键代码：</strong>用 HashMap 存储这些对象。<br><strong>应用实例：</strong> 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。<br><strong>优点：</strong>大大减少对象的创建，降低系统的内存，使效率提高。<br><strong>缺点：</strong>提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。<br><strong>使用场景：</strong> 1、系统有大量相似对象。 2、需要缓冲池的场景。<br><strong>注意事项：</strong> 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。<br><strong>实现</strong><br>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类 Circle。下一步是定义工厂类 ShapeFactory。<br>ShapeFactory 有一个 Circle 的 HashMap，其中键名为 Circle 对象的颜色。无论何时接收到请求，都会创建一个特定颜色的圆。ShapeFactory 检查它的 HashMap 中的 circle 对象，如果找到 Circle 对象，则返回该对象，否则将创建一个存储在 hashmap 中以备后续使用的新对象，并把该对象返回到客户端。<br>FlyWeightPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（red / green / blue/ black / white），以便获取它所需对象的颜色。<br><img src="设计模式/flyweight_pattern_uml_diagram-1.jpg" alt="flyweight_pattern" title="flyweight_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口。</p>
<p>Shape.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Shape &#123;</div><div class="line">   void draw();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class Circle implements Shape &#123;</div><div class="line">   private String color;</div><div class="line">   private int x;</div><div class="line">   private int y;</div><div class="line">   private int radius;</div><div class="line"></div><div class="line">   public Circle(String color)&#123;</div><div class="line">      this.color = color;		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setX(int x) &#123;</div><div class="line">      this.x = x;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setY(int y) &#123;</div><div class="line">      this.y = y;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setRadius(int radius) &#123;</div><div class="line">      this.radius = radius;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Circle: Draw() [Color : &quot; + color </div><div class="line">         +&quot;, x : &quot; + x +&quot;, y :&quot; + y +&quot;, radius :&quot; + radius);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建一个工厂，生成基于给定信息的实体类的对象。</p>
<p>ShapeFactory.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import java.util.HashMap;</div><div class="line"></div><div class="line">public class ShapeFactory &#123;</div><div class="line">   private static final HashMap&lt;String, Shape&gt; circleMap = new HashMap();</div><div class="line"></div><div class="line">   public static Shape getCircle(String color) &#123;</div><div class="line">      Circle circle = (Circle)circleMap.get(color);</div><div class="line"></div><div class="line">      if(circle == null) &#123;</div><div class="line">         circle = new Circle(color);</div><div class="line">         circleMap.put(color, circle);</div><div class="line">         System.out.println(&quot;Creating circle of color : &quot; + color);</div><div class="line">      &#125;</div><div class="line">      return circle;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用该工厂，通过传递颜色信息来获取实体类的对象。</p>
<p>FlyweightPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class FlyweightPatternDemo &#123;</div><div class="line">   private static final String colors[] = </div><div class="line">      &#123; &quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot;, &quot;White&quot;, &quot;Black&quot; &#125;;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      for(int i=0; i &lt; 20; ++i) &#123;</div><div class="line">         Circle circle = </div><div class="line">            (Circle)ShapeFactory.getCircle(getRandomColor());</div><div class="line">         circle.setX(getRandomX());</div><div class="line">         circle.setY(getRandomY());</div><div class="line">         circle.setRadius(100);</div><div class="line">         circle.draw();</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">   private static String getRandomColor() &#123;</div><div class="line">      return colors[(int)(Math.random()*colors.length)];</div><div class="line">   &#125;</div><div class="line">   private static int getRandomX() &#123;</div><div class="line">      return (int)(Math.random()*100 );</div><div class="line">   &#125;</div><div class="line">   private static int getRandomY() &#123;</div><div class="line">      return (int)(Math.random()*100);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Creating circle of color : Black</div><div class="line">Circle: Draw() [Color : Black, x : 36, y :71, radius :100</div><div class="line">Creating circle of color : Green</div><div class="line">Circle: Draw() [Color : Green, x : 27, y :27, radius :100</div><div class="line">Creating circle of color : White</div><div class="line">Circle: Draw() [Color : White, x : 64, y :10, radius :100</div><div class="line">Creating circle of color : Red</div><div class="line">Circle: Draw() [Color : Red, x : 15, y :44, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 19, y :10, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 94, y :32, radius :100</div><div class="line">Circle: Draw() [Color : White, x : 69, y :98, radius :100</div><div class="line">Creating circle of color : Blue</div><div class="line">Circle: Draw() [Color : Blue, x : 13, y :4, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 21, y :21, radius :100</div><div class="line">Circle: Draw() [Color : Blue, x : 55, y :86, radius :100</div><div class="line">Circle: Draw() [Color : White, x : 90, y :70, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 78, y :3, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 64, y :89, radius :100</div><div class="line">Circle: Draw() [Color : Blue, x : 3, y :91, radius :100</div><div class="line">Circle: Draw() [Color : Blue, x : 62, y :82, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 97, y :61, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 86, y :12, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 38, y :93, radius :100</div><div class="line">Circle: Draw() [Color : Red, x : 76, y :82, radius :100</div><div class="line">Circle: Draw() [Color : Blue, x : 95, y :82, radius :100</div></pre></td></tr></table></figure>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。<br>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。<br><strong>意图：</strong>为其他对象提供一种代理以控制对这个对象的访问。<br><strong>主要解决：</strong>在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。<br><strong>何时使用：</strong>想在访问一个类时做一些控制。<br><strong>如何解决：</strong>增加中间层。<br>关键代码：实现与被代理类组合。<br><strong>应用实例：</strong> 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。<br><strong>优点：</strong> 1、职责清晰。 2、高扩展性。 3、智能化。<br><strong>缺点：</strong> 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。<br><strong>使用场景：</strong>按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。<br><strong>注意事项：</strong> 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。<br><strong>实现</strong><br>我们将创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。<br>ProxyPatternDemo，我们的演示类使用 ProxyImage 来获取要加载的 Image 对象，并按照需求进行显示。<br><img src="设计模式/proxy_pattern_uml_diagram.jpg" alt="proxy_pattern" title="proxy_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口。</p>
<p>Image.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Image &#123;</div><div class="line">   void display();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>RealImage.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class RealImage implements Image &#123;</div><div class="line"></div><div class="line">   private String fileName;</div><div class="line"></div><div class="line">   public RealImage(String fileName)&#123;</div><div class="line">      this.fileName = fileName;</div><div class="line">      loadFromDisk(fileName);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void display() &#123;</div><div class="line">      System.out.println(&quot;Displaying &quot; + fileName);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private void loadFromDisk(String fileName)&#123;</div><div class="line">      System.out.println(&quot;Loading &quot; + fileName);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ProxyImage.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class ProxyImage implements Image&#123;</div><div class="line"></div><div class="line">   private RealImage realImage;</div><div class="line">   private String fileName;</div><div class="line"></div><div class="line">   public ProxyImage(String fileName)&#123;</div><div class="line">      this.fileName = fileName;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void display() &#123;</div><div class="line">      if(realImage == null)&#123;</div><div class="line">         realImage = new RealImage(fileName);</div><div class="line">      &#125;</div><div class="line">      realImage.display();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>当被请求时，使用 ProxyImage 来获取 RealImage 类的对象。</p>
<p>ProxyPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class ProxyPatternDemo &#123;</div><div class="line">	</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Image image = new ProxyImage(&quot;test_10mb.jpg&quot;);</div><div class="line"></div><div class="line">      //图像将从磁盘加载</div><div class="line">      image.display(); </div><div class="line">      System.out.println(&quot;&quot;);</div><div class="line">      //图像将无法从磁盘加载</div><div class="line">      image.display(); 	</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Loading test_10mb.jpg</div><div class="line">Displaying test_10mb.jpg</div><div class="line"></div><div class="line">Displaying test_10mb.jpg</div></pre></td></tr></table></figure>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。<br>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。<br><strong>意图：</strong>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。<br><strong>主要解决：</strong>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。<br><strong>何时使用：</strong>在处理消息的时候以过滤很多道。<br><strong>如何解决：</strong>拦截的类都实现统一接口。<br><strong>关键代码：</strong>Handler 里面聚合它自己，在 HanleRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。<br><strong>应用实例：</strong> 1、红楼梦中的”击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。<br><strong>优点：</strong> 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。<br><strong>缺点：</strong> 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。<br><strong>使用场景：</strong> 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。<br>注意事项：在 JAVA WEB 中遇到很多应用。<br><strong>实现 </strong><br>我们创建抽象类 AbstractLogger，带有详细的日志记录级别。然后我们创建三种类型的记录器，都扩展了 AbstractLogger。每个记录器消息的级别是否属于自己的级别，如果是则相应地打印出来，否则将不打印并把消息传给下一个记录器。<br><img src="设计模式/chain_pattern_uml_diagram.jpg" alt="chain_pattern" title="chain_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建抽象的记录器类。</p>
<p>AbstractLogger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public abstract class AbstractLogger &#123;</div><div class="line">   public static int INFO = 1;</div><div class="line">   public static int DEBUG = 2;</div><div class="line">   public static int ERROR = 3;</div><div class="line"></div><div class="line">   protected int level;</div><div class="line"></div><div class="line">   //责任链中的下一个元素</div><div class="line">   protected AbstractLogger nextLogger;</div><div class="line"></div><div class="line">   public void setNextLogger(AbstractLogger nextLogger)&#123;</div><div class="line">      this.nextLogger = nextLogger;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void logMessage(int level, String message)&#123;</div><div class="line">      if(this.level &lt;= level)&#123;</div><div class="line">         write(message);</div><div class="line">      &#125;</div><div class="line">      if(nextLogger !=null)&#123;</div><div class="line">         nextLogger.logMessage(level, message);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   abstract protected void write(String message);</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建扩展了该记录器类的实体类。</p>
<p>ConsoleLogger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class ConsoleLogger extends AbstractLogger &#123;</div><div class="line"></div><div class="line">   public ConsoleLogger(int level)&#123;</div><div class="line">      this.level = level;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   protected void write(String message) &#123;		</div><div class="line">      System.out.println(&quot;Standard Console::Logger: &quot; + message);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ErrorLogger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class ErrorLogger extends AbstractLogger &#123;</div><div class="line"></div><div class="line">   public ErrorLogger(int level)&#123;</div><div class="line">      this.level = level;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   protected void write(String message) &#123;		</div><div class="line">      System.out.println(&quot;Error Console::Logger: &quot; + message);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>FileLogger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class FileLogger extends AbstractLogger &#123;</div><div class="line"></div><div class="line">   public FileLogger(int level)&#123;</div><div class="line">      this.level = level;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   protected void write(String message) &#123;		</div><div class="line">      System.out.println(&quot;File::Logger: &quot; + message);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建不同类型的记录器。赋予它们不同的错误级别，并在每个记录器中设置下一个记录器。每个记录器中的下一个记录器代表的是链的一部分。</p>
<p>ChainPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class ChainPatternDemo &#123;</div><div class="line">	</div><div class="line">   private static AbstractLogger getChainOfLoggers()&#123;</div><div class="line"></div><div class="line">      AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR);</div><div class="line">      AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG);</div><div class="line">      AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO);</div><div class="line"></div><div class="line">      errorLogger.setNextLogger(fileLogger);</div><div class="line">      fileLogger.setNextLogger(consoleLogger);</div><div class="line"></div><div class="line">      return errorLogger;	</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      AbstractLogger loggerChain = getChainOfLoggers();</div><div class="line"></div><div class="line">      loggerChain.logMessage(AbstractLogger.INFO, </div><div class="line">         &quot;This is an information.&quot;);</div><div class="line"></div><div class="line">      loggerChain.logMessage(AbstractLogger.DEBUG, </div><div class="line">         &quot;This is an debug level information.&quot;);</div><div class="line"></div><div class="line">      loggerChain.logMessage(AbstractLogger.ERROR, </div><div class="line">         &quot;This is an error information.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Standard Console::Logger: This is an information.</div><div class="line">File::Logger: This is an debug level information.</div><div class="line">Standard Console::Logger: This is an debug level information.</div><div class="line">Error Console::Logger: This is an error information.</div><div class="line">File::Logger: This is an error information.</div><div class="line">Standard Console::Logger: This is an error information.</div></pre></td></tr></table></figure>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。<br><strong>意图：</strong>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。<br><strong>主要解决：</strong>在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。<br><strong>何时使用：</strong>在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。<br><strong>如何解决：</strong>通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。<br><strong>关键代码：</strong>定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口<br><strong>应用实例：</strong>struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。<br><strong>优点：</strong> 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。<br><strong>缺点：</strong>使用命令模式可能会导致某些系统有过多的具体命令类。<br><strong>使用场景：</strong>认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。<br><strong>注意事项：</strong>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。<br><strong>实现</strong><br>我们首先创建作为命令的接口 Order，然后创建作为请求的 Stock 类。实体命令类 BuyStock 和 SellStock，实现了 Order 接口，将执行实际的命令处理。创建作为调用对象的类 Broker，它接受订单并能下订单。<br>Broker 对象使用命令模式，基于命令的类型确定哪个对象执行哪个命令。CommandPatternDemo，我们的演示类使用 Broker 类来演示命令模式。<br><img src="设计模式/command_pattern_uml_diagram.jpg" alt="command_pattern" title="command_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个命令接口。</p>
<p>Order.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Order &#123;</div><div class="line">   void execute();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建一个请求类。</p>
<p>Stock.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Stock &#123;</div><div class="line">	</div><div class="line">   private String name = &quot;ABC&quot;;</div><div class="line">   private int quantity = 10;</div><div class="line"></div><div class="line">   public void buy()&#123;</div><div class="line">      System.out.println(&quot;Stock [ Name: &quot;+name+&quot;, </div><div class="line">         Quantity: &quot; + quantity +&quot; ] bought&quot;);</div><div class="line">   &#125;</div><div class="line">   public void sell()&#123;</div><div class="line">      System.out.println(&quot;Stock [ Name: &quot;+name+&quot;, </div><div class="line">         Quantity: &quot; + quantity +&quot; ] sold&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实现了 Order 接口的实体类。</p>
<p>BuyStock.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class BuyStock implements Order &#123;</div><div class="line">   private Stock abcStock;</div><div class="line"></div><div class="line">   public BuyStock(Stock abcStock)&#123;</div><div class="line">      this.abcStock = abcStock;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void execute() &#123;</div><div class="line">      abcStock.buy();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SellStock.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class SellStock implements Order &#123;</div><div class="line">   private Stock abcStock;</div><div class="line"></div><div class="line">   public SellStock(Stock abcStock)&#123;</div><div class="line">      this.abcStock = abcStock;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void execute() &#123;</div><div class="line">      abcStock.sell();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建命令调用类。</p>
<p>Broker.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">   public class Broker &#123;</div><div class="line">   private List&lt;Order&gt; orderList = new ArrayList&lt;Order&gt;(); </div><div class="line"></div><div class="line">   public void takeOrder(Order order)&#123;</div><div class="line">      orderList.add(order);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void placeOrders()&#123;</div><div class="line">      for (Order order : orderList) &#123;</div><div class="line">         order.execute();</div><div class="line">      &#125;</div><div class="line">      orderList.clear();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>使用 Broker 类来接受并执行命令。</p>
<p>CommandPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class CommandPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Stock abcStock = new Stock();</div><div class="line"></div><div class="line">      BuyStock buyStockOrder = new BuyStock(abcStock);</div><div class="line">      SellStock sellStockOrder = new SellStock(abcStock);</div><div class="line"></div><div class="line">      Broker broker = new Broker();</div><div class="line">      broker.takeOrder(buyStockOrder);</div><div class="line">      broker.takeOrder(sellStockOrder);</div><div class="line"></div><div class="line">      broker.placeOrders();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Stock [ Name: ABC, Quantity: 10 ] bought</div><div class="line">Stock [ Name: ABC, Quantity: 10 ] sold</div></pre></td></tr></table></figure>
<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。<br>意图：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。<br><strong>主要解决：</strong>对于一些固定文法构建一个解释句子的解释器。<br><strong>何时使用：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。  
</strong>如何解决：<strong>构件语法树，定义终结符与非终结符。  
</strong>关键代码：<strong>构件环境类，包含解释器之外的一些全局信息，一般是 HashMap。  
</strong>应用实例：<strong>编译器、运算表达式计算。  
</strong>优点：<strong> 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。  
</strong>缺点：<strong> 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。  
</strong>使用场景：<strong> 1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 2、一些重复出现的问题可以用一种简单的语言来进行表达。 3、一个简单语法需要解释的场景。<br>注意事项：可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。  
</strong>实现 **<br>我们将创建一个接口 Expression 和实现了 Expression 接口的实体类。定义作为上下文中主要解释器的 TerminalExpression 类。其他的类 OrExpression、AndExpression 用于创建组合式表达式。<br>InterpreterPatternDemo，我们的演示类使用 Expression 类创建规则和演示表达式的解析。<br><img src="设计模式/interpreter_pattern_uml_diagram.jpg" alt="interpreter_pattern" title="interpreter_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个表达式接口。</p>
<p>Expression.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Expression &#123;</div><div class="line">   public boolean interpret(String context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现了上述接口的实体类。</p>
<p>TerminalExpression.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class TerminalExpression implements Expression &#123;</div><div class="line">	</div><div class="line">   private String data;</div><div class="line"></div><div class="line">   public TerminalExpression(String data)&#123;</div><div class="line">      this.data = data; </div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public boolean interpret(String context) &#123;</div><div class="line">      if(context.contains(data))&#123;</div><div class="line">         return true;</div><div class="line">      &#125;</div><div class="line">      return false;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OrExpression.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class OrExpression implements Expression &#123;</div><div class="line">	 </div><div class="line">   private Expression expr1 = null;</div><div class="line">   private Expression expr2 = null;</div><div class="line"></div><div class="line">   public OrExpression(Expression expr1, Expression expr2) &#123; </div><div class="line">      this.expr1 = expr1;</div><div class="line">      this.expr2 = expr2;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public boolean interpret(String context) &#123;		</div><div class="line">      return expr1.interpret(context) || expr2.interpret(context);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AndExpression.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class AndExpression implements Expression &#123;</div><div class="line">	 </div><div class="line">   private Expression expr1 = null;</div><div class="line">   private Expression expr2 = null;</div><div class="line"></div><div class="line">   public AndExpression(Expression expr1, Expression expr2) &#123; </div><div class="line">      this.expr1 = expr1;</div><div class="line">      this.expr2 = expr2;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public boolean interpret(String context) &#123;		</div><div class="line">      return expr1.interpret(context) &amp;&amp; expr2.interpret(context);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong><br>InterpreterPatternDemo 使用 Expression 类来创建规则，并解析它们。</p>
<p>InterpreterPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class InterpreterPatternDemo &#123;</div><div class="line"></div><div class="line">   //规则：Robert 和 John 是男性</div><div class="line">   public static Expression getMaleExpression()&#123;</div><div class="line">      Expression robert = new TerminalExpression(&quot;Robert&quot;);</div><div class="line">      Expression john = new TerminalExpression(&quot;John&quot;);</div><div class="line">      return new OrExpression(robert, john);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //规则：Julie 是一个已婚的女性</div><div class="line">   public static Expression getMarriedWomanExpression()&#123;</div><div class="line">      Expression julie = new TerminalExpression(&quot;Julie&quot;);</div><div class="line">      Expression married = new TerminalExpression(&quot;Married&quot;);</div><div class="line">      return new AndExpression(julie, married);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Expression isMale = getMaleExpression();</div><div class="line">      Expression isMarriedWoman = getMarriedWomanExpression();</div><div class="line"></div><div class="line">      System.out.println(&quot;John is male? &quot; + isMale.interpret(&quot;John&quot;));</div><div class="line">      System.out.println(&quot;Julie is a married women? &quot; </div><div class="line">      + isMarriedWoman.interpret(&quot;Married Julie&quot;));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">John is male? true</div><div class="line">Julie is a married women? true</div></pre></td></tr></table></figure>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。<br>迭代器模式属于行为型模式。<br><strong>意图：</strong>提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。<br><strong>主要解决：</strong>不同的方式来遍历整个整合对象。<br><strong>何时使用：</strong>遍历一个聚合对象。<br><strong>如何解决：</strong>把在元素之间游走的责任交给迭代器，而不是聚合对象。<br><strong>关键代码：</strong>定义接口：hasNext, next。<br><strong>应用实例：</strong>JAVA 中的 iterator。<br><strong>优点：</strong> 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。<br><strong>缺点：</strong>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。<br>使用场景： 1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口。<br><strong>注意事项：</strong>迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。<br><strong>实现</strong><br>我们将创建一个叙述导航方法的 Iterator 接口和一个返回迭代器的 Container 接口。实现了 Container 接口的实体类将负责实现 Iterator 接口。<br>IteratorPatternDemo，我们的演示类使用实体类 NamesRepository 来打印 NamesRepository 中存储为集合的 Names。<br><img src="设计模式/iterator_pattern_uml_diagram.jpg" alt="iterator_pattern" title="iterator_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建接口。</p>
<p>Iterator.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface Iterator &#123;</div><div class="line">   public boolean hasNext();</div><div class="line">   public Object next();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Container.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Container &#123;</div><div class="line">   public Iterator getIterator();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现了 Container 接口的实体类。该类有实现了 Iterator 接口的内部类 NameIterator。</p>
<p>NameRepository.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class NameRepository implements Container &#123;</div><div class="line">   public String names[] = &#123;&quot;Robert&quot; , &quot;John&quot; ,&quot;Julie&quot; , &quot;Lora&quot;&#125;;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public Iterator getIterator() &#123;</div><div class="line">      return new NameIterator();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private class NameIterator implements Iterator &#123;</div><div class="line"></div><div class="line">      int index;</div><div class="line"></div><div class="line">      @Override</div><div class="line">      public boolean hasNext() &#123;</div><div class="line">         if(index &lt; names.length)&#123;</div><div class="line">            return true;</div><div class="line">         &#125;</div><div class="line">         return false;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      @Override</div><div class="line">      public Object next() &#123;</div><div class="line">         if(this.hasNext())&#123;</div><div class="line">            return names[index++];</div><div class="line">         &#125;</div><div class="line">         return null;</div><div class="line">      &#125;		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>使用 NameRepository 来获取迭代器，并打印名字。</p>
<p>IteratorPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class IteratorPatternDemo &#123;</div><div class="line">	</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      NameRepository namesRepository = new NameRepository();</div><div class="line"></div><div class="line">      for(Iterator iter = namesRepository.getIterator(); iter.hasNext();)&#123;</div><div class="line">         String name = (String)iter.next();</div><div class="line">         System.out.println(&quot;Name : &quot; + name);</div><div class="line">      &#125; 	</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Name : Robert</div><div class="line">Name : John</div><div class="line">Name : Julie</div><div class="line">Name : Lora</div></pre></td></tr></table></figure>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。<br><strong>意图：</strong>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br><strong>主要解决：</strong>对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。<br><strong>何时使用：</strong>多个类相互耦合，形成了网状结构。<br><strong>如何解决：</strong>将上述网状结构分离为星型结构。<br><strong>关键代码：</strong>对象 Colleague 之间的通信封装到一个类中单独处理。<br><strong>应用实例：</strong> 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。<br><strong>优点：</strong> 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。<br><strong>缺点：</strong>中介者会庞大，变得复杂难以维护。<br>使用场景： 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。<br>注意事项：不应当在职责混乱的时候使用。<br><strong>实现</strong><br>我们通过聊天室实例来演示中介者模式。实例中，多个用户可以向聊天室发送消息，聊天室向所有的用户显示消息。我们将创建两个类 ChatRoom 和 User。User 对象使用 ChatRoom 方法来分享他们的消息。<br>MediatorPatternDemo，我们的演示类使用 User 对象来显示他们之间的通信。<br><img src="设计模式/mediator_pattern_uml_diagram.jpg" alt="mediator_pattern" title="mediator_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建中介类。</p>
<p>ChatRoom.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import java.util.Date;</div><div class="line"></div><div class="line">public class ChatRoom &#123;</div><div class="line">   public static void showMessage(User user, String message)&#123;</div><div class="line">      System.out.println(new Date().toString()</div><div class="line">         + &quot; [&quot; + user.getName() +&quot;] : &quot; + message);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建 user 类。</p>
<p>User.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class User &#123;</div><div class="line">   private String name;</div><div class="line"></div><div class="line">   public String getName() &#123;</div><div class="line">      return name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setName(String name) &#123;</div><div class="line">      this.name = name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public User(String name)&#123;</div><div class="line">      this.name  = name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void sendMessage(String message)&#123;</div><div class="line">      ChatRoom.showMessage(this,message);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>使用 User 对象来显示他们之间的通信。</p>
<p>MediatorPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class MediatorPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      User robert = new User(&quot;Robert&quot;);</div><div class="line">      User john = new User(&quot;John&quot;);</div><div class="line"></div><div class="line">      robert.sendMessage(&quot;Hi! John!&quot;);</div><div class="line">      john.sendMessage(&quot;Hello! Robert!&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Thu Jan 31 16:05:46 IST 2013 [Robert] : Hi! John!</div><div class="line">Thu Jan 31 16:05:46 IST 2013 [John] : Hello! Robert!</div></pre></td></tr></table></figure>
<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。<br><strong>意图：</strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。<br><strong>主要解决：</strong>所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。<br><strong>何时使用：</strong>很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。<br><strong>如何解决：</strong>通过一个备忘录类专门存储对象状态。<br><strong>关键代码：</strong>客户不与备忘录类耦合，与备忘录管理类耦合。<br><strong>应用实例：</strong> 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、IE 中的后退。 4、数据库的事务管理。<br><strong>优点：</strong> 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。<br><strong>缺点：</strong>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。<br><strong>使用场景：</strong> 1、需要保存/恢复数据的相关状态场景。 2、提供一个可回滚的操作。<br><strong>注意事项：</strong> 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。<br><strong>实现</strong><br>备忘录模式使用三个类 Memento、Originator 和 CareTaker。Memento 包含了要被恢复的对象的状态。  Originator 创建并在 Memento 对象中存储状态。Caretaker 对象负责从 Memento 中恢复对象的状态。<br>MementoPatternDemo，我们的演示类使用 CareTaker 和 Originator 对象来显示对象的状态恢复。<br><img src="设计模式/memento_pattern_uml_diagram.jpg" alt="memento_pattern" title="memento_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建 Memento 类。</p>
<p>Memento.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Memento &#123;</div><div class="line">   private String state;</div><div class="line"></div><div class="line">   public Memento(String state)&#123;</div><div class="line">      this.state = state;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getState()&#123;</div><div class="line">      return state;</div><div class="line">   &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建 Originator 类。</p>
<p>Originator.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Originator &#123;</div><div class="line">   private String state;</div><div class="line"></div><div class="line">   public void setState(String state)&#123;</div><div class="line">      this.state = state;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getState()&#123;</div><div class="line">      return state;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public Memento saveStateToMemento()&#123;</div><div class="line">      return new Memento(state);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void getStateFromMemento(Memento Memento)&#123;</div><div class="line">      state = Memento.getState();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建 CareTaker 类。</p>
<p>CareTaker.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class CareTaker &#123;</div><div class="line">   private List&lt;Memento&gt; mementoList = new ArrayList&lt;Memento&gt;();</div><div class="line"></div><div class="line">   public void add(Memento state)&#123;</div><div class="line">      mementoList.add(state);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public Memento get(int index)&#123;</div><div class="line">      return mementoList.get(index);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 CareTaker 和 Originator 对象。</p>
<p>MementoPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class MementoPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Originator originator = new Originator();</div><div class="line">      CareTaker careTaker = new CareTaker();</div><div class="line">      originator.setState(&quot;State #1&quot;);</div><div class="line">      originator.setState(&quot;State #2&quot;);</div><div class="line">      careTaker.add(originator.saveStateToMemento());</div><div class="line">      originator.setState(&quot;State #3&quot;);</div><div class="line">      careTaker.add(originator.saveStateToMemento());</div><div class="line">      originator.setState(&quot;State #4&quot;);</div><div class="line"></div><div class="line">      System.out.println(&quot;Current State: &quot; + originator.getState());		</div><div class="line">      originator.getStateFromMemento(careTaker.get(0));</div><div class="line">      System.out.println(&quot;First saved State: &quot; + originator.getState());</div><div class="line">      originator.getStateFromMemento(careTaker.get(1));</div><div class="line">      System.out.println(&quot;Second saved State: &quot; + originator.getState());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Current State: State #4</div><div class="line">First saved State: State #2</div><div class="line">Second saved State: State #3</div></pre></td></tr></table></figure>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。<br>意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。<br><strong>主要解决：</strong>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。<br><strong>何时使用：</strong>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。<br><strong>如何解决：</strong>使用面向对象技术，可以将这种依赖关系弱化。<br><strong>关键代码：</strong>在抽象类里有一个 ArrayList 存放观察者们。<br><strong>应用实例：</strong> 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。<br><strong>优点：</strong> 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。<br><strong>缺点：</strong> 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。<br><strong>使用场景：</strong> 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。<br><strong>注意事项：</strong> 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。<br><strong>实现</strong><br>观察者模式使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。我们创建 Subject 类、Observer 抽象类和扩展了抽象类 Observer 的实体类。<br>ObserverPatternDemo，我们的演示类使用 Subject 和实体类对象来演示观察者模式。<br><img src="设计模式/observer_pattern_uml_diagram.jpg" alt="observer_pattern" title="observer_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建 Subject 类。</p>
<p>Subject.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class Subject &#123;</div><div class="line">	</div><div class="line">   private List&lt;Observer&gt; observers </div><div class="line">      = new ArrayList&lt;Observer&gt;();</div><div class="line">   private int state;</div><div class="line"></div><div class="line">   public int getState() &#123;</div><div class="line">      return state;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setState(int state) &#123;</div><div class="line">      this.state = state;</div><div class="line">      notifyAllObservers();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void attach(Observer observer)&#123;</div><div class="line">      observers.add(observer);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void notifyAllObservers()&#123;</div><div class="line">      for (Observer observer : observers) &#123;</div><div class="line">         observer.update();</div><div class="line">      &#125;</div><div class="line">   &#125; 	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建 Observer 类。</p>
<p>Observer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public abstract class Observer &#123;</div><div class="line">   protected Subject subject;</div><div class="line">   public abstract void update();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实体观察者类。</p>
<p>BinaryObserver.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class BinaryObserver extends Observer&#123;</div><div class="line"></div><div class="line">   public BinaryObserver(Subject subject)&#123;</div><div class="line">      this.subject = subject;</div><div class="line">      this.subject.attach(this);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void update() &#123;</div><div class="line">      System.out.println( &quot;Binary String: &quot; </div><div class="line">      + Integer.toBinaryString( subject.getState() ) ); </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OctalObserver.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class OctalObserver extends Observer&#123;</div><div class="line"></div><div class="line">   public OctalObserver(Subject subject)&#123;</div><div class="line">      this.subject = subject;</div><div class="line">      this.subject.attach(this);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void update() &#123;</div><div class="line">     System.out.println( &quot;Octal String: &quot; </div><div class="line">     + Integer.toOctalString( subject.getState() ) ); </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>HexaObserver.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class HexaObserver extends Observer&#123;</div><div class="line"></div><div class="line">   public HexaObserver(Subject subject)&#123;</div><div class="line">      this.subject = subject;</div><div class="line">      this.subject.attach(this);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void update() &#123;</div><div class="line">      System.out.println( &quot;Hex String: &quot; </div><div class="line">      + Integer.toHexString( subject.getState() ).toUpperCase() ); </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 Subject 和实体观察者对象。</p>
<p>ObserverPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class ObserverPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Subject subject = new Subject();</div><div class="line"></div><div class="line">      new HexaObserver(subject);</div><div class="line">      new OctalObserver(subject);</div><div class="line">      new BinaryObserver(subject);</div><div class="line"></div><div class="line">      System.out.println(&quot;First state change: 15&quot;);	</div><div class="line">      subject.setState(15);</div><div class="line">      System.out.println(&quot;Second state change: 10&quot;);	</div><div class="line">      subject.setState(10);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">First state change: 15</div><div class="line">Hex String: F</div><div class="line">Octal String: 17</div><div class="line">Binary String: 1111</div><div class="line">Second state change: 10</div><div class="line">Hex String: A</div><div class="line">Octal String: 12</div><div class="line">Binary String: 1010</div></pre></td></tr></table></figure>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。<br>在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。<br>介绍<br><strong>意图：</strong>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。<br><strong>主要解决：</strong>对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。<br><strong>何时使用：</strong>代码中包含大量与对象状态有关的条件语句。<br><strong>如何解决：</strong>将各种具体的状态类抽象出来。<br><strong>关键代码：</strong>通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。<br><strong>应用实例：</strong> 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。<br><strong>优点：</strong> 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。<br><strong>缺点：</strong> 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。<br><strong>使用场景：</strong> 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。<br><strong>注意事项：</strong>在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。<br><strong>实现</strong><br>我们将创建一个 State 接口和实现了 State 接口的实体状态类。Context 是一个带有某个状态的类。<br>StatePatternDemo，我们的演示类使用 Context 和状态对象来演示 Context 在状态改变时的行为变化。<br><img src="设计模式/state_pattern_uml_diagram.jpg" alt="state_pattern" title="state_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口。</p>
<p>State.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface State &#123;</div><div class="line">   public void doAction(Context context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>StartState.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class StartState implements State &#123;</div><div class="line"></div><div class="line">   public void doAction(Context context) &#123;</div><div class="line">      System.out.println(&quot;Player is in start state&quot;);</div><div class="line">      context.setState(this);	</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String toString()&#123;</div><div class="line">      return &quot;Start State&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>StopState.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class StopState implements State &#123;</div><div class="line"></div><div class="line">   public void doAction(Context context) &#123;</div><div class="line">      System.out.println(&quot;Player is in stop state&quot;);</div><div class="line">      context.setState(this);	</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String toString()&#123;</div><div class="line">      return &quot;Stop State&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建 Context 类。</p>
<p>Context.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Context &#123;</div><div class="line">   private State state;</div><div class="line"></div><div class="line">   public Context()&#123;</div><div class="line">      state = null;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setState(State state)&#123;</div><div class="line">      this.state = state;		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public State getState()&#123;</div><div class="line">      return state;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 Context 来查看当状态 State 改变时的行为变化。</p>
<p>StatePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class StatePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Context context = new Context();</div><div class="line"></div><div class="line">      StartState startState = new StartState();</div><div class="line">      startState.doAction(context);</div><div class="line"></div><div class="line">      System.out.println(context.getState().toString());</div><div class="line"></div><div class="line">      StopState stopState = new StopState();</div><div class="line">      stopState.doAction(context);</div><div class="line"></div><div class="line">      System.out.println(context.getState().toString());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Player is in start state</div><div class="line">Start State</div><div class="line">Player is in stop state</div><div class="line">Stop State</div></pre></td></tr></table></figure>
<h2 id="空对象模式"><a href="#空对象模式" class="headerlink" title="空对象模式"></a>空对象模式</h2><p>在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。<br>在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。<br><strong>实现</strong><br>我们将创建一个定义操作（在这里，是客户的名称）的 AbstractCustomer 抽象类，和扩展了 AbstractCustomer 类的实体类。工厂类 CustomerFactory 基于客户传递的名字来返回 RealCustomer 或 NullCustomer 对象。<br>NullPatternDemo，我们的演示类使用 CustomerFactory 来演示空对象模式的用法。<br><img src="设计模式/null_pattern_uml_diagram.jpg" alt="null_pattern" title="null_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个抽象类。</p>
<p>AbstractCustomer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public abstract class AbstractCustomer &#123;</div><div class="line">   protected String name;</div><div class="line">   public abstract boolean isNil();</div><div class="line">   public abstract String getName();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建扩展了上述类的实体类。</p>
<p>RealCustomer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class RealCustomer extends AbstractCustomer &#123;</div><div class="line"></div><div class="line">   public RealCustomer(String name) &#123;</div><div class="line">      this.name = name;		</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @Override</div><div class="line">   public String getName() &#123;</div><div class="line">      return name;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @Override</div><div class="line">   public boolean isNil() &#123;</div><div class="line">      return false;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>NullCustomer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class NullCustomer extends AbstractCustomer &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String getName() &#123;</div><div class="line">      return &quot;Not Available in Customer Database&quot;;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public boolean isNil() &#123;</div><div class="line">      return true;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建 CustomerFactory 类。</p>
<p>CustomerFactory.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class CustomerFactory &#123;</div><div class="line">	</div><div class="line">   public static final String[] names = &#123;&quot;Rob&quot;, &quot;Joe&quot;, &quot;Julie&quot;&#125;;</div><div class="line"></div><div class="line">   public static AbstractCustomer getCustomer(String name)&#123;</div><div class="line">      for (int i = 0; i &lt; names.length; i++) &#123;</div><div class="line">         if (names[i].equalsIgnoreCase(name))&#123;</div><div class="line">            return new RealCustomer(name);</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      return new NullCustomer();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 CustomerFactory，基于客户传递的名字，来获取 RealCustomer 或 NullCustomer 对象。</p>
<p>NullPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class NullPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      AbstractCustomer customer1 = CustomerFactory.getCustomer(&quot;Rob&quot;);</div><div class="line">      AbstractCustomer customer2 = CustomerFactory.getCustomer(&quot;Bob&quot;);</div><div class="line">      AbstractCustomer customer3 = CustomerFactory.getCustomer(&quot;Julie&quot;);</div><div class="line">      AbstractCustomer customer4 = CustomerFactory.getCustomer(&quot;Laura&quot;);</div><div class="line"></div><div class="line">      System.out.println(&quot;Customers&quot;);</div><div class="line">      System.out.println(customer1.getName());</div><div class="line">      System.out.println(customer2.getName());</div><div class="line">      System.out.println(customer3.getName());</div><div class="line">      System.out.println(customer4.getName());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Customers</div><div class="line">Rob</div><div class="line">Not Available in Customer Database</div><div class="line">Julie</div><div class="line">Not Available in Customer Database</div></pre></td></tr></table></figure>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。<br>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。<br><strong>意图：</strong>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。<br><strong>主要解决：</strong>在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。<br><strong>何时使用：</strong>一个系统有许多许多类，而区分它们的只是他们直接的行为。<br><strong>如何解决：</strong>将这些算法封装成一个一个的类，任意地替换。<br><strong>关键代码：</strong>实现同一个接口。<br><strong>应用实例：</strong> 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。<br><strong>优点：</strong> 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。<br><strong>缺点：</strong> 1、策略类会增多。 2、所有策略类都需要对外暴露。<br><strong>使用场景：</strong> 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。<br>注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。<br><strong>实现 </strong><br>我们将创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。<br>StrategyPatternDemo，我们的演示类使用 Context 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。<br><img src="设计模式/strategy_pattern_uml_diagram.jpg" alt="strategy_pattern" title="strategy_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口。</p>
<p>Strategy.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Strategy &#123;</div><div class="line">   public int doOperation(int num1, int num2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>OperationAdd.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class OperationAdd implements Strategy&#123;</div><div class="line">   @Override</div><div class="line">   public int doOperation(int num1, int num2) &#123;</div><div class="line">      return num1 + num2;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OperationSubstract.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class OperationSubstract implements Strategy&#123;</div><div class="line">   @Override</div><div class="line">   public int doOperation(int num1, int num2) &#123;</div><div class="line">      return num1 - num2;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OperationMultiply.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class OperationMultiply implements Strategy&#123;</div><div class="line">   @Override</div><div class="line">   public int doOperation(int num1, int num2) &#123;</div><div class="line">      return num1 * num2;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建 Context 类。</p>
<p>Context.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Context &#123;</div><div class="line">   private Strategy strategy;</div><div class="line"></div><div class="line">   public Context(Strategy strategy)&#123;</div><div class="line">      this.strategy = strategy;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public int executeStrategy(int num1, int num2)&#123;</div><div class="line">      return strategy.doOperation(num1, num2);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 Context 来查看当它改变策略 Strategy 时的行为变化。</p>
<p>StrategyPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class StrategyPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Context context = new Context(new OperationAdd());		</div><div class="line">      System.out.println(&quot;10 + 5 = &quot; + context.executeStrategy(10, 5));</div><div class="line"></div><div class="line">      context = new Context(new OperationSubstract());		</div><div class="line">      System.out.println(&quot;10 - 5 = &quot; + context.executeStrategy(10, 5));</div><div class="line"></div><div class="line">      context = new Context(new OperationMultiply());		</div><div class="line">      System.out.println(&quot;10 * 5 = &quot; + context.executeStrategy(10, 5));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">10 + 5 = 15</div><div class="line">10 - 5 = 5</div><div class="line">10 * 5 = 50</div></pre></td></tr></table></figure>
<h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。<br>意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br><strong>主要解决：</strong>一些方法通用，却在每一个子类都重新写了这一方法。<br><strong>何时使用：</strong>有一些通用的方法。<br><strong>如何解决：</strong>将这些通用算法抽象出来。<br><strong>关键代码：</strong>在抽象类实现，其他步骤在子类实现。<br><strong>应用实例：</strong> 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。<br><strong>优点：</strong> 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。<br><strong>缺点：</strong>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。<br><strong>使用场景：</strong> 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。<br><strong>注意事项：</strong>为防止恶意操作，一般模板方法都加上 final 关键词。<br><strong>实现</strong><br>我们将创建一个定义操作的 Game 抽象类，其中，模板方法设置为 final，这样它就不会被重写。Cricket 和 Football 是扩展了 Game 的实体类，它们重写了抽象类的方法。<br>TemplatePatternDemo，我们的演示类使用 Game 来演示模板模式的用法。<br><img src="设计模式/template_pattern_uml_diagram.jpg" alt="template_pattern" title="template_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个抽象类，它的模板方法被设置为 final。</p>
<p>Game.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public abstract class Game &#123;</div><div class="line">   abstract void initialize();</div><div class="line">   abstract void startPlay();</div><div class="line">   abstract void endPlay();</div><div class="line"></div><div class="line">   //模板</div><div class="line">   public final void play()&#123;</div><div class="line"></div><div class="line">      //初始化游戏</div><div class="line">      initialize();</div><div class="line"></div><div class="line">      //开始游戏</div><div class="line">      startPlay();</div><div class="line"></div><div class="line">      //结束游戏</div><div class="line">      endPlay();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建扩展了上述类的实体类。</p>
<p>Cricket.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Cricket extends Game &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   void endPlay() &#123;</div><div class="line">      System.out.println(&quot;Cricket Game Finished!&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   void initialize() &#123;</div><div class="line">      System.out.println(&quot;Cricket Game Initialized! Start playing.&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   void startPlay() &#123;</div><div class="line">      System.out.println(&quot;Cricket Game Started. Enjoy the game!&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Football.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Football extends Game &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   void endPlay() &#123;</div><div class="line">      System.out.println(&quot;Football Game Finished!&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   void initialize() &#123;</div><div class="line">      System.out.println(&quot;Football Game Initialized! Start playing.&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   void startPlay() &#123;</div><div class="line">      System.out.println(&quot;Football Game Started. Enjoy the game!&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>使用 Game 的模板方法 play() 来演示游戏的定义方式。</p>
<p>TemplatePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class TemplatePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      Game game = new Cricket();</div><div class="line">      game.play();</div><div class="line">      System.out.println();</div><div class="line">      game = new Football();</div><div class="line">      game.play();		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Cricket Game Initialized! Start playing.</div><div class="line">Cricket Game Started. Enjoy the game!</div><div class="line">Cricket Game Finished!</div><div class="line"></div><div class="line">Football Game Initialized! Start playing.</div><div class="line">Football Game Started. Enjoy the game!</div><div class="line">Football Game Finished!</div></pre></td></tr></table></figure>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。<br>意图：主要将数据结构与数据操作分离。<br><strong> 主要解决：</strong> 稳定的数据结构和易变的操作耦合问题。<br><strong> 何时使用：</strong> 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。<br><strong> 如何解决：</strong> 在被访问的类里面加一个对外提供接待访问者的接口。<br><strong> 关键代码：</strong> 在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。<br><strong> 应用实例：</strong> 您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。<br><strong> 优点：</strong>  1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。<br><strong> 缺点：</strong>  1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。<br><strong> 使用场景：</strong>  1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。<br><strong> 注意事项：</strong> 访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。<br><strong> 实现</strong><br>我们将创建一个定义接受操作的 ComputerPart 接口。Keyboard、Mouse、Monitor 和 Computer 是实现了 ComputerPart 接口的实体类。我们将定义另一个接口 ComputerPartVisitor，它定义了访问者类的操作。Computer 使用实体访问者来执行相应的动作。<br>VisitorPatternDemo，我们的演示类使用 Computer、ComputerPartVisitor 类来演示访问者模式的用法。<br><img src="设计模式/visitor_pattern_uml_diagram.jpg" alt="visitor_pattern" title="visitor_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>定义一个表示元素的接口。</p>
<p>ComputerPart.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface ComputerPart &#123;</div><div class="line">   public void accept(ComputerPartVisitor computerPartVisitor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建扩展了上述类的实体类。</p>
<p>Keyboard.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Keyboard  implements ComputerPart &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void accept(ComputerPartVisitor computerPartVisitor) &#123;</div><div class="line">      computerPartVisitor.visit(this);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Monitor.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Monitor  implements ComputerPart &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void accept(ComputerPartVisitor computerPartVisitor) &#123;</div><div class="line">      computerPartVisitor.visit(this);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Mouse.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Mouse  implements ComputerPart &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void accept(ComputerPartVisitor computerPartVisitor) &#123;</div><div class="line">      computerPartVisitor.visit(this);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Computer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Computer implements ComputerPart &#123;</div><div class="line">	</div><div class="line">   ComputerPart[] parts;</div><div class="line"></div><div class="line">   public Computer()&#123;</div><div class="line">      parts = new ComputerPart[] &#123;new Mouse(), new Keyboard(), new Monitor()&#125;;		</div><div class="line">   &#125; </div><div class="line"></div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void accept(ComputerPartVisitor computerPartVisitor) &#123;</div><div class="line">      for (int i = 0; i &lt; parts.length; i++) &#123;</div><div class="line">         parts[i].accept(computerPartVisitor);</div><div class="line">      &#125;</div><div class="line">      computerPartVisitor.visit(this);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>定义一个表示访问者的接口。</p>
<p>ComputerPartVisitor.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public interface ComputerPartVisitor &#123;</div><div class="line">	public void visit(Computer computer);</div><div class="line">	public void visit(Mouse mouse);</div><div class="line">	public void visit(Keyboard keyboard);</div><div class="line">	public void visit(Monitor monitor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建实现了上述类的实体访问者。</p>
<p>ComputerPartDisplayVisitor.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class ComputerPartDisplayVisitor implements ComputerPartVisitor &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void visit(Computer computer) &#123;</div><div class="line">      System.out.println(&quot;Displaying Computer.&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void visit(Mouse mouse) &#123;</div><div class="line">      System.out.println(&quot;Displaying Mouse.&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void visit(Keyboard keyboard) &#123;</div><div class="line">      System.out.println(&quot;Displaying Keyboard.&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void visit(Monitor monitor) &#123;</div><div class="line">      System.out.println(&quot;Displaying Monitor.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>使用 ComputerPartDisplayVisitor 来显示 Computer 的组成部分。</p>
<p>VisitorPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class VisitorPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      ComputerPart computer = new Computer();</div><div class="line">      computer.accept(new ComputerPartDisplayVisitor());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Displaying Mouse.</div><div class="line">Displaying Keyboard.</div><div class="line">Displaying Monitor.</div><div class="line">Displaying Computer.</div></pre></td></tr></table></figure>
<h2 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC 模式"></a>MVC 模式</h2><p>MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。<br><strong>Model（模型）</strong> - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。<br><strong>View（视图） </strong>- 视图代表模型包含的数据的可视化。<br><strong>Controller（控制器）</strong> - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。<br><strong>实现</strong><br>我们将创建一个作为模型的 Student 对象。StudentView 是一个把学生详细信息输出到控制台的视图类，StudentController 是负责存储数据到 Student 对象中的控制器类，并相应地更新视图 StudentView。<br>MVCPatternDemo，我们的演示类使用 StudentController 来演示 MVC 模式的用法。</p>
<p><img src="设计模式/mvc_pattern_uml_diagram.jpg" alt="mvc_pattern" title="mvc_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建模型。</p>
<p>Student.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Student &#123;</div><div class="line">   private String rollNo;</div><div class="line">   private String name;</div><div class="line">   public String getRollNo() &#123;</div><div class="line">      return rollNo;</div><div class="line">   &#125;</div><div class="line">   public void setRollNo(String rollNo) &#123;</div><div class="line">      this.rollNo = rollNo;</div><div class="line">   &#125;</div><div class="line">   public String getName() &#123;</div><div class="line">      return name;</div><div class="line">   &#125;</div><div class="line">   public void setName(String name) &#123;</div><div class="line">      this.name = name;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建视图。</p>
<p>StudentView.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class StudentView &#123;</div><div class="line">   public void printStudentDetails(String studentName, String studentRollNo)&#123;</div><div class="line">      System.out.println(&quot;Student: &quot;);</div><div class="line">      System.out.println(&quot;Name: &quot; + studentName);</div><div class="line">      System.out.println(&quot;Roll No: &quot; + studentRollNo);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建控制器。</p>
<p>StudentController.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class StudentController &#123;</div><div class="line">   private Student model;</div><div class="line">   private StudentView view;</div><div class="line"></div><div class="line">   public StudentController(Student model, StudentView view)&#123;</div><div class="line">      this.model = model;</div><div class="line">      this.view = view;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setStudentName(String name)&#123;</div><div class="line">      model.setName(name);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getStudentName()&#123;</div><div class="line">      return model.getName();		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setStudentRollNo(String rollNo)&#123;</div><div class="line">      model.setRollNo(rollNo);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getStudentRollNo()&#123;</div><div class="line">      return model.getRollNo();		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void updateView()&#123;				</div><div class="line">      view.printStudentDetails(model.getName(), model.getRollNo());</div><div class="line">   &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 StudentController 方法来演示 MVC 设计模式的用法。</p>
<p>MVCPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class MVCPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      //从数据可获取学生记录</div><div class="line">      Student model  = retriveStudentFromDatabase();</div><div class="line"></div><div class="line">      //创建一个视图：把学生详细信息输出到控制台</div><div class="line">      StudentView view = new StudentView();</div><div class="line"></div><div class="line">      StudentController controller = new StudentController(model, view);</div><div class="line"></div><div class="line">      controller.updateView();</div><div class="line"></div><div class="line">      //更新模型数据</div><div class="line">      controller.setStudentName(&quot;John&quot;);</div><div class="line"></div><div class="line">      controller.updateView();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private static Student retriveStudentFromDatabase()&#123;</div><div class="line">      Student student = new Student();</div><div class="line">      student.setName(&quot;Robert&quot;);</div><div class="line">      student.setRollNo(&quot;10&quot;);</div><div class="line">      return student;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Student: </div><div class="line">Name: Robert</div><div class="line">Roll No: 10</div><div class="line">Student: </div><div class="line">Name: John</div><div class="line">Roll No: 10</div></pre></td></tr></table></figure>
<h2 id="业务代表模式"><a href="#业务代表模式" class="headerlink" title="业务代表模式"></a>业务代表模式</h2><p>业务代表模式（Business Delegate Pattern）用于对表示层和业务层解耦。它基本上是用来减少通信或对表示层代码中的业务层代码的远程查询功能。在业务层中我们有以下实体。<br><strong>客户端（Client）</strong> - 表示层代码可以是 JSP、servlet 或 UI java 代码。<br><strong>业务代表（Business Delegate）</strong> - 一个为客户端实体提供的入口类，它提供了对业务服务方法的访问。<br><strong>查询服务（LookUp Service）</strong> - 查找服务对象负责获取相关的业务实现，并提供业务对象对业务代表对象的访问。<br><strong>业务服务（Business Service）</strong> - 业务服务接口。实现了该业务服务的实体类，提供了实际的业务实现逻辑。<br><strong>实现</strong><br>我们将创建 Client、BusinessDelegate、BusinessService、LookUpService、JMSService 和 EJBService 来表示业务代表模式中的各种实体。<br>BusinessDelegatePatternDemo，我们的演示类使用 BusinessDelegate 和 Client 来演示业务代表模式的用法。<br><img src="设计模式/business_delegate_pattern_uml_diagram.jpg" alt="business_delegate_pattern" title="business_delegate_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建 BusinessService 接口。</p>
<p>BusinessService.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface BusinessService &#123;</div><div class="line">   public void doProcessing();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实体服务类。</p>
<p>EJBService.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class EJBService implements BusinessService &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void doProcessing() &#123;</div><div class="line">      System.out.println(&quot;Processing task by invoking EJB Service&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JMSService.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class JMSService implements BusinessService &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void doProcessing() &#123;</div><div class="line">      System.out.println(&quot;Processing task by invoking JMS Service&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建业务查询服务。</p>
<p>BusinessLookUp.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class BusinessLookUp &#123;</div><div class="line">   public BusinessService getBusinessService(String serviceType)&#123;</div><div class="line">      if(serviceType.equalsIgnoreCase(&quot;EJB&quot;))&#123;</div><div class="line">         return new EJBService();</div><div class="line">      &#125;else &#123;</div><div class="line">         return new JMSService();</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建业务代表。</p>
<p>BusinessDelegate.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class BusinessDelegate &#123;</div><div class="line">   private BusinessLookUp lookupService = new BusinessLookUp();</div><div class="line">   private BusinessService businessService;</div><div class="line">   private String serviceType;</div><div class="line"></div><div class="line">   public void setServiceType(String serviceType)&#123;</div><div class="line">      this.serviceType = serviceType;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void doTask()&#123;</div><div class="line">      businessService = lookupService.getBusinessService(serviceType);</div><div class="line">      businessService.doProcessing();		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>创建客户端。</p>
<p>Client.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">	</div><div class="line">   BusinessDelegate businessService;</div><div class="line"></div><div class="line">   public Client(BusinessDelegate businessService)&#123;</div><div class="line">      this.businessService  = businessService;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void doTask()&#123;		</div><div class="line">      businessService.doTask();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>使用 BusinessDelegate 和 Client 类来演示业务代表模式。</p>
<p>BusinessDelegatePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class BusinessDelegatePatternDemo &#123;</div><div class="line">	</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      BusinessDelegate businessDelegate = new BusinessDelegate();</div><div class="line">      businessDelegate.setServiceType(&quot;EJB&quot;);</div><div class="line"></div><div class="line">      Client client = new Client(businessDelegate);</div><div class="line">      client.doTask();</div><div class="line"></div><div class="line">      businessDelegate.setServiceType(&quot;JMS&quot;);</div><div class="line">      client.doTask();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 7</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Processing task by invoking EJB Service</div><div class="line">Processing task by invoking JMS Service</div></pre></td></tr></table></figure>
<h2 id="组合实体模式"><a href="#组合实体模式" class="headerlink" title="组合实体模式"></a>组合实体模式</h2><p>组合实体模式（Composite Entity Pattern）用在 EJB 持久化机制中。一个组合实体是一个 EJB 实体 bean，代表了对象的图解。当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean 管理的。以下是组合实体 bean 的参与者。<br><strong>组合实体（Composite Entity）</strong> - 它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期。<br><strong>粗粒度对象（Coarse-Grained Object）</strong> - 该对象包含依赖对象。它有自己的生命周期，也能管理依赖对象的生命周期。<br><strong>依赖对象（Dependent Object）</strong> - 依赖对象是一个持续生命周期依赖于粗粒度对象的对象。<br><strong>策略（Strategies）</strong> - 策略表示如何实现组合实体。<br><strong>实现</strong><br>我们将创建作为组合实体的 CompositeEntity 对象。CoarseGrainedObject 是一个包含依赖对象的类。<br>CompositeEntityPatternDemo，我们的演示类使用 Client 类来演示组合实体模式的用法。<br><img src="设计模式/compositeentity_pattern_uml_diagram.jpg" alt="compositeentity_pattern" title="compositeentity_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建依赖对象。</p>
<p>DependentObject1.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class DependentObject1 &#123;</div><div class="line">	</div><div class="line">   private String data;</div><div class="line"></div><div class="line">   public void setData(String data)&#123;</div><div class="line">      this.data = data; </div><div class="line">   &#125; </div><div class="line"></div><div class="line">   public String getData()&#123;</div><div class="line">      return data;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DependentObject2.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class DependentObject2 &#123;</div><div class="line">	</div><div class="line">   private String data;</div><div class="line"></div><div class="line">   public void setData(String data)&#123;</div><div class="line">      this.data = data; </div><div class="line">   &#125; </div><div class="line"></div><div class="line">   public String getData()&#123;</div><div class="line">      return data;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建粗粒度对象。</p>
<p>CoarseGrainedObject.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class CoarseGrainedObject &#123;</div><div class="line">   DependentObject1 do1 = new DependentObject1();</div><div class="line">   DependentObject2 do2 = new DependentObject2();</div><div class="line"></div><div class="line">   public void setData(String data1, String data2)&#123;</div><div class="line">      do1.setData(data1);</div><div class="line">      do2.setData(data2);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String[] getData()&#123;</div><div class="line">      return new String[] &#123;do1.getData(),do2.getData()&#125;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建组合实体。</p>
<p>CompositeEntity.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class CompositeEntity &#123;</div><div class="line">   private CoarseGrainedObject cgo = new CoarseGrainedObject();</div><div class="line"></div><div class="line">   public void setData(String data1, String data2)&#123;</div><div class="line">      cgo.setData(data1, data2);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String[] getData()&#123;</div><div class="line">      return cgo.getData();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建使用组合实体的客户端类。</p>
<p>Client.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">   private CompositeEntity compositeEntity = new CompositeEntity();</div><div class="line"></div><div class="line">   public void printData()&#123;</div><div class="line">      for (int i = 0; i &lt; compositeEntity.getData().length; i++) &#123;</div><div class="line">         System.out.println(&quot;Data: &quot; + compositeEntity.getData()[i]);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setData(String data1, String data2)&#123;</div><div class="line">      compositeEntity.setData(data1, data2);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>使用 Client 来演示组合实体设计模式的用法。</p>
<p>CompositeEntityPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class CompositeEntityPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">       Client client = new Client();</div><div class="line">       client.setData(&quot;Test&quot;, &quot;Data&quot;);</div><div class="line">       client.printData();</div><div class="line">       client.setData(&quot;Second Test&quot;, &quot;Data1&quot;);</div><div class="line">       client.printData();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Data: Test</div><div class="line">Data: Data</div><div class="line">Data: Second Test</div><div class="line">Data: Data1</div></pre></td></tr></table></figure>
<h2 id="数据访问对象模式"><a href="#数据访问对象模式" class="headerlink" title="数据访问对象模式"></a>数据访问对象模式</h2><p>数据访问对象模式（Data Access Object Pattern）或 DAO 模式用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者。<br><strong>数据访问对象接口（Data Access Object Interface）</strong> - 该接口定义了在一个模型对象上要执行的标准操作。<br><strong>数据访问对象实体类（Data Access Object concrete class）</strong> - 该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。<br><strong>模型对象/数值对象（Model Object/Value Object）</strong> - 该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据。<br><strong>实现 </strong><br>我们将创建一个作为模型对象或数值对象的 Student 对象。StudentDao 是数据访问对象接口。StudentDaoImpl 是实现了数据访问对象接口的实体类。DaoPatternDemo，我们的演示类使用 StudentDao 来演示数据访问对象模式的用法。<br><img src="设计模式/dao_pattern_uml_diagram.jpg" alt="dao_pattern" title="dao_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建数值对象。</p>
<p>Student.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class Student &#123;</div><div class="line">   private String name;</div><div class="line">   private int rollNo;</div><div class="line"></div><div class="line">   Student(String name, int rollNo)&#123;</div><div class="line">      this.name = name;</div><div class="line">      this.rollNo = rollNo;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getName() &#123;</div><div class="line">      return name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setName(String name) &#123;</div><div class="line">      this.name = name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public int getRollNo() &#123;</div><div class="line">      return rollNo;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setRollNo(int rollNo) &#123;</div><div class="line">      this.rollNo = rollNo;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建数据访问对象接口。</p>
<p>StudentDao.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public interface StudentDao &#123;</div><div class="line">   public List&lt;Student&gt; getAllStudents();</div><div class="line">   public Student getStudent(int rollNo);</div><div class="line">   public void updateStudent(Student student);</div><div class="line">   public void deleteStudent(Student student);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实现了上述接口的实体类。</p>
<p>StudentDaoImpl.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class StudentDaoImpl implements StudentDao &#123;</div><div class="line">	</div><div class="line">   //列表是当作一个数据库</div><div class="line">   List&lt;Student&gt; students;</div><div class="line"></div><div class="line">   public StudentDaoImpl()&#123;</div><div class="line">      students = new ArrayList&lt;Student&gt;();</div><div class="line">      Student student1 = new Student(&quot;Robert&quot;,0);</div><div class="line">      Student student2 = new Student(&quot;John&quot;,1);</div><div class="line">      students.add(student1);</div><div class="line">      students.add(student2);		</div><div class="line">   &#125;</div><div class="line">   @Override</div><div class="line">   public void deleteStudent(Student student) &#123;</div><div class="line">      students.remove(student.getRollNo());</div><div class="line">      System.out.println(&quot;Student: Roll No &quot; + student.getRollNo() </div><div class="line">         +&quot;, deleted from database&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //从数据库中检索学生名单</div><div class="line">   @Override</div><div class="line">   public List&lt;Student&gt; getAllStudents() &#123;</div><div class="line">      return students;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public Student getStudent(int rollNo) &#123;</div><div class="line">      return students.get(rollNo);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void updateStudent(Student student) &#123;</div><div class="line">      students.get(student.getRollNo()).setName(student.getName());</div><div class="line">      System.out.println(&quot;Student: Roll No &quot; + student.getRollNo() </div><div class="line">         +&quot;, updated in the database&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 StudentDao 来演示数据访问对象模式的用法。</p>
<p>CompositeEntityPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class DaoPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      StudentDao studentDao = new StudentDaoImpl();</div><div class="line"></div><div class="line">      //输出所有的学生</div><div class="line">      for (Student student : studentDao.getAllStudents()) &#123;</div><div class="line">         System.out.println(&quot;Student: [RollNo : &quot;</div><div class="line">            +student.getRollNo()+&quot;, Name : &quot;+student.getName()+&quot; ]&quot;);</div><div class="line">      &#125;</div><div class="line"></div><div class="line"></div><div class="line">      //更新学生</div><div class="line">      Student student =studentDao.getAllStudents().get(0);</div><div class="line">      student.setName(&quot;Michael&quot;);</div><div class="line">      studentDao.updateStudent(student);</div><div class="line"></div><div class="line">      //获取学生</div><div class="line">      studentDao.getStudent(0);</div><div class="line">      System.out.println(&quot;Student: [RollNo : &quot;</div><div class="line">         +student.getRollNo()+&quot;, Name : &quot;+student.getName()+&quot; ]&quot;);		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Student: [RollNo : 0, Name : Robert ]</div><div class="line">Student: [RollNo : 1, Name : John ]</div><div class="line">Student: Roll No 0, updated in the database</div><div class="line">Student: [RollNo : 0, Name : Michael ]</div></pre></td></tr></table></figure>
<h2 id="前端控制器模式"><a href="#前端控制器模式" class="headerlink" title="前端控制器模式"></a>前端控制器模式</h2><p>前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。<br><strong>前端控制器（Front Controller）</strong> - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。<br><strong>调度器（Dispatcher）</strong> - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。<br><strong>视图（View）</strong> - 视图是为请求而创建的对象。<br><strong>实现 </strong><br>我们将创建 FrontController、Dispatcher 分别当作前端控制器和调度器。HomeView 和 StudentView 表示各种为前端控制器接收到的请求而创建的视图。<br>FrontControllerPatternDemo，我们的演示类使用 FrontController 来演示前端控制器设计模式。<br><img src="设计模式/frontcontroller_pattern_uml_diagram.jpg" alt="frontcontroller_pattern" title="frontcontroller_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建视图。</p>
<p>HomeView.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class HomeView &#123;</div><div class="line">   public void show()&#123;</div><div class="line">      System.out.println(&quot;Displaying Home Page&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>StudentView.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class StudentView &#123;</div><div class="line">   public void show()&#123;</div><div class="line">      System.out.println(&quot;Displaying Student Page&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建调度器 Dispatcher。</p>
<p>Dispatcher.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Dispatcher &#123;</div><div class="line">   private StudentView studentView;</div><div class="line">   private HomeView homeView;</div><div class="line">   public Dispatcher()&#123;</div><div class="line">      studentView = new StudentView();</div><div class="line">      homeView = new HomeView();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void dispatch(String request)&#123;</div><div class="line">      if(request.equalsIgnoreCase(&quot;STUDENT&quot;))&#123;</div><div class="line">         studentView.show();</div><div class="line">      &#125;else&#123;</div><div class="line">         homeView.show();</div><div class="line">      &#125;	</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建前端控制器 FrontController。</p>
<p>Context.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class FrontController &#123;</div><div class="line">	</div><div class="line">   private Dispatcher dispatcher;</div><div class="line"></div><div class="line">   public FrontController()&#123;</div><div class="line">      dispatcher = new Dispatcher();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private boolean isAuthenticUser()&#123;</div><div class="line">      System.out.println(&quot;User is authenticated successfully.&quot;);</div><div class="line">      return true;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private void trackRequest(String request)&#123;</div><div class="line">      System.out.println(&quot;Page requested: &quot; + request);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void dispatchRequest(String request)&#123;</div><div class="line">      //记录每一个请求</div><div class="line">      trackRequest(request);</div><div class="line">      //对用户进行身份验证</div><div class="line">      if(isAuthenticUser())&#123;</div><div class="line">         dispatcher.dispatch(request);</div><div class="line">      &#125;	</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 FrontController 来演示前端控制器设计模式。</p>
<p>FrontControllerPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class FrontControllerPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      FrontController frontController = new FrontController();</div><div class="line">      frontController.dispatchRequest(&quot;HOME&quot;);</div><div class="line">      frontController.dispatchRequest(&quot;STUDENT&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Page requested: HOME</div><div class="line">User is authenticated successfully.</div><div class="line">Displaying Home Page</div><div class="line">Page requested: STUDENT</div><div class="line">User is authenticated successfully.</div><div class="line">Displaying Student Page</div></pre></td></tr></table></figure>
<h2 id="拦截过滤器模式"><a href="#拦截过滤器模式" class="headerlink" title="拦截过滤器模式"></a>拦截过滤器模式</h2><p>拦截过滤器模式（Intercepting Filter Pattern）用于对应用程序的请求或响应做一些预处理/后处理。定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上。过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。<br><strong>过滤器（Filter）</strong> - 过滤器在请求处理程序执行请求之前或之后，执行某些任务。<br><strong>过滤器链（Filter Chain）</strong> - 过滤器链带有多个过滤器，并在 Target 上按照定义的顺序执行这些过滤器。<br><strong>Target </strong>- Target 对象是请求处理程序。<br><strong>过滤管理器（Filter Manager）</strong> - 过滤管理器管理过滤器和过滤器链。<br><strong>客户端（Client）</strong> - Client 是向 Target 对象发送请求的对象。<br><strong>实现</strong><br>我们将创建 FilterChain、FilterManager、Target、Client 作为表示实体的各种对象。AuthenticationFilter 和 DebugFilter 表示实体过滤器。<br>InterceptingFilterDemo，我们的演示类使用 Client 来演示拦截过滤器设计模式。<br><img src="设计模式/interceptingfilter_pattern_uml_diagram.jpg" alt="interceptingfilter_pattern" title="interceptingfilter_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建过滤器接口 Filter。</p>
<p>Filter.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Filter &#123;</div><div class="line">   public void execute(String request);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实体过滤器。</p>
<p>AuthenticationFilter.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class AuthenticationFilter implements Filter &#123;</div><div class="line">   public void execute(String request)&#123;</div><div class="line">      System.out.println(&quot;Authenticating request: &quot; + request);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DebugFilter.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class DebugFilter implements Filter &#123;</div><div class="line">   public void execute(String request)&#123;</div><div class="line">      System.out.println(&quot;request log: &quot; + request);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建 Target。</p>
<p>Target.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class Target &#123;</div><div class="line">   public void execute(String request)&#123;</div><div class="line">      System.out.println(&quot;Executing request: &quot; + request);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建过滤器链。</p>
<p>FilterChain.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class FilterChain &#123;</div><div class="line">   private List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;();</div><div class="line">   private Target target;</div><div class="line"></div><div class="line">   public void addFilter(Filter filter)&#123;</div><div class="line">      filters.add(filter);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void execute(String request)&#123;</div><div class="line">      for (Filter filter : filters) &#123;</div><div class="line">         filter.execute(request);</div><div class="line">      &#125;</div><div class="line">      target.execute(request);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setTarget(Target target)&#123;</div><div class="line">      this.target = target;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>创建过滤管理器。</p>
<p>FilterManager.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class FilterManager &#123;</div><div class="line">   FilterChain filterChain;</div><div class="line"></div><div class="line">   public FilterManager(Target target)&#123;</div><div class="line">      filterChain = new FilterChain();</div><div class="line">      filterChain.setTarget(target);</div><div class="line">   &#125;</div><div class="line">   public void setFilter(Filter filter)&#123;</div><div class="line">      filterChain.addFilter(filter);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void filterRequest(String request)&#123;</div><div class="line">      filterChain.execute(request);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>创建客户端 Client。</p>
<p>Client.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">   FilterManager filterManager;</div><div class="line"></div><div class="line">   public void setFilterManager(FilterManager filterManager)&#123;</div><div class="line">      this.filterManager = filterManager;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void sendRequest(String request)&#123;</div><div class="line">      filterManager.filterRequest(request);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 7</strong></p>
<p>使用 Client 来演示拦截过滤器设计模式。</p>
<p>FrontControllerPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class InterceptingFilterDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      FilterManager filterManager = new FilterManager(new Target());</div><div class="line">      filterManager.setFilter(new AuthenticationFilter());</div><div class="line">      filterManager.setFilter(new DebugFilter());</div><div class="line"></div><div class="line">      Client client = new Client();</div><div class="line">      client.setFilterManager(filterManager);</div><div class="line">      client.sendRequest(&quot;HOME&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 8</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Authenticating request: HOME</div><div class="line">request log: HOME</div><div class="line">Executing request: HOME</div></pre></td></tr></table></figure>
<h2 id="服务定位器模式"><a href="#服务定位器模式" class="headerlink" title="服务定位器模式"></a>服务定位器模式</h2><p>服务定位器模式（Service Locator Pattern）用在我们想使用 JNDI 查询定位各种服务的时候。考虑到为某个服务查找 JNDI 的代价很高，服务定位器模式充分利用了缓存技术。在首次请求某个服务时，服务定位器在 JNDI 中查找服务，并缓存该服务对象。当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能。以下是这种设计模式的实体。<br><strong>服务（Service）</strong> - 实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到。<br><strong>Context / 初始的 Context</strong> - JNDI Context 带有对要查找的服务的引用。<br><strong>服务定位器（Service Locator）</strong> - 服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触。<br><strong>缓存（Cache）</strong> - 缓存存储服务的引用，以便复用它们。<br><strong>客户端（Client）</strong> - Client 是通过 ServiceLocator 调用服务的对象。<br><strong>实现</strong><br>我们将创建 ServiceLocator、InitialContext、Cache、Service 作为表示实体的各种对象。Service1 和 Service2 表示实体服务。<br>ServiceLocatorPatternDemo，我们的演示类在这里是作为一个客户端，将使用 ServiceLocator 来演示服务定位器设计模式。<br><img src="设计模式/servicelocator_pattern_uml_diagram.jpg" alt="servicelocator_pattern" title="servicelocator_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建服务接口 Service。</p>
<p>Service.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface Service &#123;</div><div class="line">   public String getName();</div><div class="line">   public void execute();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实体服务。</p>
<p>Service1.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Service1 implements Service &#123;</div><div class="line">   public void execute()&#123;</div><div class="line">      System.out.println(&quot;Executing Service1&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String getName() &#123;</div><div class="line">      return &quot;Service1&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Service2.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Service2 implements Service &#123;</div><div class="line">   public void execute()&#123;</div><div class="line">      System.out.println(&quot;Executing Service2&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String getName() &#123;</div><div class="line">      return &quot;Service2&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>为 JNDI 查询创建 InitialContext。</p>
<p>InitialContext.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class InitialContext &#123;</div><div class="line">   public Object lookup(String jndiName)&#123;</div><div class="line">      if(jndiName.equalsIgnoreCase(&quot;SERVICE1&quot;))&#123;</div><div class="line">         System.out.println(&quot;Looking up and creating a new Service1 object&quot;);</div><div class="line">         return new Service1();</div><div class="line">      &#125;else if (jndiName.equalsIgnoreCase(&quot;SERVICE2&quot;))&#123;</div><div class="line">         System.out.println(&quot;Looking up and creating a new Service2 object&quot;);</div><div class="line">         return new Service2();</div><div class="line">      &#125;</div><div class="line">      return null;		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建缓存 Cache。</p>
<p>Cache.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class Cache &#123;</div><div class="line"></div><div class="line">   private List&lt;Service&gt; services;</div><div class="line"></div><div class="line">   public Cache()&#123;</div><div class="line">      services = new ArrayList&lt;Service&gt;();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public Service getService(String serviceName)&#123;</div><div class="line">      for (Service service : services) &#123;</div><div class="line">         if(service.getName().equalsIgnoreCase(serviceName))&#123;</div><div class="line">            System.out.println(&quot;Returning cached  &quot;+serviceName+&quot; object&quot;);</div><div class="line">            return service;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void addService(Service newService)&#123;</div><div class="line">      boolean exists = false;</div><div class="line">      for (Service service : services) &#123;</div><div class="line">         if(service.getName().equalsIgnoreCase(newService.getName()))&#123;</div><div class="line">            exists = true;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      if(!exists)&#123;</div><div class="line">         services.add(newService);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>创建服务定位器。</p>
<p>ServiceLocator.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class ServiceLocator &#123;</div><div class="line">   private static Cache cache;</div><div class="line"></div><div class="line">   static &#123;</div><div class="line">      cache = new Cache();		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public static Service getService(String jndiName)&#123;</div><div class="line"></div><div class="line">      Service service = cache.getService(jndiName);</div><div class="line"></div><div class="line">      if(service != null)&#123;</div><div class="line">         return service;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      InitialContext context = new InitialContext();</div><div class="line">      Service service1 = (Service)context.lookup(jndiName);</div><div class="line">      cache.addService(service1);</div><div class="line">      return service1;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>使用 ServiceLocator 来演示服务定位器设计模式。</p>
<p>ServiceLocatorPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class ServiceLocatorPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Service service = ServiceLocator.getService(&quot;Service1&quot;);</div><div class="line">      service.execute();</div><div class="line">      service = ServiceLocator.getService(&quot;Service2&quot;);</div><div class="line">      service.execute();</div><div class="line">      service = ServiceLocator.getService(&quot;Service1&quot;);</div><div class="line">      service.execute();</div><div class="line">      service = ServiceLocator.getService(&quot;Service2&quot;);</div><div class="line">      service.execute();		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 7</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Looking up and creating a new Service1 object</div><div class="line">Executing Service1</div><div class="line">Looking up and creating a new Service2 object</div><div class="line">Executing Service2</div><div class="line">Returning cached  Service1 object</div><div class="line">Executing Service1</div><div class="line">Returning cached  Service2 object</div><div class="line">Executing Service2</div></pre></td></tr></table></figure>
<h2 id="传输对象模式"><a href="#传输对象模式" class="headerlink" title="传输对象模式"></a>传输对象模式</h2><p>传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。传输对象也被称为数值对象。传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输。它没有任何的行为。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。<br><strong>业务对象（Business Object）</strong> - 为传输对象填充数据的业务服务。<br><strong>传输对象（Transfer Object）</strong> - 简单的 POJO，只有设置/获取属性的方法。<br><strong>客户端（Client）</strong> - 客户端可以发送请求或者发送传输对象到业务对象。<br><strong>实现</strong><br>我们将创建一个作为业务对象的 StudentBO 和作为传输对象的 StudentVO，它们都代表了我们的实体。<br>TransferObjectPatternDemo，我们的演示类在这里是作为一个客户端，将使用 StudentBO 和 Student 来演示传输对象设计模式。<br><img src="设计模式/transferobject_pattern_uml_diagram.jpg" alt="transferobject_pattern" title="transferobject_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建传输对象。</p>
<p>StudentVO.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class StudentVO &#123;</div><div class="line">   private String name;</div><div class="line">   private int rollNo;</div><div class="line"></div><div class="line">   StudentVO(String name, int rollNo)&#123;</div><div class="line">      this.name = name;</div><div class="line">      this.rollNo = rollNo;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getName() &#123;</div><div class="line">      return name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setName(String name) &#123;</div><div class="line">      this.name = name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public int getRollNo() &#123;</div><div class="line">      return rollNo;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setRollNo(int rollNo) &#123;</div><div class="line">      this.rollNo = rollNo;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建业务对象。</p>
<p>StudentBO.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class StudentBO &#123;</div><div class="line">	</div><div class="line">   //列表是当作一个数据库</div><div class="line">   List&lt;StudentVO&gt; students;</div><div class="line"></div><div class="line">   public StudentBO()&#123;</div><div class="line">      students = new ArrayList&lt;StudentVO&gt;();</div><div class="line">      StudentVO student1 = new StudentVO(&quot;Robert&quot;,0);</div><div class="line">      StudentVO student2 = new StudentVO(&quot;John&quot;,1);</div><div class="line">      students.add(student1);</div><div class="line">      students.add(student2);		</div><div class="line">   &#125;</div><div class="line">   public void deleteStudent(StudentVO student) &#123;</div><div class="line">      students.remove(student.getRollNo());</div><div class="line">      System.out.println(&quot;Student: Roll No &quot; </div><div class="line">      + student.getRollNo() +&quot;, deleted from database&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //从数据库中检索学生名单</div><div class="line">   public List&lt;StudentVO&gt; getAllStudents() &#123;</div><div class="line">      return students;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public StudentVO getStudent(int rollNo) &#123;</div><div class="line">      return students.get(rollNo);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void updateStudent(StudentVO student) &#123;</div><div class="line">      students.get(student.getRollNo()).setName(student.getName());</div><div class="line">      System.out.println(&quot;Student: Roll No &quot; </div><div class="line">      + student.getRollNo() +&quot;, updated in the database&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>使用 StudentBO 来演示传输对象设计模式。</p>
<p>TransferObjectPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class TransferObjectPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      StudentBO studentBusinessObject = new StudentBO();</div><div class="line"></div><div class="line">      //输出所有的学生</div><div class="line">      for (StudentVO student : studentBusinessObject.getAllStudents()) &#123;</div><div class="line">         System.out.println(&quot;Student: [RollNo : &quot;</div><div class="line">         +student.getRollNo()+&quot;, Name : &quot;+student.getName()+&quot; ]&quot;);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      //更新学生</div><div class="line">      StudentVO student =studentBusinessObject.getAllStudents().get(0);</div><div class="line">      student.setName(&quot;Michael&quot;);</div><div class="line">      studentBusinessObject.updateStudent(student);</div><div class="line"></div><div class="line">      //获取学生</div><div class="line">      studentBusinessObject.getStudent(0);</div><div class="line">      System.out.println(&quot;Student: [RollNo : &quot;</div><div class="line">      +student.getRollNo()+&quot;, Name : &quot;+student.getName()+&quot; ]&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Student: [RollNo : 0, Name : Robert ]</div><div class="line">Student: [RollNo : 1, Name : John ]</div><div class="line">Student: Roll No 0, updated in the database</div><div class="line">Student: [RollNo : 0, Name : Michael ]</div></pre></td></tr></table></figure>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p>本章列出了设计模式相关的网站、书籍和文章。</p>
<p><strong>设计模式相关的网站</strong></p>
<p><a href="http://en.wikipedia.org/wiki/Design_pattern_(computer_science" target="_blank" rel="external"><font color="#0366d6">Wiki Page for Design Patterns</font></a>) - 以一种非常通用的方式检查设计模式。<br><a href="http://en.wikibooks.org/wiki/Java_Programming/Design_Patterns" target="_blank" rel="external"><font color="#0366d6">Java Programming/Design Patterns</font></a> - 一篇关于设计模式的好文章。<br><a href="http://java.sun.com/docs/books/tutorial/index.html" target="_blank" rel="external"><font color="#0366d6">The JavaTM Tutorials</font></a> - 该 Java 教程是为那些想用 Java 编程语言创建应用程序的编程人员提供的实用指南。<br><a href="http://java.sun.com/j2se/1.4.2/docs/index.html" target="_blank" rel="external"><font color="#0366d6">JavaTM 2 SDK, Standard Edition</font></a> - JavaTM 2 SDK, Standard Edition 的官网。<br><a href="http://exciton.cs.rice.edu/javaresources/DesignPatterns/" target="_blank" rel="external"><font color="#0366d6">Java DesignPatterns</font></a> - 关于设计模式的短文。</p>
<p><strong>Java 设计模式有用的书籍</strong><br>Java Design Patterns<br>Head First Design Patterns<br>Java Design Pattern Essentials<br>Design Patterns: Elements of Reusable Object-Oriented Software<br>Design Patterns in Java(TM)<br>Design Patterns Java Workbook </p>
<p><a href="http://www.runoob.com/design-pattern/design-pattern-tutorial.html" target="_blank" rel="external"><font color="#0366d6">原文地址</font></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;设计模式/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;设计模式简介&lt;/strong&gt;&lt;br&gt;设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 &lt;/p&gt;
&lt;p&gt;设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://jethan.bid/categories/java/"/>
    
      <category term="设计模式" scheme="http://jethan.bid/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Singleton Pattern" scheme="http://jethan.bid/tags/Singleton-Pattern/"/>
    
      <category term="Factory Pattern" scheme="http://jethan.bid/tags/Factory-Pattern/"/>
    
      <category term="Proxy Pattern" scheme="http://jethan.bid/tags/Proxy-Pattern/"/>
    
      <category term="MVC Pattern" scheme="http://jethan.bid/tags/MVC-Pattern/"/>
    
      <category term="Intercepting Filter Pattern" scheme="http://jethan.bid/tags/Intercepting-Filter-Pattern/"/>
    
      <category term="Iterator Pattern" scheme="http://jethan.bid/tags/Iterator-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>mysql数据库引擎</title>
    <link href="http://jethan.bid/2017/08/06/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E/"/>
    <id>http://jethan.bid/2017/08/06/mysql数据库引擎/</id>
    <published>2017-08-06T06:16:24.000Z</published>
    <updated>2017-08-06T06:16:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/mysql.jpg" alt="mysql" title="mysql"></p>
<h2 id="数据库引擎"><a href="#数据库引擎" class="headerlink" title="数据库引擎"></a>数据库引擎</h2><p>　　数据库引擎是用于存储、处理和保护数据的核心服务。利用数据库引擎可控制访问权限并快速处理事务，从而满足企业内大多数需要处理大量数据的应用程序的要求。 使用数据库引擎创建用于联机事务处理或联机分析处理数据的关系数据库。这包括创建用于存储数据的表和用于查看、管理和保护数据安全的数据库对象（如索引、视图和存储过程）。</p>
<h2 id="数据库引擎任务"><a href="#数据库引擎任务" class="headerlink" title="数据库引擎任务"></a>数据库引擎任务</h2><p>在数据库引擎文档中，各主题的顺序遵循用于实现使用数据库引擎进行数据存储的系统的任务的主要顺序。</p>
<p>设计并创建数据库以保存系统所需的关系或XML文档<br>实现系统以访问和更改数据库中存储的数据。包括实现网站或使用数据的应用程序，还包括生成使用SQL Server工具和实用工具以使用数据的过程。<br>为单位或客户部署实现的系统<br>提供日常管理支持以优化数据库的性能<br><a id="more"></a></p>
<h2 id="MySQL数据库引擎类别"><a href="#MySQL数据库引擎类别" class="headerlink" title="MySQL数据库引擎类别"></a>MySQL数据库引擎类别</h2><p>　　你能用的数据库引擎取决于mysql在安装的时候是如何被编译的。要添加一个新的引擎，就必须重新编译MYSQL。在缺省情况下，MYSQL支持三个引擎：ISAM、MYISAM和HEAP。另外两种类型INNODB和BERKLEY（BDB），也常常可以使用。</p>
<h3 id="ISAM"><a href="#ISAM" class="headerlink" title="ISAM"></a>ISAM</h3><p>　　ISAM是一个定义明确且历经时间考验的数据表格管理方法，它在设计之时就考虑到数据库被查询的次数要远大于更新的次数。因此，ISAM执行读取操作的速度很快，而且不占用大量的内存和存储资源。ISAM的两个主要不足之处在于，它不支持事务处理，也不能够容错：如果你的硬盘崩溃了，那么数据文件就无法恢复了。如果你正在把ISAM用在关键任务应用程序里，那就必须经常备份你所有的实时数据，通过其复制特性，MYSQL能够支持这样的备份应用程序。</p>
<h3 id="MYISAM"><a href="#MYISAM" class="headerlink" title="MYISAM"></a>MYISAM</h3><p>　　MYISAM是MYSQL的ISAM扩展格式和缺省的数据库引擎。除了提供ISAM里所没有的索引和字段管理的功能，MYISAM还使用一种表格锁定的机制，来优化多个并发的读写操作。其代价是你需要经常运行OPTIMIZE TABLE命令，来恢复被更新机制所浪费的空间。MYISAM还有一些有用的扩展，例如用来修复数据库文件的MYISAMCHK工具和用来恢复浪费空间的MYISAMPACK工具。<br>　　MYISAM强调了快速读取操作，这可能就是为什么MYSQL受到了WEB开发如此青睐的主要原因：在WEB开发中你所进行的大量数据操作都是读取操作。所以，大多数虚拟主机提供商和INTERNET平台提供商只允许使用MYISAM格式。</p>
<h3 id="HEAP"><a href="#HEAP" class="headerlink" title="HEAP"></a>HEAP</h3><p>　　HEAP允许只驻留在内存里的临时表格。驻留在内存里让HEAP要比ISAM和MYISAM都快，但是它所管理的数据是不稳定的，而且如果在关机之前没有进行保存，那么所有的数据都会丢失。在数据行被删除的时候，HEAP也不会浪费大量的空间。HEAP表格在你需要使用SELECT表达式来选择和操控数据的时候非常有用。要记住，在用完表格之后就删除表格。</p>
<h3 id="INNODB和BERKLEYDB"><a href="#INNODB和BERKLEYDB" class="headerlink" title="INNODB和BERKLEYDB"></a>INNODB和BERKLEYDB</h3><p>　　INNODB和BERKLEYDB（BDB）数据库引擎都是造就MYSQL灵活性的技术的直接产品，这项技术就是MYSQL++ API。在使用MYSQL的时候，你所面对的每一个挑战几乎都源于ISAM和MYISAM数据库引擎不支持事务处理也不支持外来键。尽管要比ISAM和MYISAM引擎慢很多，但是INNODB和BDB包括了对事务处理和外来键的支持，这两点都是前两个引擎所没有的。如前所述，如果你的设计需要这些特性中的一者或者两者，那你就要被迫使用后两个引擎中的一个了。</p>
<h2 id="mysql数据引擎更换方式"><a href="#mysql数据引擎更换方式" class="headerlink" title="mysql数据引擎更换方式"></a>mysql数据引擎更换方式</h2><h3 id="查看当前数据库支持的引擎和默认的数据库引擎"><a href="#查看当前数据库支持的引擎和默认的数据库引擎" class="headerlink" title="查看当前数据库支持的引擎和默认的数据库引擎"></a>查看当前数据库支持的引擎和默认的数据库引擎</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show engines;</div></pre></td></tr></table></figure>
<p>我的查询结果如下：</p>
<p><img src="mysql数据库引擎/mysql_engines.png" alt="mysql" title="mysql"></p>
<h3 id="更改数据库引擎"><a href="#更改数据库引擎" class="headerlink" title="更改数据库引擎"></a>更改数据库引擎</h3><h4 id="更改方式1：修改配置文件my-ini"><a href="#更改方式1：修改配置文件my-ini" class="headerlink" title="更改方式1：修改配置文件my.ini"></a>更改方式1：修改配置文件my.ini</h4><p>修改<code>my.ini</code>，在<code>[mysqld]</code>后面添加<code>default-storage-engine=InnoDB</code>，重启服务，数据库默认的引擎修改为<code>InnoDB</code></p>
<h4 id="更改方式2-在建表的时候指定"><a href="#更改方式2-在建表的时候指定" class="headerlink" title="更改方式2:在建表的时候指定"></a>更改方式2:在建表的时候指定</h4><p> 建表时指定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">create table mytbl(   </div><div class="line">    id int primary key,   </div><div class="line">    name varchar(50)   </div><div class="line">)type=MyISAM;</div></pre></td></tr></table></figure>
<h4 id="更改方式3：建表后更改"><a href="#更改方式3：建表后更改" class="headerlink" title="更改方式3：建表后更改"></a>更改方式3：建表后更改</h4><p>　　<code>alter table mytbl2 type = InnoDB;</code></p>
<h3 id="查看修改结果"><a href="#查看修改结果" class="headerlink" title="查看修改结果"></a>查看修改结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#方式1：</div><div class="line">show table status from mytest; </div><div class="line">#方式2：</div><div class="line">show create table table_name</div></pre></td></tr></table></figure>
<h2 id="MyIASM-和-Innodb引擎详解"><a href="#MyIASM-和-Innodb引擎详解" class="headerlink" title="MyIASM 和 Innodb引擎详解"></a>MyIASM 和 Innodb引擎详解</h2><h3 id="Innodb引擎"><a href="#Innodb引擎" class="headerlink" title="Innodb引擎"></a>Innodb引擎</h3><p>　　Innodb引擎提供了对数据库<strong>ACID事务的支持</strong>，并且实现了SQL标准的四种隔离级别，关于数据库事务与其隔离级别的内容请见<a href="http://jet-han.oschina.io/2017/08/04/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/" target="_blank" rel="external">数据库事务与其隔离级别</a>。该引擎还提供了<strong>行级锁和外键约束</strong>，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持<code>FULLTEXT</code>类型的索引，而且它没有保存表的行数，当<code>SELECT COUNT(*) FROM TABLE</code>时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用<code>Innodb</code>引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。</p>
<h4 id="内存结构和特性"><a href="#内存结构和特性" class="headerlink" title="内存结构和特性"></a>内存结构和特性</h4><p>　　MySQL区别于其他数据库的最为重要的特点就是其插件式的表存储引擎。而在众多存储引擎中，InnoDB是最为常用的存储引擎。从MySQL5.5.8版本开始，InnoDB存储引擎是默认的存储引擎。<br>　　InnoDB存储引擎支持事务，其设计目标主要面向在线事务处理(OLTP)的应用。其特点是行锁设计、支持外键，并支持非锁定读，即默认读操作不会产生锁。<br>　　InnoDB通过使用多版本并发控制(MVCC)来获取高并发性，并且实现了SQL标准的4中隔离级别，默认为REPEATABLE级别。同时，使用一种被称为next-key-locking的策略来避免幻读现象的产生。除此之外，InnoDB存储引擎还提供了插入缓冲(insert buffer)、二次写(double write)、自适应哈希索引(adaptive hash index)、预读(read ahead)等高性能和高可用的功能。</p>
<p><img src="mysql数据库引擎/innodb1.png" alt="mysql" title="mysql"></p>
<p>上图详细显示了InnoDB存储引擎的体系架构，从图中可见，InnoDB存储引擎由内存池，后台线程和磁盘文件三大部分组成。接下来我们就来简单了解一下内存相关的概念和原理。</p>
<p><strong>缓冲池</strong>  </p>
<p> InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。但是由于CPU速度和磁盘速度之间的鸿沟，基于磁盘的数据库系统通常使用缓冲池记录来提高数据库的的整体性能。<br> 在数据库中进行读取操作，首先将从磁盘中读到的页放在缓冲池中，下次再读相同的页中时，首先判断该页是否在缓冲池中。若在缓冲池中，称该页在缓冲池中被命中，直接读取该页。否则，读取磁盘上的页。<br> 对于数据库中页的修改操作，则首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，而是通过一种称为CheckPoint的机制刷新回磁盘。<br> 所以，缓冲池的大小直接影响着数据库的整体性能，可以通过配置参数innodb_buffer_pool_size来设置。<br> 具体来看，缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲(insert buffer)、自适应哈希索引(adaptive hash index)、InnoDB存储的锁信息(lock info)和数据字典信息(data dictionary)。<br> 在架构图上可以看到，InnoDB存储引擎的内存区域除了有缓冲池之外，还有重做日志缓冲和额外内存池。InnoDB存储引擎首先将重做日志信息先放到这个缓冲区中，然后按照一定频率将其刷新到重做日志文件中。重做日志缓冲一般不需要设置的很大，该值可由配置参数innodb_log_buffer_size控制。   </p>
<p><strong>数据页和索引页</strong>  </p>
<p> Page是Innodb存储的最基本结构，也是Innodb磁盘管理的最小单位，与数据库相关的所有内容都存储在Page结构里。Page分为几种类型，数据页和索引页就是其中最为重要的两种类型。</p>
<p><strong>插入缓冲(Insert Buffer)</strong>  </p>
<p> 我们都知道，在InnoDB引擎上进行插入操作时，一般需要按照主键顺序进行插入，这样才能获得较高的插入性能。当一张表中存在非聚簇的且不唯一的索引时，在插入时，数据页的存放还是按照主键进行顺序存放，但是对于非聚簇索引叶节点的插入不再是顺序的了，这时就需要离散的访问非聚簇索引页，由于随机读取的存在导致插入操作性能下降。<br> InnoDB为此设计了Insert Buffer来进行插入优化。对于非聚簇索引的插入或者更新操作，不是每一次都直接插入到索引页中，而是先判断插入的非聚集索引是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer中。看似数据库这个非聚集的索引已经查到叶节点，而实际没有，这时存放在另外一个位置。然后再以一定的频率和情况进行Insert Buffer和非聚簇索引页子节点的合并操作。这时通常能够将多个插入合并到一个操作中，这样就大大提高了对于非聚簇索引的插入性能。  </p>
<p><strong>两次写(Double Write)</strong>  </p>
<p> 如果说Insert Buffer给InnoDB存储引擎带来了性能上的提升，那么Double Write带给InnoDB存储引擎的是数据页的可靠性。</p>
<p> <img src="mysql数据库引擎/innodb2.png" alt="mysql" title="mysql"></p>
<p> 如上图所示，Double Write由两部分组成，一部分是内存中的double write buffer，大小为2MB，另一部分是物理磁盘上共享表空间连续的128个页，大小也为2MB。在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是通过memcpy函数将脏页先复制到内存中的该区域，之后通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免操作系统缓冲写带来的问题。在完成doublewrite页的写入后，再讲doublewirite buffer中的页写入各个表空间文件中。<br> 如果操作系统在将页写入磁盘的过程中发生了崩溃，在恢复过程中，InnoDB存储引擎可以从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件中，再应用重做日志。 </p>
<p><strong>重做日志(Redo Log Buffer)</strong>  </p>
<p> 当缓冲池中的页的版本比磁盘要新时，数据库需要将新版本的页从缓冲池刷新到磁盘。但是如果每次一个页发送变化，就进行刷新，那么性能开发是非常大的，于是InnoDB采用了Write Ahead Log策略，即当事务提交时，先写重做日志，然后再择时将脏页写入磁盘。如果发生宕机导致数据丢失，就通过重做日志进行数据恢复。  </p>
<p> <img src="mysql数据库引擎/innodb3.png" alt="mysql" title="mysql"></p>
<p> InnoDB存储引擎会首先将重做日志信息先放入重做日志缓冲中，然后再按照一定频率将其刷新到重做日志文件。重做日志缓冲一般不需要设置得很大，因为一般情况每一秒钟都会讲重做日志缓冲刷新到日志文件中。可通过配置参数innodb_log_buffer_size控制，默认为8MB。<br> 除了每秒刷新机制之外，每次事务提交时重做日志缓冲也会刷新到日志中。InnoDB是事务的存储引擎，其通过Force Log at Commit机制实现事务的持久性，即当事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化，然后事务的提交操作完成才算完成。InnoDB的写入机制大致入下图所示。<br> 为了确保每次日志都写入到重做日志文件，在每次讲重做日志缓冲写入重做日志后，必须调用一次fsync操作，将缓冲文件从文件系统缓存中真正写入磁盘。<br> 可以通过innodb_flush_log_at_trx_commit来控制重做日志刷新到磁盘的策略。该参数默认值为1，表示事务提交必须进行一次fsync操作，还可以设置为0和2。0表示事务提交时不进行写入重做日志操作，该操作只在主线程中完成，2表示提交时写入重做日志，但是只写入文件系统缓存，不进行fsync操作。由此可见，设置为0时，性能最高，但是丧失了事务的一致性。 </p>
<p><strong>自适应哈希索引(Adaptive Hash Index)</strong>  </p>
<p> InnoDB会根据访问的频率和模式，为热点页建立哈希索引，来提高查询效率。InnoDB存储引擎会监控对表上各个索引页的查询，如果观察到建立哈希索引可以带来速度上的提升，则建立哈希索引，所以叫做自适应哈希索引。</p>
<p> 自适应哈希索引是通过缓冲池的B+树页构建而来，因此建立速度很快，而且不需要对整张数据表建立哈希索引。其有一个要求，即对这个页的连续访问模式必须是一样的，也就是说其查询的条件(WHERE)必须完全一样，而且必须是连续的。  </p>
<p><strong>锁信息(lock info)</strong></p>
<p> 我们都知道，InnoDB存储引擎会在行级别上对表数据进行上锁。不过InnoDB也会在数据库内部其他很多地方使用锁，从而允许对多种不同资源提供并发访问。数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。关于锁的具体知识我们之后再进行详细学习。 </p>
<p><strong>数据字典信息(Data Dictionary)</strong></p>
<p> InnoDB有自己的表缓存，可以称为表定义缓存或者数据字典。当InnoDB打开一张表，就增加一个对应的对象到数据字典。<br> 数据字典是对数据库中的数据、库对象、表对象等的元信息的集合。在MySQL中，数据字典信息内容就包括表结构、数据库名或表名、字段的数据类型、视图、索引、表字段信息、存储过程、触发器等内容。MySQL INFORMATION_SCHEMA库提供了对数据局元数据、统计信息、以及有关MySQL server的访问信息（例如：数据库名或表名，字段的数据类型和访问权限等）。该库中保存的信息也可以称为MySQL的数据字典。   </p>
<h4 id="磁盘文件及落盘机制"><a href="#磁盘文件及落盘机制" class="headerlink" title="磁盘文件及落盘机制"></a>磁盘文件及落盘机制</h4><p>任何一个技术都有其底层的关键基础技术，这些关键技术很有可能也是其他技术的关键技术，学习这些底层技术，就可以一通百通，让你很快的掌握其他技术。如何在磁盘上存储数据，如何使用日志文件保证数据不丢失以及如何落盘，不仅是MySQL等数据库的关键技术，也是MQ消息队列或者其他中间件的关键技术之一。</p>
<p> <img src="mysql数据库引擎/innodb4.png" alt="mysql" title="mysql"></p>
<p> 上图详细显示了InnoDB存储引擎的体系架构，从图中可见，InnoDB存储引擎由内存池，后台线程和磁盘文件三大部分组成。接下来我们就来简单了解一下磁盘文件相关的概念和原理。<br>    InnoDB的主要的磁盘文件主要分为三大块：一是系统表空间，二是用户表空间，三是redo日志文件和归档文件。二进制文件(binlog)等文件是MySQL Server层维护的文件，所以未列入InnoDB的磁盘文件中。  </p>
<p><strong>系统表空间和用户表空间</strong>  </p>
<p> InnoDB系统表空间包含InnoDB数据字典(元数据以及相关对象)并且doublewrite buffer,change buffer,undo logs的存储区域。系统表空间也默认包含任何用户在系统表空间创建的表数据和索引数据。系统表空间是一个共享的表空间因为它是被多个表共享的<br> 系统表空间是由一个或者多个数据文件组成。默认情况下,1个初始大小为10MB，名为ibdata1的系统数据文件在MySQL的data目录下被创建。用户可以使用innodb_data_file_path对数据文件的大小和数量进行配置。<br> innodb_data_file_path的格式如下：</p>
<pre><code>  innodb_data_file_path=datafile1[,datafile2]...
</code></pre><p> 用户可以通过多个文件组成一个表空间，同时制定文件的属性：</p>
<pre><code>  innodb_data_file_path = /db/ibdata1:1000M;/dr2/db/ibdata2:1000M:autoextend
</code></pre><p> 这里讲/db/ibdata1和/dr2/db/ibdata2两个文件组成系统表空间。如果这两个文件位于不同的磁盘上，磁盘的负载可能被平均，因此可以提高数据库的整体性能。两个文件的文件名之后都跟了属性，表示文件ibdata1的大小为1000MB，文件ibdata2的大小为1000MB，而且用完空间之后可以自动增长(autoextend)。</p>
<p> 设置innodb_data_file_path参数之后，所以基于InnoDB存储引擎的表的数据都会记录到该系统表空间中，如果设置了参数innodb_file_per_table，则用户可以将每个基于InnoDB存储引擎的表产生一个独立的用户表空间。用户表空间的命名规则为：表名.ibd。<br> 通过这种方式，用户不用将所有数据都存放于默认的系统表空间中，但是用户表空只存储该表的数据、索引和插入缓冲BITMAP等信息，其余信息还是存放在默认的表空间中。</p>
<p> <img src="mysql数据库引擎/innodb5.png" alt="mysql" title="mysql"></p>
<p> 上图显示InnoDB存储引擎对于文件的存储方式，其中frm文件是表结构定义文件，记录每个表的表结构定义。  </p>
<p><strong>重做日志文件和归档文件</strong>  </p>
<p> 默认情况下，在InnoDB存储引擎的数据目录下会有两个名为ib_logfile0和ib_logfile1的文件，这就是InnoDB的重做日志文件(redo log fiel)，它记录了对于InnoDB存储引擎的事务日志。<br> 当InnoDB的数据存储文件发生错误时，重做日志文件就能派上用场。InnoDB存储引擎可以使用重做日志文件将数据恢复为正确状态，以此来保证数据的正确性和完整性。</p>
<p> 每个InnoDB存储引擎至少有1个重做日志文件组(group)，每个文件组下至少有2个重做日志文件，如默认的ib_logfile0和ib_logfile1。<br> 为了得到更高的可靠性，用户可以设置多个镜像日志组，将不同的文件组放在不同的磁盘上，以此来提高重做日志的高可用性。</p>
<p> 在日志组中每个重做日志文件的大小一致，并以循环写入的方式运行。InnoDB存储引擎先写入重做日志文件1，当文件被写满时，会切换到重做日志文件2，再当重做日志文件2也被写满时，再切换到重做日志文件1。</p>
<p> 用户可以使用innodb_log_file_size来设置重做日志文件的大小，这对InnoDB存储引擎的性能有着非常大的影响。</p>
<p> 如果重做日志文件设置的太大，数据丢失时，恢复时可能需要很长的时间；另一方面，如果设置的太小，重做日志文件太小会导致依据checkpoint的检查需要频繁刷新脏页到磁盘中，导致性能的抖动。<br> 重做日志相关和Checkpoint的机制可以阅读我之前文章的相应章节。MySQL探秘(三):InnoDB的内存结构和特性</p>
<p><strong>重做日志的落盘机制</strong>  </p>
<p> InnoDB对于数据文件和日志文件的刷盘遵守WAL(Write ahead redo log) 和Force-log-at-commit两种规则，二者保证了事务的持久性。WAL要求数据的变更写入到磁盘前，首先必须将内存中的日志写入到磁盘；Force-log-at-commit要求当一个事务提交时，所有产生的日志都必须刷新到磁盘上，如果日志刷新成功后，缓冲池中的数据刷新到磁盘前数据库发生了宕机，那么重启时，数据库可以从日志中恢复数据。</p>
<p>  <img src="mysql数据库引擎/innodb6.png" alt="mysql" title="mysql"></p>
<p>如上图所示，InnoDB在缓冲池中变更数据时，会首先将相关变更写入重做日志缓冲中，然后再按时或者当事务提交时写入磁盘，这符合Force-log-at-commit原则；当重做日志写入磁盘后，缓冲池中的变更数据才会依据checkpoint机制择时写入到磁盘中，这符合WAL原则。<br> 在checkpoint择时机制中，就有重做日志文件写满的判断，所以，如前文所述，如果重做日志文件太小，经常被写满，就会频繁导致checkpoint将更改的数据写入磁盘，导致性能抖动。</p>
<p> 操作系统的文件系统是带有缓存的，当InnoDB向磁盘写入数据时，有可能只是写入到了文件系统的缓存中，没有真正的“落袋为安”。<br> InnoDB的innodb_flush_log_at_trx_commit属性可以控制每次事务提交时InnoDB的行为。当属性值为0时，事务提交时，不会对重做日志进行写入操作，而是等待主线程按时写入；当属性值为1时，事务提交时，会将重做日志写入文件系统缓存，并且调用文件系统的fsync，将文件系统缓冲中的数据真正写入磁盘存储，确保不会出现数据丢失；当属性值为2时，事务提交时，也会将日志文件写入文件系统缓存，但是不会调用fsync，而是让文件系统自己去判断何时将缓存写入磁盘。日志的刷盘机制如下图所示。</p>
<p>   <img src="mysql数据库引擎/innodb7.png" alt="mysql" title="mysql"></p>
<p> innodb_flush_log_at_commit是InnoDB性能调优的一个基础参数，涉及InnoDB的写入效率和数据安全。当参数值为0时，写入效率最高，但是数据安全最低；参数值为1时，写入效率最低，但是数据安全最高；参数值为2时，二者都是中等水平。一般建议将该属性值设置为1，以获得较高的数据安全性，而且也只有设置为1，才能保证事务的持久性。  </p>
<h4 id="锁的类型和状态查询"><a href="#锁的类型和状态查询" class="headerlink" title="锁的类型和状态查询"></a>锁的类型和状态查询</h4><p>锁是数据库系统区分于文件系统的一个关键特性。数据库使用锁来支持对共享资源进行并发访问，提供数据的完整性和一致性。此外，数据库事务的隔离性也是通过锁实现的。InnoDB在此方面一直优于其他数据库引擎。InnoDB会在行级别上对表数据上锁，而MyISAM只能在表级别上锁，二者性能差异可想而知。</p>
<p>InnoDB存储引擎中的锁<br> InnoDB存储引擎实现了如下两种标准的行级锁：</p>
<p>共享锁(S Lock)，允许事务读取一行</p>
<p>排他锁(X Lock)，允许事务删除或更新一行数据</p>
<p>  如果一个事务T1已经获取了行r的共享锁，那么另外一个事务T2可以立刻获得行r的共享锁，因为读取并不会改变数据，可以进行并发的读取操作；但若其他的事务T3想要获取行r的排他锁，则必须等待事务T1和T2释放行r上的共享锁之后才能继续，因为获取排他锁一般是为了改变数据，所以不能同时进行读取或则其他写入操作。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">X</th>
<th style="text-align:center">S</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">不兼容</td>
<td style="text-align:center">不兼容</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">不兼容</td>
<td style="text-align:center">兼容</td>
</tr>
</tbody>
</table>
</div>
<p> InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种称为意向锁的锁方式。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。</p>
<p> InnoDB存储引擎的意向锁即为表级别的锁。设计目的主要是为了在一个事务中揭示下一行将被请求的锁类型。其支持两种意向锁：</p>
<ul>
<li>意向共享锁(IS Lock)，事务想要获得一张表中某几行的共享锁</li>
<li>意向排他锁(IX Lock)，事务想要获得一张表中某几行的排他锁</li>
</ul>
<p>需要注意的是意向锁是表级别的锁，它不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。故表级别的意向锁和表级别的锁的兼容性如下表所示。  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">IS</th>
<th style="text-align:center">IX</th>
<th style="text-align:center">S</th>
<th>X</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IS</td>
<td style="text-align:center">兼容</td>
<td style="text-align:center">兼容</td>
<td style="text-align:center">兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td style="text-align:center">IX</td>
<td style="text-align:center">兼容</td>
<td style="text-align:center">兼容</td>
<td style="text-align:center">不兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">兼容</td>
<td style="text-align:center">不兼容</td>
<td style="text-align:center">兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">不兼容</td>
<td style="text-align:center">不兼容</td>
<td style="text-align:center">不兼容</td>
<td>不兼容</td>
</tr>
</tbody>
</table>
</div>
<p> 向一个表添加表级X锁的时候(执行ALTER TABLE, DROP TABLE, LOCK TABLES等操作)，如果没有意向锁的话，则需要遍历所有整个表判断是否有行锁的存在，以免发生冲突。如果有了意向锁，只需要判断该意向锁与即将添加的表级锁是否兼容即可。因为意向锁的存在代表了，有行级锁的存在或者即将有行级锁的存在，因而无需遍历整个表，即可获取结果。</p>
<p> <img src="mysql数据库引擎/innodb8.png" alt="mysql" title="mysql"></p>
<p> 如果将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象进行上锁，那么首先需要对粗粒度的对象上锁。如上图所示，如果需要对表1的记录m行上X锁，那么需要先对表1加意向IX锁，然后对记录m上X锁。如果其中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成。</p>
<p>InnoDB锁相关状态查询<br> 用户可以使用INFOMATION_SCHEMA库下的INNODB_TRX、INNODB_LOCKS和INNODB_LOCK_WAITS表来监控当前事务并分析可能出现的锁问题。INNODB_TRX的定义如下表所示，其由8个字段组成。</p>
<ul>
<li>trx_id：InnoDB存储引擎内部唯一的事务ID</li>
<li>trx_state：当前事务的状态</li>
<li>trx_started：事务的开始时间</li>
<li>trx_request_lock_id：等待事务的锁ID。如果trx_state的状态为LOCK WAIT,那么该字段代表当前事务等待之前事务占用的锁资源ID</li>
<li>trx_wait_started：事务等待的时间</li>
<li>trx_weight：事务的权重，反映了一个事务修改和锁住的行数，当发生死锁需要回滚时，会选择该数值最小的进行回滚</li>
<li>trx_mysql_thread_id：线程ID，SHOW PROCESSLIST 显示的结果</li>
<li>trx_query：事务运行的SQL语句</li>
</ul>
<pre><code>mysql&gt; SELECT * FROM information_schema.INNODB_TRX\G;    
************** 1.row ***********************     
trx_id:  7311F4  
trx_state: LOCK WAIT  
trx_started: 2010-01-04 10:49:33  
trx_requested_lock_id: 7311F4:96:3:2  
trx_wait_started: 2010-01-04 10:49:33  
trx_weight: 2  
trx_mysql_thread_id: 471719  
trx_query: select * from parent lock in share mode    
</code></pre><p> INNODB_TRX表只能显示当前运行的InnoDB事务，并不能直接判断锁的一些情况。如果需要查看锁，则还需要访问表INNODB_LOCKS，该表的字段组成如下表所示。</p>
<ul>
<li>lock_id：锁的ID</li>
<li>lock_trx_id：事务的ID</li>
<li>lock_mode：锁的模式</li>
<li>lock_type：锁的类型，表锁还是行锁</li>
<li>lock_table：要加锁的表</li>
<li>lock_index：锁住的索引</li>
<li>lock_space：锁住的space id</li>
<li>lock_page：事务锁定页的数量，若是表锁，则该值为NULL</li>
<li>lock_rec：事务锁定行的数量，如果是表锁，则该值为NULL</li>
<li>lock_data：</li>
</ul>
<pre><code>  mysql&gt; SELECT * FROM information_schema.INNODB_LOCKS\G;
  ***************** 1.row ***********************
  lock_id: 7311F4:96:3:2
  lock_trx_id: 7311F4
  lock_mode: S
  lock_type: RECORD
  lock_type: &#39;mytest&#39;.&#39;parent&#39;
  lock_index: &#39;PRIMARY&#39;
  lock_space: 96
  lock_page: 3
  lock_rec: 2
  lock_data: 1
</code></pre><p> 通过表INNODB_LOCKS查看每张表上锁的情况后，用户就可以来判断由此引发的等待情况。当时当事务量非常大，其中锁和等待也时常发生，这个时候就不那么容易判断。但是通过表INNODB_LOCK_WAITS，可以很直观的反应当前事务的等待。表INNODB_LOCK_WAITS由四个字段组成，如下表所示。</p>
<ul>
<li>requesting_trx_id：申请锁资源的事务ID</li>
<li>requesting_lock_id：申请的锁的ID</li>
<li>blocking_trx_id：阻塞的事务ID</li>
<li>blocking_lock_id：阻塞的锁的ID</li>
</ul>
<pre><code>  mysql&gt; SELECT * FROM information_schema.INNODB_LOCK_WAITS\G;
  ******************1.row**************************
  requesting_trx_id: 7311F4
  requesting_lock_id: 7311F4:96:3:2
  blocking_trx_id: 730FEE
  blocking_lock_id: 730FEE:96:3:2

通过上述的SQL语句，用户可以清楚直观地看到哪个事务阻塞了另一个事务，然后使用上述的事务ID和锁ID，去INNODB_TRX和INNDOB_LOCKS表中查看更加详细的信息。
</code></pre><h4 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h4><p>一致性非锁定读(consistent nonlocking read)是指InnoDB存储引擎通过多版本控制(MVVC)读取当前数据库中行数据的方式。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB会去读取行的一个快照。</p>
<p><img src="mysql数据库引擎/innodb9.png" alt="mysql" title="mysql"></p>
<p>上图直观地展现了InnoDB一致性非锁定读的机制。之所以称其为非锁定读，是因为不需要等待行上排他锁的释放。快照数据是指该行的之前版本的数据，每行记录可能有多个版本，一般称这种技术为行多版本技术。</p>
<pre><code>由此带来的并发控制，称之为多版本并发控制(Multi Version Concurrency Control, MVVC)。InnoDB是通过undo log来实现MVVC。undo log本身用来在事务中回滚数据，因此快照数据本身是没有额外开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。
</code></pre><p> 一致性非锁定读是InnoDB默认的读取方式，即读取不会占用和等待行上的锁。但是并不是在每个事务隔离级别下都是采用此种方式。此外，即使都是使用一致性非锁定读，但是对于快照数据的定义也各不相同。</p>
<p> 在事务隔离级别READ COMMITTED和REPEATABLE READ下，InnoDB使用一致性非锁定读。然而，对于快照数据的定义却不同。在READ COMMITTED事务隔离级别下，一致性非锁定读总是读取被锁定行的最新一份快照数据。而在REPEATABLE READ事务隔离级别下，则读取事务开始时的行数据版本。</p>
<p> 我们下面举个例子来详细说明一下上述的情况。</p>
<h1 id="session-A"><a href="#session-A" class="headerlink" title="session A"></a>session A</h1><pre><code>mysql&gt; BEGIN;
mysql&gt; SELECT * FROM test WHERE id = 1;
</code></pre><p> 我们首先在会话A中显示地开启一个事务，然后读取test表中的id为1的数据，但是事务并没有结束。于此同时，用户在开启另一个会话B，这样可以模拟并发的操作，然后对会话B做出如下的操作：</p>
<h1 id="session-B"><a href="#session-B" class="headerlink" title="session B"></a>session B</h1><pre><code>mysql&gt; BEGIN;
mysql&gt; UPDATE test SET id = 3 WHERE id = 1;
</code></pre><p> 在会话B的事务中，将test表中id为1的记录修改为id=3，但是事务同样也没有提交，这样id=1的行其实加了一个排他锁。由于InnoDB在READ COMMITTED和REPEATABLE READ事务隔离级别下使用一致性非锁定读，这时如果会话A再次读取id为1的记录，仍然能够读取到相同的数据。此时，READ COMMITTED和REPEATABLE READ事务隔离级别没有任何区别。</p>
<p><img src="mysql数据库引擎/innodb10.png" alt="mysql" title="mysql"></p>
<p> 如上图所示，当会话B提交事务后，会话A再次运行SELECT * FROM test WHERE id = 1的SQL语句时，两个事务隔离级别下得到的结果就不一样了。<br> 对于READ COMMITTED的事务隔离级别，它总是读取行的最新版本，如果行被锁定了，则读取该行版本的最新一个快照。因为会话B的事务已经提交，所以在该隔离级别下上述SQL语句的结果集是空的。<br> 对于REPEATABLE READ的事务隔离级别，总是读取事务开始时的行数据，因此，在该隔离级别下，上述SQL语句仍然会获得相同的数据。</p>
<p><strong>MVVC</strong></p>
<p> 我们首先来看一下wiki上对MVVC的定义：</p>
<pre><code>  Multiversion concurrency control (MCC or MVCC), is a concurrency control
  method commonly used by database management systems to provide
  concurrent access to the database and in programming languages to
  implement transactional memory.
</code></pre><p> 由定义可知，MVVC是用于数据库提供并发访问控制的并发控制技术。<br>数据库的并发控制机制有很多，最为常见的就是锁机制。锁机制一般会给竞争资源加锁，阻塞读或者写操作来解决事务之间的竞争条件，最终保证事务的可串行化。</p>
<pre><code>而MVVC则引入了另外一种并发控制，它让读写操作互不阻塞，每一个写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适的结果直接返回，由此解决了事务的竞争条件。
</code></pre><p> 考虑一个现实场景。管理者要查询所有用户的存款总额，假设除了用户A和用户B之外，其他用户的存款总额都为0，A、B用户各有存款1000，所以所有用户的存款总额为2000。但是在查询过程中，用户A会向用户B进行转账操作。转账操作和查询总额操作的时序图如下图所示。</p>
<p><img src="mysql数据库引擎/innodb11.png" alt="mysql" title="mysql"></p>
<p> 如果没有任何的并发控制机制，查询总额事务先读取了用户A的账户存款，然后转账事务改变了用户A和用户B的账户存款，最后查询总额事务继续读取了转账后的用户B的账号存款，导致最终统计的存款总额多了100元，发生错误。</p>
<p> 使用锁机制可以解决上述的问题。查询总额事务会对读取的行加锁，等到操作结束后再释放所有行上的锁。因为用户A的存款被锁，导致转账操作被阻塞，直到查询总额事务提交并将所有锁都释放。</p>
<p><img src="mysql数据库引擎/innodb12.png" alt="mysql" title="mysql"></p>
<p> 但是这时可能会引入新的问题，当转账操作是从用户B向用户A进行转账时会导致死锁。转账事务会先锁住用户B的数据，等待用户A数据上的锁，但是查询总额的事务却先锁住了用户A数据，等待用户B的数据上的锁。<br>    使用MVVC机制也可以解决这个问题。查询总额事务先读取了用户A的账户存款，然后转账事务会修改用户A和用户B账户存款，查询总额事务读取用户B存款时不会读取转账事务修改后的数据，而是读取本事务开始时的数据副本(在REPEATABLE READ隔离等级下)。</p>
<p><img src="mysql数据库引擎/innodb13.png" alt="mysql" title="mysql"></p>
<p> MVCC使得数据库读不会对数据加锁，普通的SELECT请求不会加锁，提高了数据库的并发处理能力。借助MVCC，数据库可以实现READ COMMITTED，REPEATABLE READ等隔离级别，用户可以查看当前数据的前一个或者前几个历史版本，保证了ACID中的I特性（隔离性)</p>
<p><strong>InnoDB的MVVC实现</strong></p>
<p> 多版本并发控制仅仅是一种技术概念，并没有统一的实现标准， 其的核心理念就是数据快照，不同的事务访问不同版本的数据快照，从而实现不同的事务隔离级别。虽然字面上是说具有多个版本的数据快照，但这并不意味着数据库必须拷贝数据，保存多份数据文件，这样会浪费大量的存储空间。InnoDB通过事务的undo日志巧妙地实现了多版本的数据快照。<br> 数据库的事务有时需要进行回滚操作，这时就需要对之前的操作进行undo。因此，在对数据进行修改时，InnoDB会产生undo log。当事务需要进行回滚时，InnoDB可以利用这些undo log将数据回滚到修改之前的样子。<br> 根据行为的不同 undo log 分为两种 insert undo log和update undo log。<br> insert undo log 是在 insert 操作中产生的 undo log。因为 insert 操作的记录只对事务本身可见，对于其它事务此记录是不可见的，所以 insert undo log 可以在事务提交后直接删除而不需要进行 purge 操作。<br> update undo log 是 update 或 delete 操作中产生的 undo log，因为会对已经存在的记录产生影响，为了提供 MVCC机制，因此 update undo log 不能在事务提交时就进行删除，而是将事务提交时放到入 history list 上，等待 purge 线程进行最后的删除操作。<br> 为了保证事务并发操作时，在写各自的undo log时不产生冲突，InnoDB采用回滚段的方式来维护undo log的并发写入和持久化。回滚段实际上是一种 Undo 文件组织方式。<br> InnoDB行记录有三个隐藏字段：分别对应该行的rowid、事务号db_trx_id和回滚指针db_roll_ptr，其中db_trx_id表示最近修改的事务的id，db_roll_ptr指向回滚段中的undo log。如下图所示。</p>
<p> <img src="mysql数据库引擎/innodb14.png" alt="mysql" title="mysql"></p>
<p> 当事务2使用UPDATE语句修改该行数据时，会首先使用排他锁锁定改行，将该行当前的值复制到undo log中，然后再真正地修改当前行的值，最后填写事务ID，使用回滚指针指向undo log中修改前的行。如下图所示。</p>
<p><img src="mysql数据库引擎/innodb15.png" alt="mysql" title="mysql"></p>
<p> 当事务3进行修改与事务2的处理过程类似，如下图所示。</p>
<p><img src="mysql数据库引擎/innodb16.png" alt="mysql" title="mysql"></p>
<p> REPEATABLE READ隔离级别下事务开始后使用MVVC机制进行读取时，会将当时活动的事务id记录下来，记录到Read View中。READ COMMITTED隔离级别下则是每次读取时都创建一个新的Read View。<br> Read View是InnoDB中用于判断记录可见性的数据结构，记录了一些用于判断可见性的属性。</p>
<p>low_limit_id：某行记录的db_trx_id &lt; 该值，则该行对于当前Read View是一定可见的</p>
<p>up_limit_id：某行记录的db_trx_id &gt;= 该值，则该行对于当前read view是一定不可见的</p>
<p>low_limit_no：用于purge操作的判断</p>
<p>rw_trx_ids：读写事务数组</p>
<p> Read View创建后，事务再次进行读操作时比较记录的db_trx_id和Read View中的low_limit_id，up_limit_id和读写事务数组来判断可见性。</p>
<p> 如果该行中的db_trx_id等于当前事务id，说明是事务内部发生的更改，直接返回该行数据。否则的话，如果db_trx_id小于up_limit_id，说明是事务开始前的修改，则该记录对当前Read View是可见的，直接返回该行数据。</p>
<p> 如果db_trx_id大于或者等于low_limit_id，则该记录对于该Read View一定是不可见的。如果db_trx_id位于[up_limit_id, low_limit_id)范围内，需要在活跃读写事务数组(rw_trx_ids)中查找db_trx_id是否存在，如果存在，记录对于当前Read View是不可见的。<br> 如果记录对于Read View不可见，需要通过记录的DB_ROLL_PTR指针遍历undo log，构造对当前Read View可见版本数据。<br> 简单来说，Read View记录读开始时及其之后，所有的活动事务，这些事务所做的修改对于Read View是不可见的。除此之外，所有其他的小于创建Read View的事务号的所有记录均可见。</p>
<p><strong>ACID</strong></p>
<p><strong>A  事务的原子性(Atomicity)：</strong>指一个事务要么全部执行,要么不执行.也就是说一个事务不可能只执行了一半就停止了.比如你从取款机取钱,这个事务可以分成两个步骤:1划卡,2出钱.不可能划了卡,而钱却没出来.这两步必须同时完成.要么就不完成.<br><strong>C 事务的一致性(Consistency)：</strong>指事务的运行并不改变数据库中数据的一致性.例如,完整性约束了a+b=10,一个事务改变了a,那么b也应该随之改变.<br><strong>I 独立性(Isolation）:</strong>事务的独立性也有称作隔离性,是指两个以上的事务不会出现交错执行的状态.因为这样可能会导致数据不一致.<br><strong>D 持久性(Durability）:</strong>事务的持久性是指事务执行成功以后,该事务所对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚.</p>
<h3 id="MyIASM引擎"><a href="#MyIASM引擎" class="headerlink" title="MyIASM引擎"></a>MyIASM引擎</h3><p>　　MyIASM是MySQL默认的引擎，但是它<font color="#e07878">没有提供对数据库事务的支持，也不支持行级锁和外键</font>，因此当<code>INSERT</code>(插入)或<code>UPDATE</code>(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyIASM中存储了表的行数，于是<code>SELECT COUNT(*) FROM TABLE</code>时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。</p>
<h3 id="两种引擎的选择"><a href="#两种引擎的选择" class="headerlink" title="两种引擎的选择"></a>两种引擎的选择</h3><p>　　大尺寸的数据集趋向于选择InnoDB引擎，因为它<font color="#e07878">支持事务处理和故障恢复,支持行级锁和外键</font>。数据库的大小决定了故障恢复的时间长短，InnoDB可以利用事务日志进行数据恢复，这会比较快。主键查询在InnoDB引擎下也会相当快，不过需要注意的是如果主键太长也会导致性能问题，关于这个问题我会在下文中讲到。大批的<code>INSERT</code>语句(在每个<code>INSERT</code>语句中写入多行，批量插入)在MyISAM下会快一些，但是<code>UPDATE</code>语句在InnoDB下则会更快一些，尤其是在并发量大的时候。</p>
<h3 id="Index——索引"><a href="#Index——索引" class="headerlink" title="Index——索引"></a>Index——索引</h3><p>　　索引（Index）是帮助MySQL高效获取数据的数据结构。MyIASM和Innodb都使用了树这种数据结构做为索引。下面我接着讲这两种引擎使用的索引结构，讲到这里，首先应该谈一下B-Tree和B+Tree。</p>
<h4 id="MyIASM引擎的索引结构"><a href="#MyIASM引擎的索引结构" class="headerlink" title="MyIASM引擎的索引结构"></a>MyIASM引擎的索引结构</h4><p>　　MyISAM引擎的索引结构为<code>B+Tree</code>，其中<code>B+Tree</code>的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，只不过是用索引指向了实际的数据，这种索引就是所谓的<strong>非聚集索引</strong>。如下图所示：</p>
<p><img src="mysql数据库引擎/MyIasm1.png" alt="mysql" title="mysql"></p>
<p>　　这里设表一共有三列，假设我们以Col1为主键，则上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p>
<p><img src="mysql数据库引擎/MyIasm2.png" alt="mysql" title="mysql"></p>
<p>　　同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<h4 id="Innodb引擎的索引结构"><a href="#Innodb引擎的索引结构" class="headerlink" title="Innodb引擎的索引结构"></a>Innodb引擎的索引结构</h4><p>　　与MyISAM引擎的索引结构同样也是<code>B+Tree</code>，但是Innodb的索引文件本身就是数据文件，即<code>B+Tree</code>的数据域存储的就是实际的数据，这种索引就是聚集索引。这个索引的key就是数据表的主键，因此<code>InnoDB</code>表数据文件本身就是主索引。</p>
<p>　　并且和MyISAM不同，InnoDB的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。所以Innodb不建议使用过长的主键，否则会使辅助索引变得过大。建议使用自增的字段作为主键，这样B+Tree的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。</p>
<h3 id="两者区别："><a href="#两者区别：" class="headerlink" title="两者区别："></a>两者区别：</h3><p>　　第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p><img src="mysql数据库引擎/Innodb1.png" alt="mysql" title="mysql"></p>
<p>　　上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<p>　　第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：</p>
<p><img src="mysql数据库引擎/Innodb2.png" alt="mysql" title="mysql"></p>
<p>　　这里以英文字符的<code>ASCII</code>码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
<p>　　了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调(可能是指“非递增”的意思)的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗<code>B+Tree</code>，非单调(可能是指“非递增”的意思)的主键会造成在插入新记录时数据文件为了维持<code>B+Tree</code>的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>
<p><strong>MyISAM适合：</strong></p>
<p>(1)做很多count 的计算；<br>(2)读多写少，插入不频繁，查询非常频繁；<br>(3)没有事务。 </p>
<p><strong>InnoDB适合：</strong> </p>
<p>(1)可靠性要求比较高，或者要求事务；<br>(2)表更新和查询都相当的频繁，并且表锁定的机会比较大的情况指定数据引擎的创建；<br>(3)支持行级锁，外键。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/mysql.jpg&quot; alt=&quot;mysql&quot; title=&quot;mysql&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;数据库引擎&quot;&gt;&lt;a href=&quot;#数据库引擎&quot; class=&quot;headerlink&quot; title=&quot;数据库引擎&quot;&gt;&lt;/a&gt;数据库引擎&lt;/h2&gt;&lt;p&gt;　　数据库引擎是用于存储、处理和保护数据的核心服务。利用数据库引擎可控制访问权限并快速处理事务，从而满足企业内大多数需要处理大量数据的应用程序的要求。 使用数据库引擎创建用于联机事务处理或联机分析处理数据的关系数据库。这包括创建用于存储数据的表和用于查看、管理和保护数据安全的数据库对象（如索引、视图和存储过程）。&lt;/p&gt;
&lt;h2 id=&quot;数据库引擎任务&quot;&gt;&lt;a href=&quot;#数据库引擎任务&quot; class=&quot;headerlink&quot; title=&quot;数据库引擎任务&quot;&gt;&lt;/a&gt;数据库引擎任务&lt;/h2&gt;&lt;p&gt;在数据库引擎文档中，各主题的顺序遵循用于实现使用数据库引擎进行数据存储的系统的任务的主要顺序。&lt;/p&gt;
&lt;p&gt;设计并创建数据库以保存系统所需的关系或XML文档&lt;br&gt;实现系统以访问和更改数据库中存储的数据。包括实现网站或使用数据的应用程序，还包括生成使用SQL Server工具和实用工具以使用数据的过程。&lt;br&gt;为单位或客户部署实现的系统&lt;br&gt;提供日常管理支持以优化数据库的性能&lt;br&gt;
    
    </summary>
    
      <category term="database" scheme="http://jethan.bid/categories/database/"/>
    
      <category term="mysql" scheme="http://jethan.bid/categories/database/mysql/"/>
    
    
      <category term="ISAM" scheme="http://jethan.bid/tags/ISAM/"/>
    
      <category term="MyIsam" scheme="http://jethan.bid/tags/MyIsam/"/>
    
      <category term="HEAP" scheme="http://jethan.bid/tags/HEAP/"/>
    
      <category term="Innodb" scheme="http://jethan.bid/tags/Innodb/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之线程池ThreadPoolExecutor</title>
    <link href="http://jethan.bid/2017/08/06/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor/"/>
    <id>http://jethan.bid/2017/08/06/并发编程之线程池ThreadPoolExecutor/</id>
    <published>2017-08-06T05:32:02.000Z</published>
    <updated>2017-08-06T05:32:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="并发编程之线程池ThreadPoolExecutor/java.jpg" alt="java" title="java"></p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>当前越来越多的系统使用多线程来处理任务，但是为每一个任务创建线程并不是合理的方案，原因有2点：一是创建线程的开销很大，一个任务一个线程的方式会有性能上的损失；二是可能导致线程数量的膨胀，不但不易于线程的管理，还可能导致内存被消耗完，导致out of memory（OOM）,从而使系统崩溃。为了解决这个问题，线程池应运而生。线程池有两个作用：一个是限制线程的数量，不会导致线程的膨胀；二是线程复用，线程执行完一个人任务之后，可以接着执行下一个任务，减少了创建线程的开销。 </p>
<p>java中一个运用非常普遍的线程池是ThreadPoolExecutor。下面来探究下ThreadPoolExecutor的功能和实现原理。<br><a id="more"></a><br><strong>ThreadPoolExecutor的功能</strong></p>
<ol>
<li>自定义线程池的核心线程数和最大线程数。如果当前池中的线程数小于核心线程数，则直接为任务创建新线程来执行，如果前池中的线程数大于核心线程数，则把任务放入任务队列中，等待线程池中已有的线程去执行。如果任务队列满了，但是池中的线程数小于最大线程数，则创建新线程执行任务。如果任务队列满了，池中的线程数等于最大线程数，那么执行拒绝任务策略。</li>
<li>可配置拒绝任务策略，ThreadPoolExecutor自带了四种拒绝策略：丢弃当前将要加入队列的任务本身（DiscardPolicy），丢弃任务队列中最旧任务（DiscardOldestPolicy），抛出异常的方式（AbortPolicy），将任务交由调用者线程去执行（CallerRunsPolicy），除了自带的策略之外，用户还可以自定义策略。</li>
<li>线程声明周期管理。如果线程空闲时间超过了配置的时间keepAliveTime，则线程将被销毁。</li>
<li>配置线程工厂，用户可以自定义创建线程的工厂。</li>
<li>配置阻塞队列类型。</li>
<li>线程池生命周期管理。可以强制shutdown线程池，也可以优雅shutdown线程池。</li>
</ol>
<p>为了实现上面的配置管理。ThreadPoolExecutor提供了不同的创建线程池的构造方法，用户可以根据自身实际情况选择。</p>
<p><strong>ThreadPoolExecutor实现原理</strong></p>
<p> ThreadPoolExecutor的属性</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性名</th>
<th>属性说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>volatile int runState</td>
<td><strong>runState</strong>主要提供了生命周期的控制，下面是主要的状态：<br><strong>RUNNING：0。</strong>接收新任务以及处理队列中的任务<br><strong>SHUTDOWN：1。</strong>不再接收新任务，但是处理队列中的任务<br><strong>STOP：2。</strong>不再接收新任务，也不处理队列中的任务，同时中断正在执行的任务<br><strong>TERMINATED：3。</strong>跟STOP相同，同时所有的线程都终止了。</td>
</tr>
<tr>
<td>BlockingQueue<runnable> workQueue</runnable></td>
<td>任务队列</td>
</tr>
<tr>
<td>ReentrantLock mainLock</td>
<td>为poolSize, corePoolSize,maximumPoolSize, runState, and workers属性的set提供同步。</td>
</tr>
<tr>
<td>HashSet<worker> workers</worker></td>
<td>保存线程池中所有的工作线程，只有获得mainLock锁才能访问</td>
</tr>
<tr>
<td>volatile long  keepAliveTime</td>
<td>空闲线程的最大存活时间</td>
</tr>
<tr>
<td>volatile boolean allowCoreThreadTimeOut</td>
<td>核心线程是否也支持最大存活时间管理</td>
</tr>
<tr>
<td>volatile int corePoolSize</td>
<td>线程池核心线程数</td>
</tr>
<tr>
<td>volatile int   maximumPoolSize</td>
<td>线程池最大线程数</td>
</tr>
<tr>
<td>volatile int   poolSize</td>
<td>线程池当前线程数</td>
</tr>
<tr>
<td>int largestPoolSize</td>
<td>线程池峰值线程数</td>
</tr>
<tr>
<td>long completedTaskCount</td>
<td>线程池总共处理的任务数</td>
</tr>
<tr>
<td>volatile RejectedExecutionHandler handler</td>
<td>任务拒绝策略</td>
</tr>
<tr>
<td>volatile ThreadFactory threadFactory</td>
<td>创建线程工厂</td>
</tr>
</tbody>
</table>
</div>
<p>ThreadPoolExecutor的属性，基本上大部分都是构造函数中可配置的，也说明了ThreadPoolExecutor的灵活性。不过通过上面的表大家可能会有点疑惑：怎么没有保存Thread对象集合的属性？不要急，大家应该发现了里面有个HashSet<worker> workers属性。这个集合里Worker对象是ThreadPoolExecutor定义的一个内部类，它包含了thread对象。现在我们来看下Worker对象包含的属性。</worker></p>
<p><strong>Worker对象的属性</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性名称</th>
<th>属性说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>inal ReentrantLock runLock</td>
<td>这个锁的作用是保护取消worker线程的中断，而不是中断正在执行的任务。</td>
</tr>
<tr>
<td>Runnable firstTask</td>
<td>由于线程池创建现在的时候都是为某个任务创建，所以该属性就是记录该刚线程创建时执行的任务</td>
</tr>
<tr>
<td>long completedTasks</td>
<td>这个线程执行的任务数</td>
</tr>
<tr>
<td>Thread thread</td>
<td>本worker运行的线程</td>
</tr>
<tr>
<td>volatile boolean hasRun</td>
<td>本worker对象运行的线程是否执行过该worker的run方法。只有hasRun为true时worker的线程才能被中断。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>ThreadPoolExecutor的任务处理流程</strong></p>
<p>前面介绍了ThreadPoolExecutor的属性以及需要用到的内部类，素材有了，那么下面来看看是如何来把素材加工成成品的吧。在用户创建完线程池之后，需要把任务提交给线程池，线程池提供了submit和execute方法来提交任务，而submit方法最终还是调用的execute方法，它只是把任务封装成futuretask，以便获得任务的返回值。对于没有返回值的任务直接用execute提交就可以了，如果有返回值的任务，用submit提交更好。所以提交任务的核心还是execute方法。现在就来看看execute的实现代码：</p>
<pre><code>1.public void execute(Runnable command) {  
2.        if (command == null)  
3.            throw new NullPointerException();  
4.        if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) {  
5.            if (runState == RUNNING &amp;&amp; workQueue.offer(command)) {  
6.                if (runState != RUNNING || poolSize == 0)  
7.                    ensureQueuedTaskHandled(command);  
8.            }  
9.            else if (!addIfUnderMaximumPoolSize(command))  
10.                reject(command); // is shutdown or saturated  
11.        }  
12.    }  
</code></pre><p>这段代码的主要逻辑如下：</p>
<p>1.如果当选线程数大于等于核心线程数，则直接把任务放到任务队列里，等待已有的线程去执行它。如果当前选线程数小于核心线程数，则为该任务创建新的线程去执行它，这个的功能的实现方法是<code>addIfUnderCorePoolSize(command)</code>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private boolean addIfUnderCorePoolSize(Runnable firstTask) &#123;  </div><div class="line">   Thread t = null;  </div><div class="line">   final ReentrantLock mainLock = this.mainLock;  </div><div class="line">   mainLock.lock();  </div><div class="line">   try &#123;  </div><div class="line">      if (poolSize &lt; corePoolSize &amp;&amp; runState == RUNNING)  </div><div class="line">      t = addThread(firstTask);  </div><div class="line">   &#125; finally &#123;  </div><div class="line">   mainLock.unlock();  </div><div class="line">   &#125;  </div><div class="line">   return t != null;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现，这段源码是如果发现小于corePoolSize就会调用addThread()方法创建一个新的线程，并且调用线程的start()方法将线程运行起来。只有没有创建成功Thread才会返回false，也就是当当前的poolSize &gt; corePoolSize的时候，或线程池已经不是在running状态的时候才会出现。execute对poolSize和corePoolSize的比较只是粗略判断，而addIfUnderCorePoolSize（）内部是加锁后判定的，以得到更为准确的结果，而外部初步判定如果是大于了，就没有必要进入这段有锁的代码了。<br> 2.如果addIfUnderCorePoolSize返回false，说明没有为任务创建线程（原因可能是线程池不是RUNNING状态，或者poolsize大于corepoolsize了）。则需要把任务存放到任务队列中。<br> 3.在任务放到队列之前，先初步判断下此时线程池的状态。如果是running才接受新任务，否则addIfUnderMaximumPoolSize方法精确线程池状态。<br> 4.如果任务可以添加到任务队列，则判调用队列的offer方法，往队列末尾加入任务。由于队列是一个自定义的阻塞队列，可以是有界也可以是无界的。如果加入队列成功，还有先判断下runState != RUNNING || poolSize == 0。前面判断了状态之后为什么还要判断呢？这是因为有时间差，状态随时可以发生改变。记住了这一点在看这样一堆状态判断就不会难以理解了。好了，如果线程池不是RUNNING状态或线程池里没有线程了，则执行<code>ensureQueuedTaskHandled</code>方法处理任务如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">private void ensureQueuedTaskHandled(Runnable command) &#123;  </div><div class="line">        final ReentrantLock mainLock = this.mainLock;  </div><div class="line">        mainLock.lock();  </div><div class="line">        boolean reject = false;  </div><div class="line">        Thread t = null;  </div><div class="line">        try &#123;  </div><div class="line">            int state = runState;  </div><div class="line">            if (state != RUNNING &amp;&amp; workQueue.remove(command))  </div><div class="line">                reject = true;  </div><div class="line">            else if (state &lt; STOP &amp;&amp;  </div><div class="line">                     poolSize &lt; Math.max(corePoolSize, 1) &amp;&amp;  </div><div class="line">                     !workQueue.isEmpty())  </div><div class="line">                t = addThread(null);  </div><div class="line">        &#125; finally &#123;  </div><div class="line">            mainLock.unlock();  </div><div class="line">        &#125;  </div><div class="line">        if (reject)  </div><div class="line">            reject(command);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码是处理拒绝任务的。这里也会加锁来锁定当前的状态和工作队列。如果状态确实不等于running，则把任务从任务列表中移除并执行拒绝策略。如果任务remove失败，并且当前状态为running和shutdown状态，任务队列不为空，并且poolSize小于Math.max(corePoolSize, 1)。则调用addThread为线程池创建一个新线程。但是这个任务并没有直接给新线程执行。为什么要判断poolSize小于Math.max(corePoolSize, 1)，因为corePoolSize可以设置为0.当corePoolSize=0时，需要至少有1个线程去执行任务。前面的几个方法中出现了几次创建addThread的方法，现在来看看这个方法做了哪些事情：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">private Thread addThread(Runnable firstTask) &#123;  </div><div class="line">        Worker w = new Worker(firstTask);  </div><div class="line">        Thread t = threadFactory.newThread(w);  </div><div class="line">        boolean workerStarted = false;  </div><div class="line">        if (t != null) &#123;  </div><div class="line">            if (t.isAlive()) // precheck that t is startable  </div><div class="line">                throw new IllegalThreadStateException();  </div><div class="line">            w.thread = t;  </div><div class="line">            workers.add(w);  </div><div class="line">            int nt = ++poolSize;  </div><div class="line">            if (nt &gt; largestPoolSize)  </div><div class="line">                largestPoolSize = nt;  </div><div class="line">            try &#123;  </div><div class="line">                t.start();  </div><div class="line">                workerStarted = true;  </div><div class="line">            &#125;  </div><div class="line">            finally &#123;  </div><div class="line">                if (!workerStarted)  </div><div class="line">                    workers.remove(w);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        return t;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法的参数名firstTask可能比较难理解。这里详细说明一下：首先在线程池中，一个新线程的创建大多数情况都是为执行某个任务而创建的，这个任务不会加入任务队列，而是通过firstTask传给为他而建的新线程去执行。所以这个任务也就是这个线程执行的第一个任务。如果firstTask设为null，那么线程将去执行任务队列中的任务。下面来分析这个方法的功能，首先先创建一个worker对象，把firstTask初始化这个worker对象。然后通过线程工厂创建一个线程，并检查这个线程的状态，同时跟新线程池的峰值线程数的值。需要注意的是，这个线程不是属于某个具体任务的，而是属于这个worker的，即该线程不是执行某个任务的run，而是执行这个worker的run。最后把worker对象添加到worker队列里面。所以发到这里可以明白了ThreadPoolExecutor为什么没有thread的集合属性了。<br>5.第4点阐述了任务加入队列成功的情况，但是如果队列满了加入队列也可能失败。这时候会去尝试创建新线程来执行该任务。即执行addIfUnderMaximumPoolSize方法。这个方法与addIfUnderCorePoolSize基本一致，只是后者是拿poolSize跟corePoolSize比较，而前者是拿poolSize跟maximumPoolSize比较。如果addIfUnderMaximumPoolSize方法为任务创建线程失败，则执行拒绝策略来处理这个任务。<br>到目前为止，前面讲的5个步骤将了一个任务提交给线程池之后是如何处理的。但是细心的用户可能发现，里面缺失了非常重要的一个功能：任务被添加到任务队列之后是如何被线程池处理掉的？线程处理完它的首个任务之后是如何获取新任务的呢？线程池是不是有类似Timer一样的守护进程不断扫描线程队列和等待队列？还是利用某种锁机制，实现类似wait和notify实现的？ 别急。下面来揭开它的神秘面纱。<br>前面提到了ThreadPoolExecutor的内部类Worker，也在介绍addThread方法的时候提到了线程池的线程是和Worker对象绑定在一起的。所以现在来看看Worker类做了什么事情？通过代码发现Worker的定义也是一个Runnable。addthread方法中调用了这个Worker的start()方法，也就是线程的启动方法，其实也就是调用了Worker的run()方法。现在来看看worker的run方法做了什么事情：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public void run() &#123;  </div><div class="line">            try &#123;  </div><div class="line">                hasRun = true;  </div><div class="line">                Runnable task = firstTask;  </div><div class="line">                firstTask = null;  </div><div class="line">                while (task != null || (task = getTask()) != null) &#123;  </div><div class="line">                   runTask(task);  </div><div class="line">                   task = null;  </div><div class="line">               &#125;  </div><div class="line">            &#125; finally &#123;  </div><div class="line">                workerDone(this);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>woker的run方法主要是通过while循环不断调用getTask()方法去获取任务。然后执行runTask(task)方法来执行任务，最后调用workerDone()方法来执行一些清除操作。</p>
<p> runTask(task)其实做的事情很简单：它的核心就是调用任务的run方法来执行真正的用户任务，除此之外还执行了任务执行前后需要的一些操作，以及统计一下这个worker完成的任务数。这个方法不需要深究，代码也比较简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">private void runTask(Runnable task) &#123;  </div><div class="line">            final ReentrantLock runLock = this.runLock;  </div><div class="line">            runLock.lock();  </div><div class="line">            try &#123;  </div><div class="line">                if ((runState &gt;= STOP ||  </div><div class="line">                    (Thread.interrupted() &amp;&amp; runState &gt;= STOP)) &amp;&amp;  </div><div class="line">                    hasRun)  </div><div class="line">                    thread.interrupt();  </div><div class="line">                boolean ran = false;  </div><div class="line">                beforeExecute(thread, task);  </div><div class="line">                try &#123;  </div><div class="line">                    task.run();  </div><div class="line">                    ran = true;  </div><div class="line">                    afterExecute(task, null);  </div><div class="line">                    ++completedTasks;  </div><div class="line">                &#125; catch (RuntimeException ex) &#123;  </div><div class="line">                    if (!ran)  </div><div class="line">                        afterExecute(task, ex);  </div><div class="line">                    throw ex;  </div><div class="line">                &#125;  </div><div class="line">            &#125; finally &#123;  </div><div class="line">                runLock.unlock();  </div><div class="line">            &#125;  </div><div class="line"> &#125; </div><div class="line">``` </div><div class="line"> </div><div class="line"> worker的润方法真正的核心是如果不断获取任务的。所以这里必须认真解读下getTask()方法，下面是getTask()的代码：</div><div class="line"> </div><div class="line"> </div><div class="line">``` </div><div class="line">Runnable getTask() &#123;  </div><div class="line">        for (;;) &#123;  </div><div class="line">            try &#123;  </div><div class="line">                int state = runState;  </div><div class="line">                if (state &gt; SHUTDOWN)  </div><div class="line">                    return null;  </div><div class="line">                Runnable r;  </div><div class="line">                if (state == SHUTDOWN)  // Help drain queue  </div><div class="line">                    r = workQueue.poll();  </div><div class="line">                else if (poolSize &gt; corePoolSize || allowCoreThreadTimeOut)  </div><div class="line">                    r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);  </div><div class="line">                else  </div><div class="line">                    r = workQueue.take();  </div><div class="line">                if (r != null)  </div><div class="line">                    return r;  </div><div class="line">                if (workerCanExit()) &#123;  </div><div class="line">                    if (runState &gt;= SHUTDOWN) // Wake up others  </div><div class="line">                        interruptIdleWorkers();  </div><div class="line">                    return null;  </div><div class="line">                &#125;  </div><div class="line">                // Else retry  </div><div class="line">            &#125; catch (InterruptedException ie) &#123;  </div><div class="line">                // On interruption, re-check runState  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>你会发现getTask()方法是从workQueue队列中，也就是等待队列中获取一个任务出来并返回！如果没有获得任务，则通过 interruptIdleWorkers()方法去关闭空闲时间超过阈值的空闲线程。</p>
<p>至此，完整的ThreadPoolExecutor线程池处理任务的原理就解读完毕了。其他的一些诸如关闭线程池和获取线程池的状态和统计信息等的接口都比较简单，这里就不一一解释了。</p>
<h2 id="常见线程池"><a href="#常见线程池" class="headerlink" title="常见线程池"></a>常见线程池</h2><p><strong>1. newSingleThreadExecutor。</strong><br>只有一个线程的线程池，即corePoolSize和maximumPoolSize都等于1。<br><strong>2. newCachedThreadPool</strong><br>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。在newCachedThreadPool构造参数中，corePoolSize=0，maximumPoolSize=Integer.MAX_VALUE，即可与无限制的创建线程。但是它使用的是阻塞队列是SynchronousQueue。这个队列比较奇葩，虽然他是无界的，但是里面只能有一个元素。在添加一个任务的时候，必须要有一个线程正在等待一个任务。即通过这个阻塞队列，既可以保证任务能够马上得到线程去运行，同时又能重用已有的空闲线程。<br><strong>3. newFixedThreadPool</strong><br>线程数固定的线程池，即corePoolSize=maximumPoolSize。当线程数达到了corePoolSize时，不能创建新的线程了，所以新的任务只能放到任务队列中，因此这个线程池用的阻塞队列是无界队列LinkedBlockingQueue。<br><strong>4. ScheduledThreadPoolExecutor</strong><br>可以执行延迟固定时间的任务，也可以执行定时任务的线程池。ScheduledThreadPoolExecutor的底层不是基于ThreadPoolExecutor实现的，它有一个自己的实现类。</p>
<p>其实我们的要求很简单，希望线程池能跟连接池一样，能设置最小线程数、最大线程数，当最小数&lt;任务&lt;最大数时，应该分配新的线程处理；当任务&gt;最大数时，应该等待有空闲线程再处理该任务。<br>但线程池的设计思路是，任务应该放到Queue中，当Queue放不下时再考虑用新线程处理，如果Queue满且无法派生新线程，就拒绝该任务。设计导致“先放等执行”、“放不下再执行”、“拒绝不等待”。所以，根据不同的Queue参数，要提高吞吐量不能一味地增大maximumPoolSize。<br>当然，要达到我们的目标，必须对线程池进行一定的封装，幸运的是ThreadPoolExecutor中留了足够的自定义接口以帮助我们达到目标。我们封装的方式是：  </p>
<ol>
<li>以SynchronousQueue作为参数，使maximumPoolSize发挥作用，以防止线程被无限制的分配，同时可以通过提高maximumPoolSize来提高系统吞吐量  </li>
<li>自定义一个RejectedExecutionHandler，当线程数超过maximumPoolSize时进行处理，处理方式为隔一段时间检查线程池是否可以执行新Task，如果可以把拒绝的Task重新放入到线程池，检查的时间依赖keepAliveTime的大小。</li>
</ol>
<h2 id="线程池的两个核心队列"><a href="#线程池的两个核心队列" class="headerlink" title="线程池的两个核心队列"></a>线程池的两个核心队列</h2><ul>
<li>线程等待池，即线程队列BlockingQueue。 </li>
<li>任务处理池（PoolWorker），即正在工作的Thread列表（HashSet）。<br>线程池的核心参数： </li>
<li>核心池大小（corePoolSize），即固定大小，设定好之后，线程池的稳定峰值，达到这个值之后池的线程数大小不会释放。 </li>
<li>最大处理线程池数（maximumPoolSize），当线程池里面的线程数超过corePoolSize，小于maximumPoolSize时会动态创建与回收线程池里面的线程池资源。</li>
</ul>
<p>线程池的运行机制：</p>
<p>举个例子。假如有一个工厂，工厂里面有10个人，每个工人同时只能做一件事情。因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；当10个工人都有任务时，如果还来任务，就把任务进行排队等待。<br>如果说新任务数目增长的速度远远大于工作做任务的速度，那么此时工厂的主管可能就需要采取补救措施了，比如重新招4个工人进来；然后就将任务分配给这4个刚招进来的工人处理。<br>如果说这14个工人做任务的速度还是不够，此时工厂主管就要考虑不再接受新的任务或者抛弃前面的一些任务了。当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管就要考虑辞掉4个临时工了，只保持原来10个工人，比较额外的工人是需要花费的。<br>而这个例子中永远等待干活的10个工人机制就是workerQueue。这个栗子中的corePoolSize就是10，而maximumPoolSize就是14（10+4）。也就是说corePoolSize就是线程池的大小，maximumPoolSize在我看来就是一种线程池任务超过负荷的一种补救措施，即任务量突然过大时的一种补救措施。再看看下面图好好理解一下。工人永远在等待干活，就像workerQueue永远在循环干活一样，除非，整个线程池停止了。<br><img src="并发编程之线程池ThreadPoolExecutor/thread1.png" alt="thread" title="thread"></p>
<p>线程池里面的线程的时序图如下图所示：<br><img src="并发编程之线程池ThreadPoolExecutor/thread2.png" alt="thread" title="thread"></p>
<p>自定义线程池与ExecutorService<br>自定义线程池需要用到ThreadFactory，本节将通过创建一个线程的例子对ExecutorService及其参数进行详细讲解。<br><strong>1.认识ExecutorService家族 </strong><br>ExecutorService家族成员如下所示：<br><img src="并发编程之线程池ThreadPoolExecutor/thread3.png" alt="thread" title="thread"></p>
<p>上图中主要元素说明如下：<br><strong>Executor：</strong>线程池的顶级接口，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。<br><strong>ExecutorService：</strong>真正线程池接口。这个接口继承了<code>Executor</code>接口，并声明了一些方法：<br><code>submit</code>、<code>invokeAll</code>、<code>invokeAny</code>以及<code>shutDown</code>等。<br><strong>ThreadPoolExecutor：</strong>ExecutorService的默认实现，继承了类AbstractExecutorService。<br><strong>ScheduledExecutorService：</strong>与Timer/TimerTask类似，解决那些需要任务重复执行的问题。<br><strong>ScheduledThreadPoolExecutor：</strong>继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。<br>Executors是个线程工厂类，方便我们快速地创建线程池。</p>
<p><strong>2.利用ThreadFactory创建一个线程</strong><br><code>Java.util.concurrent.ThreadFactory</code>提供了一个创建线程的工厂的接口。<br>ThreadFactory源码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface ThreadFactory&#123;</div><div class="line">  @override</div><div class="line">  public Thread newThread(Runnable r);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到上面的接口类中有一个<code>newThread()</code>的方法，为此我们自己手动定义一个线程工厂类，有木有激动啊，呵呵，下面我们就手动写一个自己的线程工厂类吧！  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class MyThreadFactory implements ThreadFactory&#123;</div><div class="line">  @Override</div><div class="line">  public Thread newThread(Runnable r)&#123;</div><div class="line">        return new Thread(r);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面已经创建好了我们自己的线程工厂类，但是啥都没有做，就是直接new了一个Thread就返回回去了，我们一般在创建线程的时候，都需要定义其线程的名字，因为我们在定义了线程的名字之后就能在出现问题的时候根据监视工具来查找错误的来源，所以我们来看下官方实现的<code>ThreadFactory</code>吧！<br>这个类在<code>java.util.concurrent.Executors</code>类中的静态类中<code>DefaultThreadFactory</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">*  The default thread factory</div><div class="line">*/static class DefaultThreadFactory implements ThreadFactory&#123;</div><div class="line">  private static final AtomicInteger poolNumber=new AtomicInteger(1);</div><div class="line">  private final ThreadGroup group;</div><div class="line">  private final AtomicInteger threadNumber=new AtomicInteger(1);</div><div class="line">  private final String namePrefix;</div><div class="line"></div><div class="line">  DefaultThreadFactory()&#123;</div><div class="line">    SecurityManager s=System.getSecurityManager();</div><div class="line">    group=(s!=null)?s.getThreadGroup():Thread.currentThread().getThreadGroup();</div><div class="line">    namePrefix=&quot;pool-&quot;+poolNumber.getAndIncrement()+&quot;-thread-&quot;;</div><div class="line">  &#125;</div><div class="line">  public Thread newThread(Runnable r)&#123;</div><div class="line">      Thread t=new Thread(group,r,namePrefix+threadNumber.getAndIncrement(),0);</div><div class="line">      if((t.isDaemon())</div><div class="line">          t.setDaemon(false);</div><div class="line">      if(t.getPriority()!=Thread.NORM_PRIORITY)</div><div class="line">          t.setPriority(Thread.NORM_PRIORITY);</div><div class="line">      return t;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>3.了解线程池的拒绝策略(RejectExecutionHandler)</strong><br>当调用<code>ThreadPoolExecuto</code>r的<code>execute</code>方法时，而此时线程池处于一个饱和的状态，并且任务队列也已经满了那么就需要做丢弃处理，<code>RejectExecutionHandler</code>就是这样的一个处理接口类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public interface RejectedExecutionHandler &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Method that may be invoked by a &#123;@link ThreadPoolExecutor&#125; when</div><div class="line">     * &#123;@link ThreadPoolExecutor#execute execute&#125; cannot accept a</div><div class="line">     * task.  This may occur when no more threads or queue slots are</div><div class="line">     * available because their bounds would be exceeded, or upon</div><div class="line">     * shutdown of the Executor.</div><div class="line">     *</div><div class="line">     * &lt;p&gt;In the absence of other alternatives, the method may throw</div><div class="line">     * an unchecked &#123;@link RejectedExecutionException&#125;, which will be</div><div class="line">     * propagated to the caller of &#123;@code execute&#125;.</div><div class="line">     *</div><div class="line">     * @param r the runnable task requested to be executed</div><div class="line">     * @param executor the executor attempting to execute this task</div><div class="line">     * @throws RejectedExecutionException if there is no remedy</div><div class="line">     */</div><div class="line">    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在JDK里面有4种拒绝策略，如下图所示：<br><img src="并发编程之线程池ThreadPoolExecutor/thread4.png" alt="thread" title="thread"></p>
<ol>
<li><strong>AbortPolicy：</strong>一言不合就抛异常（默认使用策略）。</li>
<li><strong>CallerRunsPolicy：</strong>只用调用者所在线程来运行任务。</li>
<li><strong>DiscardOldestPolicy：</strong>丢弃队列里最近的一个任务，并执行当前任务。</li>
<li><strong>DiscardPolicy：</strong>不处理，直接丢弃。</li>
</ol>
<p>来看下源码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">AbortPolicy : 一言不合就抛异常的</div><div class="line">   /**</div><div class="line">     * A handler for rejected tasks that throws a</div><div class="line">     * &#123;@code RejectedExecutionException&#125;.</div><div class="line">     */</div><div class="line">    public static class AbortPolicy implements RejectedExecutionHandler &#123;</div><div class="line">        /**</div><div class="line">         * Creates an &#123;@code AbortPolicy&#125;.</div><div class="line">         */</div><div class="line">        public AbortPolicy() &#123; &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * Always throws RejectedExecutionException.</div><div class="line">         *</div><div class="line">         * @param r the runnable task requested to be executed</div><div class="line">         * @param e the executor attempting to execute this task</div><div class="line">         * @throws RejectedExecutionException always.</div><div class="line">         */</div><div class="line">        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</div><div class="line">            throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +</div><div class="line">                                                 &quot; rejected from &quot; +</div><div class="line">                                                 e.toString());</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>CallerRunsPolicy：调用者所在线程来运行任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * A handler for rejected tasks that runs the rejected task</div><div class="line"> * directly in the calling thread of the &#123;@code execute&#125; method,</div><div class="line"> * unless the executor has been shut down, in which case the task</div><div class="line"> * is discarded.</div><div class="line"> */</div><div class="line">public static class CallerRunsPolicy implements RejectedExecutionHandler &#123;</div><div class="line">    /**</div><div class="line">     * Creates a &#123;@code CallerRunsPolicy&#125;.</div><div class="line">     */</div><div class="line">    public CallerRunsPolicy() &#123; &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Executes task r in the caller&apos;s thread, unless the executor</div><div class="line">     * has been shut down, in which case the task is discarded.</div><div class="line">     *</div><div class="line">     * @param r the runnable task requested to be executed</div><div class="line">     * @param e the executor attempting to execute this task</div><div class="line">     */</div><div class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</div><div class="line">        if (!e.isShutdown()) &#123;</div><div class="line">            r.run();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DiscardOldestPolicy :丢弃队列里面最近的一个任务,并执行当前任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * A handler for rejected tasks that discards the oldest unhandled</div><div class="line"> * request and then retries &#123;@code execute&#125;, unless the executor</div><div class="line"> * is shut down, in which case the task is discarded.</div><div class="line"> */</div><div class="line">public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123;</div><div class="line">    /**</div><div class="line">     * Creates a &#123;@code DiscardOldestPolicy&#125; for the given executor.</div><div class="line">     */</div><div class="line">    public DiscardOldestPolicy() &#123; &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Obtains and ignores the next task that the executor</div><div class="line">     * would otherwise execute, if one is immediately available,</div><div class="line">     * and then retries execution of task r, unless the executor</div><div class="line">     * is shut down, in which case task r is instead discarded.</div><div class="line">     *</div><div class="line">     * @param r the runnable task requested to be executed</div><div class="line">     * @param e the executor attempting to execute this task</div><div class="line">     */</div><div class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</div><div class="line">        if (!e.isShutdown()) &#123;</div><div class="line">            e.getQueue().poll();</div><div class="line">            e.execute(r);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DiscardPolicy : 不处理，直接丢弃</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * A handler for rejected tasks that silently discards the</div><div class="line">     * rejected task.</div><div class="line">     */</div><div class="line">    public static class DiscardPolicy implements RejectedExecutionHandler &#123;</div><div class="line">        /**</div><div class="line">         * Creates a &#123;@code DiscardPolicy&#125;.</div><div class="line">         */</div><div class="line">        public DiscardPolicy() &#123; &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * Does nothing, which has the effect of discarding task r.</div><div class="line">         *</div><div class="line">         * @param r the runnable task requested to be executed</div><div class="line">         * @param e the executor attempting to execute this task</div><div class="line">         */</div><div class="line">        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>思考问题：<br>为什么有任务拒绝的情况发生呢：<br>这里先假设有一个前提：线程池里面有一个任务队列，用于缓存所有待处理的任务，正在处理的任务将从任务队列中移除。因此，在任务队列长度有限的情况下，就会出现现任务的拒绝情况，需要一种策略来处理发生这种已满无法加入的情况。另外，在线程池关闭的时候，也需要对任务加入队列操作进行额外的协调处理。  </p>
<p><strong>4.ThreadPoolExecutor详解</strong></p>
<p><code>ThreadPoolExecutor</code>类是线程池中最核心的一个类，因此如果要想透彻的了解Java线程池，必须先了解这个大BOSS，下面来看下其源码：</p>
<p>4种构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,TimeUnit unit,</div><div class="line">                      BlockingQueue&lt;Runnable&gt; workQueue) &#123;</div><div class="line">    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,Executors.defaultThreadFactory(), defaultHandler);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,long keepAliveTime,TimeUnit unit,</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory) &#123;</div><div class="line">    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,threadFactory, defaultHandler);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,long keepAliveTime,TimeUnit unit,</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123;</div><div class="line">    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,</div><div class="line">                         BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory,RejectedExecutionHandler handler) &#123;</div><div class="line">    if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0)</div><div class="line">        throw new IllegalArgumentException();</div><div class="line">    if (workQueue == null || threadFactory == null || handler == null)</div><div class="line">        throw new NullPointerException();</div><div class="line">    this.corePoolSize = corePoolSize;</div><div class="line">    this.maximumPoolSize = maximumPoolSize;</div><div class="line">    this.workQueue = workQueue;</div><div class="line">    this.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class="line">    this.threadFactory = threadFactory;</div><div class="line">    this.handler = handler;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过源码我们清楚的看到，最终构造函数调用了最后一个构造函数，后面的那个构造函数才是真正的构造函数，接下来研究一下参数。</p>
<ul>
<li>int corePoolSize：核心池大小，这个参数跟后面讲的线程池原理有很大的关系。在创建了线程池之后，默认情况下，线程池中并没有任何线程，而是等待所有的任务到来之时才进行创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法 ，从这个两个方法的名字可以知道是预创建线程的意思，即在没有任务来临之前先创建好corePoolSize个线程或者一个线程。默认情况下，在创建好线程池之后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数量达到corePoolSize后，就会把达到的任务放到缓存队列中去。 </li>
<li>int maximumPoolSize：线程池最大线程数量，这是个非常重要的参数，它表示在线程池中最多能创建线程的数量；在corePoolSize和maximumPoolSize的线程数会被自动释放，而小于corePoolSize的则不会。 </li>
<li>long keepAliveTime：表示线程没有执行任务时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会生效,直到线程池数量不大于corePoolSize，即只有当线程池数量大于corePoolSize数量，超出这个数量的线程一旦到达keepAliveTime就会终止。但是如果调用了allowCoreThreadTimeout(boolean)方法，即使线程池的线程数量不大于corePoolSize，线程也会在keepAliveTime之后就终止，知道线程池的数量为0为止。 </li>
<li>TimeUnit unit：参数keepAliveTime的时间单位，一个时间单位枚举类。 </li>
<li>BlockingQueue workQueue：一个阻塞队列，用来存储等待执行任务的队列，这个参数选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列就是（ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue；）。 </li>
<li>ThreadFactory ThreadFactory：线程工厂，主要用来创建线程；可以是一个自定义的线程工厂，默认就是Executors.defaultThreadFactory()。用来在线程池中创建线程。 </li>
<li>RejectedExecutionHandler handler：表示当拒绝处理任务时的策略，也是可以自定义的，默认是我们前面的4种取值： </li>
</ul>
<ul>
<li>ThreadPoolExecutor.AbortPolicy（默认的，一言不合即抛异常的） </li>
<li>ThreadPoolExecutor.DiscardPolicy（一言不合就丢弃任务） </li>
<li>ThreadPoolExecutor.DiscardOldestPolicy（一言不合就把最近的任务给抛弃，然后执行当前任务） </li>
<li>ThreadPoolExecutor.CallerRunsPolicy（由调用者所在线程来执行任务）<br>所以想自定义线程池就可以从上面的几个参数入手。接下来具体看下代码,了解一下实现原理：<br> // 默认异常处理机制<br> private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();<br> //任务缓存队列，用来存放等待执行的任务<br> private final BlockingQueue<runnable> workQueue;<br> //线程池的主要状态锁，对线程状态（比如线程大小、runState等）的改变都需要这个锁<br> private final ReentrantLock mainLock = new ReentrantLock();<br> //用来存放工作集<br> private final HashSet<worker> workers = new HashSet<worker>();<br> //volatile 可变变量关键字，写的时候用mainLock做锁，读的时候无锁，高性能<br> private volatile long keepAliveTime;<br> //是否允许核心线程超时<br> private volatile boolean allowCoreThreadTimeOut;<br> //核心线程数量<br> private volatile int corePoolSize;<br> //线程最大线程数量<br> private volatile int maximumPoolSize;<br> //任务拒绝策略<br> private volatile RejectedExcutionHandler handler;<br>结合之前的知识，大概就能猜出里面是怎么实现的了，具体可以参考一下JDK的源代码，这样我们就能做到了解原理又会用了。</worker></worker></runnable></li>
</ul>
<p><strong>5.自定义实现一个简单的Web请求连接池</strong><br>我们来自定义一个简单的Web请求线程池。模仿Web服务的需求场景说明如下：  </p>
<ul>
<li>服务器可容纳的最小请求数是多少。   </li>
<li>可以动态扩充的请求数大小是多少。   </li>
<li>多久回收多余线程数即请求数。   </li>
<li>用户访问量打了怎么处理。   </li>
<li>线程队列机制采取有优先级的排队的执行机制。<br>根据上面的场景，看下这个线程池如何编写？ </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class MyExecutors extends Executors&#123;</div><div class="line">    //利用默认线程工厂和PriorityBlockingQueue队列机制，当然了，我们还可以自定义ThreadFactory和继承queue进行自定义扩展</div><div class="line">   public static ExecutorService newMyWebThreadPool(int minSpareThreads,int maxThreads,int maxIdleTime)&#123;</div><div class="line">    return new ThreadPoolExecutor(minSpareThread,maxThreads,maxIdleTime,TimeUnit.MILLISECONDS，</div><div class="line">          new PriorityBlockingQueue&lt;Runnable&gt;());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>6.线程池在工作中的错误使用</strong><br>(1)分不清楚线程是单例还是多对象。<br>(2)线程池数量设置很大。<br>(3)注意死锁问题  </p>
<p><strong>连接池（org.apache.commons.dbcp.BasicDataSource）</strong><br>在使用org.apache.commons.dbcp.BasicDataSource的时候，因为之前采用了默认配置，所以当访问量大时，通过JMX观察到很多Tomcat线程都阻塞在BasicDataSource使用的Apache ObjectPool的锁上，直接原因当时是因为BasicDataSource连接池的最大连接数设置的太小，默认的BasicDataSource配置，仅使用8个最大连接。<br>我还观察到一个问题，当较长的时间不访问系统，比如2天，DB上的Mysql会断掉所以的连接，导致连接池中缓存的连接不能用。为了解决这些问题，我们充分研究了BasicDataSource，发现了一些优化的点：    </p>
<ul>
<li>Mysql默认支持100个链接，所以每个连接池的配置要根据集群中的机器数进行，如有2台服务器，可每个设置为60  </li>
<li>initialSize：参数是一直打开的连接数  </li>
<li>minEvictableIdleTimeMillis：该参数设置每个连接的空闲时间，超过这个时间连接将被关闭  </li>
<li>timeBetweenEvictionRunsMillis：后台线程的运行周期，用来检测过期连接  </li>
<li>maxActive：最大能分配的连接数  </li>
<li>maxIdle：最大空闲数，当连接使用完毕后发现连接数大于maxIdle，连接将被直接关闭。只有initialSize &lt; x &lt; maxIdle的连接将被定期检测是否超期。这个参数主要用来在峰值访问时提高吞吐量。  </li>
<li>initialSize是如何保持的？经过研究代码发现，BasicDataSource会关闭所有超期的连接，然后再打开initialSize数量的连接，这个特性与minEvictableIdleTimeMillis、timeBetweenEvictionRunsMillis一起保证了所有超期的initialSize连接都会被重新连接，从而避免了Mysql长时间无动作会断掉连接的问题。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;并发编程之线程池ThreadPoolExecutor/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;ThreadPoolExecutor&quot;&gt;&lt;a href=&quot;#ThreadPoolExecutor&quot; class=&quot;headerlink&quot; title=&quot;ThreadPoolExecutor&quot;&gt;&lt;/a&gt;ThreadPoolExecutor&lt;/h2&gt;&lt;p&gt;当前越来越多的系统使用多线程来处理任务，但是为每一个任务创建线程并不是合理的方案，原因有2点：一是创建线程的开销很大，一个任务一个线程的方式会有性能上的损失；二是可能导致线程数量的膨胀，不但不易于线程的管理，还可能导致内存被消耗完，导致out of memory（OOM）,从而使系统崩溃。为了解决这个问题，线程池应运而生。线程池有两个作用：一个是限制线程的数量，不会导致线程的膨胀；二是线程复用，线程执行完一个人任务之后，可以接着执行下一个任务，减少了创建线程的开销。 &lt;/p&gt;
&lt;p&gt;java中一个运用非常普遍的线程池是ThreadPoolExecutor。下面来探究下ThreadPoolExecutor的功能和实现原理。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://jethan.bid/categories/java/"/>
    
      <category term="并发编程" scheme="http://jethan.bid/categories/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="ThreadPoolExecutor" scheme="http://jethan.bid/tags/ThreadPoolExecutor/"/>
    
      <category term="线程池" scheme="http://jethan.bid/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>线程的实现方式</title>
    <link href="http://jethan.bid/2017/08/05/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>http://jethan.bid/2017/08/05/线程的实现方式/</id>
    <published>2017-08-05T08:32:32.000Z</published>
    <updated>2017-08-05T08:32:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="线程的实现方式/java.jpg" alt="java" title="java"></p>
<h2 id="线程实现方式"><a href="#线程实现方式" class="headerlink" title="线程实现方式"></a>线程实现方式</h2><ol>
<li>继承java.lang.Thread类  </li>
<li>实现java.lang.Runnable接口</li>
</ol>
<p><strong>区别：</strong>第一种是继承，第二种是实现<br><strong>好处：</strong>  在实际开发中通常以实现Runnable接口为主，因为实现Runnable接口相比继承Thread类可以避免继承的局限，一个类可以继承多个接口，适合于资源的共享<br><a id="more"></a><br>示例1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">1.class ThreadTest extends Thread&#123;  </div><div class="line">2.  public void run()&#123; </div><div class="line">3.     private int tickets = 100;  </div><div class="line">4.    while(true)&#123;  </div><div class="line">5.      if(ticket &gt; 0)&#123;  </div><div class="line">6.        System.out.println(Thread.currentThread().getName() +  </div><div class="line">7.          &quot;is saling ticket&quot; + ticket--);  </div><div class="line">8.      &#125;else&#123;  </div><div class="line">9.        break;  </div><div class="line">10.      &#125;  </div><div class="line">11.    &#125;  </div><div class="line">12.  &#125;  </div><div class="line">13.&#125;  </div><div class="line"></div><div class="line">#main测试类: </div><div class="line">1.public class ThreadDome1&#123;  </div><div class="line">2.  public static void main(String[] args)&#123;  </div><div class="line">3.    ThreadTest t = new ThreadTest();  </div><div class="line">4.    t.start();  </div><div class="line">5.    t.start();  </div><div class="line">6.    t.start();  </div><div class="line">7.    t.start();  </div><div class="line">8.  &#125;  </div><div class="line">9.&#125;</div></pre></td></tr></table></figure></p>
<p>【说明】一个线程对象只能启动一个线程，无论你调用多少遍start()方法，结果只有一个线程。</p>
<p>示例2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">1.public class ThreadDemo1&#123;  </div><div class="line">2.  public static void main(String[] args)&#123;  </div><div class="line">3.    new ThreadTest().start();  </div><div class="line">4.    new ThreadTest().start();  </div><div class="line">5.    new ThreadTest().start();  </div><div class="line">6.    new ThreadTest().start();  </div><div class="line">7.  &#125;  </div><div class="line">8.&#125;  </div><div class="line"></div><div class="line">1.class ThreadTest extends Thread&#123;  </div><div class="line">2.  public void run()&#123; </div><div class="line">3.     private int tickets = 100;  </div><div class="line">4.    while(true)&#123;  </div><div class="line">5.      if(ticket &gt; 0)&#123;  </div><div class="line">6.        System.out.println(Thread.currentThread().getName() +   </div><div class="line">7.           &quot; is saling ticket&quot; + ticket--);  </div><div class="line">8.      &#125;else&#123;  </div><div class="line">9.        break;  </div><div class="line">10.      &#125;  </div><div class="line">11.    &#125;  </div><div class="line">12.  &#125;  </div><div class="line">13.&#125;</div></pre></td></tr></table></figure></p>
<p>【说明】创建了四个ThreadTest对象，就等于创建了四个资源，每个资源都有100张票，每个线程都在独自处理各自的资源。</p>
<p>示例4：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">1.public class ThreadDemo1&#123;  </div><div class="line">2.  public static void main(String[] args)&#123;  </div><div class="line">3.    ThreadTest t = new ThreadTest();  </div><div class="line">4.    new Thread(t).start();  </div><div class="line">5.    new Thread(t).start();  </div><div class="line">6.    new Thread(t).start();  </div><div class="line">7.    new Thread(t).start();  </div><div class="line">8.  &#125;  </div><div class="line">9.&#125;  </div><div class="line"></div><div class="line">1.class ThreadTest implements Runnable&#123;   </div><div class="line">2.  public void run()&#123; </div><div class="line">3.     private int tickets = 100; //局部变量，如果是成员变量，则所有线程则共享它，会出现问题 </div><div class="line">4.    while(true)&#123;  </div><div class="line">5.      if(tickets &gt; 0)&#123;  </div><div class="line">6.        System.out.println(Thread.currentThread().getName() +  </div><div class="line">7.          &quot; is saling ticket &quot; + tickets--);  </div><div class="line">8.      &#125;  </div><div class="line">9.    &#125;  </div><div class="line">10.  &#125;  </div><div class="line">11.&#125;</div></pre></td></tr></table></figure>
<p>【注意】创建了四个线程，每个线程调用的是同一个ThreadTest对象中的run()方法，访问的是同一个对象中的变量（tickets）的实例<br>　如果一个变量是成员变量，那么多个线程对同一个对象的成员变量进行操作时，它们对该成员变量是彼此影响的，也就是说一个线程对成员变量的改变会影响到另一个线程。<br>　如果一个变量是局部变量，那么每个线程都会有一个该局部变量的拷贝（即便是同一个对象中的方法的局部变量，也会对每一个线程有一个拷贝），一个线程对该局部变量的改变不会影响到其他线程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;线程的实现方式/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;线程实现方式&quot;&gt;&lt;a href=&quot;#线程实现方式&quot; class=&quot;headerlink&quot; title=&quot;线程实现方式&quot;&gt;&lt;/a&gt;线程实现方式&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;继承java.lang.Thread类  &lt;/li&gt;
&lt;li&gt;实现java.lang.Runnable接口&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;区别：&lt;/strong&gt;第一种是继承，第二种是实现&lt;br&gt;&lt;strong&gt;好处：&lt;/strong&gt;  在实际开发中通常以实现Runnable接口为主，因为实现Runnable接口相比继承Thread类可以避免继承的局限，一个类可以继承多个接口，适合于资源的共享&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://jethan.bid/categories/java/"/>
    
      <category term="java基础" scheme="http://jethan.bid/categories/java/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="thread" scheme="http://jethan.bid/tags/thread/"/>
    
      <category term="runnable" scheme="http://jethan.bid/tags/runnable/"/>
    
  </entry>
  
  <entry>
    <title>jvm调优</title>
    <link href="http://jethan.bid/2017/08/05/jvm%E8%B0%83%E4%BC%98/"/>
    <id>http://jethan.bid/2017/08/05/jvm调优/</id>
    <published>2017-08-05T08:05:44.000Z</published>
    <updated>2017-08-05T08:05:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="jvm调优/java.jpg" alt="java" title="java"></p>
<h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p>1.根据Java虚拟机规范，JVM将内存划分为：<br><strong>New（年轻代）<br>Tenured（年老代）<br>永久代（Perm）</strong><br><a id="more"></a><br><img src="jvm调优/jvm2.gif" alt="jvm" title="jvm"><br>  其中New和Tenured属于堆内存，堆内存会从JVM启动参数（-Xmx:3G）指定的内存中分配，Perm不属于堆内存，有虚拟机直接分配，但可以通过-XX:PermSize -XX:MaxPermSize 等参数调整其大小。<br><img src="jvm调优/jvm4.jpg" alt="jvm" title="jvm"></p>
<p><strong>年轻代（New）：</strong>年轻代用来存放JVM刚分配的Java对象<br><strong>年老代（Tenured)：</strong>年轻代中经过垃圾回收没有回收掉的对象将被Copy到年老代<br><strong>永久代（Perm）：</strong>永久代存放Class、Method元信息，其大小跟项目的规模、类、方法的量有关，一般设置为128M就足够，设置原则是预留30%的空间。</p>
<p>New又分为几个部分：<br><strong>Eden：</strong>Eden用来存放JVM刚分配的对象<br><strong>Survivor1</strong><br><strong>Survivro2：</strong>两个Survivor空间一样大，当Eden中的对象经过垃圾回收没有被回收掉时，会在两个Survivor之间来回Copy，当满足某个条件，比如Copy次数，就会被Copy到Tenured。显然，Survivor只是增加了对象在年轻代中的逗留时间，增加了被垃圾回收的可能性。</p>
<p><strong>各代如何设置比例</strong><br><strong>堆大小设置</strong><br>JVM 中最大堆大小有三方面限制：相关操作系统的数据模型（32-bt还是64-bit）限制；系统的可用虚拟内存限制；系统的可用物理内存限制。32位系统下，一般限制在1.5G~2G；64为操作系统对内存无限制。我在Windows Server 2003 系统，3.5G物理内存，JDK5.0下测试，最大可设置为1478m。<br><strong>典型设置：</strong><br>- java -Xmx3550m -Xms3550m -Xmn2g -Xss128k<br>- -Xmx3550m：设置JVM最大可用内存为3550M。<br>- -Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。<br>- -Xmn2g：设置年轻代大小为2G。整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。<br>- -Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。<br>- java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0<br>- -XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5<br>- -XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6<br>- -XX:MaxPermSize=16m:设置持久代大小为16m。<br>- -XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。 </p>
<p>如果程序确实需要大量的线程，现有的设置不能达到要求，那么可以通过修改MaxProcessMemory，JVMMemory，ThreadStackSize这三个因素，来增加能创建的线程数：<br>a. MaxProcessMemory 使用64位JVM<br>    经测试在，64位jvm下生成的线程数不受上述公式的制约，值为63260，这个数值应该足够用了，<br>    测试数据如下, (指令|能启动的线程数量)</p>
<p>java -Xms512M -Xmx2G -cp . TestNativeOutOfMemoryError  | 63389<br>java -Xms512M -Xmx8G -cp . TestNativeOutOfMemoryError  | 63260<br>java -Xms512M -Xmx16G -cp . TestNativeOutOfMemoryError  | 63385<br>java -Xms512M -Xmx32G -cp . TestNativeOutOfMemoryError  | 63380<br>java -Xms512M -Xmx64G -cp . TestNativeOutOfMemoryError  |63387</p>
<p>b. JVMMemory   减少JVMMemory的分配(即减少xms/xmx的大小)<br>c. ThreadStackSize  减小单个线程的栈大小 (-Xss)</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>垃圾回收算法可以分为三类，都基于标记-清除（复制）算法：<br><strong>Serial算法（单线程）<br>并行算法<br>并发算法</strong><br>JVM会根据机器的硬件配置对每个内存代选择适合的回收算法，比如，如果机器多于1个核，会对年轻代选择并行算法，关于选择细节请参考JVM调优文档。 </p>
<p>稍微解释下的是，并行算法是用多线程进行垃圾回收，回收期间会暂停程序的执行，而并发算法，也是多线程回收，但期间不停止应用执行。所以，并发算法适用于交互性高的一些程序。经过观察，并发算法会减少年轻代的大小，其实就是使用了一个大的年老代，这反过来跟并行算法相比吞吐量相对较低。  </p>
<p><strong>还有一个问题是，垃圾回收动作何时执行？</strong></p>
<ul>
<li>当年轻代内存满时，会引发一次普通GC，该GC仅回收年轻代。需要强调的时，年轻代满是指Eden代满，Survivor满不会引发GC</li>
<li>当年老代满时会引发Full GC，Full GC将会同时回收年轻代、年老代</li>
<li>当永久代满时也会引发Full GC，会导致Class、Method元信息的卸载<br>另一个问题是，何时会抛出OutOfMemoryException，并不是内存被耗空的时候才抛出</li>
<li>JVM98%的时间都花费在内存回收</li>
<li>每次回收的内存小于2%<br>满足这两个条件将触发OutOfMemoryException，这将会留给系统一个微小的间隙以做一些Down之前的操作，比如手动打印Heap Dump。</li>
</ul>
<h2 id="内存泄漏及解决方法"><a href="#内存泄漏及解决方法" class="headerlink" title="内存泄漏及解决方法"></a>内存泄漏及解决方法</h2><p><img src="jvm调优/jvm.jpeg" alt="jvm" title="jvm"><br><img src="jvm调优/jvm内存溢出.png" alt="jvm" title="jvm"><br>1.系统崩溃前的一些现象：</p>
<ul>
<li>每次垃圾回收的时间越来越长，由之前的10ms延长到50ms左右，FullGC的时间也有之前的0.5s延长到4、5s</li>
<li>FullGC的次数越来越多，最频繁时隔不到1分钟就进行一次FullGC</li>
<li>年老代的内存越来越大并且每次FullGC后年老代没有内存被释放<br>之后系统会无法响应新的请求，逐渐到达OutOfMemoryError的临界值。</li>
</ul>
<p>2.生成堆的dump文件<br> 通过JMX的MBean生成当前的Heap信息，大小为一个3G（整个堆的大小）的hprof文件，如果没有启动JMX可以通过Java的jmap命令来生成该文件。<br> <img src="jvm调优/jmap.png" alt="jvm" title="jvm"></p>
<p>3.分析dump文件<br> 下面要考虑的是如何打开这个3G的堆信息文件，显然一般的Window系统没有这么大的内存，必须借助高配置的Linux。当然我们可以借助X-Window把Linux上的图形导入到Window。我们考虑用下面几种工具打开该文件：</p>
<ul>
<li>Visual VM  </li>
<li>IBM HeapAnalyzer  </li>
<li>JDK 自带的Hprof工具  </li>
</ul>
<p>使用这些工具时为了确保加载速度，建议设置最大内存为6G。使用后发现，这些工具都无法直观地观察到内存泄漏，Visual VM虽能观察到对象大小，但看不到调用堆栈；HeapAnalyzer虽然能看到调用堆栈，却无法正确打开一个3G的文件。因此，我们又选用了Eclipse专门的静态内存分析工具：Mat。</p>
<p>4.分析内存泄漏<br> 通过Mat我们能清楚地看到，哪些对象被怀疑为内存泄漏，哪些对象占的空间最大及对象的调用关系。针对本案，在ThreadLocal中有很多的JbpmContext实例，经过调查是JBPM的Context没有关闭所致。<br> 另，通过Mat或JMX我们还可以分析线程状态，可以观察到线程被阻塞在哪个对象上，从而判断系统的瓶颈。  </p>
<p>5.回归问题<br>   Q：<strong>为什么崩溃前垃圾回收的时间越来越长？</strong><br>   A:根据内存模型和垃圾回收算法，垃圾回收分两部分：内存标记、清除（复制），标记部分只要内存大小固定时间是不变的，变的是复制部分，因为每次垃圾回收都有一些回收不掉的内存，所以增加了复制量，导致时间延长。所以，垃圾回收的时间也可以作为判断内存泄漏的依据<br>   Q：<strong>为什么Full GC的次数越来越多？</strong><br>   A：因此内存的积累，逐渐耗尽了年老代的内存，导致新对象分配没有更多的空间，从而导致频繁的垃圾回收<br>   Q:<strong>为什么年老代占用的内存越来越大？</strong><br>   A:因为年轻代的内存无法被回收，越来越多地被Copy到年老代  </p>
<h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><p> 除了上述内存泄漏外，我们还发现CPU长期不足3%，系统吞吐量不够，针对8core×16G、64bit的Linux服务器来说，是严重的资源浪费。<br> 在CPU负载不足的同时，偶尔会有用户反映请求的时间过长，我们意识到必须对程序及JVM进行调优。从以下几个方面进行：  </p>
<ul>
<li>线程池：解决用户响应时间长的问题  </li>
<li>连接池  </li>
<li>JVM启动参数：调整各代的内存比例和垃圾回收算法，提高吞吐量  </li>
<li>程序算法：改进程序逻辑算法提高性能</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;jvm调优/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;JVM内存模型&quot;&gt;&lt;a href=&quot;#JVM内存模型&quot; class=&quot;headerlink&quot; title=&quot;JVM内存模型&quot;&gt;&lt;/a&gt;JVM内存模型&lt;/h2&gt;&lt;p&gt;1.根据Java虚拟机规范，JVM将内存划分为：&lt;br&gt;&lt;strong&gt;New（年轻代）&lt;br&gt;Tenured（年老代）&lt;br&gt;永久代（Perm）&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://jethan.bid/categories/java/"/>
    
      <category term="jvm" scheme="http://jethan.bid/categories/java/jvm/"/>
    
    
      <category term="性能调优" scheme="http://jethan.bid/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>web.xml加载顺序</title>
    <link href="http://jethan.bid/2017/08/05/web-xml%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/"/>
    <id>http://jethan.bid/2017/08/05/web-xml加载顺序/</id>
    <published>2017-08-05T06:42:06.000Z</published>
    <updated>2017-08-05T06:42:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="web.xml加载顺序/java.jpg" alt="java" title="java"></p>
<p><strong>web.xml 的加载顺序:</strong><br>ServletContext-&gt; context-param -&gt;listener -&gt; filter -&gt; servlet，而同个类型之间的实际程序调用的时候的顺序是根据对应的 mapping 的顺序进行调用的。ServletContext即Servlet上下文对象，该对象表示当前的web应用环境信息，一个Web应用只会创建一个ServletContext对象。</p>
<p>Web容器启动的时候，它会为每个Web应用程序都创建一个对应的ServletContext对象，它代表当前的web应用。<br>[注意]由于一个Web应用中的所有Servlet共享一个ServletContext对象，所以多个Servlet通过ServletContext对象实现数据共享，ServletContext对象通常称为Context域对象。<br><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;web.xml加载顺序/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;web.xml 的加载顺序:&lt;/strong&gt;&lt;br&gt;ServletContext-&amp;gt; context-param -&amp;gt;listener -&amp;gt; filter -&amp;gt; servlet，而同个类型之间的实际程序调用的时候的顺序是根据对应的 mapping 的顺序进行调用的。ServletContext即Servlet上下文对象，该对象表示当前的web应用环境信息，一个Web应用只会创建一个ServletContext对象。&lt;/p&gt;
&lt;p&gt;Web容器启动的时候，它会为每个Web应用程序都创建一个对应的ServletContext对象，它代表当前的web应用。&lt;br&gt;[注意]由于一个Web应用中的所有Servlet共享一个ServletContext对象，所以多个Servlet通过ServletContext对象实现数据共享，ServletContext对象通常称为Context域对象。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://jethan.bid/categories/java/"/>
    
      <category term="java基础" scheme="http://jethan.bid/categories/java/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="web.xml加载顺序" scheme="http://jethan.bid/tags/web-xml%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>sping之IOC，AOP</title>
    <link href="http://jethan.bid/2017/08/05/sping%E4%B9%8BIOC%EF%BC%8CAOP/"/>
    <id>http://jethan.bid/2017/08/05/sping之IOC，AOP/</id>
    <published>2017-08-05T06:34:04.000Z</published>
    <updated>2017-08-05T06:34:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="sping之IOC，AOP/spring.jpg" alt="spring" title="spring"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Spring AOP和IOC个人理解<br><strong>IOC inversion of control 控制反转</strong><br>将new对象的权力由调用者转移到spring容器（即xml文件），Struts2与Spring整合（scope=”prototype”）由spring来维护struts的生命周期，在启动web容器时spring容器创建action实例对象，又分两种方式：<br>第一种xml方式 需要set方法为被调用的属性赋值，xml中需要<code>ref</code>注入被调要的对象。<br>第二种注解方式 不需要set方法为被调用属性赋值，但需要在action层service层dao层的类上对应写上<br><code>@Controller,@Service,@Repository</code>通过在属性上加上<code>@Resource(name=&quot;&quot;)</code>来为属性赋值，这一步相当于xml方式的<code>ref</code>。<br>事务管理器<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;txManager&quot;class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt; </div><div class="line">&lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;&gt;&lt;/property&gt;  </div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>相当于切面需要注入<code>sessionFactory</code></p>
<p><strong>AOP Aspect Oriented Programming 面向切面编程</strong><br>通过代理的方式在需要的时候通过切入点给指定位置的程序添加逻辑代码或功能。声明事务处理分为两种方式：<br><strong>第一种xml方式:</strong> 需要在xml中配置事务的通知<code>&lt;tx:advice&gt;</code>里面放增删改查等方法的<code>isolation=&quot;DEFAULT&quot;        propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot;&lt;/tx:advice&gt;）</code><br>用切面关联通知，然后再用通知关联切入点<code>&lt;aop:config&gt;</code>（即事务操作业务层）切入地点是所有service 包及其子包下类的所有方法。<br><strong>第二种注解方式:</strong> 使用注解的方式配置声明式事务处理，在Service层类中，<code>@Transcational</code>(事务处理的)     <code>&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;</code><br>不需要关联通知也不需要通知关联切入点</p>
<h2 id="spring的基本框架主要包含六大模块：DAO、ORM、AOP、JEE、WEB、CORE"><a href="#spring的基本框架主要包含六大模块：DAO、ORM、AOP、JEE、WEB、CORE" class="headerlink" title="spring的基本框架主要包含六大模块：DAO、ORM、AOP、JEE、WEB、CORE"></a>spring的基本框架主要包含六大模块：DAO、ORM、AOP、JEE、WEB、CORE</h2><p><img src="sping之IOC，AOP/spring-structure.png" alt="spring" title="spring"></p>
<p><strong>Spring DAO：</strong>Spring提供了对JDBC的操作支持：JdbcTemplate模板工具类 。<br><strong>Spring ORM：</strong>Spring可以与ORM框架整合。例如Spring整合Hibernate框架，其中Spring还提供  HibernateDaoSupport工具类，简化了Hibernate的操作 。<br><strong>Spring WEB：</strong>Spring提供了对Struts、Springmvc的支持，支持WEB开发。与此同时Spring自身也提供了基于MVC的解决方案 。<br><strong>Spring  AOP：</strong>Spring提供面向切面的编程，可以给某一层提供事务管理，例如在Service层添加事物控制 。<br><strong>Spring   JEE：</strong>J2EE开发规范的支持，例如EJB 。<br><strong>8Spring Core：</strong>提供IOC容器对象的创建和处理依赖对象关系 。  </p>
<h2 id="Spring下IOC容器和DI-依赖注入Dependency-injection"><a href="#Spring下IOC容器和DI-依赖注入Dependency-injection" class="headerlink" title="Spring下IOC容器和DI(依赖注入Dependency injection)"></a>Spring下IOC容器和DI(依赖注入Dependency injection)</h2><p>　　<strong>IOC容器：</strong>就是具有依赖注入功能的容器，是可以创建对象的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。通常new一个实例，控制权由程序员控制，而”控制反转”是指new实例工作不由程序员来做而是交给Spring容器来做。。在Spring中BeanFactory是IOC容器的实际代表者。<br>　　<strong>DI(依赖注入Dependency injection) ：</strong>在容器创建对象后，处理对象的依赖关系。<br>依赖注入spring的注入方式： </p>
<p><strong>set注入方式<br>静态工厂注入方式<br>构造方法注入方式<br>基于注解的方式 </strong><br>1、 set注入方式：<br>控制层代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private OrderServiceImp orderService;</div><div class="line">    public void setOrderService(OrderServiceImp orderService) &#123;</div><div class="line">       this.orderService = orderService;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Spring配置XML文件：其中配置声明OrderAction类存在属性orderService。程式运行时候，会将已经实例化的orderService对象调用setOrderService方式注入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;bean name=&quot;orderAction&quot; class=&quot;com.pec.action.OrderAction&quot;&gt;</div><div class="line">        &lt;property name=&quot;orderService&quot; ref=&quot;orderService&quot;&gt;&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line">&lt;bean name=&quot;orderService&quot; class=&quot;com.pec.service.imp.OrderServiceImp&quot;&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>2、 构造器注入方式：<br>控制层代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private OrderServiceImp orderService;</div><div class="line">    public OrderAction(OrderServiceImp orderService) &#123;</div><div class="line">        this.orderService = orderService;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>Spring配置XML文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;bean name=&quot;orderAction&quot; class=&quot;com.pec.action.OrderAction&quot;&gt;</div><div class="line">      &lt;constructor-arg ref=&quot;orderService&quot;&gt;&lt;/constructor-arg&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line">&lt;bean name=&quot;orderService&quot; class=&quot;com.pec.service.imp.OrderServiceImp&quot;&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>3、基于注解的方式 （推荐使用，比较便捷少配置）<br>控制层代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@Autowired   //@Resourceprivate OrderServiceImp orderService;</div></pre></td></tr></table></figure></p>
<p>服务层代码：</p>
<pre><code>    @Service(&quot;orderService&quot;)
    public class OrderServiceImp implements IOrderService {

    @Autowired
    private JavaOrderMDaoImp javaOrderMDao;

    @Autowired
    private JavaOrderDDaoImp javaOrderDDao;

    @Override
    public List&lt;JavaOrderMList&gt; findOrderM(OrderSearch search) {
        return javaOrderMDao.findJavaOrderM(search);
    }

    @Override
    public List&lt;JavaOrderDList&gt; findOrderD(OrderSearch search) {
        return javaOrderDDao.findJavaOrderD(search);
    }

}
</code></pre><p> DAO层代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Repository(&quot;javaOrderMDao&quot;)</div><div class="line">public class JavaOrderMDaoImp extends BaseHibernateDAO&lt;JavaOrderM, Serializable&gt; implements IJavaOrderMDao &#123;...&#125;</div><div class="line">@Repository(&quot;javaOrderDDao&quot;)</div><div class="line">public class JavaOrderDDaoImp extendsBaseHibernateDAO&lt;JavaOrderD, Serializable&gt; implements IJavaOrderDDao &#123;...&#125;</div></pre></td></tr></table></figure></p>
<p>【注意点】<br>⑴ 持久层DAO层注解Repository中规定了名称，在Service层中声明名称必须一致。<br>⑵ 服务层Service层注解Service中规定了名称，在控制层中声明的名称必须一致。<br>⑶ 注解方式注入依赖注解：</p>
<p><strong>@Component </strong>        把对象加入ioc容器，对象引用名称是类名，第一个字母小写<br><strong>@Component(“name”)</strong> 把指定名称的对象，加入ioc容器<br><strong>@Repository</strong>        主要用于标识加入容器的对象是一个持久层的组件(类)<br><strong>@Service</strong>           主要用于标识加入容器的对象是一个业务逻辑层的组件<br><strong>@Controller </strong>       主要用于标识加入容器的对象是一个控制层的组件<br><strong>@Resource </strong>         注入属性(DI), 会从容器中找对象注入到@Resource修饰的对象上<br><strong>@Autowired </strong>        注入属性(DI), 会从容器中找对象注入到@Autowired修饰的对象上</p>
<p><strong>开启注解</strong><br><code>&lt;mvc:annotation-driven/&gt;</code><br><strong>静态资源由WEB服务器默认的Servlet来处理    ，必须和<mvc:annotation-driven>一起</mvc:annotation-driven></strong><br><code>&lt;mvc:default-servlet-handler/&gt;</code><br><strong>包扫描路径</strong><br><code>&lt;context:component-scan base-package=&quot;com.fh.controller&quot; /&gt;</code></p>
<p>注解可以简化配置，提升开发效率，但是也不利于后期维护。</p>
<ol>
<li>@Autowired与@Resource都可以用来装配bean. 都可以写在字段上,或写在setter方法上。   </li>
<li><p>@Autowired默认按类型装配（这个注解是属业spring的），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@Autowired() @Qualifier(&quot;baseDao&quot;)     </div><div class="line">private BaseDao baseDao;</div></pre></td></tr></table></figure>
</li>
<li><p>@Resource（这个注解属于J2EE的），默认安照名称进行装配，名称可以通过name属性进行指定，<br>如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。 当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@Resource(name=&quot;baseDao&quot;)     </div><div class="line">private BaseDao baseDao;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>我喜欢用 @Resource注解在字段上，且这个注解是属于J2EE的，减少了与spring的耦合。最重要的这样代码看起就比较优雅。  </p>
<h2 id="Spring面向切面编程-AOP-和事务管理配置"><a href="#Spring面向切面编程-AOP-和事务管理配置" class="headerlink" title="Spring面向切面编程(AOP)和事务管理配置"></a>Spring面向切面编程(AOP)和事务管理配置</h2><p>AOP就是纵向的编程，如业务1和业务2都需要一个共同的操作，与其往每个业务中都添加同样的代码，不如写一遍代码，让两个业务共同使用这段代码。在日常有订单管理、商品管理、资金管理、库存管理等业务，都会需要到类似日志记录、事务控制、权限控制、性能统计、异常处理及事务处理等。AOP把所有共有代码全部抽取出来，放置到某个地方集中管理，然后在具体运行时，再由容器动态织入这些共有代码。<br><img src="sping之IOC，AOP/aop.png" alt="spring" title="spring"></p>
<p>AOP涉及名称：<br><strong>切面（Aspect）：</strong>其实就是共有功能的实现。如日志切面、权限切面、事务切面等。在实际应用中通常是一个存放共有功能实现的普通Java类，之所以能被AOP容器识别成切面，是在配置中指定的。<br><strong>通知（Advice）：</strong>是切面的具体实现。以目标方法为参照点，根据放置的地方不同，可分为前置通知（Before）、后置通知（AfterReturning）、异常通知（AfterThrowing）、最终通知（After）与环绕通知（Around）5种。在实际应用中通常是切面类中的一个方法，具体属于哪类通知，同样是在配置中指定的。<br><strong>连接点（Joinpoint）：</strong>就是程序在运行过程中能够插入切面的地点。例如，方法调用、异常抛出或字段修改等，但Spring只支持方法级的连接点。<br><strong>切入点（Pointcut）：</strong>用于定义通知应该切入到哪些连接点上。不同的通知通常需要切入到不同的连接点上，这种精准的匹配是由切入点的正则表达式来定义的。<br><strong>目标对象（Target）：</strong>就是那些即将切入切面的对象，也就是那些被通知的对象。这些对象中已经只剩下干干净净的核心业务逻辑代码了，所有的共有功能代码等待AOP容器的切入。<br><strong>代理对象（Proxy）：</strong>将通知应用到目标对象之后被动态创建的对象。可以简单地理解为，代理对象的功能等于目标对象的核心业务逻辑功能加上共有功能。代理对象对于使用者而言是透明的，是程序运行过程中的产物。<br><strong>织入（Weaving）：</strong>将切面应用到目标对象从而创建一个新的代理对象的过程。这个过程可以发生在编译期、类装载期及运行期，当然不同的发生点有着不同的前提条件。譬如发生在编译期的话，就要求有一个支持这种AOP实现的特殊编译器；发生在类装载期，就要求有一个支持AOP实现的特殊类装载器；只有发生在运行期，则可直接通过Java语言的反射机制与动态代理机制来动态实现。<br> Spring配置文件中关于事务配置总是由三个组成部分，分别是DataSource、TransactionManager和代理机制这三部分，无论哪种配置方式，一般变化的只是代理机制这部分。<br>  DataSource、TransactionManager这两部分只是会根据数据访问方式有所变化，比如使用hibernate进行数据访问时，DataSource实际为SessionFactory，TransactionManager的实现为HibernateTransactionManager。<br><img src="sping之IOC，AOP/spring.gif" alt="spring" title="spring"><br>根据代理机制的不同，总结了五种Spring事务的配置方式，配置文件如下：<br>第一种方式：每个Bean都有一个代理  </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-2.5.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd&quot;&gt;

&lt;bean id=&quot;sessionFactory&quot;  
        class=&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&gt;  
    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot; /&gt;  
    &lt;property name=&quot;configurationClass&quot; value=&quot;org.hibernate.cfg.AnnotationConfiguration&quot; /&gt;
&lt;/bean&gt;  

&lt;!-- 定义事务管理器（声明式的事务） --&gt;  
&lt;bean id=&quot;transactionManager&quot;
    class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;
&lt;/bean&gt;

&lt;!-- 配置DAO --&gt;
&lt;bean id=&quot;userDaoTarget&quot; class=&quot;com.bluesky.spring.dao.UserDaoImpl&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userDao&quot;  
    class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&gt;  
       &lt;!-- 配置事务管理器 --&gt;  
       &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot; /&gt;     
    &lt;property name=&quot;target&quot; ref=&quot;userDaoTarget&quot; /&gt;  
     &lt;property name=&quot;proxyInterfaces&quot; value=&quot;com.bluesky.spring.dao.GeneratorDao&quot; /&gt;
    &lt;!-- 配置事务属性 --&gt;  
    &lt;property name=&quot;transactionAttributes&quot;&gt;  
        &lt;props&gt;  
            &lt;prop key=&quot;*&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;/props&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;  
&lt;/beans&gt;
</code></pre><p>第二种方式：所有Bean共享一个代理基类</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-2.5.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd&quot;&gt;

&lt;bean id=&quot;sessionFactory&quot;  
        class=&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&gt;  
    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot; /&gt;  
    &lt;property name=&quot;configurationClass&quot; value=&quot;org.hibernate.cfg.AnnotationConfiguration&quot; /&gt;
&lt;/bean&gt;  

&lt;!-- 定义事务管理器（声明式的事务） --&gt;  
&lt;bean id=&quot;transactionManager&quot;
    class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;transactionBase&quot;  
        class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;  
        lazy-init=&quot;true&quot; abstract=&quot;true&quot;&gt;  
    &lt;!-- 配置事务管理器 --&gt;  
    &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot; /&gt;  
    &lt;!-- 配置事务属性 --&gt;  
    &lt;property name=&quot;transactionAttributes&quot;&gt;  
        &lt;props&gt;  
            &lt;prop key=&quot;*&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt;  
        &lt;/props&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;    

&lt;!-- 配置DAO --&gt;
&lt;bean id=&quot;userDaoTarget&quot; class=&quot;com.bluesky.spring.dao.UserDaoImpl&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userDao&quot; parent=&quot;transactionBase&quot; &gt;  
    &lt;property name=&quot;target&quot; ref=&quot;userDaoTarget&quot; /&gt;   
&lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>第三种方式：使用拦截器</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-2.5.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd&quot;&gt;

&lt;bean id=&quot;sessionFactory&quot;  
        class=&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&gt;  
    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot; /&gt;  
    &lt;property name=&quot;configurationClass&quot; value=&quot;org.hibernate.cfg.AnnotationConfiguration&quot; /&gt;
&lt;/bean&gt;  

&lt;!-- 定义事务管理器（声明式的事务） --&gt;  
&lt;bean id=&quot;transactionManager&quot;
    class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;
&lt;/bean&gt; 

&lt;bean id=&quot;transactionInterceptor&quot;  
    class=&quot;org.springframework.transaction.interceptor.TransactionInterceptor&quot;&gt;  
    &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot; /&gt;  
    &lt;!-- 配置事务属性 --&gt;  
    &lt;property name=&quot;transactionAttributes&quot;&gt;  
        &lt;props&gt;  
            &lt;prop key=&quot;*&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt;  
        &lt;/props&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;

&lt;bean class=&quot;org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator&quot;&gt;  
    &lt;property name=&quot;beanNames&quot;&gt;  
        &lt;list&gt;  
            &lt;value&gt;*Dao&lt;/value&gt;
        &lt;/list&gt;  
    &lt;/property&gt;  
    &lt;property name=&quot;interceptorNames&quot;&gt;  
        &lt;list&gt;  
            &lt;value&gt;transactionInterceptor&lt;/value&gt;  
        &lt;/list&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;  

&lt;!-- 配置DAO --&gt;
&lt;bean id=&quot;userDao&quot; class=&quot;com.bluesky.spring.dao.UserDaoImpl&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;
&lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>第四种方式：使用tx标签配置的拦截器</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-2.5.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd
       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&quot;&gt;

&lt;context:annotation-config /&gt;
&lt;context:component-scan base-package=&quot;com.bluesky&quot; /&gt;

&lt;bean id=&quot;sessionFactory&quot;  
        class=&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&gt;  
    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot; /&gt;  
    &lt;property name=&quot;configurationClass&quot; value=&quot;org.hibernate.cfg.AnnotationConfiguration&quot; /&gt;
&lt;/bean&gt;  

&lt;!-- 定义事务管理器（声明式的事务） --&gt;  
&lt;bean id=&quot;transactionManager&quot;
    class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;
&lt;/bean&gt;

&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; /&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;

&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;interceptorPointCuts&quot;
        expression=&quot;execution(* com.bluesky.spring.dao.*.*(..))&quot; /&gt;
    &lt;aop:advisor advice-ref=&quot;txAdvice&quot;
        pointcut-ref=&quot;interceptorPointCuts&quot; /&gt;        
&lt;/aop:config&gt;      
&lt;/beans&gt;
</code></pre><p>第五种方式：全注解</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-2.5.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd
       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&quot;&gt;

&lt;context:annotation-config /&gt;
&lt;context:component-scan base-package=&quot;com.bluesky&quot; /&gt;

&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;

&lt;bean id=&quot;sessionFactory&quot;  
        class=&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&gt;  
    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot; /&gt;  
    &lt;property name=&quot;configurationClass&quot; value=&quot;org.hibernate.cfg.AnnotationConfiguration&quot; /&gt;
&lt;/bean&gt;  

&lt;!-- 定义事务管理器（声明式的事务） --&gt;  
&lt;bean id=&quot;transactionManager&quot;
    class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;
&lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>此时在DAO上需加上@Transactional注解，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.bluesky.spring.dao;</div><div class="line"></div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">import org.hibernate.SessionFactory;</div><div class="line">import org.springframework.beans.factory.annotation.Autowired;</div><div class="line">import org.springframework.orm.hibernate3.support.HibernateDaoSupport;</div><div class="line">import org.springframework.stereotype.Component;</div><div class="line"></div><div class="line">import com.bluesky.spring.domain.User;</div><div class="line"></div><div class="line">@Transactional</div><div class="line">@Component(&quot;userDao&quot;)</div><div class="line">public class UserDaoImpl extends HibernateDaoSupport implements UserDao &#123;</div><div class="line"></div><div class="line">    public List&lt;User&gt; listUsers() &#123;</div><div class="line">        return this.getSession().createQuery(&quot;from User&quot;).list();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;sping之IOC，AOP/spring.jpg&quot; alt=&quot;spring&quot; title=&quot;spring&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Spring AOP和IOC个人理解&lt;br&gt;&lt;strong&gt;IOC inversion of control 控制反转&lt;/strong&gt;&lt;br&gt;将new对象的权力由调用者转移到spring容器（即xml文件），Struts2与Spring整合（scope=”prototype”）由spring来维护struts的生命周期，在启动web容器时spring容器创建action实例对象，又分两种方式：&lt;br&gt;第一种xml方式 需要set方法为被调用的属性赋值，xml中需要&lt;code&gt;ref&lt;/code&gt;注入被调要的对象。&lt;br&gt;第二种注解方式 不需要set方法为被调用属性赋值，但需要在action层service层dao层的类上对应写上&lt;br&gt;&lt;code&gt;@Controller,@Service,@Repository&lt;/code&gt;通过在属性上加上&lt;code&gt;@Resource(name=&amp;quot;&amp;quot;)&lt;/code&gt;来为属性赋值，这一步相当于xml方式的&lt;code&gt;ref&lt;/code&gt;。&lt;br&gt;事务管理器&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://jethan.bid/categories/java/"/>
    
      <category term="spring" scheme="http://jethan.bid/categories/java/spring/"/>
    
    
      <category term="IOC" scheme="http://jethan.bid/tags/IOC/"/>
    
      <category term="AOP" scheme="http://jethan.bid/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>spring事务的传播属性和隔离级别</title>
    <link href="http://jethan.bid/2017/08/05/spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://jethan.bid/2017/08/05/spring事务的传播属性和隔离级别/</id>
    <published>2017-08-05T04:03:28.000Z</published>
    <updated>2017-08-05T04:03:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/spring.jpg" alt="spring" title="spring"></p>
<h2 id="spring事务传播属性"><a href="#spring事务传播属性" class="headerlink" title="spring事务传播属性"></a>spring事务传播属性</h2><p><strong>Propagation（事务的传播属性） ：</strong>key属性确定代理应该给哪个方法增加事务行为。这样的属性最重要的部份是传播行为。有以下选项可供使用：<br><strong>PROPAGATION_REQUIRED</strong>—支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。<br><strong>PROPAGATION_SUPPORTS</strong>—支持当前事务，如果当前没有事务，就以非事务方式执行。<br><strong>PROPAGATION_MANDATORY</strong>—支持当前事务，如果当前没有事务，就抛出异常。<br><strong>PROPAGATION_REQUIRES_NEW</strong>—新建事务，如果当前存在事务，把当前事务挂起。<br><strong>PROPAGATION_NOT_SUPPORTED</strong>—以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br><strong>PROPAGATION_NEVER</strong>—以非事务方式执行，如果当前存在事务，则抛出异常。<br><a id="more"></a></p>
<ol>
<li>PROPAGATION_REQUIRED<br>加入当前正要执行的事务不在另外一个事务里，那么就起一个新的事务<br>比如说，ServiceB.methodB的事务级别定义为PROPAGATION_REQUIRED, 那么由于执行ServiceA.methodA的时候，<br>ServiceA.methodA已经起了事务，这时调用ServiceB.methodB，ServiceB.methodB看到自己已经运行在ServiceA.methodA<br>的事务内部，就不再起新的事务。而假如ServiceA.methodA运行的时候发现自己没有在事务中，他就会为自己分配一个事务。<br>这样，在ServiceA.methodA或者在ServiceB.methodB内的任何地方出现异常，事务都会被回滚。即使ServiceB.methodB的事务已经被<br>提交，但是ServiceA.methodA在接下来fail要回滚，ServiceB.methodB也要回滚</li>
<li>PROPAGATION_SUPPORTS<br>如果当前在事务中，即以事务的形式运行，如果当前不再一个事务中，那么就以非事务的形式运行</li>
<li>PROPAGATION_MANDATORY<br>必须在一个事务中运行。也就是说，他只能被一个父事务调用。否则，他就要抛出异常</li>
<li>PROPAGATION_REQUIRES_NEW<br>这个就比较绕口了。 比如我们设计ServiceA.methodA的事务级别为PROPAGATION_REQUIRED，ServiceB.methodB的事务级别为PROPAGATION_REQUIRES_NEW，<br>那么当执行到ServiceB.methodB的时候，ServiceA.methodA所在的事务就会挂起，ServiceB.methodB会起一个新的事务，等待ServiceB.methodB的事务完成以后，<br>他才继续执行。他与PROPAGATION_REQUIRED 的事务区别在于事务的回滚程度了。因为ServiceB.methodB是新起一个事务，那么就是存在<br>两个不同的事务。如果ServiceB.methodB已经提交，那么ServiceA.methodA失败回滚，ServiceB.methodB是不会回滚的。如果ServiceB.methodB失败回滚，<br>如果他抛出的异常被ServiceA.methodA捕获，ServiceA.methodA事务仍然可能提交。</li>
<li>PROPAGATION_NOT_SUPPORTED<br>当前不支持事务。比如ServiceA.methodA的事务级别是PROPAGATION_REQUIRED ，而ServiceB.methodB的事务级别是PROPAGATION_NOT_SUPPORTED ，<br>那么当执行到ServiceB.methodB时，ServiceA.methodA的事务挂起，而他以非事务的状态运行完，再继续ServiceA.methodA的事务。</li>
<li>PROPAGATION_NEVER<br>不能在事务中运行。假设ServiceA.methodA的事务级别是PROPAGATION_REQUIRED， 而ServiceB.methodB的事务级别是PROPAGATION_NEVER ，<br>那么ServiceB.methodB就要抛出异常了。</li>
<li>PROPAGATION_NESTED<br>理解Nested的关键是savepoint。他与PROPAGATION_REQUIRES_NEW的区别是，PROPAGATION_REQUIRES_NEW另起一个事务，将会与他的父事务相互独立，<br>而Nested的事务和他的父事务是相依的，他的提交是要等和他的父事务一块提交的。也就是说，如果父事务最后回滚，他也要回滚的。<br>而Nested事务的好处是他有一个savepoint。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ServiceA &#123;</div><div class="line">/**</div><div class="line">* 事务属性配置为 PROPAGATION_REQUIRED</div><div class="line">*/</div><div class="line">void methodA() &#123;</div><div class="line">try &#123;</div><div class="line">//savepoint</div><div class="line">ServiceB.methodB(); //PROPAGATION_NESTED 级别</div><div class="line">&#125; catch (SomeException) &#123;</div><div class="line">// 执行其他业务, 如 ServiceC.methodC();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说ServiceB.methodB失败回滚，那么ServiceA.methodA也会回滚到savepoint点上，ServiceA.methodA可以选择另外一个分支，比如<br>ServiceC.methodC，继续执行，来尝试完成自己的事务。<br>但是这个事务并没有在EJB标准中定义。</p>
<h2 id="Spring事务的隔离级别"><a href="#Spring事务的隔离级别" class="headerlink" title="Spring事务的隔离级别"></a>Spring事务的隔离级别</h2><ol>
<li><strong>ISOLATION_DEFAULT：</strong> 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.<br>  另外四个与JDBC的隔离级别相对应  </li>
<li><strong>ISOLATION_READ_UNCOMMITTED：</strong> 这是事务最低的隔离级别，它充许令外一个事务可以看到这个事务未提交的数据。<br>  这种隔离级别会产生脏读，不可重复读和幻像读。</li>
<li><strong>ISOLATION_READ_COMMITTED：</strong> 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据</li>
<li><strong>ISOLATION_REPEATABLE_READ：</strong> 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。<br>  它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。</li>
<li><strong>ISOLATION_SERIALIZABLE:</strong> 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。</li>
</ol>
<p><strong>事务的四个特性</strong>  </p>
<ol>
<li><strong>原子性（Atomicity）</strong><br>　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</li>
<li><strong>一致性（Consistency）</strong><br>　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。<br>　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</li>
<li><strong>隔离性（Isolation）</strong><br>　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。<br>　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。<br>　　关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。</li>
<li><strong>持久性（Durability）</strong><br>　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。<br>　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。<br>　　以上介绍完事务的四大特性(简称ACID)，现在重点来说明下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题：  <ol>
<li><strong>脏读:</strong> 指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据， 那么另外一<br>个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。  </li>
<li><strong>不可重复读:</strong> 指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。<br>那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据<br>可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。  </li>
<li><strong>幻觉读:</strong> 指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及<br>到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，<br>以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</li>
</ol>
</li>
</ol>
<p>除了防止脏读，不可重复读外，还避免了幻像读，需要设置事务隔离级别</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/spring.jpg&quot; alt=&quot;spring&quot; title=&quot;spring&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;spring事务传播属性&quot;&gt;&lt;a href=&quot;#spring事务传播属性&quot; class=&quot;headerlink&quot; title=&quot;spring事务传播属性&quot;&gt;&lt;/a&gt;spring事务传播属性&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Propagation（事务的传播属性） ：&lt;/strong&gt;key属性确定代理应该给哪个方法增加事务行为。这样的属性最重要的部份是传播行为。有以下选项可供使用：&lt;br&gt;&lt;strong&gt;PROPAGATION_REQUIRED&lt;/strong&gt;—支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。&lt;br&gt;&lt;strong&gt;PROPAGATION_SUPPORTS&lt;/strong&gt;—支持当前事务，如果当前没有事务，就以非事务方式执行。&lt;br&gt;&lt;strong&gt;PROPAGATION_MANDATORY&lt;/strong&gt;—支持当前事务，如果当前没有事务，就抛出异常。&lt;br&gt;&lt;strong&gt;PROPAGATION_REQUIRES_NEW&lt;/strong&gt;—新建事务，如果当前存在事务，把当前事务挂起。&lt;br&gt;&lt;strong&gt;PROPAGATION_NOT_SUPPORTED&lt;/strong&gt;—以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。&lt;br&gt;&lt;strong&gt;PROPAGATION_NEVER&lt;/strong&gt;—以非事务方式执行，如果当前存在事务，则抛出异常。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://jethan.bid/categories/java/"/>
    
      <category term="spring" scheme="http://jethan.bid/categories/java/spring/"/>
    
    
      <category term="事务传播属性" scheme="http://jethan.bid/tags/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7/"/>
    
      <category term="隔离级别" scheme="http://jethan.bid/tags/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>乐观锁与悲观锁及应用举例</title>
    <link href="http://jethan.bid/2017/08/05/%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%E5%8F%8A%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B/"/>
    <id>http://jethan.bid/2017/08/05/乐观锁与悲观锁及应用举例/</id>
    <published>2017-08-05T03:53:43.000Z</published>
    <updated>2017-08-05T03:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/mysql.jpg" alt="mysql" title="mysql"></p>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>   正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）的修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。<br>  以常用的mysql InnoDB存储引擎为例：加入商品表items表中有一个字段status，status=1表示该商品未被下单，status=2表示该商品已经被下单，那么我们对每个商品下单前必须确保此商品的status=1。假设有一件商品，其id为10000；如果不使用锁，那么操作方法如下:<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//查出商品状态</div><div class="line">select status from items where id=10000;</div><div class="line">//根据商品信息生成订单</div><div class="line">insert into orders(id,item_id) values(null,10000);</div><div class="line">//修改商品状态为2</div><div class="line">update Items set status=2 where id=10000;</div></pre></td></tr></table></figure>
<p><strong>上述场景在高并发环境下可能出现问题：</strong><br>前面已经提到只有商品的status=1是才能对它进行下单操作，上面第一步操作中，查询出来的商品status为1。但是当我们执行第三步update操作的时候，有可能出现其他人先一步对商品下单把Item的status修改为2了，但是我们并不知道数据已经被修改了，这样就可能造成同一个商品被下单2次，使得数据不一致。所以说这种方式是不安全的。<br>使用悲观锁来实现：在上面的场景中，商品信息从查询出来到修改，中间有一个处理订单的过程，使用悲观锁的原理就是，当我们在查询出items信息后就把当前的数据锁定，直到我们修改完毕后再解锁。那么在这个过程中，因为items被锁定了，就不会出现有第三者来对其进行修改了。<br>注：要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。我们可以使用命令设置MySQL为非autocommit模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">set autocommit=0;</div><div class="line">设置完autocommit后，我们就可以执行我们的正常业务了。具体如下：</div><div class="line">//开始事务</div><div class="line">begin;/begin work;/start transaction; (三者选一就可以)</div><div class="line">//查询出商品信息</div><div class="line">select status from items where id=10000 for update;</div><div class="line">//根据商品信息生成订单</div><div class="line">insert into orders (id,item_id) values (null,10000);</div><div class="line">//修改商品status为2</div><div class="line">update items set status=2 where id=10000;</div><div class="line">//提交事务</div><div class="line">commit;/commit work;</div></pre></td></tr></table></figure></p>
<p>注：上面的begin/commit为事务的开始和结束，因为在前一步我们关闭了mysql的autocommit，所以需要手动控制事务的提交，在这里就不细表了。<br>上面的第一步我们执行了一次查询操作：select status from items where id=10000 for update;与普通查询不一样的是，我们使用了select…for update的方式，这样就通过数据库实现了悲观锁。此时在items表中，id为10000的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。<br>注：需要注意的是，在事务中，只有SELECT … FOR UPDATE 或LOCK IN SHARE MODE 同一笔数据时会等待其它事务结束后才执行，一般SELECT … 则不受此影响。拿上面的实例来说，当我执行select status from items where id=10000 for update;后。我在另外的事务中如果再次执行select status from items where id=10000 for update;则第二个事务会一直等待第一个事务的提交，此时第二个查询处于阻塞的状态，但是如果我是在第二个事务中执行select status from items where id=10000;则能正常查询出数据，不会受第一个事务的影响。<br>上面我们提到，使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认Row-Level Lock，所以只有明确地指定主键，MySQL 才会执行Row lock (只锁住被选取的数据) ，否则MySQL 将会执行Table Lock (将整个数据表单给锁住)。除了主键外，使用索引也会影响数据库的锁定级别。<br>悲观锁并不是适用于任何场景，它也有它存在的一些不足，因为悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。如果加锁的时间过长，其他用户长时间无法访问，影响了程序的并发访问性，同时这样对数据库性能开销影响也很大，特别是对长事务而言，这样的开销往往无法承受。</p>
<h2 id="乐观锁（-Optimistic-Locking-）"><a href="#乐观锁（-Optimistic-Locking-）" class="headerlink" title="乐观锁（ Optimistic Locking ）"></a>乐观锁（ Optimistic Locking ）</h2><p>相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。那么我们如何实现乐观锁呢，一般来说有以下2种方式：  </p>
<ol>
<li><p>使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值+1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。<br>如果更新操作顺序执行，则数据的版本（version）依次递增，不会产生冲突。但是如果发生有不同的业务操作对同一版本的数据进行修改，那么，先提交的操作（图中B）会把数据version更新为2，当A在B之后提交更新时发现数据的version已经被修改了，那么A的更新操作会失败。</p>
</li>
<li><p>乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似（其实不用新加字段，用需要修改的字段作为条件进行修改操作即可），也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。<br>以mysql InnoDB存储引擎为例，还是拿之前的例子商品表items表中有一个字段status，status=1表示该商品未被下单，status=2表示该商品已经被下单，那么我们对每个商品下单前必须确保此商品的status=1。假设有一件商品，其id为10000；<br>下单操作包括3步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//查询出商品信息</div><div class="line">select (status,version) from items where id=#&#123;id&#125;</div><div class="line">//根据商品信息生成订单</div><div class="line">//修改商品status为2</div><div class="line">update items set status=2,version=version+1 where id=#&#123;id&#125; and version=#&#123;version&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>为了使用乐观锁，我们需要首先修改items表，增加一个version字段，数据默认version可设为1；<br>其实我们周围的很多产品都有乐观锁的使用，比如我们经常使用的分布式存储引擎Tair，Tair中存储的每个数据都有版本号，版本号在每次更新后都会递增，相应的，在Tair put接口中也有此version参数，这个参数是为了解决并发更新同一个数据而设置的，这其实就是乐观锁；<br>很多情况下，更新数据是先get，修改get回来的数据，然后put回系统。如果有多个客户端get到同一份数据，都对其修改并保存，那么先保存的修改就会被后到达的修改覆盖，从而导致数据一致性问题,在大部分情况下应用能够接受，但在少量特殊情况下，这个是我们不希望发生的。<br>比如系统中有一个值”1”, 现在A和B客户端同时都取到了这个值。之后A和B客户端都想改动这个值，假设A要改成12，B要改成13，如果不加控制的话，无论A和B谁先更新成功，它的更新都会被后到的更新覆盖。Tair引入的乐观锁机制避免了这样的问题。刚刚的例子中，假设A和B同时取到数据，当时版本号是10，A先更新，更新成功后，值为12，版本为11。当B更新的时候，由于其基于的版本号是10，此时服务器会拒绝更新，返回version error，从而避免A的更新被覆盖。B可以选择get新版本的value，然后在其基础上修改，也可以选择强行更新。<br>当然了，乐观锁也是要精心挑选的，主要的目的就是避免锁的失败率过高又要规避ABA问题。关于锁力度太大导致接口操作失败率过高。<br>商品库存扣减时，尤其是在秒杀、聚划算这种高并发的场景下，若采用version号作为乐观锁，则每次只有一个事务能更新成功，业务感知上就是大量操作失败。<br>若挑选以库存数作为乐观锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">update item </div><div class="line">set </div><div class="line">    quantity=quantity-#sub_quantity# </div><div class="line">where </div><div class="line">    item_id = #id# </div><div class="line">    and quantity-#sub_quantity# &gt; 0</div></pre></td></tr></table></figure></p>
<p>通过挑选乐观锁，可以减小锁力度，从而提升吞吐<br>乐观锁需要灵活运用,现在互联网高并发的架构中，受到fail-fast思路的影响，悲观锁已经非常少见了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/mysql.jpg&quot; alt=&quot;mysql&quot; title=&quot;mysql&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;悲观锁&quot;&gt;&lt;a href=&quot;#悲观锁&quot; class=&quot;headerlink&quot; title=&quot;悲观锁&quot;&gt;&lt;/a&gt;悲观锁&lt;/h2&gt;&lt;p&gt;   正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）的修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。&lt;br&gt;  以常用的mysql InnoDB存储引擎为例：加入商品表items表中有一个字段status，status=1表示该商品未被下单，status=2表示该商品已经被下单，那么我们对每个商品下单前必须确保此商品的status=1。假设有一件商品，其id为10000；如果不使用锁，那么操作方法如下:&lt;br&gt;
    
    </summary>
    
      <category term="database" scheme="http://jethan.bid/categories/database/"/>
    
      <category term="mysql" scheme="http://jethan.bid/categories/database/mysql/"/>
    
    
      <category term="乐观锁" scheme="http://jethan.bid/tags/%E4%B9%90%E8%A7%82%E9%94%81/"/>
    
      <category term="悲观锁" scheme="http://jethan.bid/tags/%E6%82%B2%E8%A7%82%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>mysql事务隔离级别</title>
    <link href="http://jethan.bid/2017/08/04/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://jethan.bid/2017/08/04/mysql事务隔离级别/</id>
    <published>2017-08-04T03:58:09.000Z</published>
    <updated>2017-08-04T03:58:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="mysql事务隔离级别/mysql.jpg" alt="mysql" title="mysql"></p>
<h1 id="mysql事务隔离级别"><a href="#mysql事务隔离级别" class="headerlink" title="mysql事务隔离级别"></a>mysql事务隔离级别</h1><h2 id="第1级别：Read-Uncommitted-读取未提交内容"><a href="#第1级别：Read-Uncommitted-读取未提交内容" class="headerlink" title="第1级别：Read Uncommitted(读取未提交内容)"></a>第1级别：Read Uncommitted(读取未提交内容)</h2><p>1.所有事务都可以看到其他未提交事务的执行结果<br>2.本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少<br>3.该级别引发的问题是——脏读(Dirty Read)：读取到了未提交的数据<br><a id="more"></a></p>
<pre><code>#首先，修改隔离级别
set tx_isolation=&#39;READ-UNCOMMITTED&#39;;  
select @@tx_isolation; 
| @@tx_isolation |
| READ-UNCOMMITTED |
#事务A：启动一个事务  
start transaction;  
select * from tx;  
| id   | num  |  
|    1 |    1 |  
|    2 |    2 |  
|    3 |    3 |  

#事务B：也启动一个事务(那么两个事务交叉了)  
#在事务B中执行更新语句，且不提交
start transaction;   
update tx set num=10 where id=1;  
select * from tx;
| id   | num  |  
|    1 |   10 |  
|    2 |    2 |  
|    3 |    3 | 

#事务A：那么这时候事务A能看到这个更新了的数据吗?  
select * from tx;  
| id   | num  |  
|    1 |   10 |   ---&gt;可以看到！说明我们读到了事务B还没有提交的数据  
|    2 |    2 |  
|    3 |    3 |  

#事务B：事务B回滚,仍然未提交  
rollback;  
select * from tx;  
| id   | num  |  
|    1 |    1 |  
|    2 |    2 |  
|    3 |    3 |  

#事务A：在事务A里面看到的也是B没有提交的数据
select * from tx;  
| id   | num  |  
|    1 |    1 |      ---&gt;脏读意味着我在这个事务中(A中)，事务B虽然没有提交，但它任何一条数据变化，我都可以看到！  
|    2 |    2 |  
|    3 |    3 |  
</code></pre><h2 id="第2级别：Read-Committed-读取提交内容"><a href="#第2级别：Read-Committed-读取提交内容" class="headerlink" title="第2级别：Read Committed(读取提交内容)"></a>第2级别：Read Committed(读取提交内容)</h2><p>1.这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）<br>2.它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变<br>3.这种隔离级别出现的问题是——不可重复读(Nonrepeatable Read)：不可重复读意味着我们在同一个事务中执行完全相同的select语句时可能看到不一样的结果。<br> ——&gt;导致这种情况的原因可能有：<br> (1)有一个交叉的事务有新的commit，导致了数据的改变;<br> (2)一个数据库被多个实例操作时,同一事务的其他实例在该实例处理其间可能会有新的commit</p>
<pre><code>  #首先修改隔离级别
  set tx_isolation=&#39;read-committed&#39;;  
  select @@tx_isolation;  
  | @@tx_isolation |  
  | READ-COMMITTED |  

  #事务A：启动一个事务
  start transaction;  
  select * from tx;  
  | id   | num  |  
  |    1 |    1 |  
  |    2 |    2 |  
  |    3 |    3 |  

  #事务B：也启动一个事务(那么两个事务交叉了)
  #在这事务中更新数据，且未提交
  start transaction;  
  update tx set num=10 where id=1;  
  select * from tx; 
  | id   | num  |  
  |    1 |   10 |  
  |    2 |    2 |  
  |    3 |    3 |  

  #事务A：这个时候我们在事务A中能看到数据的变化吗?
  select * from tx;
  | id   | num  |  
  |    1 |    1 |---&gt;并不能看到！  
  |    2 |    2 |                 
  |    3 |    3 |     
  |——&gt;相同的select语句，结果却不一样

  #事务B：如果提交了事务B呢?           
  commit;                          

  #事务A:                           
  select * from tx;  
  | id   | num  |  
  |    1 |   10 |---&gt;因为事务B已经提交了，所以在A中我们看到了数据变化  
  |    2 |    2 |  
  |    3 |    3 |  
</code></pre><h2 id="第3级别：Repeatable-Read-可重读"><a href="#第3级别：Repeatable-Read-可重读" class="headerlink" title="第3级别：Repeatable Read(可重读)"></a>第3级别：Repeatable Read(可重读)</h2><p>1.这是MySQL的默认事务隔离级别<br>2.它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行<br>3.此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行<br>4.InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题  </p>
<pre><code>    #首先，更改隔离级别  
    set tx_isolation=&#39;repeatable-read&#39;;  
    select @@tx_isolation;  
    | @@tx_isolation  |
    +------+------+
    | REPEATABLE-READ |
    +------+------+

    #事务A：启动一个事务
    start transaction;  
    select * from tx;  
    | id   | num  |
    +------+------+
    |    1 |    1 |
    |    2 |    2 |
    |    3 |    3 |
    +------+------+

    #事务B：开启一个新事务(那么这两个事务交叉了)
    #在事务B中更新数据，并提交
    start transaction;  
    update tx set num=10 where id=1;  
    select * from tx;  
    +------+------+  
    | id   | num  |  
    +------+------+  
    |    1 |   10 |  
    |    2 |    2 |  
    |    3 |    3 |  
    +------+------+  
    commit;  

    #事务A：这时候即使事务B已经提交了,但A能不能看到数据变化？
    select * from tx;+------+------+  
    | id   | num  |  
    +------+------+  
    |    1 |    1 | ---&gt;还是看不到的！(这个级别2不一样，也说明级别3解决了不可重复读问题)  
    |    2 |    2 |  
    |    3 |    3 |  
    +------+------+  

    #事务A：只有当事务A也提交了，它才能够看到数据变化
    commit;select * from tx;  
    +------+------+  
    | id   | num  |  
    +------+------+  
    |    1 |   10 |  
    |    2 |    2 |  
    |    3 |    3 |  
    +------+------+  
</code></pre><h2 id="第4级别：Serializable-可串行化"><a href="#第4级别：Serializable-可串行化" class="headerlink" title="第4级别：Serializable(可串行化)"></a>第4级别：Serializable(可串行化)</h2><p>1.这是最高的隔离级别<br>2.它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁。<br>3.在这个级别，可能导致大量的超时现象和锁竞争</p>
<pre><code>    #首先修改隔离界别
    set tx_isolation=&#39;serializable&#39;;  
    select @@tx_isolation;  
    +----------------+  
    | @@tx_isolation |  
    +----------------+  
    | SERIALIZABLE   |  
    +----------------+  

    #事务A：开启一个新事务  
    start transaction;  

    #事务B：在A没有commit之前，这个交叉事务是不能更改数据的  
    start transaction;  
    insert tx values(&#39;4&#39;,&#39;4&#39;);  
    ERROR 1205 (HY000): Lock wait timeout exceeded;   
    try restarting transactionupdate tx set num=10 where id=1;ERROR 1205 (HY000): Lock wait timeout exceeded;   
    try restarting transaction  
</code></pre><p><img src="mysql事务隔离级别/transaction.jpg" alt="transaction" title="transaction"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;mysql事务隔离级别/mysql.jpg&quot; alt=&quot;mysql&quot; title=&quot;mysql&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;mysql事务隔离级别&quot;&gt;&lt;a href=&quot;#mysql事务隔离级别&quot; class=&quot;headerlink&quot; title=&quot;mysql事务隔离级别&quot;&gt;&lt;/a&gt;mysql事务隔离级别&lt;/h1&gt;&lt;h2 id=&quot;第1级别：Read-Uncommitted-读取未提交内容&quot;&gt;&lt;a href=&quot;#第1级别：Read-Uncommitted-读取未提交内容&quot; class=&quot;headerlink&quot; title=&quot;第1级别：Read Uncommitted(读取未提交内容)&quot;&gt;&lt;/a&gt;第1级别：Read Uncommitted(读取未提交内容)&lt;/h2&gt;&lt;p&gt;1.所有事务都可以看到其他未提交事务的执行结果&lt;br&gt;2.本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少&lt;br&gt;3.该级别引发的问题是——脏读(Dirty Read)：读取到了未提交的数据&lt;br&gt;
    
    </summary>
    
      <category term="database" scheme="http://jethan.bid/categories/database/"/>
    
      <category term="mysql" scheme="http://jethan.bid/categories/database/mysql/"/>
    
    
      <category term="事务隔离级别" scheme="http://jethan.bid/tags/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    
  </entry>
  
</feed>
