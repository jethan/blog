<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>学海无涯</title>
  <subtitle>技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jet-han.oschina.io/"/>
  <updated>2018-12-07T05:14:07.083Z</updated>
  <id>http://jet-han.oschina.io/</id>
  
  <author>
    <name>Jet</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Cron</title>
    <link href="http://jet-han.oschina.io/2017/12/05/Cron/"/>
    <id>http://jet-han.oschina.io/2017/12/05/Cron/</id>
    <published>2017-12-05T08:11:06.000Z</published>
    <updated>2018-12-07T05:14:07.083Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/12/05/Cron/../../../../../../../../../img/icons/cron.png" alt="cron" title="cron"></p>
<h2 id="cron表达式格式"><a href="#cron表达式格式" class="headerlink" title="cron表达式格式"></a>cron表达式格式</h2><ul>
<li>{秒数} {分钟} {小时} {日期} {月份} {星期} {年份(可为空)}</li>
</ul>
<p>先了解每个位置代表的含义，再了解每个位置允许的范围，以及一些特殊写法，还有常用的案例，足够你掌握<code>cron</code>表达式</p>
<h3 id="每个字段的允许值"><a href="#每个字段的允许值" class="headerlink" title="每个字段的允许值"></a>每个字段的允许值</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字段</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">允许值</th>
<th style="text-align:center">允许的特殊字符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Seconds</td>
<td style="text-align:center">秒</td>
<td style="text-align:center">0-59</td>
<td style="text-align:center">, - * /</td>
</tr>
<tr>
<td style="text-align:center">Minutes</td>
<td style="text-align:center">分</td>
<td style="text-align:center">0-59</td>
<td style="text-align:center">, - * /</td>
</tr>
<tr>
<td style="text-align:center">Hours</td>
<td style="text-align:center">小时</td>
<td style="text-align:center">0-23</td>
<td style="text-align:center">, - * /</td>
</tr>
<tr>
<td style="text-align:center">Day-of-Month</td>
<td style="text-align:center">日期</td>
<td style="text-align:center">1-31</td>
<td style="text-align:center">, - * ? / L W C</td>
</tr>
<tr>
<td style="text-align:center">Month</td>
<td style="text-align:center">月份</td>
<td style="text-align:center">1-12 或者 JAN-DEC</td>
<td style="text-align:center">, - * /</td>
</tr>
<tr>
<td style="text-align:center">Day-of-Week</td>
<td style="text-align:center">星期</td>
<td style="text-align:center">1-7 或者 SUN-SAT</td>
<td style="text-align:center">, - * ? / L C #</td>
</tr>
<tr>
<td style="text-align:center">Year</td>
<td style="text-align:center">年（可选）</td>
<td style="text-align:center">留空, 1970-2099</td>
<td style="text-align:center">, - * /</td>
</tr>
</tbody>
</table>
</div>
<a id="more"></a>
<h4 id="秒"><a href="#秒" class="headerlink" title="秒"></a>秒</h4><p>允许值范围: 0~59 ,不允许为空值，若值不合法，调度器将抛出<code>SchedulerException</code>异常</p>
<ul>
<li><code>*</code> 代表每隔1秒钟触发</li>
<li><code>,</code> 代表在指定的秒数触发，比如”0,15,45”代表0秒、15秒和45秒时触发任务</li>
<li><code>-</code>  代表在指定的范围内触发，比如”25-45”代表从25秒开始触发到45秒结束触发，每隔1秒触发1次</li>
<li><code>/</code> 代表触发步进(step)，”/“前面的值代表初始值(“*“等同”0”)，后面的值代表偏移量，比如”0/20”或者”*/20”代表从0秒钟开始，每隔20秒钟触发1次，即0秒触发1次，20秒触发1次，40秒触发1次；”5/20”代表5秒触发1次，25秒触发1次，45秒触发1次；”10-45/20”代表在[10,45]内步进20秒命中的时间点触发，即10秒触发1次，30秒触发1次</li>
</ul>
<h4 id="分钟"><a href="#分钟" class="headerlink" title="分钟"></a>分钟</h4><p>允许值范围: 0~59 ,不允许为空值，若值不合法，调度器将抛出<code>SchedulerException</code>异常</p>
<ul>
<li><code>*</code> 代表每隔1分钟触发</li>
<li><code>,</code> 代表在指定的分钟触发，比如”10,20,40”代表10分钟、20分钟和40分钟时触发任务</li>
<li><code>-</code>代表在指定的范围内触发，比如”5-30”代表从5分钟开始触发到30分钟结束触 发，每隔1分钟触发</li>
<li><code>/</code>代表触发步进(step)，”/“前面的值代表初始值(“<em>“等同”0”)，后面的值代表偏移量，比如”0/25”或者”</em>/25”代表从0分钟开始，每隔25分钟触发1次，即0分钟触发1次，第25分钟触发1次，第50分钟触发1次；”5/25”代表5分钟触发1次，30分钟触发1次，55分钟触发1次；”10-45/20”代表在[10,45]内步进20分钟命中的时间点触发，即10分钟触发1次，30分钟触发1次</li>
</ul>
<h4 id="小时"><a href="#小时" class="headerlink" title="小时"></a>小时</h4><p>允许值范围: 0~23 ,不允许为空值，若值不合法，调度器将抛出<code>SchedulerException</code>异常</p>
<ul>
<li><code>*</code> 代表每隔1小时触发</li>
<li><code>,</code> 代表在指定的时间点触发，比如”10,20,23”代表10点钟、20点钟和23点触发任务</li>
<li><code>-</code> 代表在指定的时间段内触发，比如”20-23”代表从20点开始触发到23点结束触发，每隔1小时触发</li>
<li><code>/</code> 代表触发步进(step)，”/“前面的值代表初始值(“<em>“等同”0”)，后面的值代表偏移量，比如”0/1”或者”</em>/1”代表从0点开始触发，每隔1小时触发1次；”1/2”代表从1点开始触发，以后每隔2小时触发一次</li>
</ul>
<h4 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h4><p>允许值范围: 1~12 (JAN-DEC),不允许为空值，若值不合法，调度器将抛出<code>SchedulerException</code>异常</p>
<ul>
<li><code>*</code> 代表每个月都触发</li>
<li><code>,</code> 代表在指定的月份触发，比如”1,6,12”代表1月份、6月份和12月份触发任务</li>
<li><code>-</code> 代表在指定的月份范围内触发，比如”1-6”代表从1月份开始触发到6月份结束触发，每隔1个月触发</li>
<li><code>/</code> 代表触发步进(step)，”/“前面的值代表初始值(“<em>“等同”1”)，后面的值代表偏移量，比如”1/2”或者”</em>/2”代表从1月份开始触发，每隔2个月触发1次；”6/6”代表从6月份开始触发，以后每隔6个月触发一次；”1-6/12”表达式意味着每年1月份触发</li>
</ul>
<h4 id="星期"><a href="#星期" class="headerlink" title="星期"></a>星期</h4><p>允许值范围: 1~7 (SUN-SAT),1代表星期天(一星期的第一天)，以此类推，7代表星期六(一星期的最后一天)，不允许为空值，若值不合法，调度器将抛出<code>SchedulerException</code>异常</p>
<ul>
<li><code>*</code> 代表每星期都触发；</li>
<li><code>?</code> 与{日期}互斥，即意味着若明确指定{日期}触发，则表示{星期}无意义，以免引起冲突和混乱</li>
<li><code>,</code> 代表在指定的星期约定触发，比如”1,3,5”代表星期天、星期二和星期四触发</li>
<li><code>-</code> 代表在指定的星期范围内触发，比如”2-4”代表从星期一开始触发到星期三结束触发，每隔1天触发</li>
<li><code>/</code> 代表触发步进(step)，”/“前面的值代表初始值(“<em>“等同”1”)，后面的值代表偏移量，比如”1/3”或者”</em>/3”代表从星期天开始触发，每隔3天触发1次；”1-5/2”表达式意味着在[1,5]范围内，每隔2天触发，即星期天、星期二、星期四触发</li>
<li><code>L</code> 如果{星期}占位符如果是”L”，即意味着星期的的最后一天触发，即星期六触发，L= 7或者 L = SAT，因此，”5L”意味着一个月的最后一个星期四触发</li>
<li><code>#</code> 用来指定具体的周数，”#”前面代表星期，”#”后面代表本月第几周，比如”2#2”表示本月第二周的星期一，”5#3”表示本月第三周的星期四，因此，”5L”这种形式只不过是”#”的特殊形式而已</li>
</ul>
<h4 id="年份"><a href="#年份" class="headerlink" title="年份"></a>年份</h4><p>允许值范围: 1970~2099 ,允许为空，若值不合法，调度器将抛出<code>SchedulerException</code>异常</p>
<ul>
<li><code>*</code> 代表每年都触发</li>
<li><code>,</code> 代表在指定的年份才触发，比如”2011,2012,2013”代表2011年、2012年和2013年触发任务</li>
<li><code>-</code> 代表在指定的年份范围内触发，比如”2011-2020”代表从2011年开始触发到2020年结束触发，每隔1年触发</li>
<li><code>/</code> 代表触发步进(step)，”/“前面的值代表初始值(“<em>“等同”1970”)，后面的值代表偏移量，比如”2011/2”或者”</em>/2”代表从2011年开始触发，每隔2年触发1次</li>
</ul>
<p><strong>注意：</strong> 除了{日期}和{星期}可以使用”?”来实现互斥，表达无意义的信息之外，其他占位符都要具有具体的时间含义，且依赖关系为：年-&gt;月-&gt;日期(星期)-&gt;小时-&gt;分钟-&gt;秒数</p>
<h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h4><h5 id=""><a href="#" class="headerlink" title="*"></a>*</h5><p><code>*</code> 字符被用来指定所有的值。如：”*”在分钟的字段域里表示“每分钟”。</p>
<h5 id="-1"><a href="#-1" class="headerlink" title="?"></a>?</h5><p><code>?</code> 字符只在日期域和星期域中使用。它被用来指定“非明确的值”。当你需要通过在这两个域中的一个来指定一些东西的时候，它是有用的。看下面的例子你就会明白。 月份中的日期和星期中的日期这两个元素时互斥的一起应该通过设置一个问号来表明不想设置那个字段。</p>
<h5 id="-2"><a href="#-2" class="headerlink" title="-"></a>-</h5><p><code>-</code> 字符被用来指定一个范围。如：“10-12”在小时域意味着“10点、11点、12点”。</p>
<h5 id="-3"><a href="#-3" class="headerlink" title=","></a>,</h5><p><code>,</code> 字符被用来指定另外的值。如：“MON,WED,FRI”在星期域里表示”星期一、星期三、星期五”。</p>
<h5 id="-4"><a href="#-4" class="headerlink" title="/"></a>/</h5><p><code>/</code> 字符用于指定增量。如：“0/15”在秒域意思是每分钟的0，15，30和45秒。“5/15”在分钟域表示每小时的5，20，35和50。符号“<em>”在“/”前面（如：</em>/10）等价于0在“/”前面（如：0/10）。记住一条本质：表达式的每个数值域都是一个有最大值和最小值的集合，如：秒域和分钟域的集合是0-59，日期域是1-31，月份域是1-12。字符“/”可以帮助你在每个字符域中取相应的数值。如：“7/6”在月份域的时候只有当7月的时候才会触发，并不是表示每个6月。</p>
<h5 id="L"><a href="#L" class="headerlink" title="L"></a>L</h5><p><code>L</code> 是‘last’的省略写法可以表示day-of-month和day-of-week域，但在两个字段中的意思不同，例如day-of-month域中表示一个月的最后一天。如果在day-of-week域表示‘7’或者‘SAT’，如果在day-of-week域中前面加上数字，它表示一个月的最后几天，例如‘6L’就表示一个月的最后一个星期五。</p>
<h5 id="W"><a href="#W" class="headerlink" title="W"></a>W</h5><p><code>W</code> 字符“W”只允许日期域出现。这个字符用于指定日期的最近工作日。例如：如果你在日期域中写 “15W”，表示：这个月15号最近的工作日。所以，如果15号是周六，则任务会在14号触发。如果15好是周日，则任务会在周一也就是16号触发。如果是在日期域填写“1W”即使1号是周六，那么任务也只会在下周一，也就是3号触发，“W”字符指定的最近工作日是不能够跨月份的。字符“W”只能配合一个单独的数值使用，不能够是一个数字段，如：1-15W是错误的。</p>
<p><code>L</code>和<code>W</code>可以在日期域中联合使用，LW表示这个月最后一周的工作日。</p>
<h5 id="-5"><a href="#-5" class="headerlink" title="\"></a>\</h5><p><code>#</code> 字符“#”只允许在星期域中出现。这个字符用于指定本月的某某天。例如：“6#3”表示本月第三周的星期五（6表示星期五，3表示第三周）。“2#1”表示本月第一周的星期一。“4#5”表示第五周的星期三。</p>
<h5 id="C"><a href="#C" class="headerlink" title="C"></a>C</h5><p><code>C</code> 字符“C”允许在日期域和星期域出现。这个字符依靠一个指定的“日历”。也就是说这个表达式的值依赖于相关的“日历”的计算结果，如果没有“日历”关联，则等价于所有包含的“日历”。如：日期域是“5C”表示关联“日历”中第一天，或者这个月开始的第一天的后5天。星期域是“1C”表示关联“日历”中第一天，或者星期的第一天的后1天，也就是周日的后一天（周一）。</p>
<h4 id="一些cron表达式案例"><a href="#一些cron表达式案例" class="headerlink" title="一些cron表达式案例"></a>一些cron表达式案例</h4><ul>
<li><em>/5 </em> <em> </em> * ? 每隔5秒执行一次</li>
<li>0 <em>/1 </em> <em> </em> ? 每隔1分钟执行一次</li>
<li>0 0 5-15 <em> </em> ? 每天5-15点整点触发</li>
<li>0 0/3 <em> </em> * ? 每三分钟触发一次</li>
<li>0 0-5 14 <em> </em> ? 在每天下午2点到下午2:05期间的每1分钟触发 </li>
<li>0 0/5 14 <em> </em> ? 在每天下午2点到下午2:55期间的每5分钟触发</li>
<li>0 0/5 14,18 <em> </em> ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发</li>
<li>0 0/30 9-17 <em> </em> ? 朝九晚五工作时间内每半小时</li>
<li>0 0 10,14,16 <em> </em> ? 每天上午10点，下午2点，4点 </li>
<li>0 0 12 ? * WED 表示每个星期三中午12点</li>
<li>0 0 17 ? * TUES,THUR,SAT 每周二、四、六下午五点</li>
<li>0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 </li>
<li>0 15 10 ? * MON-FRI 周一至周五的上午10:15触发</li>
<li>0 0 23 L * ? 每月最后一天23点执行一次</li>
<li>0 15 10 L * ? 每月最后一日的上午10:15触发 </li>
<li>0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发 </li>
<li>0 15 10 <em> </em> ? 2005 2005年的每天上午10:15触发 </li>
<li>0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发 </li>
<li>0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发</li>
<li>“30 <em> </em> <em> </em> ?” 每半分钟触发任务</li>
<li>“30 10 <em> </em> * ?” 每小时的10分30秒触发任务</li>
<li>“30 10 1 <em> </em> ?” 每天1点10分30秒触发任务</li>
<li>“30 10 1 20 * ?” 每月20号1点10分30秒触发任务</li>
<li>“30 10 1 20 10 ? *” 每年10月20号1点10分30秒触发任务</li>
<li>“30 10 1 20 10 ? 2011” 2011年10月20号1点10分30秒触发任务</li>
<li>“30 10 1 ? 10 * 2011” 2011年10月每天1点10分30秒触发任务</li>
<li>“30 10 1 ? 10 SUN 2011” 2011年10月每周日1点10分30秒触发任务</li>
<li>“15,30,45 <em> </em> <em> </em> ?” 每15秒，30秒，45秒时触发任务</li>
<li>“15-45 <em> </em> <em> </em> ?” 15到45秒内，每秒都触发任务</li>
<li>“15/5 <em> </em> <em> </em> ?” 每分钟的每15秒开始触发，每隔5秒触发一次</li>
<li>“15-30/5 <em> </em> <em> </em> ?” 每分钟的15秒到30秒之间开始触发，每隔5秒触发一次</li>
<li>“0 0/3 <em> </em> * ?” 每小时的第0分0秒开始，每三分钟触发一次</li>
<li>“0 15 10 ? * MON-FRI” 星期一到星期五的10点15分0秒触发任务</li>
<li>“0 15 10 L * ?” 每个月最后一天的10点15分0秒触发任务</li>
<li>“0 15 10 LW * ?” 每个月最后一个工作日的10点15分0秒触发任务</li>
<li>“0 15 10 ? * 5L” 每个月最后一个星期四的10点15分0秒触发任务</li>
<li>“0 15 10 ? * 5#3” 每个月第三周的星期四的10点15分0秒触发任务</li>
</ul>
<h3 id="表达式生成器"><a href="#表达式生成器" class="headerlink" title="表达式生成器"></a>表达式生成器</h3><p>有很多的cron表达式在线生成器，这里给大家推荐几款<br><a href="http://www.bejson.com/othertools/cron/" target="_blank" rel="external">http://www.bejson.com/othertools/cron/</a><br><a href="http://cron.qqe2.com/" target="_blank" rel="external">http://cron.qqe2.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017/12/05/Cron/../../../../../../../../../img/icons/cron.png&quot; alt=&quot;cron&quot; title=&quot;cron&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;cron表达式格式&quot;&gt;&lt;a href=&quot;#cron表达式格式&quot; class=&quot;headerlink&quot; title=&quot;cron表达式格式&quot;&gt;&lt;/a&gt;cron表达式格式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;{秒数} {分钟} {小时} {日期} {月份} {星期} {年份(可为空)}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先了解每个位置代表的含义，再了解每个位置允许的范围，以及一些特殊写法，还有常用的案例，足够你掌握&lt;code&gt;cron&lt;/code&gt;表达式&lt;/p&gt;
&lt;h3 id=&quot;每个字段的允许值&quot;&gt;&lt;a href=&quot;#每个字段的允许值&quot; class=&quot;headerlink&quot; title=&quot;每个字段的允许值&quot;&gt;&lt;/a&gt;每个字段的允许值&lt;/h3&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;字段&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;描述&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;允许值&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;允许的特殊字符&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Seconds&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;秒&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0-59&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;, - * /&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Minutes&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;分&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0-59&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;, - * /&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Hours&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;小时&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0-23&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;, - * /&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Day-of-Month&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;日期&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1-31&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;, - * ? / L W C&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Month&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;月份&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1-12 或者 JAN-DEC&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;, - * /&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Day-of-Week&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;星期&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1-7 或者 SUN-SAT&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;, - * ? / L C #&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Year&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;年（可选）&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;留空, 1970-2099&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;, - * /&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
    
    </summary>
    
    
      <category term="cron" scheme="http://jet-han.oschina.io/tags/cron/"/>
    
      <category term="quartz" scheme="http://jet-han.oschina.io/tags/quartz/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis相关</title>
    <link href="http://jet-han.oschina.io/2017/11/30/Mybatis%E7%9B%B8%E5%85%B3/"/>
    <id>http://jet-han.oschina.io/2017/11/30/Mybatis相关/</id>
    <published>2017-11-30T06:30:37.000Z</published>
    <updated>2018-11-30T10:41:03.872Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/11/30/Mybatis相关/../../../../../../img/icons/mybatis.png" alt="mybatis" title="mybatis"></p>
<p> 每个现象背后都有其缘由，越离奇的bug越是由不起眼的细节引发，每个bug背后都有框架或代码运行的原理和机制所在，解决bug，不仅仅需要去网上查询，还需要对其背后的原理进行了解和总结。  同事大佬最近在学习并使用Mybatis，他使用Mybatis的MapperScannerConfigurer来进行相关配置，并希望通过yml配置来指定basePackage，mappers等属性。为此，编写了自定义的配置类 <code>StarterAutoConfiguration</code>和自定义属性类 <code>TkProperties</code>，并在初始化 <code>MapperScannerConfigurer</code>时使用 <code>TkProperties</code>中的属性。但是，事与愿违，在初始化 <code>MapperScannerConfigurer</code>时， <code>TkProperties</code>实例中的属性死活都是未初始化状态。</p>
<p> 为此，我们花了大量时间探查缘由，最后不得不询问了另一位大佬，才发现这个离奇问题的背后竟然有着这样的缘由。  我们首先来看一下大佬关于 <code>MapperScannerConfigurer</code>的自定义配置实现。他首先定义了自定义配置类 <code>BkStarterAutoConfiguration</code>，使用 <code>@EnableConfigurationProperties</code>注解将 <code>TkProperties</code>声明为配置属性类。</p>
 <a id="more"></a>
<h2 id="MapperScannerConfigurer"><a href="#MapperScannerConfigurer" class="headerlink" title="MapperScannerConfigurer"></a>MapperScannerConfigurer</h2><pre><code>@Configuration
@EnableConfigurationProperties({TkProperties.class})
@AutoConfigureBefore(MybatisAutoConfiguration.class)`
public  class  BkStarterAutoConfiguration  {
    @Bean
    @ConditionalOnMissingBean
    @Order(Ordered.HIGHEST_PRECEDENCE)
    public  TkProperties tkProperties()  {
    return  new  TkProperties();`
    }
}
</code></pre><p> 下面是 <code>TkProperties</code>的定义，使用 <code>@ConfigurationProperties</code>注解声明了该属性配置的前缀，两个属性名称为 <code>basePackage</code>和 <code>mappers</code>。</p>
<pre><code>        @Data
        @ConfigurationProperties(prefix =  &quot;tk&quot;)
        public  class  TkProperties  {
            private  String basePackage;
            private  String mappers;
        }
</code></pre><p>  <code>MapperConfig</code>是声明并配置 <code>MapperScannerConfigurer</code>实例的配置类，使用被 <code>@Bean</code>注解修饰的 <code>mapperScannerConfigurer</code>方法来初始化，其方法参数为 <code>TkProperties</code>。</p>
<pre><code>@Configuration
public  class  MapperConfig  {
@Bean
public  MapperScannerConfigurer mapperScannerConfigurer(TkProperties tkProperties)  {
    MapperScannerConfigurer mapperScannerConfigurer =  new  MapperScannerConfigurer();
    mapperScannerConfigurer.setSqlSessionFactoryBeanName(&quot;sqlSessionFactory&quot;);
    //使用TkProperties的成员变量来配置mapperScannerConfigurer
    mapperScannerConfigurer.setBasePackage(tkProperties.getBasePackage());
    Properties properties =  new  Properties();
     properties.setProperty(&quot;mappers&quot;, tkProperties.getMappers());
     mapperScannerConfigurer.setProperties(properties);
     return mapperScannerConfigurer;
     }
}
</code></pre><p> yml配置文件如下所示。</p>
<pre><code>tk:
  basePackage: cn.remcarpediem.mybatis.dao
  mappers: cn.remcarpediem.mappers.BaseDao
</code></pre><p> 代码乍看起来一定问题都没有，但是运行时，在初始化MapperScannerConfigurer实例时，TkProperties实例的属性死活就是没有初始化成功。</p>
<p> <img src="/2017/11/30/Mybatis相关/mybatis1.png" alt="mybatis" title="mybatis"></p>
<p> 一定有很多见多识广的读者已经知道这个现象背后的原因。“凶手”就是 <code>MapperScannerConfigurer</code>实现的接口 <code>BeanDefinitionRegistryPostProcessor</code>。具体原因我们还需要慢慢来解释，因为它涉及了Spring Boot的很多原理。</p>
<p> 首先， <code>BeanDefinitionRegistryPostProcessor</code>接口继承了 <code>BeanFactoryPostProcessor</code>接口，大家一般都对 <code>BeanFactoryPostProcessor</code>较为熟悉，它是实例工厂(BeanFactory)的后处理器(PostProcessor)，与之类似的还有实例的后处理器(BeanPostProcessor)。 <code>BeanFactoryPostProcessor</code>中只定义了一个方法，其将会在 <code>ApplicationContext</code>内部的 <code>BeanFactory</code>加载完 <code>BeanDefinition</code>后，但是在Bean实例化之前进行。所以通常我们可以通过实现该接口来对实例化之前的 <code>BeanDefinition</code>进行修改。比如说 <code>PropertySourcesPlaceholderConfigurer</code>就实现 <code>BeanFactoryPostProcessor</code>接口，用于处理实例中被 <code>@Value</code>注解修饰的变量，修改其数值。</p>
<pre><code>  public  interface  BeanFactoryPostProcessor  {
   void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)  throws  BeansException;
 }
</code></pre><p> 而 <code>BeanDefinitionRegistryPostProcessor</code>接口扩展自 <code>BeanFactoryPostProcessor</code>，它是 <code>BeanDefinitionRegistry</code>的后处理器，它可以在 <code>BeanFactoryPostProcessor</code>检测之前注册一些特殊的 <code>BeanDefinition</code>，比如说可以注册用来定义 <code>BeanFactoryPostProcessor</code>的 <code>BeanDefintion</code>，比如说我们之前提到的 <code>MapperScannerConfigurer</code>和 <code>ConfigurationClassPostProcessor</code>。</p>
<pre><code> public  interface  BeanDefinitionRegistryPostProcessor  extends  BeanFactoryPostProcessor  {
   void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)  throws  BeansException;
 }
</code></pre><p>  <code>MapperScannerConfigurer</code>的 <code>postProcessBeanDefinitionRegistry</code>主要用来 <code>ClassPathMapperScanner</code>来扫描 <code>Mybatis</code>的 <code>Mapper</code>。 <code>ClassPathMapperScanner</code>继承了 <code>ClassPathBeanDefinitionScanner</code>，在 <code>doScan</code>方法中获取了 <code>basePackage</code>指定的包路径下的所有 <code>Mapper</code>的 <code>BeanDefinition</code>，然后进行注册。</p>
<p> 而 <code>BeanPostProcessor</code>就是Bean实例的后处理器。每个Bean实例在进行初始化前会调用其 <code>postProcessBeforeInitialization</code>方法和初始化之后调用其 <code>postProcessAfterInitialization</code>方法。 <code>ConfigurationPropertiesBindingPostProcessor</code>实现了 <code>BeanPostProcessor</code>接口，用于处理被 <code>@ConfigurationProperties</code>修饰的实例。</p>
<pre><code>  public  interface  BeanPostProcessor  {
   Object postProcessBeforeInitialization(Object bean,  String beanName)  throws  BeansException;
   Object postProcessAfterInitialization(Object bean,  String beanName)  throws  BeansException;
  }
</code></pre><p> 我们可以总结一下 <code>BeanDefinitionRegistryPostProcessor</code>， <code>BeanFactoryPostProcessor</code>和 <code>BeanPostProcessor</code>三个后处理器发挥作用的次序和时机。</p>
<p>  <img src="/2017/11/30/Mybatis相关/mybatis2.png" alt="mybatis" title="mybatis"></p>
<p> <strong>由此，我们也能够理解为什么 <code>MapperScannerConfigurer</code>初始化时， <code>TkProperties</code>还没有初始化，那是因为 <code>ConfigurationPropertiesBindingPostProcessor</code>还没有初始化，并且也没有对 <code>TkProperties</code>进行处理</strong>。</p>
<p> 遇到问题和bug，不要百度一下解决方案处理就结束了，而是要深入了解一下背后的机制和原理，希望大家都能够多多探索更加深入的原理，获得更多的知识。</p>
<h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="$和#的区别"></a>$和#的区别</h2><p><code>#</code>相当于对数据 加上 双引号，<code>$</code>相当于直接显示数据</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">#</th>
<th style="text-align:center">$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">相当于对数据加上双引号</td>
<td style="text-align:center">相当于直接显示数据</td>
</tr>
<tr>
<td style="text-align:center">很大程度上防止SQL注入</td>
<td style="text-align:center">无法防止SQL注入</td>
</tr>
<tr>
<td style="text-align:center">#{xxx},使用的是PreparedStatement,会有类型转换，比较安全</td>
<td style="text-align:center">${xxx}，使用字符串拼接，容易SQL注入</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>使用#{参数}传入会加上单引号，sql语句解析是会加上””    </li>
</ul>
<p>比如  <code>select * from table where name = #{name}</code> ,传入的name为小李，那么最后打印出来的就是</p>
<p><code>select * from table where name = ‘小李’</code>，就是会当成字符串来解析，这样相比于$的好处是比较明显对的吧，#{}传参能防止sql注入，如果你传入的参数为 单引号’，那么如果使用${},这种方式 那么是会报错的，</p>
<ul>
<li>${}   </li>
</ul>
<p>另外一种场景是，如果你要做动态的排序，比如  <code>order by   column</code>，这个时候务必要用${},</p>
<p>因为如果你使用了#{},那么打印出来的将会是  <code>select * from table order by  &#39;name&#39;</code>  ,这样是没用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017/11/30/Mybatis相关/../../../../../../img/icons/mybatis.png&quot; alt=&quot;mybatis&quot; title=&quot;mybatis&quot;&gt;&lt;/p&gt;
&lt;p&gt; 每个现象背后都有其缘由，越离奇的bug越是由不起眼的细节引发，每个bug背后都有框架或代码运行的原理和机制所在，解决bug，不仅仅需要去网上查询，还需要对其背后的原理进行了解和总结。  同事大佬最近在学习并使用Mybatis，他使用Mybatis的MapperScannerConfigurer来进行相关配置，并希望通过yml配置来指定basePackage，mappers等属性。为此，编写了自定义的配置类 &lt;code&gt;StarterAutoConfiguration&lt;/code&gt;和自定义属性类 &lt;code&gt;TkProperties&lt;/code&gt;，并在初始化 &lt;code&gt;MapperScannerConfigurer&lt;/code&gt;时使用 &lt;code&gt;TkProperties&lt;/code&gt;中的属性。但是，事与愿违，在初始化 &lt;code&gt;MapperScannerConfigurer&lt;/code&gt;时， &lt;code&gt;TkProperties&lt;/code&gt;实例中的属性死活都是未初始化状态。&lt;/p&gt;
&lt;p&gt; 为此，我们花了大量时间探查缘由，最后不得不询问了另一位大佬，才发现这个离奇问题的背后竟然有着这样的缘由。  我们首先来看一下大佬关于 &lt;code&gt;MapperScannerConfigurer&lt;/code&gt;的自定义配置实现。他首先定义了自定义配置类 &lt;code&gt;BkStarterAutoConfiguration&lt;/code&gt;，使用 &lt;code&gt;@EnableConfigurationProperties&lt;/code&gt;注解将 &lt;code&gt;TkProperties&lt;/code&gt;声明为配置属性类。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mybatis" scheme="http://jet-han.oschina.io/tags/mybatis/"/>
    
      <category term="sql" scheme="http://jet-han.oschina.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-SQL语句执行</title>
    <link href="http://jet-han.oschina.io/2017/11/28/Mysql-SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C/"/>
    <id>http://jet-han.oschina.io/2017/11/28/Mysql-SQL语句执行/</id>
    <published>2017-11-28T10:41:59.000Z</published>
    <updated>2018-11-29T07:40:23.954Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/mysql.jpg" alt="mysql" title="mysql"></p>
<p>昔日庖丁解牛，未见全牛，所赖者是其对牛内部骨架结构的了解，对于MySQL亦是如此，只有更加全面地了解SQL语句执行的每个过程，才能更好的进行SQL的设计和优化。<br> 当希望MySQL能够以更高的性能运行查询时，最好的办法就是弄清楚MySQL是如何优化和执行查询的。一旦理解了这一点，很多查询优化工作实际上就是遵循一些原则能够按照预想的合理的方式运行。<br> 如下图所示，当向MySQL发送一个请求的时候，MySQL到底做了什么：</p>
<ul>
<li>客户端发送一条查询给服务器。</li>
<li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。</li>
<li>服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。</li>
<li>MySQL根据优化器生成的执行计划，再调用存储引擎的API来执行查询。</li>
<li>将结果返回给客户端。</li>
</ul>
<a id="more"></a>
<p><img src="/2017/11/28/Mysql-SQL语句执行/execute1.png" alt="mysql" title="mysql"></p>
<h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p> MySQL查询缓存保存查询返回的完整结构。当查询命中该缓存时，MySQL会立刻返回结果，跳过了解析、优化和执行阶段。<br> 查询缓存系统会跟踪查询中涉及的每个表，如果这些表发生了变化，那么和这个表相关的所有缓存数据都将失效。<br> MySQL将缓存存放在一个引用表中，通过一个哈希值引用，这个哈希值包括了以下因素，即查询本身、当前要查询的数据库、客户端协议的版本等一些其他可能影响返回结果的信息。<br> 当判断缓存是否命中时，MySQL不会进行解析查询语句，而是直接使用SQL语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中。<br> 当查询语句中有一些不确定的数据时，则不会被缓存。例如包含函数NOW()或者CURRENT_DATE()的查询不会缓存。包含任何用户自定义函数，存储函数，用户变量，临时表，mysql数据库中的系统表或者包含任何列级别权限的表，都不会被缓存。<br> 有一点需要注意，MySQL并不是会因为查询中包含一个不确定的函数而不检查查询缓存，因为检查查询缓存之前，MySQL不会解析查询语句，所以也无法知道语句中是否有不确定的函数。<br> 事实则是，如果查询语句中包含任何的不确定的函数，那么其查询结果不会被缓存，因为查询缓存中也无法找到对应的缓存结果。<br> 有关查询缓存的配置如下所示。  </p>
<ul>
<li>query_cache_type:是否打开查询缓存。可以设置为OFF、ON和DEMAND。DEMAND表示只有在查询语句中明确写明SQL_CACHE的语句才会放入查询缓存。</li>
<li>query_cache_size:查询缓存使用的总内存空间。</li>
<li>query_cache_min_res_unit:在查询缓存中分配内存块时的最小单元。较小的该值可以减少碎片导致的内存空间浪费，但是会导致更频繁的内存块操作。</li>
<li>query_cache_limit:MySQL能够查询的最大查询结果。如果查询结果大于这个值，则不会被缓存。因为查询缓存在数据生成的时候就开始尝试缓存数据，所以当结果全部返回后，MySQL才知道查询结果是否超出限制。超出之后，才会将结果从查询缓存中删除。</li>
</ul>
<p>对查询缓存的优化是数据库性能优化的重要一环。判断流程大致如下图所示。</p>
<p><img src="/2017/11/28/Mysql-SQL语句执行/execute2.png" alt="mysql" title="mysql"></p>
<p>缓存命中率可以通过如下公式计算：Qcache_hits/(Qcache_hits + Com_select)来计算。</p>
<h2 id="解析和预处理"><a href="#解析和预处理" class="headerlink" title="解析和预处理"></a>解析和预处理</h2><p> 解析器通过关键字将SQL语句进行解析，并生成对应的解析树。MySQL解析器将使用MySQL语法规则验证和解析查询。<br> 预处理器则根据一些MySQL规则进行进一步检查解析书是否合法，例如检查数据表和数据列是否存在，还会解析名字和别名，看看它们是否有歧义。</p>
<h2 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h2><p> 查询优化器会将解析树转化成执行计划。一条查询可以有多种执行方法，最后都是返回相同结果。优化器的作用就是找到这其中最好的执行计划。<br> 生成执行计划的过程会消耗较多的时间，特别是存在许多可选的执行计划时。如果在一条SQL语句执行的过程中将该语句对应的最终执行计划进行缓存，当相似的语句再次被输入服务器时，就可以直接使用已缓存的执行计划，从而跳过SQL语句生成执行计划的整个过程，进而可以提高语句的执行速度。</p>
<p><img src="/2017/11/28/Mysql-SQL语句执行/execute3.png" alt="mysql" title="mysql"></p>
<p> MySQL使用基于成本的查询优化器(Cost-Based Optimizer，CBO)。它会尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最少的一个。<br> 优化器会根据优化规则对关系表达式进行转换，这里的转换是说一个关系表达式经过优化规则后会生成另外一个关系表达式，同时原有表达式也会保留，经过一系列转换后会生成多个执行计划，然后CBO会根据统计信息和代价模型(Cost Model)计算每个执行计划的Cost，从中挑选Cost最小的执行计划。由上可知，CBO中有两个依赖：统计信息和代价模型。统计信息的准确与否、代价模型的合理与否都会影响CBO选择最优计划。<br> 有关优化器的原理十分复杂，这里就不进行详细讲解了，大家可以自行学习。</p>
<h2 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h2><p> 在解析和优化阶段，MySQL将生成查询对应的执行计划，MySQL的查询执行引擎根据这个执行计划来完成整个查询。这里执行计划是一个数据结构，而不是和其他的关系型数据库那样生成对应的字节码。</p>
<h2 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h2><p> 如果查询可以被缓存，那么MySQL在这个阶段页会将结果存放到查询缓存中。<br> MySQL将结果集返回给客户端是一个增量、逐步返回的过程。在查询生成第一条结果时，MySQL就可以开始向客户端逐步返回结果集了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>SQL优化器原理——查询优化器综述 <a href="https://zhuanlan.zhihu.com/p/40478975" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/40478975</a></li>
<li>《高性能MySQL》</li>
<li>《MySQL技术内幕-InnoDB存储引擎》</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/mysql.jpg&quot; alt=&quot;mysql&quot; title=&quot;mysql&quot;&gt;&lt;/p&gt;
&lt;p&gt;昔日庖丁解牛，未见全牛，所赖者是其对牛内部骨架结构的了解，对于MySQL亦是如此，只有更加全面地了解SQL语句执行的每个过程，才能更好的进行SQL的设计和优化。&lt;br&gt; 当希望MySQL能够以更高的性能运行查询时，最好的办法就是弄清楚MySQL是如何优化和执行查询的。一旦理解了这一点，很多查询优化工作实际上就是遵循一些原则能够按照预想的合理的方式运行。&lt;br&gt; 如下图所示，当向MySQL发送一个请求的时候，MySQL到底做了什么：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端发送一条查询给服务器。&lt;/li&gt;
&lt;li&gt;服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。&lt;/li&gt;
&lt;li&gt;服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。&lt;/li&gt;
&lt;li&gt;MySQL根据优化器生成的执行计划，再调用存储引擎的API来执行查询。&lt;/li&gt;
&lt;li&gt;将结果返回给客户端。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://jet-han.oschina.io/tags/mysql/"/>
    
      <category term="语句执行" scheme="http://jet-han.oschina.io/tags/%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-B-Tree索引</title>
    <link href="http://jet-han.oschina.io/2017/11/28/Msql-B-Tree%E7%B4%A2%E5%BC%95/"/>
    <id>http://jet-han.oschina.io/2017/11/28/Msql-B-Tree索引/</id>
    <published>2017-11-28T06:13:59.000Z</published>
    <updated>2018-12-11T09:02:02.254Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/mysql.jpg" alt="mysql" title="mysql"></p>
<p>MySQL是目前业界最为流行的关系型数据库之一，而索引的优化也是数据库性能优化的关键之一。所以，充分地了解MySQL索引有助于提升开发人员对MySQL数据库的使用优化能力。</p>
<p>MySQL的索引有很多种类型，可以为不同的场景提供更好的性能。而B-Tree索引是最为常见的MySQL索引类型，一般谈论MySQL索引时，如果没有特别说明，就是指B-Tree索引。本文就详细讲解一下B-Tree索引的的底层结构，使用原则和特性。</p>
<p>主要内容如下：</p>
<ul>
<li>B-Tree索引的底层结构</li>
<li>B-Tree索引的使用规则</li>
<li>聚簇索引</li>
<li>InnoDB和MyISAM引擎索引的差异</li>
<li>松散索引</li>
<li>覆盖索引</li>
</ul>
<a id="more"></a>
<h2 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h2><p>B-Tree索引使用B-Tree来存储数据，当然不同存储引擎的实现方式不同。B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同，下图展示了B-Tree索引的抽象表示，由此可以看出MySQL的B-Tree索引的大致工作机制。</p>
<p>B-Tree索引的底层数据结构一般是B+树，其具体数据结构和优势这里就不作详细描述，下图展示了B-树索引的抽象表示，大致反应了MyISAM索引是如何工作的，而InnoDB使用的结构有所不同。</p>
<p><img src="/2017/11/28/Msql-B-Tree索引/b-tree1.png" alt="mysql" title="mysql"></p>
<p>MySQL可以在单独一列上添加B-Tree索引，也可以在多列数据上添加B-Tree索引，多列的数据按照添加索引声明的顺序组合起来，存储在B-Tree的页中。假设有如下数据表：</p>
<p><img src="/2017/11/28/Msql-B-Tree索引/b-tree2.png" alt="mysql" title="mysql"></p>
<p>  对于表中的每一行数据，索引中包含了last_name，first_name和birthday列的值，下图展示了该索引是如何组织数据的存储的。</p>
<p><img src="/2017/11/28/Msql-B-Tree索引/b-tree3.png" alt="mysql" title="mysql">  </p>
<p>B-Tree索引使用B-Tree作为其存储数据的数据结构，其使用的查询规则也由此决定。一般来说，B-Tree索引适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于根据最左前缀查找。B-Tree索引支持的查询原则如下所示：</p>
<ul>
<li>全值匹配：全值匹配指的是和索引中的所有列进行匹配。</li>
<li>匹配最左前缀：前边提到的索引可以用于查找所有姓Allen的人，即只使用索引中的第一列。</li>
<li>匹配列前缀：也可以只匹配某一列的值的开头部分。例如前面提到的索引可用于查找所有以J开头的姓的人。这里也只用到了索引的第一列。</li>
<li>匹配范围值：例如前边提到的索引可用于查找姓在Allen和Barrymore之间的人。这里也只使用了索引的第一列。</li>
<li>精确匹配某一列并范围匹配另外一列：前边提到的索引也可用于查找所有姓为Allen，并且名字是字母K开头(比如Kim,Karl等)的人。即第一列last_name全匹配，第二列first_name范围匹配。</li>
</ul>
<p>因为索引树的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的ORDER BY操作(按顺序查找)，如果ORDER BY子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。</p>
<p>下面是一些关于B-Tree索引的限制：</p>
<ul>
<li>如果不是按照索引的最左列开始查找，则无法使用索引。例如上面例子中的索引无法查找名字为Bill的人，也无法查找某个特定生日的日，因为这两列都不是最左数据列。</li>
<li>如果查询中有某个列的范围查询，则其右侧所有列都无法使用索引优化查找。</li>
</ul>
<h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体的细节依赖于其实现方式，但是InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。</p>
<p>当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中，这也就是说数据行和相邻的键值紧凑地存储在一起。</p>
<p>下图展示了聚簇索引中的记录是如何存放的。注意到，叶子页包含了行的全部数据行，但是节点页只包含了索引列。</p>
<p><img src="/2017/11/28/Msql-B-Tree索引/b-tree4.png" alt="mysql" title="mysql">  </p>
<p>聚簇索引可能对性能有帮助，但也可能导致严重的性能问题。聚簇的数据是有一些重要的优点：</p>
<ul>
<li>数据访问更快，聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</li>
</ul>
<p>如果在设计表和查询时能充分利用上面的优点，那么就能极大地提升性能。同时，聚簇索引也有一些缺点：</p>
<ul>
<li>插入顺序严重依赖插入顺序。按照主键的顺序插入是向InnoDB表中插入数据速度最快的方式，需要避免主键键值随机的(不连续且值得分布范围非常大)聚簇索引，比如使用UUID作为主键，而应该使用类似AUTO_INCREMENT的自增列。</li>
<li>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动位置到新的位置。</li>
<li>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行时，可能面临“页分裂”的问题。当行的主键值要求必须将这行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间。</li>
<li>二级索引可能比想象的更大，因为在二级索引中的叶节点包含了引用行的主键列。</li>
<li>二级索引访问需要两次索引查找，而不是一次。</li>
</ul>
<h3 id="InnoDB和MyISAM的索引区别"><a href="#InnoDB和MyISAM的索引区别" class="headerlink" title="InnoDB和MyISAM的索引区别"></a>InnoDB和MyISAM的索引区别</h3><p>聚簇索引和非聚簇索引的数据分布有区别，以及对应的主键索引和二级索引的数据分布也有区别，通常会让人感到困惑和意外。下图展示了MyISAM和InnoDB的不同索引和数据存储方式。</p>
<p>MyISAM的数据分布非常简单，按照数据插入的顺序存储在磁盘上，主键索引和二级索引的叶节点存储着指针，指向对应的数据行。InnoDB中，聚簇索引“就是”表，所以不会像MyISAM那样需要独立的行存储。聚簇索引的每个叶节点都包含了主键值和所有的剩余列(在此例中是col2)。</p>
<p>InnoDB的二级索引和聚簇索引很不同。InnoDB二级索引的叶节点中存储的不是“行指针”，而是主键值，并以此作为指向行的“指针”。</p>
<p><img src="/2017/11/28/Msql-B-Tree索引/b-tree5.png" alt="mysql" title="mysql">  </p>
<h2 id="松散索引扫描"><a href="#松散索引扫描" class="headerlink" title="松散索引扫描"></a>松散索引扫描</h2><p>MySQL并不支持松散索引扫描，也就是无法按照不连续的方式扫描一个索引。通常，MySQL的索引扫描需要先定义一个起点和终点，即使需要的数据只是这段索引中很少数的几个，MySQL仍然需要扫描这段索引中的每个条目。</p>
<p>下面，我们通过一个示例说明这点，假设我们有如下索引(a,b)，有下面的查询：</p>
<p>因为索引的前导字段是列a，但是在查询中只指定了字段b，MySQL无法使用这个索引，从而只能通过全表扫描找到匹配的行，如下图所示。</p>
<p><img src="/2017/11/28/Msql-B-Tree索引/b-tree6.png" alt="mysql" title="mysql">  </p>
<p>了解索引的物理结构的话，不难发现还可以有一个更快的办法执行上面的查询。索引的物理结构(不是存储引擎的API)是的可以先扫描a列第一个值对应的b列的范围，然后再跳到a列第二个不不同值扫描对应的b列的范围。下图展示了如果由MySQL来实现这个过程会怎样。</p>
<p><img src="/2017/11/28/Msql-B-Tree索引/b-tree7.png" alt="mysql" title="mysql"> </p>
<p>注意到，这时就无须再使用WHERE子句过滤，因为松散索引扫描已经跳过了所有不需要的记录。</p>
<p><img src="/2017/11/28/Msql-B-Tree索引/b-tree8.png" alt="mysql" title="mysql"> </p>
<p>MySQL 5.0之后的版本，在某些特殊的场景下是可以使用松散索引扫描的，例如，在一个分组查询中需要找到分组的最大值和最小值：</p>
<p>在EXPLAIN中的Extra字段显示”Using index for group-by”，表示这里将使用松散索引扫描。</p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>索引除了是一种查找数据的高效方式之外，也是一种列数据的直接获取方式。MySQL可以使用索引来直接获取列的数据，这样就不需要读取数据行。如果一个索引包含所有需要查询的字段的值，我们就称之为“覆盖索引”。</p>
<p>覆盖索引是非常有用的工具，能够极大地提高性能。SQL查询只需要扫描索引而无需回表，会带来很多好处：</p>
<ul>
<li>索引条目数量和大小通常远小于数据行的条目和大小，所以如果只需要读取索引，那么MySQL就会极大地减少数据访问量。</li>
<li>因为索引是按照列顺序存储的，所以对于I/O密集型的范围查找会比随机从磁盘读取每一行数据的I/O要少的多。</li>
<li>由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点中保存了行的主键，索引如果二级主键能够覆盖查询，则避免对主键索引的第二次查询。</li>
</ul>
<p>当发起一个被覆盖索引的查询(也叫索引覆盖查询)时，在EXPLAIN的Extra列可以看到”Using Index”的信息。例如，表sakila.inventory有一个多列索引(store_id, film_id)。MySQL如果只需要访问这两列，就可以使用这个索引做覆盖索引，如下所示：</p>
<p><img src="/2017/11/28/Msql-B-Tree索引/b-tree9.png" alt="mysql" title="mysql"> </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>MySQL索引背后的数据结构及算法原理 blog.codinglabs.org</li>
<li>《高性能MySQL》</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/mysql.jpg&quot; alt=&quot;mysql&quot; title=&quot;mysql&quot;&gt;&lt;/p&gt;
&lt;p&gt;MySQL是目前业界最为流行的关系型数据库之一，而索引的优化也是数据库性能优化的关键之一。所以，充分地了解MySQL索引有助于提升开发人员对MySQL数据库的使用优化能力。&lt;/p&gt;
&lt;p&gt;MySQL的索引有很多种类型，可以为不同的场景提供更好的性能。而B-Tree索引是最为常见的MySQL索引类型，一般谈论MySQL索引时，如果没有特别说明，就是指B-Tree索引。本文就详细讲解一下B-Tree索引的的底层结构，使用原则和特性。&lt;/p&gt;
&lt;p&gt;主要内容如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B-Tree索引的底层结构&lt;/li&gt;
&lt;li&gt;B-Tree索引的使用规则&lt;/li&gt;
&lt;li&gt;聚簇索引&lt;/li&gt;
&lt;li&gt;InnoDB和MyISAM引擎索引的差异&lt;/li&gt;
&lt;li&gt;松散索引&lt;/li&gt;
&lt;li&gt;覆盖索引&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://jet-han.oschina.io/tags/mysql/"/>
    
      <category term="B-Tree索引" scheme="http://jet-han.oschina.io/tags/B-Tree%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring中bean的生命周期</title>
    <link href="http://jet-han.oschina.io/2017/09/13/Spring%E4%B8%ADbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://jet-han.oschina.io/2017/09/13/Spring中bean的生命周期/</id>
    <published>2017-09-13T09:58:54.000Z</published>
    <updated>2018-11-13T07:29:44.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring中bean的生命周期"><a href="#Spring中bean的生命周期" class="headerlink" title="Spring中bean的生命周期"></a>Spring中bean的生命周期</h1><p><img src="/2017/09/13/Spring中bean的生命周期/spring.jpg" alt="spring" title="spring"></p>
<p>一分钟掌握Spring中bean的生命周期！<br>在spring中，从BeanFactory或ApplicationContext取得的实例为Singleton，也就是预设为每一个Bean的别名只能维持一个实例.</p>
<p>在spring中，从BeanFactory或ApplicationContext取得的实例为Singleton，也就是预设为每一个Bean的别名只能维持一个实例，而不是每次都产生一个新的对象使用Singleton模式产生单一实例，对单线程的程序说并不会有什么问题，但对于多线程的程序，就必须注意安全(Thread-safe)的议题，防止多个线程同时存取共享资源所引发的数据不同步问题。</p>
<p>然而在spring中 可以设定每次从BeanFactory或ApplicationContext指定别名并取得Bean时都产生一个新的实例：例如：</p>
<p>在spring中，singleton属性默认是true，只有设定为false，则每次指定别名取得的Bean时都会产生一个新的实例</p>
<p>一个Bean从创建到销毁，如果是用BeanFactory来生成,管理Bean的话，会经历几个执行阶段(如图)：</p>
<a id="more"></a>
<p><img src="/2017/09/13/Spring中bean的生命周期/spring-bean-1.png" alt="spring-bean生命周期"></p>
<ul>
<li>Bean的建立：</li>
</ul>
<p>容器寻找Bean的定义信息并将其实例化。</p>
<ul>
<li>属性注入：</li>
</ul>
<p>使用依赖注入，Spring按照Bean定义信息配置Bean所有属性</p>
<ul>
<li>BeanNameAware的setBeanName()：</li>
</ul>
<p>如果Bean类有实现org.springframework.beans.BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的ID。</p>
<ul>
<li>BeanFactoryAware的setBeanFactory()：</li>
</ul>
<p>如果Bean类有实现org.springframework.beans.factory.BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身。</p>
<ul>
<li>BeanPostProcessors的ProcessBeforeInitialization()</li>
</ul>
<p>如果有org.springframework.beans.factory.config.BeanPostProcessors和Bean关联，那么其postProcessBeforeInitialization()方法将被将被调用。</p>
<ul>
<li>initializingBean的afterPropertiesSet()：</li>
</ul>
<p>如果Bean类已实现org.springframework.beans.factory.InitializingBean接口，则执行他的afterProPertiesSet()方法</p>
<ul>
<li>Bean定义文件中定义init-method：</li>
</ul>
<p>可以在Bean定义文件中使用”init-method”属性设定方法名称例如：</p>
<p>如果有以上设置的话，则执行到这个阶段，就会执行initBean()方法</p>
<ul>
<li>BeanPostProcessors的ProcessaAfterInitialization()</li>
</ul>
<p>如果有任何的BeanPostProcessors实例与Bean实例关联，则执行BeanPostProcessors实例的ProcessaAfterInitialization()方法</p>
<p>此时，Bean已经可以被应用系统使用，并且将保留在BeanFactory中知道它不在被使用。有两种方法可以将其从BeanFactory中删除掉(如图):</p>
<p><img src="/2017/09/13/Spring中bean的生命周期/spring-bean-2.png" alt="spring-bean生命周期"></p>
<ul>
<li>DisposableBean的destroy()</li>
</ul>
<p>在容器关闭时，如果Bean类有实现org.springframework.beans.factory.DisposableBean接口，则执行他的destroy()方法</p>
<ul>
<li>Bean定义文件中定义destroy-method</li>
</ul>
<p>在容器关闭时，可以在Bean定义文件中使用”destroy-method”属性设定方法名称，例如：</p>
<p>如果有以上设定的话，则进行至这个阶段时，就会执行destroy()方法，如果是使用ApplicationContext来生成并管理Bean的话则稍有不同，使用ApplicationContext来生成及管理Bean实例的话，在执行BeanFactoryAware的setBeanFactory()阶段后，若Bean类上有实现org.springframework.context.ApplicationContextAware接口，则执行其setApplicationContext()方法，接着才执行BeanPostProcessors的ProcessBeforeInitialization()及之后的流程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring中bean的生命周期&quot;&gt;&lt;a href=&quot;#Spring中bean的生命周期&quot; class=&quot;headerlink&quot; title=&quot;Spring中bean的生命周期&quot;&gt;&lt;/a&gt;Spring中bean的生命周期&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2017/09/13/Spring中bean的生命周期/spring.jpg&quot; alt=&quot;spring&quot; title=&quot;spring&quot;&gt;&lt;/p&gt;
&lt;p&gt;一分钟掌握Spring中bean的生命周期！&lt;br&gt;在spring中，从BeanFactory或ApplicationContext取得的实例为Singleton，也就是预设为每一个Bean的别名只能维持一个实例.&lt;/p&gt;
&lt;p&gt;在spring中，从BeanFactory或ApplicationContext取得的实例为Singleton，也就是预设为每一个Bean的别名只能维持一个实例，而不是每次都产生一个新的对象使用Singleton模式产生单一实例，对单线程的程序说并不会有什么问题，但对于多线程的程序，就必须注意安全(Thread-safe)的议题，防止多个线程同时存取共享资源所引发的数据不同步问题。&lt;/p&gt;
&lt;p&gt;然而在spring中 可以设定每次从BeanFactory或ApplicationContext指定别名并取得Bean时都产生一个新的实例：例如：&lt;/p&gt;
&lt;p&gt;在spring中，singleton属性默认是true，只有设定为false，则每次指定别名取得的Bean时都会产生一个新的实例&lt;/p&gt;
&lt;p&gt;一个Bean从创建到销毁，如果是用BeanFactory来生成,管理Bean的话，会经历几个执行阶段(如图)：&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring" scheme="http://jet-han.oschina.io/tags/spring/"/>
    
      <category term="life cycle" scheme="http://jet-han.oschina.io/tags/life-cycle/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://jet-han.oschina.io/2017/08/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jet-han.oschina.io/2017/08/08/设计模式/</id>
    <published>2017-08-08T06:34:34.000Z</published>
    <updated>2018-11-13T07:49:44.489Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/08/08/设计模式/java.jpg" alt="java" title="java"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>设计模式简介</strong><br>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 </p>
<p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。<br><a id="more"></a><br><strong>什么是 GOF（四人帮，全拼 Gang of Four）？</strong><br>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。<br>四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。<br>对接口编程而不是对实现编程。<br>优先使用对象组合而不是继承。<br><strong>设计模式的使用</strong><br>设计模式在软件开发中的两个主要用途。<br><strong>开发人员的共同平台</strong><br>设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。<br><strong>最佳的实践</strong><br>设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。<br><strong>设计模式的类型</strong><br>根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th>模式&amp;描述</th>
<th>包含</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td><strong>创建型模式</strong><br>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑<br>的方式，而不是使用 new 运算符直接实例化对象。这<br>使得程序在判断针对某个给定实例需要创建哪些对象时<br>更加灵活。</td>
<td>工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td><strong>结构型模式</strong><br>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td>
<td>适配器模式（Adapter Pattern）<br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td><strong>行为型模式</strong><br>这些设计模式特别关注对象之间的通信。</td>
<td>责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td><strong>J2EE 模式</strong><br>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</td>
<td>MVC 模式（MVC Pattern）<br>业务代表模式（Business Delegate Pattern）<br>组合实体模式（Composite Entity Pattern）<br>数据访问对象模式（Data Access Object Pattern）<br>前端控制器模式（Front Controller Pattern）<br>拦截过滤器模式（Intercepting Filter Pattern）<br>服务定位器模式（Service Locator Pattern）<br>传输对象模式（Transfer Object Pattern）</td>
</tr>
</tbody>
</table>
</div>
<p>下面用一个图片来整体描述一下设计模式之间的关系：<br><img src="/2017/08/08/设计模式/design-patterns.jpg" alt="design-patterns" title="design-patterns"></p>
<p><strong>设计模式的六大原则</strong>  </p>
<ol>
<li><strong>开闭原则（Open Close Principle）</strong><br>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。  </li>
<li><strong>里氏代换原则（Liskov Substitution Principle）</strong><br>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。  </li>
<li><strong>依赖倒转原则（Dependence Inversion Principle）</strong><br>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。  </li>
<li><strong>接口隔离原则（Interface Segregation Principle）</strong><br>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。  </li>
<li><strong>迪米特法则，又称最少知道原则（Demeter Principle）</strong><br>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</li>
<li><strong>合成复用原则（Composite Reuse Principle）</strong><br>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</li>
</ol>
<h2 id="java常用设计模式"><a href="#java常用设计模式" class="headerlink" title="java常用设计模式"></a>java常用设计模式</h2><p>通俗一点讲就是：<br>一个程序员对设计模式的理解:<br>“不懂”为什么要把很简单的东西搞得那么复杂。后来随着软件开发经验的增加才开始明白我所看到的“复杂”恰恰就是设计模式的精髓所在，我所理解的“简单”就是一把钥匙开一把锁的模式，目的仅仅是着眼于解决现在的问题，而设计模式的“复杂”就在于它是要构造一个“万能钥匙”，目的是提出一种对所有锁的开锁方案。在真正理解设计模式之前我一直在编写“简单”的代码.<br>这个“简单”不是功能的简单，而是设计的简单。简单的设计意味着缺少灵活性，代码很钢硬，只在这个项目里有用，拿到其它的项目中就是垃圾，我将其称之为“一次性代码”。</p>
<p>要使代码可被反复使用,请用’设计模式’对你的代码进行设计。 </p>
<p>很多我所认识的程序员在接触到设计模式之后，都有一种相见恨晚的感觉，有人形容学习了设计模式之后感觉自己好像已经脱胎换骨，达到了新的境界，还有人甚至把是否了解设计模式作为程序员划分水平的标准。<br>我们也不能陷入模式的陷阱，为了使用模式而去套模式，那样会陷入形式主义。我们在使用模式的时候，一定要注意模式的意图（intent），而不要过多的去关注模式的实现细节，因为这些实现细节在特定情况下，可能会发生一些改变。不要顽固地认为设计模式一书中的类图或实现代码就代表了模式本身。  </p>
<p>设计原则：(重要)</p>
<ol>
<li>逻辑代码独立到单独的方法中，注重封装性—易读，易复用。<br>不要在一个方法中，写下上百行的逻辑代码。把各小逻辑代码独立出来，写于其它方法中，易读其可重复调用。</li>
<li>写类，写方法，写功能时，应考虑其移植性，复用性：防止一次性代码！<br>是否可以拿到其它同类事物中应该？是否可以拿到其它系统中应该？</li>
<li>熟练运用继承的思想：<br>找出应用中相同之处，且不容易发生变化的东西，把它们抽取到抽象类中，让子类去继承它们；<br>继承的思想，也方便将自己的逻辑建立于别人的成果之上。如ImageField extends JTextField；<br>熟练运用接口的思想：<br>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li>
</ol>
<p><strong>把很简单的东西搞得那么复杂，一次性代码，设计模式优势的实例说明：（策略模式）</strong><br>说明：<br>模拟鸭子游戏的应用程序，要求：游戏中会出现各种颜色外形的鸭子，一边游泳戏水，一边呱呱叫。<br><strong>1、 一次性代码 </strong><br>直接编写出各种鸭子的类：MallardDuck//野鸭，RedheadDuck//红头鸭，各类有三个方法：<br>quack()：叫的方法<br>swim()：游水的方法<br>display()：外形的方法<br><strong>2、运用继承的特性，将其中共同的部分提升出来，避免重复编程。</strong><br>即：设计一个鸭子的超类（Superclass）,并让各种鸭子继承这个超类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Duck&#123;</div><div class="line">     public void quack()&#123;  //呱呱叫</div><div class="line">              System.out.println(&quot;呱呱叫&quot;);</div><div class="line">      &#125;</div><div class="line">     public void swim()&#123;   //游泳</div><div class="line">            System.out.println(&quot; 游泳&quot;);</div><div class="line">      &#125;    </div><div class="line">     public  abstratact void display(); /*因为外观不一样，让子类自己去决定了。*/</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于它的子类只需简单的继承就可以了，并实现自己的display()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//野鸭</div><div class="line"> public class MallardDuck extends Duck&#123;</div><div class="line">     public void display()&#123;</div><div class="line">          System.out.println(&quot;野鸭的颜色...&quot;);</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line">//红头鸭</div><div class="line"> public class RedheadDuck extends Duck&#123;</div><div class="line">     public void display()&#123;</div><div class="line">          System.out.println(&quot;红头鸭的颜色...&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不幸的是，现在客户又提出了新的需求，想让鸭子飞起来。这个对于我们OO程序员，在简单不过了，在超类中在加一个方法就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Duck&#123;</div><div class="line">   public void quack()&#123;  //呱呱叫</div><div class="line">      System.out.println(&quot;呱呱叫&quot;);</div><div class="line">     &#125;</div><div class="line">   public void swim()&#123;   //游泳</div><div class="line">      System.out.println(&quot; 游泳&quot;);</div><div class="line">   &#125;    </div><div class="line">   public  abstract void display(); /*因为外观不一样，让子类自己去决定了。*/</div><div class="line">   public void fly()&#123;</div><div class="line">      System.out.println(&quot;飞吧！鸭子&quot;); </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于不能飞的鸭子，在子类中只需简单的覆盖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//残废鸭</div><div class="line"> public class DisabledDuck extends Duck&#123;</div><div class="line">    public void display()&#123;</div><div class="line">       System.out.println(&quot;残废鸭的颜色...&quot;);</div><div class="line">   &#125;</div><div class="line">   public void fly()&#123;</div><div class="line">    //覆盖，变成什么事都不做。 </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其它会飞的鸭子不用覆盖。<br>这样所有的继承这个超类的鸭子都会fly了。但是问题又出来了，客户又提出有的鸭子会飞，有的不能飞。</p>
<p><strong>对于上面的设计，你可能发现一些弊端，如果超类有新的特性，子类都必须变动，这是我们开发最不喜欢看到的，一个类变让另一个类也跟着变，这有点不符合OO设计了。这样很显然的耦合了一起。利用继承—&gt;耦合度太高了.</strong></p>
<p><strong>3、用接口改进</strong><br>我们把容易引起变化的部分提取出来并封装之，来应付以后的变法。虽然代码量加大了，但可用性提高了，耦合度也降低了。<br>我们把Duck中的fly方法和quack提取出来。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> public interface Flyable&#123;</div><div class="line">    public void fly(); </div><div class="line">&#125;</div><div class="line"> public interface Quackable&#123;</div><div class="line">   public void quack();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  最后Duck的设计成为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class Duck&#123;</div><div class="line">     public void swim()&#123;   //游泳</div><div class="line">            System.out.println(&quot; 游泳&quot;);</div><div class="line">    &#125;    </div><div class="line">    public  abstract void display(); /*因为外观不一样，让子类自 己去决定了。*/</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 而MallardDuck,RedheadDuck,DisabledDuck 就可以写成为：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">//野鸭</div><div class="line"> public class MallardDuck extends Duck implements Flyable,Quackable&#123;</div><div class="line">     public void display()&#123;</div><div class="line">          System.out.println(&quot;野鸭的颜色...&quot;);</div><div class="line">   &#125;</div><div class="line">   public void fly()&#123;</div><div class="line">    //实现该方法</div><div class="line">  &#125;</div><div class="line">   public void quack()&#123;</div><div class="line">    //实现该方法</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line">//红头鸭</div><div class="line"> public class RedheadDuck extends Duck implements Flyable,Quackable&#123;</div><div class="line">     public void display()&#123;</div><div class="line">          System.out.println(&quot;红头鸭的颜色...&quot;);</div><div class="line">   &#125;</div><div class="line">   public void fly()&#123;</div><div class="line">    //实现该方法</div><div class="line">  &#125;</div><div class="line">   public void quack()&#123;</div><div class="line">    //实现该方法</div><div class="line">  &#125;</div><div class="line">&#125; </div><div class="line">//残废鸭 只实现Quackable（能叫不能飞）</div><div class="line"> public class DisabledDuck extends Duck implements Quackable&#123;</div><div class="line">     public void display()&#123;</div><div class="line">          System.out.println(&quot;残废鸭的颜色...&quot;);</div><div class="line">   &#125;</div><div class="line">   public void quack()&#123;</div><div class="line">    //实现该方法</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好处:<br>这样已设计，我们的程序就降低了它们之间的耦合。<br>不足:<br>Flyable和 Quackable接口一开始似乎还挺不错的，解决了问题（只有会飞到鸭子才实现 Flyable），但是Java接口不具有实现代码，所以<strong>实现接口无法达到代码的复用</strong>。</p>
<p><strong>继承的好处:</strong>让共同部分,可以复用.避免重复编程.<br><strong>继承的不好:</strong>耦合性高.一旦超类添加一个新方法,子类都继承,拥有此方法,若子类相当部分不实现此方法,则要进行大批量修改.继承时,子类就不可继承其它类了.<br><strong>接口的好处:</strong>解决了继承耦合性高的问题,且可让实现类,继承或实现其它类或接口.<br><strong>接口的不好:</strong>不能真正实现代码的复用.可用以下的策略模式来解决.</p>
<h2 id="strategy-策略模式"><a href="#strategy-策略模式" class="headerlink" title="strategy(策略模式)"></a>strategy(策略模式)</h2><p>我们有一个设计原则：<br>找出应用中相同之处，且不容易发生变化的东西，把它们抽取到抽象类中，让子类去继承它们；<br>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。   </p>
<p>现在，为了要分开“变化和不变化的部分”，我们准备建立两组类（完全远离Duck类），一个是”fly”相关的，另一个是“quack”相关的，每一组类将实现各自的动作。比方说，我们可能有一个类实现“呱呱叫”，另一个类实现“吱吱叫”，还有一个类实现“安静”。<br>首先写两个接口。<br>FlyBehavior(飞行行为)和QuackBehavior（叫的行为）.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public interface FlyBehavior&#123;</div><div class="line">   public void fly();     </div><div class="line">&#125;</div><div class="line">public interface QuackBehavior&#123;</div><div class="line">   public void quack();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在定义一些针对FlyBehavior的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class FlyWithWings implements FlyBehavior&#123;</div><div class="line">   public void  fly()&#123;</div><div class="line">     //实现了所有有翅膀的鸭子飞行行为。</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line">public class FlyNoWay implements FlyBehavior&#123;</div><div class="line">   public void  fly()&#123;</div><div class="line">      //什么都不做，不会飞</div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>针对QuackBehavior的几种具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Quack implements QuackBehavior&#123;</div><div class="line">   public void quack()&#123;</div><div class="line">      //实现呱呱叫的鸭子</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public class Squeak implements QuackBehavior&#123;</div><div class="line">   public void quack()&#123;</div><div class="line">      //实现吱吱叫的鸭子 </div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public class MuteQuack implements QuackBehavior&#123;</div><div class="line">   public void quack()&#123;</div><div class="line">      //什么都不做，不会叫</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>点评一:<br>这样的设计，可以让飞行和呱呱叫的动作被其他的对象复用，因为这些行为已经与鸭子类无关了。而我们增加一些新的行为，不会影响到既有的行为类，也不会影响“使用”到飞行行为的鸭子类。<br>最后我们看看Duck 如何设计。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Duck&#123;        ---------&gt;在抽象类中,声明各接口,定义各接口对应的方法.</div><div class="line">   FlyBehavior flyBehavior;//接口</div><div class="line">   QuackBehavior quackBehavior;//接口</div><div class="line">   public Duck()&#123;&#125;</div><div class="line">   public abstract void display();</div><div class="line">   public void swim()&#123;</div><div class="line">     //实现游泳的行为</div><div class="line">   &#125;</div><div class="line">   public void performFly()&#123;</div><div class="line">      flyBehavior.fly();  --&gt;由于是接口,会根据继承类实现的方式,而调用相应的方法.</div><div class="line">   &#125;</div><div class="line">   public void performQuack()&#123;</div><div class="line">      quackBehavior.quack();();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看看MallardDuck如何实现<br>通过构造方法,生成’飞’,’叫’具体实现类的实例,从而指定’飞’,’叫’的具体属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class MallardDuck extends Duck&#123;</div><div class="line">   public MallardDuck &#123;       </div><div class="line">      flyBehavior = new FlyWithWings ();</div><div class="line">      quackBehavior = new Quack(); </div><div class="line">     //因为MallardDuck 继承了Duck，所有具有flyBehavior 与quackBehavior 实例变量</div><div class="line">  &#125;</div><div class="line">   public void display()&#123;</div><div class="line">    //实现</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就满足了即可以飞，又可以叫，同时展现自己的颜色了。<br>这样的设计我们可以看到是把flyBehavior ，quackBehavior 的实例化写在子类了。我们还可以动态的来决定。<br>我们只需在Duck中加上两个方法。</p>
<p>在构造方法中对属性进行赋值与用属性的setter的区别：<br><strong>构造方法中对属性进行赋值：固定，不可变；<br>用属性的setter，可以在实例化对象后，动态的变化，比较灵活。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Duck&#123;</div><div class="line">   FlyBehavior flyBehavior;//接口</div><div class="line">   QuackBehavior quackBehavior;//接口</div><div class="line">   public void setFlyBehavior(FlyBehavior flyBehavior)&#123;</div><div class="line">      this.flyBehavior = flyBehavior;</div><div class="line">   &#125;</div><div class="line">   public void setQuackBehavior(QuackBehavior quackBehavior  &#123;</div><div class="line">      this.quackBehavior= quackBehavior;</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。<br><strong>意图：</strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。<br><strong>主要解决：</strong>主要解决接口选择的问题。<br><strong>何时使用：</strong>我们明确地计划不同条件下创建不同实例时。<br><strong>如何解决：</strong>让其子类实现工厂接口，返回的也是一个抽象的产品。<br><strong>关键代码：</strong>创建过程在其子类执行。<br><strong>应用实例：</strong> 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。<br><strong>优点：</strong> 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。<br><strong>缺点：</strong>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。<br><strong>注意事项：</strong>作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。<br><strong>实现</strong><br>我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。<br>FactoryPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。<br><img src="/2017/08/08/设计模式/factory_pattern_uml_diagram.jpg" alt="factory_pattern" title="factory_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口:</p>
<p>Shape.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Shape &#123;</div><div class="line">   void draw();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类:  </p>
<p>Rectangle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Rectangle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Square.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Square implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Square::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Circle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Circle::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建一个工厂，生成基于给定信息的实体类的对象:</p>
<p>ShapeFactory.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class ShapeFactory &#123;</div><div class="line">	</div><div class="line">   //使用 getShape 方法获取形状类型的对象</div><div class="line">   public Shape getShape(String shapeType)&#123;</div><div class="line">      if(shapeType == null)&#123;</div><div class="line">         return null;</div><div class="line">      &#125;		</div><div class="line">      if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123;</div><div class="line">         return new Circle();</div><div class="line">      &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123;</div><div class="line">         return new Rectangle();</div><div class="line">      &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123;</div><div class="line">         return new Square();</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用该工厂，通过传递类型信息来获取实体类的对象:</p>
<p>FactoryPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class FactoryPatternDemo &#123;</div><div class="line"></div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      ShapeFactory shapeFactory = new ShapeFactory();</div><div class="line"></div><div class="line">      //获取 Circle 的对象，并调用它的 draw 方法</div><div class="line">      Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);</div><div class="line"></div><div class="line">      //调用 Circle 的 draw 方法</div><div class="line">      shape1.draw();</div><div class="line"></div><div class="line">      //获取 Rectangle 的对象，并调用它的 draw 方法</div><div class="line">      Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);</div><div class="line"></div><div class="line">      //调用 Rectangle 的 draw 方法</div><div class="line">      shape2.draw();</div><div class="line"></div><div class="line">      //获取 Square 的对象，并调用它的 draw 方法</div><div class="line">      Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);</div><div class="line"></div><div class="line">      //调用 Square 的 draw 方法</div><div class="line">      shape3.draw();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Inside Circle::draw() method.</div><div class="line">Inside Rectangle::draw() method.</div><div class="line">Inside Square::draw() method.</div></pre></td></tr></table></figure>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。<br>介绍<br>意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br>主要解决：主要解决接口选择的问题。<br>何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。<br>如何解决：在一个产品族里面，定义多个产品。<br>关键代码：在一个工厂里聚合多个同类产品。<br>应用实例：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。<br>优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。<br>缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。<br>使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。<br>注意事项：产品族难扩展，产品等级易扩展。<br>实现<br>我们将创建 Shape 和 Color 接口和实现这些接口的实体类。下一步是创建抽象工厂类 AbstractFactory。接着定义工厂类 ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory。然后创建一个工厂创造器/生成器类 FactoryProducer。<br>AbstractFactoryPatternDemo，我们的演示类使用 FactoryProducer 来获取 AbstractFactory 对象。它将向 AbstractFactory 传递形状信息 Shape（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。同时它还向 AbstractFactory 传递颜色信息 Color（RED / GREEN / BLUE），以便获取它所需对象的类型。<br><img src="/2017/08/08/设计模式/abstractfactory_pattern_uml_diagram.jpg" alt="abstractfactory_pattern" title="abstractfactory_pattern"></p>
<p><strong>步骤 1</strong> </p>
<p>为形状创建一个接口。</p>
<p>Shape.java</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Shape &#123;</div><div class="line">   void draw();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>Rectangle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Rectangle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Square.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Square implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Square::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Circle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Circle::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>为颜色创建一个接口。</p>
<p>Color.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Color &#123;</div><div class="line">   void fill();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤4</strong> </p>
<p>创建实现接口的实体类。  </p>
<p>Red.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Red implements Color &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void fill() &#123;</div><div class="line">      System.out.println(&quot;Inside Red::fill() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Green.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Green implements Color &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void fill() &#123;</div><div class="line">      System.out.println(&quot;Inside Green::fill() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Blue.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Blue implements Color &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void fill() &#123;</div><div class="line">      System.out.println(&quot;Inside Blue::fill() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong>  </p>
<p>为 Color 和 Shape 对象创建抽象类来获取工厂。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">AbstractFactory.java</div><div class="line">public abstract class AbstractFactory &#123;</div><div class="line">   abstract Color getColor(String color);</div><div class="line">   abstract Shape getShape(String shape) ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。</p>
<p>ShapeFactory.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class ShapeFactory extends AbstractFactory &#123;</div><div class="line">	</div><div class="line">   @Override</div><div class="line">   public Shape getShape(String shapeType)&#123;</div><div class="line">      if(shapeType == null)&#123;</div><div class="line">         return null;</div><div class="line">      &#125;		</div><div class="line">      if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123;</div><div class="line">         return new Circle();</div><div class="line">      &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123;</div><div class="line">         return new Rectangle();</div><div class="line">      &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123;</div><div class="line">         return new Square();</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @Override</div><div class="line">   Color getColor(String color) &#123;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ColorFactory.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class ColorFactory extends AbstractFactory &#123;</div><div class="line">	</div><div class="line">   @Override</div><div class="line">   public Shape getShape(String shapeType)&#123;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @Override</div><div class="line">   Color getColor(String color) &#123;</div><div class="line">      if(color == null)&#123;</div><div class="line">         return null;</div><div class="line">      &#125;		</div><div class="line">      if(color.equalsIgnoreCase(&quot;RED&quot;))&#123;</div><div class="line">         return new Red();</div><div class="line">      &#125; else if(color.equalsIgnoreCase(&quot;GREEN&quot;))&#123;</div><div class="line">         return new Green();</div><div class="line">      &#125; else if(color.equalsIgnoreCase(&quot;BLUE&quot;))&#123;</div><div class="line">         return new Blue();</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 7</strong>  </p>
<p>创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。</p>
<p>FactoryProducer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class FactoryProducer &#123;</div><div class="line">   public static AbstractFactory getFactory(String choice)&#123;</div><div class="line">      if(choice.equalsIgnoreCase(&quot;SHAPE&quot;))&#123;</div><div class="line">         return new ShapeFactory();</div><div class="line">      &#125; else if(choice.equalsIgnoreCase(&quot;COLOR&quot;))&#123;</div><div class="line">         return new ColorFactory();</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 8</strong></p>
<p>使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。  </p>
<p>AbstractFactoryPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class AbstractFactoryPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      //获取形状工厂</div><div class="line">      AbstractFactory shapeFactory = FactoryProducer.getFactory(&quot;SHAPE&quot;);</div><div class="line"></div><div class="line">      //获取形状为 Circle 的对象</div><div class="line">      Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);</div><div class="line"></div><div class="line">      //调用 Circle 的 draw 方法</div><div class="line">      shape1.draw();</div><div class="line"></div><div class="line">      //获取形状为 Rectangle 的对象</div><div class="line">      Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);</div><div class="line"></div><div class="line">      //调用 Rectangle 的 draw 方法</div><div class="line">      shape2.draw();</div><div class="line">      </div><div class="line">      //获取形状为 Square 的对象</div><div class="line">      Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);</div><div class="line"></div><div class="line">      //调用 Square 的 draw 方法</div><div class="line">      shape3.draw();</div><div class="line"></div><div class="line">      //获取颜色工厂</div><div class="line">      AbstractFactory colorFactory = FactoryProducer.getFactory(&quot;COLOR&quot;);</div><div class="line"></div><div class="line">      //获取颜色为 Red 的对象</div><div class="line">      Color color1 = colorFactory.getColor(&quot;RED&quot;);</div><div class="line"></div><div class="line">      //调用 Red 的 fill 方法</div><div class="line">      color1.fill();</div><div class="line"></div><div class="line">      //获取颜色为 Green 的对象</div><div class="line">      Color color2 = colorFactory.getColor(&quot;Green&quot;);</div><div class="line"></div><div class="line">      //调用 Green 的 fill 方法</div><div class="line">      color2.fill();</div><div class="line"></div><div class="line">      //获取颜色为 Blue 的对象</div><div class="line">      Color color3 = colorFactory.getColor(&quot;BLUE&quot;);</div><div class="line"></div><div class="line">      //调用 Blue 的 fill 方法</div><div class="line">      color3.fill();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 9</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Inside Circle::draw() method.</div><div class="line">Inside Rectangle::draw() method.</div><div class="line">Inside Square::draw() method.</div><div class="line">Inside Red::fill() method.</div><div class="line">Inside Green::fill() method.</div><div class="line">Inside Blue::fill() method.</div></pre></td></tr></table></figure>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。<br>注意：<br>1、单例类只能有一个实例。<br>2、单例类必须自己创建自己的唯一实例。<br>3、单例类必须给所有其他对象提供这一实例。<br><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。<br><strong>何时使用：</strong>当您想控制实例数目，节省系统资源的时候。<br><strong>如何解决：</strong>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。<br><strong>关键代码：</strong>构造函数是私有的。<br><strong>优点： </strong>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。<br><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。<br><strong>使用场景：</strong> 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。<br><strong>注意事项：</strong>getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。<br><strong>实现</strong><br>我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。<br>SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。<br><img src="/2017/08/08/设计模式/singleton_pattern_uml_diagram.jpg" alt="singleton_pattern" title="singleton_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个 Singleton 类。</p>
<p>SingleObject.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class SingleObject &#123;</div><div class="line"></div><div class="line">   //创建 SingleObject 的一个对象</div><div class="line">   private static SingleObject instance = new SingleObject();</div><div class="line"></div><div class="line">   //让构造函数为 private，这样该类就不会被实例化</div><div class="line">   private SingleObject()&#123;&#125;</div><div class="line"></div><div class="line">   //获取唯一可用的对象</div><div class="line">   public static SingleObject getInstance()&#123;</div><div class="line">      return instance;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void showMessage()&#123;</div><div class="line">      System.out.println(&quot;Hello World!&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>从 singleton 类获取唯一的对象。</p>
<p>SingletonPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class SingletonPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      //不合法的构造函数</div><div class="line">      //编译时错误：构造函数 SingleObject() 是不可见的</div><div class="line">      //SingleObject object = new SingleObject();</div><div class="line"></div><div class="line">      //获取唯一可用的对象</div><div class="line">      SingleObject object = SingleObject.getInstance();</div><div class="line"></div><div class="line">      //显示消息</div><div class="line">      object.showMessage();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello World!</div></pre></td></tr></table></figure>
<p><strong>单例模式的几种实现方式</strong><br>单例模式的实现有多种方式，如下所示：<br><strong>1、懒汉式，线程不安全</strong><br><strong>是否 Lazy 初始化</strong>：是<br><strong>是否多线程安全：</strong>否<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。<br>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。<br><strong>代码实例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">    private static Singleton instance;  </div><div class="line">    private Singleton ()&#123;&#125;  </div><div class="line">  </div><div class="line">    public static Singleton getInstance() &#123;  </div><div class="line">    if (instance == null) &#123;  </div><div class="line">        instance = new Singleton();  </div><div class="line">    &#125;  </div><div class="line">    return instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。  </p>
<p><strong>2、懒汉式，线程安全</strong><br><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。<br><strong>优点：</strong>第一次调用才初始化，避免内存浪费。<br><strong>缺点：</strong>必须加锁 synchronized 才能保证单例，但加锁会影响效率。<br>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。<br><strong>代码实例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">    private static Singleton instance;  </div><div class="line">    private Singleton ()&#123;&#125;  </div><div class="line">    public static synchronized Singleton getInstance() &#123;  </div><div class="line">    if (instance == null) &#123;  </div><div class="line">        instance = new Singleton();  </div><div class="line">    &#125;  </div><div class="line">    return instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>3、饿汉式</strong><br><strong>是否 Lazy 初始化：</strong>否<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种方式比较常用，但容易产生垃圾对象。<br><strong>优点：</strong>没有加锁，执行效率会提高。<br><strong>缺点：</strong>类加载时就初始化，浪费内存。<br>它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。<br><strong>代码实例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">    private static Singleton instance = new Singleton();  </div><div class="line">    private Singleton ()&#123;&#125;  </div><div class="line">    public static Singleton getInstance() &#123;  </div><div class="line">    return instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>4、双检锁/双重校验锁（DCL，即 double-checked locking）</strong><br><strong>JDK 版本：</strong>JDK1.5 起<br><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>较复杂<br><strong>描述：</strong>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance() 的性能对应用程序很关键。<br><strong>代码实例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">    private volatile static Singleton singleton;  </div><div class="line">    private Singleton ()&#123;&#125;  </div><div class="line">    public static Singleton getSingleton() &#123;  </div><div class="line">    if (singleton == null) &#123;  </div><div class="line">        synchronized (Singleton.class) &#123;  </div><div class="line">        if (singleton == null) &#123;  </div><div class="line">            singleton = new Singleton();  </div><div class="line">        &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    return singleton;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>5、登记式/静态内部类</strong><br><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全</strong>：是<br><strong>实现难度：</strong>一般<br><strong>描述：</strong>这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<br>这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有显示通过调用 getInstance 方法时，才会显示装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。<br><strong>代码实例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">    private static class SingletonHolder &#123;  </div><div class="line">    private static final Singleton INSTANCE = new Singleton();  </div><div class="line">    &#125;  </div><div class="line">    private Singleton ()&#123;&#125;  </div><div class="line">    public static final Singleton getInstance() &#123;  </div><div class="line">    return SingletonHolder.INSTANCE;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>6、枚举</strong><br><strong>JDK 版本：</strong>JDK1.5 起<br><strong>是否 Lazy 初始化：</strong>否<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。<br>不能通过 reflection attack 来调用私有构造方法。<br><strong>代码实例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public enum Singleton &#123;  </div><div class="line">    INSTANCE;  </div><div class="line">    public void whateverMethod() &#123;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>经验之谈：</strong>一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。   </p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。<br>意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br><strong>主要解决：</strong>主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。<br><strong>何时使用：</strong>一些基本部件不会变，而其组合经常变化的时候。<br><strong>如何解决：</strong>将变与不变分离开。<br><strong>关键代码：</strong>建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。<br><strong>应用实例：</strong> 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。 2、JAVA 中的 StringBuilder。<br><strong>优点：</strong> 1、建造者独立，易扩展。 2、便于控制细节风险。<br><strong>缺点：</strong> 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。<br><strong>使用场景：</strong> 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。<br><strong>注意事项：</strong>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。<br><strong>实现</strong><br>我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。<br>我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。<br>然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo，我们的演示类使用 MealBuilder 来创建一个 Meal。<br><img src="/2017/08/08/设计模式/builder_pattern_uml_diagram.jpg" alt="builder_pattern" title="builder_pattern"></p>
<p><strong>步骤 1</strong>  </p>
<p>创建一个表示食物条目和食物包装的接口。</p>
<p>Item.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface Item &#123;</div><div class="line">   public String name();</div><div class="line">   public Packing packing();</div><div class="line">   public float price();	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Packing.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Packing &#123;</div><div class="line">   public String pack();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现 Packing 接口的实体类。</p>
<p>Wrapper.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Wrapper implements Packing &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String pack() &#123;</div><div class="line">      return &quot;Wrapper&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Bottle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Bottle implements Packing &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String pack() &#123;</div><div class="line">      return &quot;Bottle&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实现 Item 接口的抽象类，该类提供了默认的功能。</p>
<p>Burger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public abstract class Burger implements Item &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public Packing packing() &#123;</div><div class="line">      return new Wrapper();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public abstract float price();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ColdDrink.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public abstract class ColdDrink implements Item &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Packing packing() &#123;</div><div class="line">       return new Bottle();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public abstract float price();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建扩展了 Burger 和 ColdDrink 的实体类。</p>
<p>VegBurger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class VegBurger extends Burger &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public float price() &#123;</div><div class="line">      return 25.0f;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String name() &#123;</div><div class="line">      return &quot;Veg Burger&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ChickenBurger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class ChickenBurger extends Burger &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public float price() &#123;</div><div class="line">      return 50.5f;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String name() &#123;</div><div class="line">      return &quot;Chicken Burger&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Coke.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Coke extends ColdDrink &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public float price() &#123;</div><div class="line">      return 30.0f;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String name() &#123;</div><div class="line">      return &quot;Coke&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Pepsi.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Pepsi extends ColdDrink &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public float price() &#123;</div><div class="line">      return 35.0f;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String name() &#123;</div><div class="line">      return &quot;Pepsi&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>创建一个 Meal 类，带有上面定义的 Item 对象。</p>
<p>Meal.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class Meal &#123;</div><div class="line">   private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;();	</div><div class="line"></div><div class="line">   public void addItem(Item item)&#123;</div><div class="line">      items.add(item);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public float getCost()&#123;</div><div class="line">      float cost = 0.0f;</div><div class="line">      for (Item item : items) &#123;</div><div class="line">         cost += item.price();</div><div class="line">      &#125;		</div><div class="line">      return cost;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void showItems()&#123;</div><div class="line">      for (Item item : items) &#123;</div><div class="line">         System.out.print(&quot;Item : &quot;+item.name());</div><div class="line">         System.out.print(&quot;, Packing : &quot;+item.packing().pack());</div><div class="line">         System.out.println(&quot;, Price : &quot;+item.price());</div><div class="line">      &#125;		</div><div class="line">   &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。</p>
<p>MealBuilder.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class MealBuilder &#123;</div><div class="line"></div><div class="line">   public Meal prepareVegMeal ()&#123;</div><div class="line">      Meal meal = new Meal();</div><div class="line">      meal.addItem(new VegBurger());</div><div class="line">      meal.addItem(new Coke());</div><div class="line">      return meal;</div><div class="line">   &#125;   </div><div class="line"></div><div class="line">   public Meal prepareNonVegMeal ()&#123;</div><div class="line">      Meal meal = new Meal();</div><div class="line">      meal.addItem(new ChickenBurger());</div><div class="line">      meal.addItem(new Pepsi());</div><div class="line">      return meal;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 7</strong></p>
<p>BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern）。</p>
<p>BuilderPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class BuilderPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      MealBuilder mealBuilder = new MealBuilder();</div><div class="line"></div><div class="line">      Meal vegMeal = mealBuilder.prepareVegMeal();</div><div class="line">      System.out.println(&quot;Veg Meal&quot;);</div><div class="line">      vegMeal.showItems();</div><div class="line">      System.out.println(&quot;Total Cost: &quot; +vegMeal.getCost());</div><div class="line"></div><div class="line">      Meal nonVegMeal = mealBuilder.prepareNonVegMeal();</div><div class="line">      System.out.println(&quot;\n\nNon-Veg Meal&quot;);</div><div class="line">      nonVegMeal.showItems();</div><div class="line">      System.out.println(&quot;Total Cost: &quot; +nonVegMeal.getCost());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 8</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Veg Meal</div><div class="line">Item : Veg Burger, Packing : Wrapper, Price : 25.0</div><div class="line">Item : Coke, Packing : Bottle, Price : 30.0</div><div class="line">Total Cost: 55.0</div><div class="line"></div><div class="line">Non-Veg Meal</div><div class="line">Item : Chicken Burger, Packing : Wrapper, Price : 50.5</div><div class="line">Item : Pepsi, Packing : Bottle, Price : 35.0</div><div class="line">Total Cost: 85.5</div></pre></td></tr></table></figure>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。<br><strong>意图：</strong>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br><strong>主要解决：</strong>在运行期建立和删除原型。<br><strong>何时使用：</strong> 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。<br><strong>如何解决：</strong>利用已有的一个原型对象，快速地生成和原型对象一样的实例。<br><strong>关键代码：</strong> 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口。<br><strong>应用实例：</strong> 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。<br><strong>优点：</strong> 1、性能提高。 2、逃避构造函数的约束。<br><strong>缺点：</strong> 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。 3、逃避构造函数的约束。<br><strong>使用场景：</strong> 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。   5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。<br>注意事项：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。<br><strong>实现 </strong><br>我们将创建一个抽象类 Shape 和扩展了 Shape 类的实体类。下一步是定义类 ShapeCache，该类把 shape 对象存储在一个 Hashtable 中，并在请求的时候返回它们的克隆。<br>PrototypPatternDemo，我们的演示类使用 ShapeCache 类来获取 Shape 对象<br><img src="/2017/08/08/设计模式/prototype_pattern_uml_diagram.jpg" alt="prototype_pattern" title="prototype_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个实现了 Clonable 接口的抽象类。</p>
<p>Shape.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public abstract class Shape implements Cloneable &#123;</div><div class="line">   </div><div class="line">   private String id;</div><div class="line">   protected String type;</div><div class="line">   </div><div class="line">   abstract void draw();</div><div class="line">   </div><div class="line">   public String getType()&#123;</div><div class="line">      return type;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   public String getId() &#123;</div><div class="line">      return id;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   public void setId(String id) &#123;</div><div class="line">      this.id = id;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   public Object clone() &#123;</div><div class="line">      Object clone = null;</div><div class="line">      try &#123;</div><div class="line">         clone = super.clone();</div><div class="line">      &#125; catch (CloneNotSupportedException e) &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">      return clone;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建扩展了上面抽象类的实体类。</p>
<p>Rectangle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Rectangle extends Shape &#123;</div><div class="line"></div><div class="line">   public Rectangle()&#123;</div><div class="line">     type = &quot;Rectangle&quot;;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Square.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Square extends Shape &#123;</div><div class="line"></div><div class="line">   public Square()&#123;</div><div class="line">     type = &quot;Square&quot;;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Square::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Circle extends Shape &#123;</div><div class="line"></div><div class="line">   public Circle()&#123;</div><div class="line">     type = &quot;Circle&quot;;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Circle::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建一个类，从数据库获取实体类，并把它们存储在一个 Hashtable 中。</p>
<p>ShapeCache.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">import java.util.Hashtable;</div><div class="line"></div><div class="line">public class ShapeCache &#123;</div><div class="line">	</div><div class="line">   private static Hashtable&lt;String, Shape&gt; shapeMap </div><div class="line">      = new Hashtable&lt;String, Shape&gt;();</div><div class="line"></div><div class="line">   public static Shape getShape(String shapeId) &#123;</div><div class="line">      Shape cachedShape = shapeMap.get(shapeId);</div><div class="line">      return (Shape) cachedShape.clone();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // 对每种形状都运行数据库查询，并创建该形状</div><div class="line">   // shapeMap.put(shapeKey, shape);</div><div class="line">   // 例如，我们要添加三种形状</div><div class="line">   public static void loadCache() &#123;</div><div class="line">      Circle circle = new Circle();</div><div class="line">      circle.setId(&quot;1&quot;);</div><div class="line">      shapeMap.put(circle.getId(),circle);</div><div class="line"></div><div class="line">      Square square = new Square();</div><div class="line">      square.setId(&quot;2&quot;);</div><div class="line">      shapeMap.put(square.getId(),square);</div><div class="line"></div><div class="line">      Rectangle rectangle = new Rectangle();</div><div class="line">      rectangle.setId(&quot;3&quot;);</div><div class="line">      shapeMap.put(rectangle.getId(),rectangle);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>PrototypePatternDemo 使用 ShapeCache 类来获取存储在 Hashtable 中的形状的克隆。</p>
<p>PrototypePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class PrototypePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      ShapeCache.loadCache();</div><div class="line"></div><div class="line">      Shape clonedShape = (Shape) ShapeCache.getShape(&quot;1&quot;);</div><div class="line">      System.out.println(&quot;Shape : &quot; + clonedShape.getType());		</div><div class="line"></div><div class="line">      Shape clonedShape2 = (Shape) ShapeCache.getShape(&quot;2&quot;);</div><div class="line">      System.out.println(&quot;Shape : &quot; + clonedShape2.getType());		</div><div class="line"></div><div class="line">      Shape clonedShape3 = (Shape) ShapeCache.getShape(&quot;3&quot;);</div><div class="line">      System.out.println(&quot;Shape : &quot; + clonedShape3.getType());		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Shape : Circle</div><div class="line">Shape : Square</div><div class="line">Shape : Rectangle</div></pre></td></tr></table></figure>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。<br>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。<br>我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。<br><strong>意图：</strong>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>主要解决：主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。<br><strong>何时使用：</strong> 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）<br><strong>如何解决：</strong>继承或依赖（推荐）。<br><strong>关键代码：</strong>适配器继承或依赖已有的对象，实现想要的目标接口。<br><strong>应用实例：</strong> 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。<br><strong>优点：</strong> 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。<br><strong>缺点：</strong> 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。<br><strong>使用场景：</strong>有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。<br><strong>注意事项：</strong>适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。<br><strong>实现</strong><br>我们有一个 MediaPlayer 接口和一个实现了 MediaPlayer 接口的实体类 AudioPlayer。默认情况下，AudioPlayer 可以播放 mp3 格式的音频文件。<br>我们还有另一个接口 AdvancedMediaPlayer 和实现了 AdvancedMediaPlayer 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。<br>我们想要让 AudioPlayer 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 MediaPlayer 接口的适配器类 MediaAdapter，并使用 AdvancedMediaPlayer 对象来播放所需的格式。<br>AudioPlayer 使用适配器类 MediaAdapter 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。AdapterPatternDemo，我们的演示类使用 AudioPlayer 类来播放各种格式。<br><img src="/2017/08/08/设计模式/adapter_pattern_uml_diagram.jpg" alt="adapter_pattern" title="adapter_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>为媒体播放器和更高级的媒体播放器创建接口。</p>
<p>MediaPlayer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public interface MediaPlayer &#123;</div><div class="line">   public void play(String audioType, String fileName);</div><div class="line">&#125;</div><div class="line">AdvancedMediaPlayer.java</div><div class="line">public interface AdvancedMediaPlayer &#123;	</div><div class="line">   public void playVlc(String fileName);</div><div class="line">   public void playMp4(String fileName);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现了 AdvancedMediaPlayer 接口的实体类。</p>
<p>VlcPlayer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class VlcPlayer implements AdvancedMediaPlayer&#123;</div><div class="line">   @Override</div><div class="line">   public void playVlc(String fileName) &#123;</div><div class="line">      System.out.println(&quot;Playing vlc file. Name: &quot;+ fileName);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void playMp4(String fileName) &#123;</div><div class="line">      //什么也不做</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Mp4Player.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Mp4Player implements AdvancedMediaPlayer&#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void playVlc(String fileName) &#123;</div><div class="line">      //什么也不做</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void playMp4(String fileName) &#123;</div><div class="line">      System.out.println(&quot;Playing mp4 file. Name: &quot;+ fileName);		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实现了 MediaPlayer 接口的适配器类。</p>
<p>MediaAdapter.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class MediaAdapter implements MediaPlayer &#123;</div><div class="line"></div><div class="line">   AdvancedMediaPlayer advancedMusicPlayer;</div><div class="line"></div><div class="line">   public MediaAdapter(String audioType)&#123;</div><div class="line">      if(audioType.equalsIgnoreCase(&quot;vlc&quot;) )&#123;</div><div class="line">         advancedMusicPlayer = new VlcPlayer();			</div><div class="line">      &#125; else if (audioType.equalsIgnoreCase(&quot;mp4&quot;))&#123;</div><div class="line">         advancedMusicPlayer = new Mp4Player();</div><div class="line">      &#125;	</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void play(String audioType, String fileName) &#123;</div><div class="line">      if(audioType.equalsIgnoreCase(&quot;vlc&quot;))&#123;</div><div class="line">         advancedMusicPlayer.playVlc(fileName);</div><div class="line">      &#125;else if(audioType.equalsIgnoreCase(&quot;mp4&quot;))&#123;</div><div class="line">         advancedMusicPlayer.playMp4(fileName);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建实现了 MediaPlayer 接口的实体类。</p>
<p>AudioPlayer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class AudioPlayer implements MediaPlayer &#123;</div><div class="line">   MediaAdapter mediaAdapter; </div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void play(String audioType, String fileName) &#123;		</div><div class="line"></div><div class="line">      //播放 mp3 音乐文件的内置支持</div><div class="line">      if(audioType.equalsIgnoreCase(&quot;mp3&quot;))&#123;</div><div class="line">         System.out.println(&quot;Playing mp3 file. Name: &quot;+ fileName);			</div><div class="line">      &#125; </div><div class="line">      //mediaAdapter 提供了播放其他文件格式的支持</div><div class="line">      else if(audioType.equalsIgnoreCase(&quot;vlc&quot;) </div><div class="line">         || audioType.equalsIgnoreCase(&quot;mp4&quot;))&#123;</div><div class="line">         mediaAdapter = new MediaAdapter(audioType);</div><div class="line">         mediaAdapter.play(audioType, fileName);</div><div class="line">      &#125;</div><div class="line">      else&#123;</div><div class="line">         System.out.println(&quot;Invalid media. &quot;+</div><div class="line">            audioType + &quot; format not supported&quot;);</div><div class="line">      &#125;</div><div class="line">   &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>使用 AudioPlayer 来播放不同类型的音频格式。</p>
<p>AdapterPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class AdapterPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      AudioPlayer audioPlayer = new AudioPlayer();</div><div class="line"></div><div class="line">      audioPlayer.play(&quot;mp3&quot;, &quot;beyond the horizon.mp3&quot;);</div><div class="line">      audioPlayer.play(&quot;mp4&quot;, &quot;alone.mp4&quot;);</div><div class="line">      audioPlayer.play(&quot;vlc&quot;, &quot;far far away.vlc&quot;);</div><div class="line">      audioPlayer.play(&quot;avi&quot;, &quot;mind me.avi&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Playing mp3 file. Name: beyond the horizon.mp3</div><div class="line">Playing mp4 file. Name: alone.mp4</div><div class="line">Playing vlc file. Name: far far away.vlc</div><div class="line">Invalid media. avi format not supported</div></pre></td></tr></table></figure>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。<br>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。<br>我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。<br><strong>意图：</strong>将抽象部分与实现部分分离，使它们都可以独立的变化。<br><strong>主要解决：</strong>在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。<br><strong>何时使用：</strong>实现系统可能有多个角度分类，每一种角度都可能变化。<br><strong>如何解决：</strong>把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。<br><strong>关键代码：</strong>抽象类依赖实现类。<br><strong>应用实例：</strong> 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。<br><strong>优点：</strong> 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。<br><strong>缺点：</strong>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。<br><strong>使用场景：</strong> 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。<br><strong>注意事项：</strong>对于两个独立变化的维度，使用桥接模式再适合不过了。<br><strong>实现 </strong><br>我们有一个作为桥接实现的 DrawAPI 接口和实现了 DrawAPI 接口的实体类 RedCircle、GreenCircle。Shape 是一个抽象类，将使用 DrawAPI 的对象。BridgePatternDemo，我们的演示类使用 Shape 类来画出不同颜色的圆。<br><img src="/2017/08/08/设计模式/bridge_pattern_uml_diagram.jpg" alt="bridge_pattern" title="bridge_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建桥接实现接口。</p>
<p>DrawAPI.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface DrawAPI &#123;</div><div class="line">   public void drawCircle(int radius, int x, int y);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现了 DrawAPI 接口的实体桥接实现类。</p>
<p>RedCircle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class RedCircle implements DrawAPI &#123;</div><div class="line">   @Override</div><div class="line">   public void drawCircle(int radius, int x, int y) &#123;</div><div class="line">      System.out.println(&quot;Drawing Circle[ color: red, radius: &quot;</div><div class="line">         + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>GreenCircle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class GreenCircle implements DrawAPI &#123;</div><div class="line">   @Override</div><div class="line">   public void drawCircle(int radius, int x, int y) &#123;</div><div class="line">      System.out.println(&quot;Drawing Circle[ color: green, radius: &quot;</div><div class="line">         + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>使用 DrawAPI 接口创建抽象类 Shape。</p>
<p>Shape.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public abstract class Shape &#123;</div><div class="line">   protected DrawAPI drawAPI;</div><div class="line">   protected Shape(DrawAPI drawAPI)&#123;</div><div class="line">      this.drawAPI = drawAPI;</div><div class="line">   &#125;</div><div class="line">   public abstract void draw();	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建实现了 Shape 接口的实体类。</p>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Circle extends Shape &#123;</div><div class="line">   private int x, y, radius;</div><div class="line"></div><div class="line">   public Circle(int x, int y, int radius, DrawAPI drawAPI) &#123;</div><div class="line">      super(drawAPI);</div><div class="line">      this.x = x;  </div><div class="line">      this.y = y;  </div><div class="line">      this.radius = radius;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void draw() &#123;</div><div class="line">      drawAPI.drawCircle(radius,x,y);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>使用 Shape 和 DrawAPI 类画出不同颜色的圆。</p>
<p>BridgePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class BridgePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Shape redCircle = new Circle(100,100, 10, new RedCircle());</div><div class="line">      Shape greenCircle = new Circle(100,100, 10, new GreenCircle());</div><div class="line"></div><div class="line">      redCircle.draw();</div><div class="line">      greenCircle.draw();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Drawing Circle[ color: red, radius: 10, x: 100, 100]</div><div class="line">Drawing Circle[  color: green, radius: 10, x: 100, 100]</div></pre></td></tr></table></figure>
<h2 id="过滤器模式"><a href="#过滤器模式" class="headerlink" title="过滤器模式"></a>过滤器模式</h2><p>过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。<br><strong>实现</strong><br>我们将创建一个 Person 对象、Criteria 接口和实现了该接口的实体类，来过滤 Person 对象的列表。CriteriaPatternDemo，我们的演示类使用 Criteria 对象，基于各种标准和它们的结合来过滤 Person 对象的列表。<br><img src="/2017/08/08/设计模式/filter_pattern_uml_diagram.jpg" alt="filter_pattern" title="filter_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个类，在该类上应用标准。</p>
<p>Person.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Person &#123;</div><div class="line">	</div><div class="line">   private String name;</div><div class="line">   private String gender;</div><div class="line">   private String maritalStatus;</div><div class="line"></div><div class="line">   public Person(String name,String gender,String maritalStatus)&#123;</div><div class="line">      this.name = name;</div><div class="line">      this.gender = gender;</div><div class="line">      this.maritalStatus = maritalStatus;		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getName() &#123;</div><div class="line">      return name;</div><div class="line">   &#125;</div><div class="line">   public String getGender() &#123;</div><div class="line">      return gender;</div><div class="line">   &#125;</div><div class="line">   public String getMaritalStatus() &#123;</div><div class="line">      return maritalStatus;</div><div class="line">   &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>为标准（Criteria）创建一个接口。</p>
<p>Criteria.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public interface Criteria &#123;</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实现了 Criteria 接口的实体类。</p>
<p>CriteriaMale.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class CriteriaMale implements Criteria &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123;</div><div class="line">      List&lt;Person&gt; malePersons = new ArrayList&lt;Person&gt;(); </div><div class="line">      for (Person person : persons) &#123;</div><div class="line">         if(person.getGender().equalsIgnoreCase(&quot;MALE&quot;))&#123;</div><div class="line">            malePersons.add(person);</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      return malePersons;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CriteriaFemale.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class CriteriaFemale implements Criteria &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123;</div><div class="line">      List&lt;Person&gt; femalePersons = new ArrayList&lt;Person&gt;(); </div><div class="line">      for (Person person : persons) &#123;</div><div class="line">         if(person.getGender().equalsIgnoreCase(&quot;FEMALE&quot;))&#123;</div><div class="line">            femalePersons.add(person);</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      return femalePersons;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CriteriaSingle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class CriteriaSingle implements Criteria &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123;</div><div class="line">      List&lt;Person&gt; singlePersons = new ArrayList&lt;Person&gt;(); </div><div class="line">      for (Person person : persons) &#123;</div><div class="line">         if(person.getMaritalStatus().equalsIgnoreCase(&quot;SINGLE&quot;))&#123;</div><div class="line">            singlePersons.add(person);</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      return singlePersons;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AndCriteria.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class AndCriteria implements Criteria &#123;</div><div class="line"></div><div class="line">   private Criteria criteria;</div><div class="line">   private Criteria otherCriteria;</div><div class="line"></div><div class="line">   public AndCriteria(Criteria criteria, Criteria otherCriteria) &#123;</div><div class="line">      this.criteria = criteria;</div><div class="line">      this.otherCriteria = otherCriteria; </div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123;</div><div class="line">      List&lt;Person&gt; firstCriteriaPersons = criteria.meetCriteria(persons);		</div><div class="line">      return otherCriteria.meetCriteria(firstCriteriaPersons);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OrCriteria.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class OrCriteria implements Criteria &#123;</div><div class="line"></div><div class="line">   private Criteria criteria;</div><div class="line">   private Criteria otherCriteria;</div><div class="line"></div><div class="line">   public OrCriteria(Criteria criteria, Criteria otherCriteria) &#123;</div><div class="line">      this.criteria = criteria;</div><div class="line">      this.otherCriteria = otherCriteria; </div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123;</div><div class="line">      List&lt;Person&gt; firstCriteriaItems = criteria.meetCriteria(persons);</div><div class="line">      List&lt;Person&gt; otherCriteriaItems = otherCriteria.meetCriteria(persons);</div><div class="line"></div><div class="line">      for (Person person : otherCriteriaItems) &#123;</div><div class="line">         if(!firstCriteriaItems.contains(person))&#123;</div><div class="line">	        firstCriteriaItems.add(person);</div><div class="line">         &#125;</div><div class="line">      &#125;	</div><div class="line">      return firstCriteriaItems;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤4</strong></p>
<p>使用不同的标准（Criteria）和它们的结合来过滤 Person 对象的列表。</p>
<p>CriteriaPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList; </div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class CriteriaPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;();</div><div class="line"></div><div class="line">      persons.add(new Person(&quot;Robert&quot;,&quot;Male&quot;, &quot;Single&quot;));</div><div class="line">      persons.add(new Person(&quot;John&quot;,&quot;Male&quot;, &quot;Married&quot;));</div><div class="line">      persons.add(new Person(&quot;Laura&quot;,&quot;Female&quot;, &quot;Married&quot;));</div><div class="line">      persons.add(new Person(&quot;Diana&quot;,&quot;Female&quot;, &quot;Single&quot;));</div><div class="line">      persons.add(new Person(&quot;Mike&quot;,&quot;Male&quot;, &quot;Single&quot;));</div><div class="line">      persons.add(new Person(&quot;Bobby&quot;,&quot;Male&quot;, &quot;Single&quot;));</div><div class="line"></div><div class="line">      Criteria male = new CriteriaMale();</div><div class="line">      Criteria female = new CriteriaFemale();</div><div class="line">      Criteria single = new CriteriaSingle();</div><div class="line">      Criteria singleMale = new AndCriteria(single, male);</div><div class="line">      Criteria singleOrFemale = new OrCriteria(single, female);</div><div class="line"></div><div class="line">      System.out.println(&quot;Males: &quot;);</div><div class="line">      printPersons(male.meetCriteria(persons));</div><div class="line"></div><div class="line">      System.out.println(&quot;\nFemales: &quot;);</div><div class="line">      printPersons(female.meetCriteria(persons));</div><div class="line"></div><div class="line">      System.out.println(&quot;\nSingle Males: &quot;);</div><div class="line">      printPersons(singleMale.meetCriteria(persons));</div><div class="line"></div><div class="line">      System.out.println(&quot;\nSingle Or Females: &quot;);</div><div class="line">      printPersons(singleOrFemale.meetCriteria(persons));</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public static void printPersons(List&lt;Person&gt; persons)&#123;</div><div class="line">      for (Person person : persons) &#123;</div><div class="line">         System.out.println(&quot;Person : [ Name : &quot; + person.getName() </div><div class="line">            +&quot;, Gender : &quot; + person.getGender() </div><div class="line">            +&quot;, Marital Status : &quot; + person.getMaritalStatus()</div><div class="line">            +&quot; ]&quot;);</div><div class="line">      &#125;</div><div class="line">   &#125;      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Males: </div><div class="line">Person : [ Name : Robert, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : John, Gender : Male, Marital Status : Married ]</div><div class="line">Person : [ Name : Mike, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]</div><div class="line"></div><div class="line">Females: </div><div class="line">Person : [ Name : Laura, Gender : Female, Marital Status : Married ]</div><div class="line">Person : [ Name : Diana, Gender : Female, Marital Status : Single ]</div><div class="line"></div><div class="line">Single Males: </div><div class="line">Person : [ Name : Robert, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Mike, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]</div><div class="line"></div><div class="line">Single Or Females: </div><div class="line">Person : [ Name : Robert, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Diana, Gender : Female, Marital Status : Single ]</div><div class="line">Person : [ Name : Mike, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Laura, Gender : Female, Marital Status : Married ]</div></pre></td></tr></table></figure>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。<br>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。<br>我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。<br>意图：将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。<br><strong>主要解决：</strong>它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。<br><strong>何时使用：</strong> 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。<br><strong>如何解决：</strong>树枝和叶子实现统一接口，树枝内部组合该接口。<br>关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。<br><strong>应用实例：</strong> 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作树、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。<br><strong>优点：</strong> 1、高层模块调用简单。 2、节点自由增加。<br><strong>缺点：</strong>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。<br><strong>使用场景：</strong>部分、整体场景，如树形菜单，文件、文件夹的管理。<br><strong>注意事项：</strong>定义时为具体类。<br><strong>实现</strong><br>我们有一个类 Employee，该类被当作组合模型类。CompositePatternDemo，我们的演示类使用 Employee 类来添加部门层次结构，并打印所有员工。<br><img src="/2017/08/08/设计模式/composite_pattern_uml_diagram.jpg" alt="composite_pattern" title="composite_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建 Employee 类，该类带有 Employee 对象的列表。</p>
<p>Employee.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class Employee &#123;</div><div class="line">   private String name;</div><div class="line">   private String dept;</div><div class="line">   private int salary;</div><div class="line">   private List&lt;Employee&gt; subordinates;</div><div class="line"></div><div class="line">   //构造函数</div><div class="line">   public Employee(String name,String dept, int sal) &#123;</div><div class="line">      this.name = name;</div><div class="line">      this.dept = dept;</div><div class="line">      this.salary = sal;</div><div class="line">      subordinates = new ArrayList&lt;Employee&gt;();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void add(Employee e) &#123;</div><div class="line">      subordinates.add(e);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void remove(Employee e) &#123;</div><div class="line">      subordinates.remove(e);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public List&lt;Employee&gt; getSubordinates()&#123;</div><div class="line">     return subordinates;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String toString()&#123;</div><div class="line">      return (&quot;Employee :[ Name : &quot;+ name </div><div class="line">      +&quot;, dept : &quot;+ dept + &quot;, salary :&quot;</div><div class="line">      + salary+&quot; ]&quot;);</div><div class="line">   &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>使用 Employee 类来创建和打印员工的层次结构。</p>
<p>CompositePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class CompositePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Employee CEO = new Employee(&quot;John&quot;,&quot;CEO&quot;, 30000);</div><div class="line"></div><div class="line">      Employee headSales = new Employee(&quot;Robert&quot;,&quot;Head Sales&quot;, 20000);</div><div class="line"></div><div class="line">      Employee headMarketing = new Employee(&quot;Michel&quot;,&quot;Head Marketing&quot;, 20000);</div><div class="line"></div><div class="line">      Employee clerk1 = new Employee(&quot;Laura&quot;,&quot;Marketing&quot;, 10000);</div><div class="line">      Employee clerk2 = new Employee(&quot;Bob&quot;,&quot;Marketing&quot;, 10000);</div><div class="line"></div><div class="line">      Employee salesExecutive1 = new Employee(&quot;Richard&quot;,&quot;Sales&quot;, 10000);</div><div class="line">      Employee salesExecutive2 = new Employee(&quot;Rob&quot;,&quot;Sales&quot;, 10000);</div><div class="line"></div><div class="line">      CEO.add(headSales);</div><div class="line">      CEO.add(headMarketing);</div><div class="line"></div><div class="line">      headSales.add(salesExecutive1);</div><div class="line">      headSales.add(salesExecutive2);</div><div class="line"></div><div class="line">      headMarketing.add(clerk1);</div><div class="line">      headMarketing.add(clerk2);</div><div class="line"></div><div class="line">      //打印该组织的所有员工</div><div class="line">      System.out.println(CEO); </div><div class="line">      for (Employee headEmployee : CEO.getSubordinates()) &#123;</div><div class="line">         System.out.println(headEmployee);</div><div class="line">         for (Employee employee : headEmployee.getSubordinates()) &#123;</div><div class="line">            System.out.println(employee);</div><div class="line">         &#125;</div><div class="line">      &#125;		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Employee :[ Name : John, dept : CEO, salary :30000 ]</div><div class="line">Employee :[ Name : Robert, dept : Head Sales, salary :20000 ]</div><div class="line">Employee :[ Name : Richard, dept : Sales, salary :10000 ]</div><div class="line">Employee :[ Name : Rob, dept : Sales, salary :10000 ]</div><div class="line">Employee :[ Name : Michel, dept : Head Marketing, salary :20000 ]</div><div class="line">Employee :[ Name : Laura, dept : Marketing, salary :10000 ]</div><div class="line">Employee :[ Name : Bob, dept : Marketing, salary :10000 ]</div></pre></td></tr></table></figure>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。<br>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。<br>我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。<br><strong>意图：</strong>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。<br>主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。<br><strong>何时使用：</strong>在不想增加很多子类的情况下扩展类。<br><strong>如何解决：</strong>将具体功能职责划分，同时继承装饰者模式。<br><strong>关键代码：</strong> 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。<br><strong>应用实例：</strong> 1、孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。<br><strong>优点：</strong>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。<br><strong>缺点：</strong>多层装饰比较复杂。<br><strong>使用场景：</strong> 1、扩展一个类的功能。 2、动态增加功能，动态撤销。<br><strong>注意事项：</strong>可代替继承。<br><strong>实现</strong><br>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。<br>RedShapeDecorator 是实现了 ShapeDecorator 的实体类。<br>DecoratorPatternDemo，我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象<br><img src="/2017/08/08/设计模式/decorator_pattern_uml_diagram.jpg" alt="decorator_pattern" title="decorator_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口。</p>
<p>Shape.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Shape &#123;</div><div class="line">   void draw();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>Rectangle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Rectangle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Shape: Rectangle&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Circle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Shape: Circle&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实现了 Shape 接口的抽象装饰类。</p>
<p>ShapeDecorator.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public abstract class ShapeDecorator implements Shape &#123;</div><div class="line">   protected Shape decoratedShape;</div><div class="line"></div><div class="line">   public ShapeDecorator(Shape decoratedShape)&#123;</div><div class="line">      this.decoratedShape = decoratedShape;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void draw()&#123;</div><div class="line">      decoratedShape.draw();</div><div class="line">   &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建扩展了 ShapeDecorator 类的实体装饰类。</p>
<p>RedShapeDecorator.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class RedShapeDecorator extends ShapeDecorator &#123;</div><div class="line"></div><div class="line">   public RedShapeDecorator(Shape decoratedShape) &#123;</div><div class="line">      super(decoratedShape);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      decoratedShape.draw();	       </div><div class="line">      setRedBorder(decoratedShape);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private void setRedBorder(Shape decoratedShape)&#123;</div><div class="line">      System.out.println(&quot;Border Color: Red&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>使用 RedShapeDecorator 来装饰 Shape 对象。</p>
<p>DecoratorPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class DecoratorPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      Shape circle = new Circle();</div><div class="line"></div><div class="line">      Shape redCircle = new RedShapeDecorator(new Circle());</div><div class="line"></div><div class="line">      Shape redRectangle = new RedShapeDecorator(new Rectangle());</div><div class="line">      System.out.println(&quot;Circle with normal border&quot;);</div><div class="line">      circle.draw();</div><div class="line"></div><div class="line">      System.out.println(&quot;\nCircle of red border&quot;);</div><div class="line">      redCircle.draw();</div><div class="line"></div><div class="line">      System.out.println(&quot;\nRectangle of red border&quot;);</div><div class="line">      redRectangle.draw();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Circle with normal border</div><div class="line">Shape: Circle</div><div class="line"></div><div class="line">Circle of red border</div><div class="line">Shape: Circle</div><div class="line">Border Color: Red</div><div class="line"></div><div class="line">Rectangle of red border</div><div class="line">Shape: Rectangle</div><div class="line">Border Color: Red</div></pre></td></tr></table></figure>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。<br>这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。<br><strong>意图：</strong>为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br><strong>主要解决：</strong>降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。<br><strong>何时使用：</strong> 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。 2、定义系统的入口。<br><strong>如何解决：</strong>客户端不与系统耦合，外观类与系统耦合。<br><strong>关键代码：</strong>在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。<br><strong>应用实例：</strong> 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、JAVA 的三层开发模式。<br><strong>优点：</strong> 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。<br><strong>缺点：</strong>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。<br><strong>使用场景： </strong>1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。<br><strong>注意事项：</strong>在层次化结构中，可以使用外观模式定义系统中每一层的入口。<br><strong>实现</strong><br>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。下一步是定义一个外观类 ShapeMaker。<br>ShapeMaker 类使用实体类来代表用户对这些类的调用。FacadePatternDemo，我们的演示类使用 ShapeMaker 类来显示结果。<br><img src="/2017/08/08/设计模式/facade_pattern_uml_diagram.jpg" alt="facade_pattern" title="facade_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口。</p>
<p>Shape.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Shape &#123;</div><div class="line">   void draw();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>Rectangle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Rectangle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Rectangle::draw()&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Square.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Square implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Square::draw()&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Circle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Circle::draw()&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建一个外观类。</p>
<p>ShapeMaker.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class ShapeMaker &#123;</div><div class="line">   private Shape circle;</div><div class="line">   private Shape rectangle;</div><div class="line">   private Shape square;</div><div class="line"></div><div class="line">   public ShapeMaker() &#123;</div><div class="line">      circle = new Circle();</div><div class="line">      rectangle = new Rectangle();</div><div class="line">      square = new Square();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void drawCircle()&#123;</div><div class="line">      circle.draw();</div><div class="line">   &#125;</div><div class="line">   public void drawRectangle()&#123;</div><div class="line">      rectangle.draw();</div><div class="line">   &#125;</div><div class="line">   public void drawSquare()&#123;</div><div class="line">      square.draw();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用该外观类画出各种类型的形状。</p>
<p>FacadePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class FacadePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      ShapeMaker shapeMaker = new ShapeMaker();</div><div class="line"></div><div class="line">      shapeMaker.drawCircle();</div><div class="line">      shapeMaker.drawRectangle();</div><div class="line">      shapeMaker.drawSquare();		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Circle::draw()</div><div class="line">Rectangle::draw()</div><div class="line">Square::draw()</div></pre></td></tr></table></figure>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。<br>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对象。<br><strong>意图：</strong>运用共享技术有效地支持大量细粒度的对象。<br>主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。<br><strong>何时使用：</strong> 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。<br><strong>如何解决：</strong>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。<br><strong>关键代码：</strong>用 HashMap 存储这些对象。<br><strong>应用实例：</strong> 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。<br><strong>优点：</strong>大大减少对象的创建，降低系统的内存，使效率提高。<br><strong>缺点：</strong>提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。<br><strong>使用场景：</strong> 1、系统有大量相似对象。 2、需要缓冲池的场景。<br><strong>注意事项：</strong> 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。<br><strong>实现</strong><br>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类 Circle。下一步是定义工厂类 ShapeFactory。<br>ShapeFactory 有一个 Circle 的 HashMap，其中键名为 Circle 对象的颜色。无论何时接收到请求，都会创建一个特定颜色的圆。ShapeFactory 检查它的 HashMap 中的 circle 对象，如果找到 Circle 对象，则返回该对象，否则将创建一个存储在 hashmap 中以备后续使用的新对象，并把该对象返回到客户端。<br>FlyWeightPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（red / green / blue/ black / white），以便获取它所需对象的颜色。<br><img src="/2017/08/08/设计模式/flyweight_pattern_uml_diagram-1.jpg" alt="flyweight_pattern" title="flyweight_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口。</p>
<p>Shape.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Shape &#123;</div><div class="line">   void draw();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class Circle implements Shape &#123;</div><div class="line">   private String color;</div><div class="line">   private int x;</div><div class="line">   private int y;</div><div class="line">   private int radius;</div><div class="line"></div><div class="line">   public Circle(String color)&#123;</div><div class="line">      this.color = color;		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setX(int x) &#123;</div><div class="line">      this.x = x;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setY(int y) &#123;</div><div class="line">      this.y = y;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setRadius(int radius) &#123;</div><div class="line">      this.radius = radius;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Circle: Draw() [Color : &quot; + color </div><div class="line">         +&quot;, x : &quot; + x +&quot;, y :&quot; + y +&quot;, radius :&quot; + radius);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建一个工厂，生成基于给定信息的实体类的对象。</p>
<p>ShapeFactory.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import java.util.HashMap;</div><div class="line"></div><div class="line">public class ShapeFactory &#123;</div><div class="line">   private static final HashMap&lt;String, Shape&gt; circleMap = new HashMap();</div><div class="line"></div><div class="line">   public static Shape getCircle(String color) &#123;</div><div class="line">      Circle circle = (Circle)circleMap.get(color);</div><div class="line"></div><div class="line">      if(circle == null) &#123;</div><div class="line">         circle = new Circle(color);</div><div class="line">         circleMap.put(color, circle);</div><div class="line">         System.out.println(&quot;Creating circle of color : &quot; + color);</div><div class="line">      &#125;</div><div class="line">      return circle;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用该工厂，通过传递颜色信息来获取实体类的对象。</p>
<p>FlyweightPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class FlyweightPatternDemo &#123;</div><div class="line">   private static final String colors[] = </div><div class="line">      &#123; &quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot;, &quot;White&quot;, &quot;Black&quot; &#125;;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      for(int i=0; i &lt; 20; ++i) &#123;</div><div class="line">         Circle circle = </div><div class="line">            (Circle)ShapeFactory.getCircle(getRandomColor());</div><div class="line">         circle.setX(getRandomX());</div><div class="line">         circle.setY(getRandomY());</div><div class="line">         circle.setRadius(100);</div><div class="line">         circle.draw();</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">   private static String getRandomColor() &#123;</div><div class="line">      return colors[(int)(Math.random()*colors.length)];</div><div class="line">   &#125;</div><div class="line">   private static int getRandomX() &#123;</div><div class="line">      return (int)(Math.random()*100 );</div><div class="line">   &#125;</div><div class="line">   private static int getRandomY() &#123;</div><div class="line">      return (int)(Math.random()*100);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Creating circle of color : Black</div><div class="line">Circle: Draw() [Color : Black, x : 36, y :71, radius :100</div><div class="line">Creating circle of color : Green</div><div class="line">Circle: Draw() [Color : Green, x : 27, y :27, radius :100</div><div class="line">Creating circle of color : White</div><div class="line">Circle: Draw() [Color : White, x : 64, y :10, radius :100</div><div class="line">Creating circle of color : Red</div><div class="line">Circle: Draw() [Color : Red, x : 15, y :44, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 19, y :10, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 94, y :32, radius :100</div><div class="line">Circle: Draw() [Color : White, x : 69, y :98, radius :100</div><div class="line">Creating circle of color : Blue</div><div class="line">Circle: Draw() [Color : Blue, x : 13, y :4, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 21, y :21, radius :100</div><div class="line">Circle: Draw() [Color : Blue, x : 55, y :86, radius :100</div><div class="line">Circle: Draw() [Color : White, x : 90, y :70, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 78, y :3, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 64, y :89, radius :100</div><div class="line">Circle: Draw() [Color : Blue, x : 3, y :91, radius :100</div><div class="line">Circle: Draw() [Color : Blue, x : 62, y :82, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 97, y :61, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 86, y :12, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 38, y :93, radius :100</div><div class="line">Circle: Draw() [Color : Red, x : 76, y :82, radius :100</div><div class="line">Circle: Draw() [Color : Blue, x : 95, y :82, radius :100</div></pre></td></tr></table></figure>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。<br>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。<br><strong>意图：</strong>为其他对象提供一种代理以控制对这个对象的访问。<br><strong>主要解决：</strong>在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。<br><strong>何时使用：</strong>想在访问一个类时做一些控制。<br><strong>如何解决：</strong>增加中间层。<br>关键代码：实现与被代理类组合。<br><strong>应用实例：</strong> 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。<br><strong>优点：</strong> 1、职责清晰。 2、高扩展性。 3、智能化。<br><strong>缺点：</strong> 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。<br><strong>使用场景：</strong>按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。<br><strong>注意事项：</strong> 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。<br><strong>实现</strong><br>我们将创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。<br>ProxyPatternDemo，我们的演示类使用 ProxyImage 来获取要加载的 Image 对象，并按照需求进行显示。<br><img src="/2017/08/08/设计模式/proxy_pattern_uml_diagram.jpg" alt="proxy_pattern" title="proxy_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口。</p>
<p>Image.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Image &#123;</div><div class="line">   void display();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>RealImage.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class RealImage implements Image &#123;</div><div class="line"></div><div class="line">   private String fileName;</div><div class="line"></div><div class="line">   public RealImage(String fileName)&#123;</div><div class="line">      this.fileName = fileName;</div><div class="line">      loadFromDisk(fileName);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void display() &#123;</div><div class="line">      System.out.println(&quot;Displaying &quot; + fileName);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private void loadFromDisk(String fileName)&#123;</div><div class="line">      System.out.println(&quot;Loading &quot; + fileName);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ProxyImage.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class ProxyImage implements Image&#123;</div><div class="line"></div><div class="line">   private RealImage realImage;</div><div class="line">   private String fileName;</div><div class="line"></div><div class="line">   public ProxyImage(String fileName)&#123;</div><div class="line">      this.fileName = fileName;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void display() &#123;</div><div class="line">      if(realImage == null)&#123;</div><div class="line">         realImage = new RealImage(fileName);</div><div class="line">      &#125;</div><div class="line">      realImage.display();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>当被请求时，使用 ProxyImage 来获取 RealImage 类的对象。</p>
<p>ProxyPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class ProxyPatternDemo &#123;</div><div class="line">	</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Image image = new ProxyImage(&quot;test_10mb.jpg&quot;);</div><div class="line"></div><div class="line">      //图像将从磁盘加载</div><div class="line">      image.display(); </div><div class="line">      System.out.println(&quot;&quot;);</div><div class="line">      //图像将无法从磁盘加载</div><div class="line">      image.display(); 	</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Loading test_10mb.jpg</div><div class="line">Displaying test_10mb.jpg</div><div class="line"></div><div class="line">Displaying test_10mb.jpg</div></pre></td></tr></table></figure>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。<br>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。<br><strong>意图：</strong>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。<br><strong>主要解决：</strong>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。<br><strong>何时使用：</strong>在处理消息的时候以过滤很多道。<br><strong>如何解决：</strong>拦截的类都实现统一接口。<br><strong>关键代码：</strong>Handler 里面聚合它自己，在 HanleRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。<br><strong>应用实例：</strong> 1、红楼梦中的”击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。<br><strong>优点：</strong> 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。<br><strong>缺点：</strong> 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。<br><strong>使用场景：</strong> 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。<br>注意事项：在 JAVA WEB 中遇到很多应用。<br><strong>实现 </strong><br>我们创建抽象类 AbstractLogger，带有详细的日志记录级别。然后我们创建三种类型的记录器，都扩展了 AbstractLogger。每个记录器消息的级别是否属于自己的级别，如果是则相应地打印出来，否则将不打印并把消息传给下一个记录器。<br><img src="/2017/08/08/设计模式/chain_pattern_uml_diagram.jpg" alt="chain_pattern" title="chain_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建抽象的记录器类。</p>
<p>AbstractLogger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public abstract class AbstractLogger &#123;</div><div class="line">   public static int INFO = 1;</div><div class="line">   public static int DEBUG = 2;</div><div class="line">   public static int ERROR = 3;</div><div class="line"></div><div class="line">   protected int level;</div><div class="line"></div><div class="line">   //责任链中的下一个元素</div><div class="line">   protected AbstractLogger nextLogger;</div><div class="line"></div><div class="line">   public void setNextLogger(AbstractLogger nextLogger)&#123;</div><div class="line">      this.nextLogger = nextLogger;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void logMessage(int level, String message)&#123;</div><div class="line">      if(this.level &lt;= level)&#123;</div><div class="line">         write(message);</div><div class="line">      &#125;</div><div class="line">      if(nextLogger !=null)&#123;</div><div class="line">         nextLogger.logMessage(level, message);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   abstract protected void write(String message);</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建扩展了该记录器类的实体类。</p>
<p>ConsoleLogger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class ConsoleLogger extends AbstractLogger &#123;</div><div class="line"></div><div class="line">   public ConsoleLogger(int level)&#123;</div><div class="line">      this.level = level;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   protected void write(String message) &#123;		</div><div class="line">      System.out.println(&quot;Standard Console::Logger: &quot; + message);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ErrorLogger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class ErrorLogger extends AbstractLogger &#123;</div><div class="line"></div><div class="line">   public ErrorLogger(int level)&#123;</div><div class="line">      this.level = level;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   protected void write(String message) &#123;		</div><div class="line">      System.out.println(&quot;Error Console::Logger: &quot; + message);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>FileLogger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class FileLogger extends AbstractLogger &#123;</div><div class="line"></div><div class="line">   public FileLogger(int level)&#123;</div><div class="line">      this.level = level;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   protected void write(String message) &#123;		</div><div class="line">      System.out.println(&quot;File::Logger: &quot; + message);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建不同类型的记录器。赋予它们不同的错误级别，并在每个记录器中设置下一个记录器。每个记录器中的下一个记录器代表的是链的一部分。</p>
<p>ChainPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class ChainPatternDemo &#123;</div><div class="line">	</div><div class="line">   private static AbstractLogger getChainOfLoggers()&#123;</div><div class="line"></div><div class="line">      AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR);</div><div class="line">      AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG);</div><div class="line">      AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO);</div><div class="line"></div><div class="line">      errorLogger.setNextLogger(fileLogger);</div><div class="line">      fileLogger.setNextLogger(consoleLogger);</div><div class="line"></div><div class="line">      return errorLogger;	</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      AbstractLogger loggerChain = getChainOfLoggers();</div><div class="line"></div><div class="line">      loggerChain.logMessage(AbstractLogger.INFO, </div><div class="line">         &quot;This is an information.&quot;);</div><div class="line"></div><div class="line">      loggerChain.logMessage(AbstractLogger.DEBUG, </div><div class="line">         &quot;This is an debug level information.&quot;);</div><div class="line"></div><div class="line">      loggerChain.logMessage(AbstractLogger.ERROR, </div><div class="line">         &quot;This is an error information.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Standard Console::Logger: This is an information.</div><div class="line">File::Logger: This is an debug level information.</div><div class="line">Standard Console::Logger: This is an debug level information.</div><div class="line">Error Console::Logger: This is an error information.</div><div class="line">File::Logger: This is an error information.</div><div class="line">Standard Console::Logger: This is an error information.</div></pre></td></tr></table></figure>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。<br><strong>意图：</strong>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。<br><strong>主要解决：</strong>在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。<br><strong>何时使用：</strong>在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。<br><strong>如何解决：</strong>通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。<br><strong>关键代码：</strong>定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口<br><strong>应用实例：</strong>struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。<br><strong>优点：</strong> 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。<br><strong>缺点：</strong>使用命令模式可能会导致某些系统有过多的具体命令类。<br><strong>使用场景：</strong>认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。<br><strong>注意事项：</strong>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。<br><strong>实现</strong><br>我们首先创建作为命令的接口 Order，然后创建作为请求的 Stock 类。实体命令类 BuyStock 和 SellStock，实现了 Order 接口，将执行实际的命令处理。创建作为调用对象的类 Broker，它接受订单并能下订单。<br>Broker 对象使用命令模式，基于命令的类型确定哪个对象执行哪个命令。CommandPatternDemo，我们的演示类使用 Broker 类来演示命令模式。<br><img src="/2017/08/08/设计模式/command_pattern_uml_diagram.jpg" alt="command_pattern" title="command_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个命令接口。</p>
<p>Order.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Order &#123;</div><div class="line">   void execute();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建一个请求类。</p>
<p>Stock.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Stock &#123;</div><div class="line">	</div><div class="line">   private String name = &quot;ABC&quot;;</div><div class="line">   private int quantity = 10;</div><div class="line"></div><div class="line">   public void buy()&#123;</div><div class="line">      System.out.println(&quot;Stock [ Name: &quot;+name+&quot;, </div><div class="line">         Quantity: &quot; + quantity +&quot; ] bought&quot;);</div><div class="line">   &#125;</div><div class="line">   public void sell()&#123;</div><div class="line">      System.out.println(&quot;Stock [ Name: &quot;+name+&quot;, </div><div class="line">         Quantity: &quot; + quantity +&quot; ] sold&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实现了 Order 接口的实体类。</p>
<p>BuyStock.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class BuyStock implements Order &#123;</div><div class="line">   private Stock abcStock;</div><div class="line"></div><div class="line">   public BuyStock(Stock abcStock)&#123;</div><div class="line">      this.abcStock = abcStock;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void execute() &#123;</div><div class="line">      abcStock.buy();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SellStock.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class SellStock implements Order &#123;</div><div class="line">   private Stock abcStock;</div><div class="line"></div><div class="line">   public SellStock(Stock abcStock)&#123;</div><div class="line">      this.abcStock = abcStock;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void execute() &#123;</div><div class="line">      abcStock.sell();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建命令调用类。</p>
<p>Broker.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">   public class Broker &#123;</div><div class="line">   private List&lt;Order&gt; orderList = new ArrayList&lt;Order&gt;(); </div><div class="line"></div><div class="line">   public void takeOrder(Order order)&#123;</div><div class="line">      orderList.add(order);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void placeOrders()&#123;</div><div class="line">      for (Order order : orderList) &#123;</div><div class="line">         order.execute();</div><div class="line">      &#125;</div><div class="line">      orderList.clear();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>使用 Broker 类来接受并执行命令。</p>
<p>CommandPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class CommandPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Stock abcStock = new Stock();</div><div class="line"></div><div class="line">      BuyStock buyStockOrder = new BuyStock(abcStock);</div><div class="line">      SellStock sellStockOrder = new SellStock(abcStock);</div><div class="line"></div><div class="line">      Broker broker = new Broker();</div><div class="line">      broker.takeOrder(buyStockOrder);</div><div class="line">      broker.takeOrder(sellStockOrder);</div><div class="line"></div><div class="line">      broker.placeOrders();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Stock [ Name: ABC, Quantity: 10 ] bought</div><div class="line">Stock [ Name: ABC, Quantity: 10 ] sold</div></pre></td></tr></table></figure>
<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。<br>意图：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。<br><strong>主要解决：</strong>对于一些固定文法构建一个解释句子的解释器。<br><strong>何时使用：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。  
</strong>如何解决：<strong>构件语法树，定义终结符与非终结符。  
</strong>关键代码：<strong>构件环境类，包含解释器之外的一些全局信息，一般是 HashMap。  
</strong>应用实例：<strong>编译器、运算表达式计算。  
</strong>优点：<strong> 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。  
</strong>缺点：<strong> 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。  
</strong>使用场景：<strong> 1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 2、一些重复出现的问题可以用一种简单的语言来进行表达。 3、一个简单语法需要解释的场景。<br>注意事项：可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。  
</strong>实现 **<br>我们将创建一个接口 Expression 和实现了 Expression 接口的实体类。定义作为上下文中主要解释器的 TerminalExpression 类。其他的类 OrExpression、AndExpression 用于创建组合式表达式。<br>InterpreterPatternDemo，我们的演示类使用 Expression 类创建规则和演示表达式的解析。<br><img src="/2017/08/08/设计模式/interpreter_pattern_uml_diagram.jpg" alt="interpreter_pattern" title="interpreter_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个表达式接口。</p>
<p>Expression.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Expression &#123;</div><div class="line">   public boolean interpret(String context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现了上述接口的实体类。</p>
<p>TerminalExpression.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class TerminalExpression implements Expression &#123;</div><div class="line">	</div><div class="line">   private String data;</div><div class="line"></div><div class="line">   public TerminalExpression(String data)&#123;</div><div class="line">      this.data = data; </div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public boolean interpret(String context) &#123;</div><div class="line">      if(context.contains(data))&#123;</div><div class="line">         return true;</div><div class="line">      &#125;</div><div class="line">      return false;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OrExpression.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class OrExpression implements Expression &#123;</div><div class="line">	 </div><div class="line">   private Expression expr1 = null;</div><div class="line">   private Expression expr2 = null;</div><div class="line"></div><div class="line">   public OrExpression(Expression expr1, Expression expr2) &#123; </div><div class="line">      this.expr1 = expr1;</div><div class="line">      this.expr2 = expr2;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public boolean interpret(String context) &#123;		</div><div class="line">      return expr1.interpret(context) || expr2.interpret(context);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AndExpression.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class AndExpression implements Expression &#123;</div><div class="line">	 </div><div class="line">   private Expression expr1 = null;</div><div class="line">   private Expression expr2 = null;</div><div class="line"></div><div class="line">   public AndExpression(Expression expr1, Expression expr2) &#123; </div><div class="line">      this.expr1 = expr1;</div><div class="line">      this.expr2 = expr2;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public boolean interpret(String context) &#123;		</div><div class="line">      return expr1.interpret(context) &amp;&amp; expr2.interpret(context);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong><br>InterpreterPatternDemo 使用 Expression 类来创建规则，并解析它们。</p>
<p>InterpreterPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class InterpreterPatternDemo &#123;</div><div class="line"></div><div class="line">   //规则：Robert 和 John 是男性</div><div class="line">   public static Expression getMaleExpression()&#123;</div><div class="line">      Expression robert = new TerminalExpression(&quot;Robert&quot;);</div><div class="line">      Expression john = new TerminalExpression(&quot;John&quot;);</div><div class="line">      return new OrExpression(robert, john);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //规则：Julie 是一个已婚的女性</div><div class="line">   public static Expression getMarriedWomanExpression()&#123;</div><div class="line">      Expression julie = new TerminalExpression(&quot;Julie&quot;);</div><div class="line">      Expression married = new TerminalExpression(&quot;Married&quot;);</div><div class="line">      return new AndExpression(julie, married);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Expression isMale = getMaleExpression();</div><div class="line">      Expression isMarriedWoman = getMarriedWomanExpression();</div><div class="line"></div><div class="line">      System.out.println(&quot;John is male? &quot; + isMale.interpret(&quot;John&quot;));</div><div class="line">      System.out.println(&quot;Julie is a married women? &quot; </div><div class="line">      + isMarriedWoman.interpret(&quot;Married Julie&quot;));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">John is male? true</div><div class="line">Julie is a married women? true</div></pre></td></tr></table></figure>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。<br>迭代器模式属于行为型模式。<br><strong>意图：</strong>提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。<br><strong>主要解决：</strong>不同的方式来遍历整个整合对象。<br><strong>何时使用：</strong>遍历一个聚合对象。<br><strong>如何解决：</strong>把在元素之间游走的责任交给迭代器，而不是聚合对象。<br><strong>关键代码：</strong>定义接口：hasNext, next。<br><strong>应用实例：</strong>JAVA 中的 iterator。<br><strong>优点：</strong> 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。<br><strong>缺点：</strong>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。<br>使用场景： 1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口。<br><strong>注意事项：</strong>迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。<br><strong>实现</strong><br>我们将创建一个叙述导航方法的 Iterator 接口和一个返回迭代器的 Container 接口。实现了 Container 接口的实体类将负责实现 Iterator 接口。<br>IteratorPatternDemo，我们的演示类使用实体类 NamesRepository 来打印 NamesRepository 中存储为集合的 Names。<br><img src="/2017/08/08/设计模式/iterator_pattern_uml_diagram.jpg" alt="iterator_pattern" title="iterator_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建接口。</p>
<p>Iterator.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface Iterator &#123;</div><div class="line">   public boolean hasNext();</div><div class="line">   public Object next();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Container.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Container &#123;</div><div class="line">   public Iterator getIterator();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现了 Container 接口的实体类。该类有实现了 Iterator 接口的内部类 NameIterator。</p>
<p>NameRepository.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class NameRepository implements Container &#123;</div><div class="line">   public String names[] = &#123;&quot;Robert&quot; , &quot;John&quot; ,&quot;Julie&quot; , &quot;Lora&quot;&#125;;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public Iterator getIterator() &#123;</div><div class="line">      return new NameIterator();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private class NameIterator implements Iterator &#123;</div><div class="line"></div><div class="line">      int index;</div><div class="line"></div><div class="line">      @Override</div><div class="line">      public boolean hasNext() &#123;</div><div class="line">         if(index &lt; names.length)&#123;</div><div class="line">            return true;</div><div class="line">         &#125;</div><div class="line">         return false;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      @Override</div><div class="line">      public Object next() &#123;</div><div class="line">         if(this.hasNext())&#123;</div><div class="line">            return names[index++];</div><div class="line">         &#125;</div><div class="line">         return null;</div><div class="line">      &#125;		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>使用 NameRepository 来获取迭代器，并打印名字。</p>
<p>IteratorPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class IteratorPatternDemo &#123;</div><div class="line">	</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      NameRepository namesRepository = new NameRepository();</div><div class="line"></div><div class="line">      for(Iterator iter = namesRepository.getIterator(); iter.hasNext();)&#123;</div><div class="line">         String name = (String)iter.next();</div><div class="line">         System.out.println(&quot;Name : &quot; + name);</div><div class="line">      &#125; 	</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Name : Robert</div><div class="line">Name : John</div><div class="line">Name : Julie</div><div class="line">Name : Lora</div></pre></td></tr></table></figure>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。<br><strong>意图：</strong>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br><strong>主要解决：</strong>对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。<br><strong>何时使用：</strong>多个类相互耦合，形成了网状结构。<br><strong>如何解决：</strong>将上述网状结构分离为星型结构。<br><strong>关键代码：</strong>对象 Colleague 之间的通信封装到一个类中单独处理。<br><strong>应用实例：</strong> 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。<br><strong>优点：</strong> 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。<br><strong>缺点：</strong>中介者会庞大，变得复杂难以维护。<br>使用场景： 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。<br>注意事项：不应当在职责混乱的时候使用。<br><strong>实现</strong><br>我们通过聊天室实例来演示中介者模式。实例中，多个用户可以向聊天室发送消息，聊天室向所有的用户显示消息。我们将创建两个类 ChatRoom 和 User。User 对象使用 ChatRoom 方法来分享他们的消息。<br>MediatorPatternDemo，我们的演示类使用 User 对象来显示他们之间的通信。<br><img src="/2017/08/08/设计模式/mediator_pattern_uml_diagram.jpg" alt="mediator_pattern" title="mediator_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建中介类。</p>
<p>ChatRoom.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import java.util.Date;</div><div class="line"></div><div class="line">public class ChatRoom &#123;</div><div class="line">   public static void showMessage(User user, String message)&#123;</div><div class="line">      System.out.println(new Date().toString()</div><div class="line">         + &quot; [&quot; + user.getName() +&quot;] : &quot; + message);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建 user 类。</p>
<p>User.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class User &#123;</div><div class="line">   private String name;</div><div class="line"></div><div class="line">   public String getName() &#123;</div><div class="line">      return name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setName(String name) &#123;</div><div class="line">      this.name = name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public User(String name)&#123;</div><div class="line">      this.name  = name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void sendMessage(String message)&#123;</div><div class="line">      ChatRoom.showMessage(this,message);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>使用 User 对象来显示他们之间的通信。</p>
<p>MediatorPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class MediatorPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      User robert = new User(&quot;Robert&quot;);</div><div class="line">      User john = new User(&quot;John&quot;);</div><div class="line"></div><div class="line">      robert.sendMessage(&quot;Hi! John!&quot;);</div><div class="line">      john.sendMessage(&quot;Hello! Robert!&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Thu Jan 31 16:05:46 IST 2013 [Robert] : Hi! John!</div><div class="line">Thu Jan 31 16:05:46 IST 2013 [John] : Hello! Robert!</div></pre></td></tr></table></figure>
<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。<br><strong>意图：</strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。<br><strong>主要解决：</strong>所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。<br><strong>何时使用：</strong>很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。<br><strong>如何解决：</strong>通过一个备忘录类专门存储对象状态。<br><strong>关键代码：</strong>客户不与备忘录类耦合，与备忘录管理类耦合。<br><strong>应用实例：</strong> 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、IE 中的后退。 4、数据库的事务管理。<br><strong>优点：</strong> 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。<br><strong>缺点：</strong>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。<br><strong>使用场景：</strong> 1、需要保存/恢复数据的相关状态场景。 2、提供一个可回滚的操作。<br><strong>注意事项：</strong> 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。<br><strong>实现</strong><br>备忘录模式使用三个类 Memento、Originator 和 CareTaker。Memento 包含了要被恢复的对象的状态。  Originator 创建并在 Memento 对象中存储状态。Caretaker 对象负责从 Memento 中恢复对象的状态。<br>MementoPatternDemo，我们的演示类使用 CareTaker 和 Originator 对象来显示对象的状态恢复。<br><img src="/2017/08/08/设计模式/memento_pattern_uml_diagram.jpg" alt="memento_pattern" title="memento_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建 Memento 类。</p>
<p>Memento.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Memento &#123;</div><div class="line">   private String state;</div><div class="line"></div><div class="line">   public Memento(String state)&#123;</div><div class="line">      this.state = state;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getState()&#123;</div><div class="line">      return state;</div><div class="line">   &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建 Originator 类。</p>
<p>Originator.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Originator &#123;</div><div class="line">   private String state;</div><div class="line"></div><div class="line">   public void setState(String state)&#123;</div><div class="line">      this.state = state;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getState()&#123;</div><div class="line">      return state;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public Memento saveStateToMemento()&#123;</div><div class="line">      return new Memento(state);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void getStateFromMemento(Memento Memento)&#123;</div><div class="line">      state = Memento.getState();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建 CareTaker 类。</p>
<p>CareTaker.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class CareTaker &#123;</div><div class="line">   private List&lt;Memento&gt; mementoList = new ArrayList&lt;Memento&gt;();</div><div class="line"></div><div class="line">   public void add(Memento state)&#123;</div><div class="line">      mementoList.add(state);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public Memento get(int index)&#123;</div><div class="line">      return mementoList.get(index);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 CareTaker 和 Originator 对象。</p>
<p>MementoPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class MementoPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Originator originator = new Originator();</div><div class="line">      CareTaker careTaker = new CareTaker();</div><div class="line">      originator.setState(&quot;State #1&quot;);</div><div class="line">      originator.setState(&quot;State #2&quot;);</div><div class="line">      careTaker.add(originator.saveStateToMemento());</div><div class="line">      originator.setState(&quot;State #3&quot;);</div><div class="line">      careTaker.add(originator.saveStateToMemento());</div><div class="line">      originator.setState(&quot;State #4&quot;);</div><div class="line"></div><div class="line">      System.out.println(&quot;Current State: &quot; + originator.getState());		</div><div class="line">      originator.getStateFromMemento(careTaker.get(0));</div><div class="line">      System.out.println(&quot;First saved State: &quot; + originator.getState());</div><div class="line">      originator.getStateFromMemento(careTaker.get(1));</div><div class="line">      System.out.println(&quot;Second saved State: &quot; + originator.getState());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Current State: State #4</div><div class="line">First saved State: State #2</div><div class="line">Second saved State: State #3</div></pre></td></tr></table></figure>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。<br>意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。<br><strong>主要解决：</strong>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。<br><strong>何时使用：</strong>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。<br><strong>如何解决：</strong>使用面向对象技术，可以将这种依赖关系弱化。<br><strong>关键代码：</strong>在抽象类里有一个 ArrayList 存放观察者们。<br><strong>应用实例：</strong> 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。<br><strong>优点：</strong> 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。<br><strong>缺点：</strong> 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。<br><strong>使用场景：</strong> 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。<br><strong>注意事项：</strong> 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。<br><strong>实现</strong><br>观察者模式使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。我们创建 Subject 类、Observer 抽象类和扩展了抽象类 Observer 的实体类。<br>ObserverPatternDemo，我们的演示类使用 Subject 和实体类对象来演示观察者模式。<br><img src="/2017/08/08/设计模式/observer_pattern_uml_diagram.jpg" alt="observer_pattern" title="observer_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建 Subject 类。</p>
<p>Subject.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class Subject &#123;</div><div class="line">	</div><div class="line">   private List&lt;Observer&gt; observers </div><div class="line">      = new ArrayList&lt;Observer&gt;();</div><div class="line">   private int state;</div><div class="line"></div><div class="line">   public int getState() &#123;</div><div class="line">      return state;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setState(int state) &#123;</div><div class="line">      this.state = state;</div><div class="line">      notifyAllObservers();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void attach(Observer observer)&#123;</div><div class="line">      observers.add(observer);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void notifyAllObservers()&#123;</div><div class="line">      for (Observer observer : observers) &#123;</div><div class="line">         observer.update();</div><div class="line">      &#125;</div><div class="line">   &#125; 	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建 Observer 类。</p>
<p>Observer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public abstract class Observer &#123;</div><div class="line">   protected Subject subject;</div><div class="line">   public abstract void update();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实体观察者类。</p>
<p>BinaryObserver.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class BinaryObserver extends Observer&#123;</div><div class="line"></div><div class="line">   public BinaryObserver(Subject subject)&#123;</div><div class="line">      this.subject = subject;</div><div class="line">      this.subject.attach(this);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void update() &#123;</div><div class="line">      System.out.println( &quot;Binary String: &quot; </div><div class="line">      + Integer.toBinaryString( subject.getState() ) ); </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OctalObserver.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class OctalObserver extends Observer&#123;</div><div class="line"></div><div class="line">   public OctalObserver(Subject subject)&#123;</div><div class="line">      this.subject = subject;</div><div class="line">      this.subject.attach(this);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void update() &#123;</div><div class="line">     System.out.println( &quot;Octal String: &quot; </div><div class="line">     + Integer.toOctalString( subject.getState() ) ); </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>HexaObserver.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class HexaObserver extends Observer&#123;</div><div class="line"></div><div class="line">   public HexaObserver(Subject subject)&#123;</div><div class="line">      this.subject = subject;</div><div class="line">      this.subject.attach(this);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void update() &#123;</div><div class="line">      System.out.println( &quot;Hex String: &quot; </div><div class="line">      + Integer.toHexString( subject.getState() ).toUpperCase() ); </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 Subject 和实体观察者对象。</p>
<p>ObserverPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class ObserverPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Subject subject = new Subject();</div><div class="line"></div><div class="line">      new HexaObserver(subject);</div><div class="line">      new OctalObserver(subject);</div><div class="line">      new BinaryObserver(subject);</div><div class="line"></div><div class="line">      System.out.println(&quot;First state change: 15&quot;);	</div><div class="line">      subject.setState(15);</div><div class="line">      System.out.println(&quot;Second state change: 10&quot;);	</div><div class="line">      subject.setState(10);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">First state change: 15</div><div class="line">Hex String: F</div><div class="line">Octal String: 17</div><div class="line">Binary String: 1111</div><div class="line">Second state change: 10</div><div class="line">Hex String: A</div><div class="line">Octal String: 12</div><div class="line">Binary String: 1010</div></pre></td></tr></table></figure>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。<br>在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。<br>介绍<br><strong>意图：</strong>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。<br><strong>主要解决：</strong>对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。<br><strong>何时使用：</strong>代码中包含大量与对象状态有关的条件语句。<br><strong>如何解决：</strong>将各种具体的状态类抽象出来。<br><strong>关键代码：</strong>通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。<br><strong>应用实例：</strong> 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。<br><strong>优点：</strong> 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。<br><strong>缺点：</strong> 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。<br><strong>使用场景：</strong> 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。<br><strong>注意事项：</strong>在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。<br><strong>实现</strong><br>我们将创建一个 State 接口和实现了 State 接口的实体状态类。Context 是一个带有某个状态的类。<br>StatePatternDemo，我们的演示类使用 Context 和状态对象来演示 Context 在状态改变时的行为变化。<br><img src="/2017/08/08/设计模式/state_pattern_uml_diagram.jpg" alt="state_pattern" title="state_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口。</p>
<p>State.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface State &#123;</div><div class="line">   public void doAction(Context context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>StartState.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class StartState implements State &#123;</div><div class="line"></div><div class="line">   public void doAction(Context context) &#123;</div><div class="line">      System.out.println(&quot;Player is in start state&quot;);</div><div class="line">      context.setState(this);	</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String toString()&#123;</div><div class="line">      return &quot;Start State&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>StopState.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class StopState implements State &#123;</div><div class="line"></div><div class="line">   public void doAction(Context context) &#123;</div><div class="line">      System.out.println(&quot;Player is in stop state&quot;);</div><div class="line">      context.setState(this);	</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String toString()&#123;</div><div class="line">      return &quot;Stop State&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建 Context 类。</p>
<p>Context.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Context &#123;</div><div class="line">   private State state;</div><div class="line"></div><div class="line">   public Context()&#123;</div><div class="line">      state = null;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setState(State state)&#123;</div><div class="line">      this.state = state;		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public State getState()&#123;</div><div class="line">      return state;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 Context 来查看当状态 State 改变时的行为变化。</p>
<p>StatePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class StatePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Context context = new Context();</div><div class="line"></div><div class="line">      StartState startState = new StartState();</div><div class="line">      startState.doAction(context);</div><div class="line"></div><div class="line">      System.out.println(context.getState().toString());</div><div class="line"></div><div class="line">      StopState stopState = new StopState();</div><div class="line">      stopState.doAction(context);</div><div class="line"></div><div class="line">      System.out.println(context.getState().toString());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Player is in start state</div><div class="line">Start State</div><div class="line">Player is in stop state</div><div class="line">Stop State</div></pre></td></tr></table></figure>
<h2 id="空对象模式"><a href="#空对象模式" class="headerlink" title="空对象模式"></a>空对象模式</h2><p>在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。<br>在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。<br><strong>实现</strong><br>我们将创建一个定义操作（在这里，是客户的名称）的 AbstractCustomer 抽象类，和扩展了 AbstractCustomer 类的实体类。工厂类 CustomerFactory 基于客户传递的名字来返回 RealCustomer 或 NullCustomer 对象。<br>NullPatternDemo，我们的演示类使用 CustomerFactory 来演示空对象模式的用法。<br><img src="/2017/08/08/设计模式/null_pattern_uml_diagram.jpg" alt="null_pattern" title="null_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个抽象类。</p>
<p>AbstractCustomer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public abstract class AbstractCustomer &#123;</div><div class="line">   protected String name;</div><div class="line">   public abstract boolean isNil();</div><div class="line">   public abstract String getName();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建扩展了上述类的实体类。</p>
<p>RealCustomer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class RealCustomer extends AbstractCustomer &#123;</div><div class="line"></div><div class="line">   public RealCustomer(String name) &#123;</div><div class="line">      this.name = name;		</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @Override</div><div class="line">   public String getName() &#123;</div><div class="line">      return name;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @Override</div><div class="line">   public boolean isNil() &#123;</div><div class="line">      return false;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>NullCustomer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class NullCustomer extends AbstractCustomer &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String getName() &#123;</div><div class="line">      return &quot;Not Available in Customer Database&quot;;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public boolean isNil() &#123;</div><div class="line">      return true;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建 CustomerFactory 类。</p>
<p>CustomerFactory.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class CustomerFactory &#123;</div><div class="line">	</div><div class="line">   public static final String[] names = &#123;&quot;Rob&quot;, &quot;Joe&quot;, &quot;Julie&quot;&#125;;</div><div class="line"></div><div class="line">   public static AbstractCustomer getCustomer(String name)&#123;</div><div class="line">      for (int i = 0; i &lt; names.length; i++) &#123;</div><div class="line">         if (names[i].equalsIgnoreCase(name))&#123;</div><div class="line">            return new RealCustomer(name);</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      return new NullCustomer();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 CustomerFactory，基于客户传递的名字，来获取 RealCustomer 或 NullCustomer 对象。</p>
<p>NullPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class NullPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      AbstractCustomer customer1 = CustomerFactory.getCustomer(&quot;Rob&quot;);</div><div class="line">      AbstractCustomer customer2 = CustomerFactory.getCustomer(&quot;Bob&quot;);</div><div class="line">      AbstractCustomer customer3 = CustomerFactory.getCustomer(&quot;Julie&quot;);</div><div class="line">      AbstractCustomer customer4 = CustomerFactory.getCustomer(&quot;Laura&quot;);</div><div class="line"></div><div class="line">      System.out.println(&quot;Customers&quot;);</div><div class="line">      System.out.println(customer1.getName());</div><div class="line">      System.out.println(customer2.getName());</div><div class="line">      System.out.println(customer3.getName());</div><div class="line">      System.out.println(customer4.getName());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Customers</div><div class="line">Rob</div><div class="line">Not Available in Customer Database</div><div class="line">Julie</div><div class="line">Not Available in Customer Database</div></pre></td></tr></table></figure>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。<br>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。<br><strong>意图：</strong>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。<br><strong>主要解决：</strong>在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。<br><strong>何时使用：</strong>一个系统有许多许多类，而区分它们的只是他们直接的行为。<br><strong>如何解决：</strong>将这些算法封装成一个一个的类，任意地替换。<br><strong>关键代码：</strong>实现同一个接口。<br><strong>应用实例：</strong> 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。<br><strong>优点：</strong> 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。<br><strong>缺点：</strong> 1、策略类会增多。 2、所有策略类都需要对外暴露。<br><strong>使用场景：</strong> 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。<br>注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。<br><strong>实现 </strong><br>我们将创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。<br>StrategyPatternDemo，我们的演示类使用 Context 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。<br><img src="/2017/08/08/设计模式/strategy_pattern_uml_diagram.jpg" alt="strategy_pattern" title="strategy_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口。</p>
<p>Strategy.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Strategy &#123;</div><div class="line">   public int doOperation(int num1, int num2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>OperationAdd.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class OperationAdd implements Strategy&#123;</div><div class="line">   @Override</div><div class="line">   public int doOperation(int num1, int num2) &#123;</div><div class="line">      return num1 + num2;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OperationSubstract.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class OperationSubstract implements Strategy&#123;</div><div class="line">   @Override</div><div class="line">   public int doOperation(int num1, int num2) &#123;</div><div class="line">      return num1 - num2;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OperationMultiply.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class OperationMultiply implements Strategy&#123;</div><div class="line">   @Override</div><div class="line">   public int doOperation(int num1, int num2) &#123;</div><div class="line">      return num1 * num2;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建 Context 类。</p>
<p>Context.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Context &#123;</div><div class="line">   private Strategy strategy;</div><div class="line"></div><div class="line">   public Context(Strategy strategy)&#123;</div><div class="line">      this.strategy = strategy;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public int executeStrategy(int num1, int num2)&#123;</div><div class="line">      return strategy.doOperation(num1, num2);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 Context 来查看当它改变策略 Strategy 时的行为变化。</p>
<p>StrategyPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class StrategyPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Context context = new Context(new OperationAdd());		</div><div class="line">      System.out.println(&quot;10 + 5 = &quot; + context.executeStrategy(10, 5));</div><div class="line"></div><div class="line">      context = new Context(new OperationSubstract());		</div><div class="line">      System.out.println(&quot;10 - 5 = &quot; + context.executeStrategy(10, 5));</div><div class="line"></div><div class="line">      context = new Context(new OperationMultiply());		</div><div class="line">      System.out.println(&quot;10 * 5 = &quot; + context.executeStrategy(10, 5));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">10 + 5 = 15</div><div class="line">10 - 5 = 5</div><div class="line">10 * 5 = 50</div></pre></td></tr></table></figure>
<h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。<br>意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br><strong>主要解决：</strong>一些方法通用，却在每一个子类都重新写了这一方法。<br><strong>何时使用：</strong>有一些通用的方法。<br><strong>如何解决：</strong>将这些通用算法抽象出来。<br><strong>关键代码：</strong>在抽象类实现，其他步骤在子类实现。<br><strong>应用实例：</strong> 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。<br><strong>优点：</strong> 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。<br><strong>缺点：</strong>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。<br><strong>使用场景：</strong> 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。<br><strong>注意事项：</strong>为防止恶意操作，一般模板方法都加上 final 关键词。<br><strong>实现</strong><br>我们将创建一个定义操作的 Game 抽象类，其中，模板方法设置为 final，这样它就不会被重写。Cricket 和 Football 是扩展了 Game 的实体类，它们重写了抽象类的方法。<br>TemplatePatternDemo，我们的演示类使用 Game 来演示模板模式的用法。<br><img src="/2017/08/08/设计模式/template_pattern_uml_diagram.jpg" alt="template_pattern" title="template_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个抽象类，它的模板方法被设置为 final。</p>
<p>Game.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public abstract class Game &#123;</div><div class="line">   abstract void initialize();</div><div class="line">   abstract void startPlay();</div><div class="line">   abstract void endPlay();</div><div class="line"></div><div class="line">   //模板</div><div class="line">   public final void play()&#123;</div><div class="line"></div><div class="line">      //初始化游戏</div><div class="line">      initialize();</div><div class="line"></div><div class="line">      //开始游戏</div><div class="line">      startPlay();</div><div class="line"></div><div class="line">      //结束游戏</div><div class="line">      endPlay();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建扩展了上述类的实体类。</p>
<p>Cricket.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Cricket extends Game &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   void endPlay() &#123;</div><div class="line">      System.out.println(&quot;Cricket Game Finished!&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   void initialize() &#123;</div><div class="line">      System.out.println(&quot;Cricket Game Initialized! Start playing.&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   void startPlay() &#123;</div><div class="line">      System.out.println(&quot;Cricket Game Started. Enjoy the game!&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Football.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Football extends Game &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   void endPlay() &#123;</div><div class="line">      System.out.println(&quot;Football Game Finished!&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   void initialize() &#123;</div><div class="line">      System.out.println(&quot;Football Game Initialized! Start playing.&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   void startPlay() &#123;</div><div class="line">      System.out.println(&quot;Football Game Started. Enjoy the game!&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>使用 Game 的模板方法 play() 来演示游戏的定义方式。</p>
<p>TemplatePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class TemplatePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      Game game = new Cricket();</div><div class="line">      game.play();</div><div class="line">      System.out.println();</div><div class="line">      game = new Football();</div><div class="line">      game.play();		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Cricket Game Initialized! Start playing.</div><div class="line">Cricket Game Started. Enjoy the game!</div><div class="line">Cricket Game Finished!</div><div class="line"></div><div class="line">Football Game Initialized! Start playing.</div><div class="line">Football Game Started. Enjoy the game!</div><div class="line">Football Game Finished!</div></pre></td></tr></table></figure>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。<br>意图：主要将数据结构与数据操作分离。<br><strong> 主要解决：</strong> 稳定的数据结构和易变的操作耦合问题。<br><strong> 何时使用：</strong> 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。<br><strong> 如何解决：</strong> 在被访问的类里面加一个对外提供接待访问者的接口。<br><strong> 关键代码：</strong> 在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。<br><strong> 应用实例：</strong> 您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。<br><strong> 优点：</strong>  1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。<br><strong> 缺点：</strong>  1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。<br><strong> 使用场景：</strong>  1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。<br><strong> 注意事项：</strong> 访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。<br><strong> 实现</strong><br>我们将创建一个定义接受操作的 ComputerPart 接口。Keyboard、Mouse、Monitor 和 Computer 是实现了 ComputerPart 接口的实体类。我们将定义另一个接口 ComputerPartVisitor，它定义了访问者类的操作。Computer 使用实体访问者来执行相应的动作。<br>VisitorPatternDemo，我们的演示类使用 Computer、ComputerPartVisitor 类来演示访问者模式的用法。<br><img src="/2017/08/08/设计模式/visitor_pattern_uml_diagram.jpg" alt="visitor_pattern" title="visitor_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>定义一个表示元素的接口。</p>
<p>ComputerPart.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface ComputerPart &#123;</div><div class="line">   public void accept(ComputerPartVisitor computerPartVisitor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建扩展了上述类的实体类。</p>
<p>Keyboard.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Keyboard  implements ComputerPart &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void accept(ComputerPartVisitor computerPartVisitor) &#123;</div><div class="line">      computerPartVisitor.visit(this);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Monitor.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Monitor  implements ComputerPart &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void accept(ComputerPartVisitor computerPartVisitor) &#123;</div><div class="line">      computerPartVisitor.visit(this);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Mouse.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Mouse  implements ComputerPart &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void accept(ComputerPartVisitor computerPartVisitor) &#123;</div><div class="line">      computerPartVisitor.visit(this);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Computer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Computer implements ComputerPart &#123;</div><div class="line">	</div><div class="line">   ComputerPart[] parts;</div><div class="line"></div><div class="line">   public Computer()&#123;</div><div class="line">      parts = new ComputerPart[] &#123;new Mouse(), new Keyboard(), new Monitor()&#125;;		</div><div class="line">   &#125; </div><div class="line"></div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void accept(ComputerPartVisitor computerPartVisitor) &#123;</div><div class="line">      for (int i = 0; i &lt; parts.length; i++) &#123;</div><div class="line">         parts[i].accept(computerPartVisitor);</div><div class="line">      &#125;</div><div class="line">      computerPartVisitor.visit(this);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>定义一个表示访问者的接口。</p>
<p>ComputerPartVisitor.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public interface ComputerPartVisitor &#123;</div><div class="line">	public void visit(Computer computer);</div><div class="line">	public void visit(Mouse mouse);</div><div class="line">	public void visit(Keyboard keyboard);</div><div class="line">	public void visit(Monitor monitor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建实现了上述类的实体访问者。</p>
<p>ComputerPartDisplayVisitor.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class ComputerPartDisplayVisitor implements ComputerPartVisitor &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void visit(Computer computer) &#123;</div><div class="line">      System.out.println(&quot;Displaying Computer.&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void visit(Mouse mouse) &#123;</div><div class="line">      System.out.println(&quot;Displaying Mouse.&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void visit(Keyboard keyboard) &#123;</div><div class="line">      System.out.println(&quot;Displaying Keyboard.&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void visit(Monitor monitor) &#123;</div><div class="line">      System.out.println(&quot;Displaying Monitor.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>使用 ComputerPartDisplayVisitor 来显示 Computer 的组成部分。</p>
<p>VisitorPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class VisitorPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      ComputerPart computer = new Computer();</div><div class="line">      computer.accept(new ComputerPartDisplayVisitor());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Displaying Mouse.</div><div class="line">Displaying Keyboard.</div><div class="line">Displaying Monitor.</div><div class="line">Displaying Computer.</div></pre></td></tr></table></figure>
<h2 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC 模式"></a>MVC 模式</h2><p>MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。<br><strong>Model（模型）</strong> - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。<br><strong>View（视图） </strong>- 视图代表模型包含的数据的可视化。<br><strong>Controller（控制器）</strong> - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。<br><strong>实现</strong><br>我们将创建一个作为模型的 Student 对象。StudentView 是一个把学生详细信息输出到控制台的视图类，StudentController 是负责存储数据到 Student 对象中的控制器类，并相应地更新视图 StudentView。<br>MVCPatternDemo，我们的演示类使用 StudentController 来演示 MVC 模式的用法。</p>
<p><img src="/2017/08/08/设计模式/mvc_pattern_uml_diagram.jpg" alt="mvc_pattern" title="mvc_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建模型。</p>
<p>Student.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Student &#123;</div><div class="line">   private String rollNo;</div><div class="line">   private String name;</div><div class="line">   public String getRollNo() &#123;</div><div class="line">      return rollNo;</div><div class="line">   &#125;</div><div class="line">   public void setRollNo(String rollNo) &#123;</div><div class="line">      this.rollNo = rollNo;</div><div class="line">   &#125;</div><div class="line">   public String getName() &#123;</div><div class="line">      return name;</div><div class="line">   &#125;</div><div class="line">   public void setName(String name) &#123;</div><div class="line">      this.name = name;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建视图。</p>
<p>StudentView.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class StudentView &#123;</div><div class="line">   public void printStudentDetails(String studentName, String studentRollNo)&#123;</div><div class="line">      System.out.println(&quot;Student: &quot;);</div><div class="line">      System.out.println(&quot;Name: &quot; + studentName);</div><div class="line">      System.out.println(&quot;Roll No: &quot; + studentRollNo);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建控制器。</p>
<p>StudentController.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class StudentController &#123;</div><div class="line">   private Student model;</div><div class="line">   private StudentView view;</div><div class="line"></div><div class="line">   public StudentController(Student model, StudentView view)&#123;</div><div class="line">      this.model = model;</div><div class="line">      this.view = view;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setStudentName(String name)&#123;</div><div class="line">      model.setName(name);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getStudentName()&#123;</div><div class="line">      return model.getName();		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setStudentRollNo(String rollNo)&#123;</div><div class="line">      model.setRollNo(rollNo);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getStudentRollNo()&#123;</div><div class="line">      return model.getRollNo();		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void updateView()&#123;				</div><div class="line">      view.printStudentDetails(model.getName(), model.getRollNo());</div><div class="line">   &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 StudentController 方法来演示 MVC 设计模式的用法。</p>
<p>MVCPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class MVCPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      //从数据可获取学生记录</div><div class="line">      Student model  = retriveStudentFromDatabase();</div><div class="line"></div><div class="line">      //创建一个视图：把学生详细信息输出到控制台</div><div class="line">      StudentView view = new StudentView();</div><div class="line"></div><div class="line">      StudentController controller = new StudentController(model, view);</div><div class="line"></div><div class="line">      controller.updateView();</div><div class="line"></div><div class="line">      //更新模型数据</div><div class="line">      controller.setStudentName(&quot;John&quot;);</div><div class="line"></div><div class="line">      controller.updateView();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private static Student retriveStudentFromDatabase()&#123;</div><div class="line">      Student student = new Student();</div><div class="line">      student.setName(&quot;Robert&quot;);</div><div class="line">      student.setRollNo(&quot;10&quot;);</div><div class="line">      return student;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Student: </div><div class="line">Name: Robert</div><div class="line">Roll No: 10</div><div class="line">Student: </div><div class="line">Name: John</div><div class="line">Roll No: 10</div></pre></td></tr></table></figure>
<h2 id="业务代表模式"><a href="#业务代表模式" class="headerlink" title="业务代表模式"></a>业务代表模式</h2><p>业务代表模式（Business Delegate Pattern）用于对表示层和业务层解耦。它基本上是用来减少通信或对表示层代码中的业务层代码的远程查询功能。在业务层中我们有以下实体。<br><strong>客户端（Client）</strong> - 表示层代码可以是 JSP、servlet 或 UI java 代码。<br><strong>业务代表（Business Delegate）</strong> - 一个为客户端实体提供的入口类，它提供了对业务服务方法的访问。<br><strong>查询服务（LookUp Service）</strong> - 查找服务对象负责获取相关的业务实现，并提供业务对象对业务代表对象的访问。<br><strong>业务服务（Business Service）</strong> - 业务服务接口。实现了该业务服务的实体类，提供了实际的业务实现逻辑。<br><strong>实现</strong><br>我们将创建 Client、BusinessDelegate、BusinessService、LookUpService、JMSService 和 EJBService 来表示业务代表模式中的各种实体。<br>BusinessDelegatePatternDemo，我们的演示类使用 BusinessDelegate 和 Client 来演示业务代表模式的用法。<br><img src="/2017/08/08/设计模式/business_delegate_pattern_uml_diagram.jpg" alt="business_delegate_pattern" title="business_delegate_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建 BusinessService 接口。</p>
<p>BusinessService.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface BusinessService &#123;</div><div class="line">   public void doProcessing();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实体服务类。</p>
<p>EJBService.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class EJBService implements BusinessService &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void doProcessing() &#123;</div><div class="line">      System.out.println(&quot;Processing task by invoking EJB Service&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JMSService.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class JMSService implements BusinessService &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void doProcessing() &#123;</div><div class="line">      System.out.println(&quot;Processing task by invoking JMS Service&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建业务查询服务。</p>
<p>BusinessLookUp.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class BusinessLookUp &#123;</div><div class="line">   public BusinessService getBusinessService(String serviceType)&#123;</div><div class="line">      if(serviceType.equalsIgnoreCase(&quot;EJB&quot;))&#123;</div><div class="line">         return new EJBService();</div><div class="line">      &#125;else &#123;</div><div class="line">         return new JMSService();</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建业务代表。</p>
<p>BusinessDelegate.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class BusinessDelegate &#123;</div><div class="line">   private BusinessLookUp lookupService = new BusinessLookUp();</div><div class="line">   private BusinessService businessService;</div><div class="line">   private String serviceType;</div><div class="line"></div><div class="line">   public void setServiceType(String serviceType)&#123;</div><div class="line">      this.serviceType = serviceType;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void doTask()&#123;</div><div class="line">      businessService = lookupService.getBusinessService(serviceType);</div><div class="line">      businessService.doProcessing();		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>创建客户端。</p>
<p>Client.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">	</div><div class="line">   BusinessDelegate businessService;</div><div class="line"></div><div class="line">   public Client(BusinessDelegate businessService)&#123;</div><div class="line">      this.businessService  = businessService;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void doTask()&#123;		</div><div class="line">      businessService.doTask();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>使用 BusinessDelegate 和 Client 类来演示业务代表模式。</p>
<p>BusinessDelegatePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class BusinessDelegatePatternDemo &#123;</div><div class="line">	</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      BusinessDelegate businessDelegate = new BusinessDelegate();</div><div class="line">      businessDelegate.setServiceType(&quot;EJB&quot;);</div><div class="line"></div><div class="line">      Client client = new Client(businessDelegate);</div><div class="line">      client.doTask();</div><div class="line"></div><div class="line">      businessDelegate.setServiceType(&quot;JMS&quot;);</div><div class="line">      client.doTask();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 7</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Processing task by invoking EJB Service</div><div class="line">Processing task by invoking JMS Service</div></pre></td></tr></table></figure>
<h2 id="组合实体模式"><a href="#组合实体模式" class="headerlink" title="组合实体模式"></a>组合实体模式</h2><p>组合实体模式（Composite Entity Pattern）用在 EJB 持久化机制中。一个组合实体是一个 EJB 实体 bean，代表了对象的图解。当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean 管理的。以下是组合实体 bean 的参与者。<br><strong>组合实体（Composite Entity）</strong> - 它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期。<br><strong>粗粒度对象（Coarse-Grained Object）</strong> - 该对象包含依赖对象。它有自己的生命周期，也能管理依赖对象的生命周期。<br><strong>依赖对象（Dependent Object）</strong> - 依赖对象是一个持续生命周期依赖于粗粒度对象的对象。<br><strong>策略（Strategies）</strong> - 策略表示如何实现组合实体。<br><strong>实现</strong><br>我们将创建作为组合实体的 CompositeEntity 对象。CoarseGrainedObject 是一个包含依赖对象的类。<br>CompositeEntityPatternDemo，我们的演示类使用 Client 类来演示组合实体模式的用法。<br><img src="/2017/08/08/设计模式/compositeentity_pattern_uml_diagram.jpg" alt="compositeentity_pattern" title="compositeentity_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建依赖对象。</p>
<p>DependentObject1.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class DependentObject1 &#123;</div><div class="line">	</div><div class="line">   private String data;</div><div class="line"></div><div class="line">   public void setData(String data)&#123;</div><div class="line">      this.data = data; </div><div class="line">   &#125; </div><div class="line"></div><div class="line">   public String getData()&#123;</div><div class="line">      return data;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DependentObject2.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class DependentObject2 &#123;</div><div class="line">	</div><div class="line">   private String data;</div><div class="line"></div><div class="line">   public void setData(String data)&#123;</div><div class="line">      this.data = data; </div><div class="line">   &#125; </div><div class="line"></div><div class="line">   public String getData()&#123;</div><div class="line">      return data;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建粗粒度对象。</p>
<p>CoarseGrainedObject.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class CoarseGrainedObject &#123;</div><div class="line">   DependentObject1 do1 = new DependentObject1();</div><div class="line">   DependentObject2 do2 = new DependentObject2();</div><div class="line"></div><div class="line">   public void setData(String data1, String data2)&#123;</div><div class="line">      do1.setData(data1);</div><div class="line">      do2.setData(data2);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String[] getData()&#123;</div><div class="line">      return new String[] &#123;do1.getData(),do2.getData()&#125;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建组合实体。</p>
<p>CompositeEntity.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class CompositeEntity &#123;</div><div class="line">   private CoarseGrainedObject cgo = new CoarseGrainedObject();</div><div class="line"></div><div class="line">   public void setData(String data1, String data2)&#123;</div><div class="line">      cgo.setData(data1, data2);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String[] getData()&#123;</div><div class="line">      return cgo.getData();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建使用组合实体的客户端类。</p>
<p>Client.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">   private CompositeEntity compositeEntity = new CompositeEntity();</div><div class="line"></div><div class="line">   public void printData()&#123;</div><div class="line">      for (int i = 0; i &lt; compositeEntity.getData().length; i++) &#123;</div><div class="line">         System.out.println(&quot;Data: &quot; + compositeEntity.getData()[i]);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setData(String data1, String data2)&#123;</div><div class="line">      compositeEntity.setData(data1, data2);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>使用 Client 来演示组合实体设计模式的用法。</p>
<p>CompositeEntityPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class CompositeEntityPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">       Client client = new Client();</div><div class="line">       client.setData(&quot;Test&quot;, &quot;Data&quot;);</div><div class="line">       client.printData();</div><div class="line">       client.setData(&quot;Second Test&quot;, &quot;Data1&quot;);</div><div class="line">       client.printData();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Data: Test</div><div class="line">Data: Data</div><div class="line">Data: Second Test</div><div class="line">Data: Data1</div></pre></td></tr></table></figure>
<h2 id="数据访问对象模式"><a href="#数据访问对象模式" class="headerlink" title="数据访问对象模式"></a>数据访问对象模式</h2><p>数据访问对象模式（Data Access Object Pattern）或 DAO 模式用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者。<br><strong>数据访问对象接口（Data Access Object Interface）</strong> - 该接口定义了在一个模型对象上要执行的标准操作。<br><strong>数据访问对象实体类（Data Access Object concrete class）</strong> - 该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。<br><strong>模型对象/数值对象（Model Object/Value Object）</strong> - 该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据。<br><strong>实现 </strong><br>我们将创建一个作为模型对象或数值对象的 Student 对象。StudentDao 是数据访问对象接口。StudentDaoImpl 是实现了数据访问对象接口的实体类。DaoPatternDemo，我们的演示类使用 StudentDao 来演示数据访问对象模式的用法。<br><img src="/2017/08/08/设计模式/dao_pattern_uml_diagram.jpg" alt="dao_pattern" title="dao_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建数值对象。</p>
<p>Student.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class Student &#123;</div><div class="line">   private String name;</div><div class="line">   private int rollNo;</div><div class="line"></div><div class="line">   Student(String name, int rollNo)&#123;</div><div class="line">      this.name = name;</div><div class="line">      this.rollNo = rollNo;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getName() &#123;</div><div class="line">      return name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setName(String name) &#123;</div><div class="line">      this.name = name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public int getRollNo() &#123;</div><div class="line">      return rollNo;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setRollNo(int rollNo) &#123;</div><div class="line">      this.rollNo = rollNo;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建数据访问对象接口。</p>
<p>StudentDao.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public interface StudentDao &#123;</div><div class="line">   public List&lt;Student&gt; getAllStudents();</div><div class="line">   public Student getStudent(int rollNo);</div><div class="line">   public void updateStudent(Student student);</div><div class="line">   public void deleteStudent(Student student);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实现了上述接口的实体类。</p>
<p>StudentDaoImpl.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class StudentDaoImpl implements StudentDao &#123;</div><div class="line">	</div><div class="line">   //列表是当作一个数据库</div><div class="line">   List&lt;Student&gt; students;</div><div class="line"></div><div class="line">   public StudentDaoImpl()&#123;</div><div class="line">      students = new ArrayList&lt;Student&gt;();</div><div class="line">      Student student1 = new Student(&quot;Robert&quot;,0);</div><div class="line">      Student student2 = new Student(&quot;John&quot;,1);</div><div class="line">      students.add(student1);</div><div class="line">      students.add(student2);		</div><div class="line">   &#125;</div><div class="line">   @Override</div><div class="line">   public void deleteStudent(Student student) &#123;</div><div class="line">      students.remove(student.getRollNo());</div><div class="line">      System.out.println(&quot;Student: Roll No &quot; + student.getRollNo() </div><div class="line">         +&quot;, deleted from database&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //从数据库中检索学生名单</div><div class="line">   @Override</div><div class="line">   public List&lt;Student&gt; getAllStudents() &#123;</div><div class="line">      return students;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public Student getStudent(int rollNo) &#123;</div><div class="line">      return students.get(rollNo);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void updateStudent(Student student) &#123;</div><div class="line">      students.get(student.getRollNo()).setName(student.getName());</div><div class="line">      System.out.println(&quot;Student: Roll No &quot; + student.getRollNo() </div><div class="line">         +&quot;, updated in the database&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 StudentDao 来演示数据访问对象模式的用法。</p>
<p>CompositeEntityPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class DaoPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      StudentDao studentDao = new StudentDaoImpl();</div><div class="line"></div><div class="line">      //输出所有的学生</div><div class="line">      for (Student student : studentDao.getAllStudents()) &#123;</div><div class="line">         System.out.println(&quot;Student: [RollNo : &quot;</div><div class="line">            +student.getRollNo()+&quot;, Name : &quot;+student.getName()+&quot; ]&quot;);</div><div class="line">      &#125;</div><div class="line"></div><div class="line"></div><div class="line">      //更新学生</div><div class="line">      Student student =studentDao.getAllStudents().get(0);</div><div class="line">      student.setName(&quot;Michael&quot;);</div><div class="line">      studentDao.updateStudent(student);</div><div class="line"></div><div class="line">      //获取学生</div><div class="line">      studentDao.getStudent(0);</div><div class="line">      System.out.println(&quot;Student: [RollNo : &quot;</div><div class="line">         +student.getRollNo()+&quot;, Name : &quot;+student.getName()+&quot; ]&quot;);		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Student: [RollNo : 0, Name : Robert ]</div><div class="line">Student: [RollNo : 1, Name : John ]</div><div class="line">Student: Roll No 0, updated in the database</div><div class="line">Student: [RollNo : 0, Name : Michael ]</div></pre></td></tr></table></figure>
<h2 id="前端控制器模式"><a href="#前端控制器模式" class="headerlink" title="前端控制器模式"></a>前端控制器模式</h2><p>前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。<br><strong>前端控制器（Front Controller）</strong> - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。<br><strong>调度器（Dispatcher）</strong> - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。<br><strong>视图（View）</strong> - 视图是为请求而创建的对象。<br><strong>实现 </strong><br>我们将创建 FrontController、Dispatcher 分别当作前端控制器和调度器。HomeView 和 StudentView 表示各种为前端控制器接收到的请求而创建的视图。<br>FrontControllerPatternDemo，我们的演示类使用 FrontController 来演示前端控制器设计模式。<br><img src="/2017/08/08/设计模式/frontcontroller_pattern_uml_diagram.jpg" alt="frontcontroller_pattern" title="frontcontroller_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建视图。</p>
<p>HomeView.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class HomeView &#123;</div><div class="line">   public void show()&#123;</div><div class="line">      System.out.println(&quot;Displaying Home Page&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>StudentView.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class StudentView &#123;</div><div class="line">   public void show()&#123;</div><div class="line">      System.out.println(&quot;Displaying Student Page&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建调度器 Dispatcher。</p>
<p>Dispatcher.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Dispatcher &#123;</div><div class="line">   private StudentView studentView;</div><div class="line">   private HomeView homeView;</div><div class="line">   public Dispatcher()&#123;</div><div class="line">      studentView = new StudentView();</div><div class="line">      homeView = new HomeView();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void dispatch(String request)&#123;</div><div class="line">      if(request.equalsIgnoreCase(&quot;STUDENT&quot;))&#123;</div><div class="line">         studentView.show();</div><div class="line">      &#125;else&#123;</div><div class="line">         homeView.show();</div><div class="line">      &#125;	</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建前端控制器 FrontController。</p>
<p>Context.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class FrontController &#123;</div><div class="line">	</div><div class="line">   private Dispatcher dispatcher;</div><div class="line"></div><div class="line">   public FrontController()&#123;</div><div class="line">      dispatcher = new Dispatcher();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private boolean isAuthenticUser()&#123;</div><div class="line">      System.out.println(&quot;User is authenticated successfully.&quot;);</div><div class="line">      return true;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private void trackRequest(String request)&#123;</div><div class="line">      System.out.println(&quot;Page requested: &quot; + request);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void dispatchRequest(String request)&#123;</div><div class="line">      //记录每一个请求</div><div class="line">      trackRequest(request);</div><div class="line">      //对用户进行身份验证</div><div class="line">      if(isAuthenticUser())&#123;</div><div class="line">         dispatcher.dispatch(request);</div><div class="line">      &#125;	</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 FrontController 来演示前端控制器设计模式。</p>
<p>FrontControllerPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class FrontControllerPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      FrontController frontController = new FrontController();</div><div class="line">      frontController.dispatchRequest(&quot;HOME&quot;);</div><div class="line">      frontController.dispatchRequest(&quot;STUDENT&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Page requested: HOME</div><div class="line">User is authenticated successfully.</div><div class="line">Displaying Home Page</div><div class="line">Page requested: STUDENT</div><div class="line">User is authenticated successfully.</div><div class="line">Displaying Student Page</div></pre></td></tr></table></figure>
<h2 id="拦截过滤器模式"><a href="#拦截过滤器模式" class="headerlink" title="拦截过滤器模式"></a>拦截过滤器模式</h2><p>拦截过滤器模式（Intercepting Filter Pattern）用于对应用程序的请求或响应做一些预处理/后处理。定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上。过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。<br><strong>过滤器（Filter）</strong> - 过滤器在请求处理程序执行请求之前或之后，执行某些任务。<br><strong>过滤器链（Filter Chain）</strong> - 过滤器链带有多个过滤器，并在 Target 上按照定义的顺序执行这些过滤器。<br><strong>Target </strong>- Target 对象是请求处理程序。<br><strong>过滤管理器（Filter Manager）</strong> - 过滤管理器管理过滤器和过滤器链。<br><strong>客户端（Client）</strong> - Client 是向 Target 对象发送请求的对象。<br><strong>实现</strong><br>我们将创建 FilterChain、FilterManager、Target、Client 作为表示实体的各种对象。AuthenticationFilter 和 DebugFilter 表示实体过滤器。<br>InterceptingFilterDemo，我们的演示类使用 Client 来演示拦截过滤器设计模式。<br><img src="/2017/08/08/设计模式/interceptingfilter_pattern_uml_diagram.jpg" alt="interceptingfilter_pattern" title="interceptingfilter_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建过滤器接口 Filter。</p>
<p>Filter.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Filter &#123;</div><div class="line">   public void execute(String request);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实体过滤器。</p>
<p>AuthenticationFilter.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class AuthenticationFilter implements Filter &#123;</div><div class="line">   public void execute(String request)&#123;</div><div class="line">      System.out.println(&quot;Authenticating request: &quot; + request);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DebugFilter.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class DebugFilter implements Filter &#123;</div><div class="line">   public void execute(String request)&#123;</div><div class="line">      System.out.println(&quot;request log: &quot; + request);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建 Target。</p>
<p>Target.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class Target &#123;</div><div class="line">   public void execute(String request)&#123;</div><div class="line">      System.out.println(&quot;Executing request: &quot; + request);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建过滤器链。</p>
<p>FilterChain.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class FilterChain &#123;</div><div class="line">   private List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;();</div><div class="line">   private Target target;</div><div class="line"></div><div class="line">   public void addFilter(Filter filter)&#123;</div><div class="line">      filters.add(filter);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void execute(String request)&#123;</div><div class="line">      for (Filter filter : filters) &#123;</div><div class="line">         filter.execute(request);</div><div class="line">      &#125;</div><div class="line">      target.execute(request);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setTarget(Target target)&#123;</div><div class="line">      this.target = target;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>创建过滤管理器。</p>
<p>FilterManager.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class FilterManager &#123;</div><div class="line">   FilterChain filterChain;</div><div class="line"></div><div class="line">   public FilterManager(Target target)&#123;</div><div class="line">      filterChain = new FilterChain();</div><div class="line">      filterChain.setTarget(target);</div><div class="line">   &#125;</div><div class="line">   public void setFilter(Filter filter)&#123;</div><div class="line">      filterChain.addFilter(filter);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void filterRequest(String request)&#123;</div><div class="line">      filterChain.execute(request);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>创建客户端 Client。</p>
<p>Client.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">   FilterManager filterManager;</div><div class="line"></div><div class="line">   public void setFilterManager(FilterManager filterManager)&#123;</div><div class="line">      this.filterManager = filterManager;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void sendRequest(String request)&#123;</div><div class="line">      filterManager.filterRequest(request);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 7</strong></p>
<p>使用 Client 来演示拦截过滤器设计模式。</p>
<p>FrontControllerPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class InterceptingFilterDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      FilterManager filterManager = new FilterManager(new Target());</div><div class="line">      filterManager.setFilter(new AuthenticationFilter());</div><div class="line">      filterManager.setFilter(new DebugFilter());</div><div class="line"></div><div class="line">      Client client = new Client();</div><div class="line">      client.setFilterManager(filterManager);</div><div class="line">      client.sendRequest(&quot;HOME&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 8</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Authenticating request: HOME</div><div class="line">request log: HOME</div><div class="line">Executing request: HOME</div></pre></td></tr></table></figure>
<h2 id="服务定位器模式"><a href="#服务定位器模式" class="headerlink" title="服务定位器模式"></a>服务定位器模式</h2><p>服务定位器模式（Service Locator Pattern）用在我们想使用 JNDI 查询定位各种服务的时候。考虑到为某个服务查找 JNDI 的代价很高，服务定位器模式充分利用了缓存技术。在首次请求某个服务时，服务定位器在 JNDI 中查找服务，并缓存该服务对象。当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能。以下是这种设计模式的实体。<br><strong>服务（Service）</strong> - 实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到。<br><strong>Context / 初始的 Context</strong> - JNDI Context 带有对要查找的服务的引用。<br><strong>服务定位器（Service Locator）</strong> - 服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触。<br><strong>缓存（Cache）</strong> - 缓存存储服务的引用，以便复用它们。<br><strong>客户端（Client）</strong> - Client 是通过 ServiceLocator 调用服务的对象。<br><strong>实现</strong><br>我们将创建 ServiceLocator、InitialContext、Cache、Service 作为表示实体的各种对象。Service1 和 Service2 表示实体服务。<br>ServiceLocatorPatternDemo，我们的演示类在这里是作为一个客户端，将使用 ServiceLocator 来演示服务定位器设计模式。<br><img src="/2017/08/08/设计模式/servicelocator_pattern_uml_diagram.jpg" alt="servicelocator_pattern" title="servicelocator_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建服务接口 Service。</p>
<p>Service.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface Service &#123;</div><div class="line">   public String getName();</div><div class="line">   public void execute();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实体服务。</p>
<p>Service1.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Service1 implements Service &#123;</div><div class="line">   public void execute()&#123;</div><div class="line">      System.out.println(&quot;Executing Service1&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String getName() &#123;</div><div class="line">      return &quot;Service1&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Service2.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Service2 implements Service &#123;</div><div class="line">   public void execute()&#123;</div><div class="line">      System.out.println(&quot;Executing Service2&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String getName() &#123;</div><div class="line">      return &quot;Service2&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>为 JNDI 查询创建 InitialContext。</p>
<p>InitialContext.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class InitialContext &#123;</div><div class="line">   public Object lookup(String jndiName)&#123;</div><div class="line">      if(jndiName.equalsIgnoreCase(&quot;SERVICE1&quot;))&#123;</div><div class="line">         System.out.println(&quot;Looking up and creating a new Service1 object&quot;);</div><div class="line">         return new Service1();</div><div class="line">      &#125;else if (jndiName.equalsIgnoreCase(&quot;SERVICE2&quot;))&#123;</div><div class="line">         System.out.println(&quot;Looking up and creating a new Service2 object&quot;);</div><div class="line">         return new Service2();</div><div class="line">      &#125;</div><div class="line">      return null;		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建缓存 Cache。</p>
<p>Cache.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class Cache &#123;</div><div class="line"></div><div class="line">   private List&lt;Service&gt; services;</div><div class="line"></div><div class="line">   public Cache()&#123;</div><div class="line">      services = new ArrayList&lt;Service&gt;();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public Service getService(String serviceName)&#123;</div><div class="line">      for (Service service : services) &#123;</div><div class="line">         if(service.getName().equalsIgnoreCase(serviceName))&#123;</div><div class="line">            System.out.println(&quot;Returning cached  &quot;+serviceName+&quot; object&quot;);</div><div class="line">            return service;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void addService(Service newService)&#123;</div><div class="line">      boolean exists = false;</div><div class="line">      for (Service service : services) &#123;</div><div class="line">         if(service.getName().equalsIgnoreCase(newService.getName()))&#123;</div><div class="line">            exists = true;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      if(!exists)&#123;</div><div class="line">         services.add(newService);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>创建服务定位器。</p>
<p>ServiceLocator.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class ServiceLocator &#123;</div><div class="line">   private static Cache cache;</div><div class="line"></div><div class="line">   static &#123;</div><div class="line">      cache = new Cache();		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public static Service getService(String jndiName)&#123;</div><div class="line"></div><div class="line">      Service service = cache.getService(jndiName);</div><div class="line"></div><div class="line">      if(service != null)&#123;</div><div class="line">         return service;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      InitialContext context = new InitialContext();</div><div class="line">      Service service1 = (Service)context.lookup(jndiName);</div><div class="line">      cache.addService(service1);</div><div class="line">      return service1;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>使用 ServiceLocator 来演示服务定位器设计模式。</p>
<p>ServiceLocatorPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class ServiceLocatorPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Service service = ServiceLocator.getService(&quot;Service1&quot;);</div><div class="line">      service.execute();</div><div class="line">      service = ServiceLocator.getService(&quot;Service2&quot;);</div><div class="line">      service.execute();</div><div class="line">      service = ServiceLocator.getService(&quot;Service1&quot;);</div><div class="line">      service.execute();</div><div class="line">      service = ServiceLocator.getService(&quot;Service2&quot;);</div><div class="line">      service.execute();		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 7</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Looking up and creating a new Service1 object</div><div class="line">Executing Service1</div><div class="line">Looking up and creating a new Service2 object</div><div class="line">Executing Service2</div><div class="line">Returning cached  Service1 object</div><div class="line">Executing Service1</div><div class="line">Returning cached  Service2 object</div><div class="line">Executing Service2</div></pre></td></tr></table></figure>
<h2 id="传输对象模式"><a href="#传输对象模式" class="headerlink" title="传输对象模式"></a>传输对象模式</h2><p>传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。传输对象也被称为数值对象。传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输。它没有任何的行为。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。<br><strong>业务对象（Business Object）</strong> - 为传输对象填充数据的业务服务。<br><strong>传输对象（Transfer Object）</strong> - 简单的 POJO，只有设置/获取属性的方法。<br><strong>客户端（Client）</strong> - 客户端可以发送请求或者发送传输对象到业务对象。<br><strong>实现</strong><br>我们将创建一个作为业务对象的 StudentBO 和作为传输对象的 StudentVO，它们都代表了我们的实体。<br>TransferObjectPatternDemo，我们的演示类在这里是作为一个客户端，将使用 StudentBO 和 Student 来演示传输对象设计模式。<br><img src="/2017/08/08/设计模式/transferobject_pattern_uml_diagram.jpg" alt="transferobject_pattern" title="transferobject_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建传输对象。</p>
<p>StudentVO.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class StudentVO &#123;</div><div class="line">   private String name;</div><div class="line">   private int rollNo;</div><div class="line"></div><div class="line">   StudentVO(String name, int rollNo)&#123;</div><div class="line">      this.name = name;</div><div class="line">      this.rollNo = rollNo;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getName() &#123;</div><div class="line">      return name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setName(String name) &#123;</div><div class="line">      this.name = name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public int getRollNo() &#123;</div><div class="line">      return rollNo;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setRollNo(int rollNo) &#123;</div><div class="line">      this.rollNo = rollNo;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建业务对象。</p>
<p>StudentBO.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class StudentBO &#123;</div><div class="line">	</div><div class="line">   //列表是当作一个数据库</div><div class="line">   List&lt;StudentVO&gt; students;</div><div class="line"></div><div class="line">   public StudentBO()&#123;</div><div class="line">      students = new ArrayList&lt;StudentVO&gt;();</div><div class="line">      StudentVO student1 = new StudentVO(&quot;Robert&quot;,0);</div><div class="line">      StudentVO student2 = new StudentVO(&quot;John&quot;,1);</div><div class="line">      students.add(student1);</div><div class="line">      students.add(student2);		</div><div class="line">   &#125;</div><div class="line">   public void deleteStudent(StudentVO student) &#123;</div><div class="line">      students.remove(student.getRollNo());</div><div class="line">      System.out.println(&quot;Student: Roll No &quot; </div><div class="line">      + student.getRollNo() +&quot;, deleted from database&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //从数据库中检索学生名单</div><div class="line">   public List&lt;StudentVO&gt; getAllStudents() &#123;</div><div class="line">      return students;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public StudentVO getStudent(int rollNo) &#123;</div><div class="line">      return students.get(rollNo);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void updateStudent(StudentVO student) &#123;</div><div class="line">      students.get(student.getRollNo()).setName(student.getName());</div><div class="line">      System.out.println(&quot;Student: Roll No &quot; </div><div class="line">      + student.getRollNo() +&quot;, updated in the database&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>使用 StudentBO 来演示传输对象设计模式。</p>
<p>TransferObjectPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class TransferObjectPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      StudentBO studentBusinessObject = new StudentBO();</div><div class="line"></div><div class="line">      //输出所有的学生</div><div class="line">      for (StudentVO student : studentBusinessObject.getAllStudents()) &#123;</div><div class="line">         System.out.println(&quot;Student: [RollNo : &quot;</div><div class="line">         +student.getRollNo()+&quot;, Name : &quot;+student.getName()+&quot; ]&quot;);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      //更新学生</div><div class="line">      StudentVO student =studentBusinessObject.getAllStudents().get(0);</div><div class="line">      student.setName(&quot;Michael&quot;);</div><div class="line">      studentBusinessObject.updateStudent(student);</div><div class="line"></div><div class="line">      //获取学生</div><div class="line">      studentBusinessObject.getStudent(0);</div><div class="line">      System.out.println(&quot;Student: [RollNo : &quot;</div><div class="line">      +student.getRollNo()+&quot;, Name : &quot;+student.getName()+&quot; ]&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Student: [RollNo : 0, Name : Robert ]</div><div class="line">Student: [RollNo : 1, Name : John ]</div><div class="line">Student: Roll No 0, updated in the database</div><div class="line">Student: [RollNo : 0, Name : Michael ]</div></pre></td></tr></table></figure>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p>本章列出了设计模式相关的网站、书籍和文章。</p>
<p><strong>设计模式相关的网站</strong></p>
<p><a href="http://en.wikipedia.org/wiki/Design_pattern_(computer_science" target="_blank" rel="external"><font color="#0366d6">Wiki Page for Design Patterns</font></a>) - 以一种非常通用的方式检查设计模式。<br><a href="http://en.wikibooks.org/wiki/Java_Programming/Design_Patterns" target="_blank" rel="external"><font color="#0366d6">Java Programming/Design Patterns</font></a> - 一篇关于设计模式的好文章。<br><a href="http://java.sun.com/docs/books/tutorial/index.html" target="_blank" rel="external"><font color="#0366d6">The JavaTM Tutorials</font></a> - 该 Java 教程是为那些想用 Java 编程语言创建应用程序的编程人员提供的实用指南。<br><a href="http://java.sun.com/j2se/1.4.2/docs/index.html" target="_blank" rel="external"><font color="#0366d6">JavaTM 2 SDK, Standard Edition</font></a> - JavaTM 2 SDK, Standard Edition 的官网。<br><a href="http://exciton.cs.rice.edu/javaresources/DesignPatterns/" target="_blank" rel="external"><font color="#0366d6">Java DesignPatterns</font></a> - 关于设计模式的短文。</p>
<p><strong>Java 设计模式有用的书籍</strong><br>Java Design Patterns<br>Head First Design Patterns<br>Java Design Pattern Essentials<br>Design Patterns: Elements of Reusable Object-Oriented Software<br>Design Patterns in Java(TM)<br>Design Patterns Java Workbook </p>
<p><a href="http://www.runoob.com/design-pattern/design-pattern-tutorial.html" target="_blank" rel="external"><font color="#0366d6">原文地址</font></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017/08/08/设计模式/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;设计模式简介&lt;/strong&gt;&lt;br&gt;设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 &lt;/p&gt;
&lt;p&gt;设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="design patterns" scheme="http://jet-han.oschina.io/categories/design-patterns/"/>
    
    
      <category term="Singleton Pattern" scheme="http://jet-han.oschina.io/tags/Singleton-Pattern/"/>
    
      <category term="Factory Pattern" scheme="http://jet-han.oschina.io/tags/Factory-Pattern/"/>
    
      <category term="Proxy Pattern" scheme="http://jet-han.oschina.io/tags/Proxy-Pattern/"/>
    
      <category term="MVC Pattern" scheme="http://jet-han.oschina.io/tags/MVC-Pattern/"/>
    
      <category term="Intercepting Filter Pattern" scheme="http://jet-han.oschina.io/tags/Intercepting-Filter-Pattern/"/>
    
      <category term="Iterator Pattern" scheme="http://jet-han.oschina.io/tags/Iterator-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>mysql数据库引擎</title>
    <link href="http://jet-han.oschina.io/2017/08/06/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E/"/>
    <id>http://jet-han.oschina.io/2017/08/06/mysql数据库引擎/</id>
    <published>2017-08-06T06:16:24.000Z</published>
    <updated>2018-11-30T09:42:01.577Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/mysql.jpg" alt="mysql" title="mysql"></p>
<h2 id="数据库引擎"><a href="#数据库引擎" class="headerlink" title="数据库引擎"></a>数据库引擎</h2><p>　　数据库引擎是用于存储、处理和保护数据的核心服务。利用数据库引擎可控制访问权限并快速处理事务，从而满足企业内大多数需要处理大量数据的应用程序的要求。 使用数据库引擎创建用于联机事务处理或联机分析处理数据的关系数据库。这包括创建用于存储数据的表和用于查看、管理和保护数据安全的数据库对象（如索引、视图和存储过程）。</p>
<h2 id="数据库引擎任务"><a href="#数据库引擎任务" class="headerlink" title="数据库引擎任务"></a>数据库引擎任务</h2><p>在数据库引擎文档中，各主题的顺序遵循用于实现使用数据库引擎进行数据存储的系统的任务的主要顺序。</p>
<p>设计并创建数据库以保存系统所需的关系或XML文档<br>实现系统以访问和更改数据库中存储的数据。包括实现网站或使用数据的应用程序，还包括生成使用SQL Server工具和实用工具以使用数据的过程。<br>为单位或客户部署实现的系统<br>提供日常管理支持以优化数据库的性能<br><a id="more"></a></p>
<h2 id="MySQL数据库引擎类别"><a href="#MySQL数据库引擎类别" class="headerlink" title="MySQL数据库引擎类别"></a>MySQL数据库引擎类别</h2><p>　　你能用的数据库引擎取决于mysql在安装的时候是如何被编译的。要添加一个新的引擎，就必须重新编译MYSQL。在缺省情况下，MYSQL支持三个引擎：ISAM、MYISAM和HEAP。另外两种类型INNODB和BERKLEY（BDB），也常常可以使用。</p>
<h3 id="ISAM"><a href="#ISAM" class="headerlink" title="ISAM"></a>ISAM</h3><p>　　ISAM是一个定义明确且历经时间考验的数据表格管理方法，它在设计之时就考虑到数据库被查询的次数要远大于更新的次数。因此，ISAM执行读取操作的速度很快，而且不占用大量的内存和存储资源。ISAM的两个主要不足之处在于，它不支持事务处理，也不能够容错：如果你的硬盘崩溃了，那么数据文件就无法恢复了。如果你正在把ISAM用在关键任务应用程序里，那就必须经常备份你所有的实时数据，通过其复制特性，MYSQL能够支持这样的备份应用程序。</p>
<h3 id="MYISAM"><a href="#MYISAM" class="headerlink" title="MYISAM"></a>MYISAM</h3><p>　　MYISAM是MYSQL的ISAM扩展格式和缺省的数据库引擎。除了提供ISAM里所没有的索引和字段管理的功能，MYISAM还使用一种表格锁定的机制，来优化多个并发的读写操作。其代价是你需要经常运行OPTIMIZE TABLE命令，来恢复被更新机制所浪费的空间。MYISAM还有一些有用的扩展，例如用来修复数据库文件的MYISAMCHK工具和用来恢复浪费空间的MYISAMPACK工具。<br>　　MYISAM强调了快速读取操作，这可能就是为什么MYSQL受到了WEB开发如此青睐的主要原因：在WEB开发中你所进行的大量数据操作都是读取操作。所以，大多数虚拟主机提供商和INTERNET平台提供商只允许使用MYISAM格式。</p>
<h3 id="HEAP"><a href="#HEAP" class="headerlink" title="HEAP"></a>HEAP</h3><p>　　HEAP允许只驻留在内存里的临时表格。驻留在内存里让HEAP要比ISAM和MYISAM都快，但是它所管理的数据是不稳定的，而且如果在关机之前没有进行保存，那么所有的数据都会丢失。在数据行被删除的时候，HEAP也不会浪费大量的空间。HEAP表格在你需要使用SELECT表达式来选择和操控数据的时候非常有用。要记住，在用完表格之后就删除表格。</p>
<h3 id="INNODB和BERKLEYDB"><a href="#INNODB和BERKLEYDB" class="headerlink" title="INNODB和BERKLEYDB"></a>INNODB和BERKLEYDB</h3><p>　　INNODB和BERKLEYDB（BDB）数据库引擎都是造就MYSQL灵活性的技术的直接产品，这项技术就是MYSQL++ API。在使用MYSQL的时候，你所面对的每一个挑战几乎都源于ISAM和MYISAM数据库引擎不支持事务处理也不支持外来键。尽管要比ISAM和MYISAM引擎慢很多，但是INNODB和BDB包括了对事务处理和外来键的支持，这两点都是前两个引擎所没有的。如前所述，如果你的设计需要这些特性中的一者或者两者，那你就要被迫使用后两个引擎中的一个了。</p>
<h2 id="mysql数据引擎更换方式"><a href="#mysql数据引擎更换方式" class="headerlink" title="mysql数据引擎更换方式"></a>mysql数据引擎更换方式</h2><h3 id="查看当前数据库支持的引擎和默认的数据库引擎"><a href="#查看当前数据库支持的引擎和默认的数据库引擎" class="headerlink" title="查看当前数据库支持的引擎和默认的数据库引擎"></a>查看当前数据库支持的引擎和默认的数据库引擎</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show engines;</div></pre></td></tr></table></figure>
<p>我的查询结果如下：</p>
<p><img src="/2017/08/06/mysql数据库引擎/mysql_engines.png" alt="mysql" title="mysql"></p>
<h3 id="更改数据库引擎"><a href="#更改数据库引擎" class="headerlink" title="更改数据库引擎"></a>更改数据库引擎</h3><h4 id="更改方式1：修改配置文件my-ini"><a href="#更改方式1：修改配置文件my-ini" class="headerlink" title="更改方式1：修改配置文件my.ini"></a>更改方式1：修改配置文件my.ini</h4><p>修改<code>my.ini</code>，在<code>[mysqld]</code>后面添加<code>default-storage-engine=InnoDB</code>，重启服务，数据库默认的引擎修改为<code>InnoDB</code></p>
<h4 id="更改方式2-在建表的时候指定"><a href="#更改方式2-在建表的时候指定" class="headerlink" title="更改方式2:在建表的时候指定"></a>更改方式2:在建表的时候指定</h4><p> 建表时指定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">create table mytbl(   </div><div class="line">    id int primary key,   </div><div class="line">    name varchar(50)   </div><div class="line">)type=MyISAM;</div></pre></td></tr></table></figure>
<h4 id="更改方式3：建表后更改"><a href="#更改方式3：建表后更改" class="headerlink" title="更改方式3：建表后更改"></a>更改方式3：建表后更改</h4><p>　　<code>alter table mytbl2 type = InnoDB;</code></p>
<h3 id="查看修改结果"><a href="#查看修改结果" class="headerlink" title="查看修改结果"></a>查看修改结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#方式1：</div><div class="line">show table status from mytest; </div><div class="line">#方式2：</div><div class="line">show create table table_name</div></pre></td></tr></table></figure>
<h2 id="MyIASM-和-Innodb引擎详解"><a href="#MyIASM-和-Innodb引擎详解" class="headerlink" title="MyIASM 和 Innodb引擎详解"></a>MyIASM 和 Innodb引擎详解</h2><h3 id="Innodb引擎"><a href="#Innodb引擎" class="headerlink" title="Innodb引擎"></a>Innodb引擎</h3><p>　　Innodb引擎提供了对数据库<strong>ACID事务的支持</strong>，并且实现了SQL标准的四种隔离级别，关于数据库事务与其隔离级别的内容请见<a href="http://jet-han.oschina.io/2017/08/04/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/">数据库事务与其隔离级别</a>。该引擎还提供了<strong>行级锁和外键约束</strong>，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持<code>FULLTEXT</code>类型的索引，而且它没有保存表的行数，当<code>SELECT COUNT(*) FROM TABLE</code>时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用<code>Innodb</code>引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。</p>
<h4 id="内存结构和特性"><a href="#内存结构和特性" class="headerlink" title="内存结构和特性"></a>内存结构和特性</h4><p>　　MySQL区别于其他数据库的最为重要的特点就是其插件式的表存储引擎。而在众多存储引擎中，InnoDB是最为常用的存储引擎。从MySQL5.5.8版本开始，InnoDB存储引擎是默认的存储引擎。<br>　　InnoDB存储引擎支持事务，其设计目标主要面向在线事务处理(OLTP)的应用。其特点是行锁设计、支持外键，并支持非锁定读，即默认读操作不会产生锁。<br>　　InnoDB通过使用多版本并发控制(MVCC)来获取高并发性，并且实现了SQL标准的4中隔离级别，默认为REPEATABLE级别。同时，使用一种被称为next-key-locking的策略来避免幻读现象的产生。除此之外，InnoDB存储引擎还提供了插入缓冲(insert buffer)、二次写(double write)、自适应哈希索引(adaptive hash index)、预读(read ahead)等高性能和高可用的功能。</p>
<p><img src="/2017/08/06/mysql数据库引擎/innodb1.png" alt="mysql" title="mysql"></p>
<p>上图详细显示了InnoDB存储引擎的体系架构，从图中可见，InnoDB存储引擎由内存池，后台线程和磁盘文件三大部分组成。接下来我们就来简单了解一下内存相关的概念和原理。</p>
<p><strong>缓冲池</strong>  </p>
<p> InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。但是由于CPU速度和磁盘速度之间的鸿沟，基于磁盘的数据库系统通常使用缓冲池记录来提高数据库的的整体性能。<br> 在数据库中进行读取操作，首先将从磁盘中读到的页放在缓冲池中，下次再读相同的页中时，首先判断该页是否在缓冲池中。若在缓冲池中，称该页在缓冲池中被命中，直接读取该页。否则，读取磁盘上的页。<br> 对于数据库中页的修改操作，则首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，而是通过一种称为CheckPoint的机制刷新回磁盘。<br> 所以，缓冲池的大小直接影响着数据库的整体性能，可以通过配置参数innodb_buffer_pool_size来设置。<br> 具体来看，缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲(insert buffer)、自适应哈希索引(adaptive hash index)、InnoDB存储的锁信息(lock info)和数据字典信息(data dictionary)。<br> 在架构图上可以看到，InnoDB存储引擎的内存区域除了有缓冲池之外，还有重做日志缓冲和额外内存池。InnoDB存储引擎首先将重做日志信息先放到这个缓冲区中，然后按照一定频率将其刷新到重做日志文件中。重做日志缓冲一般不需要设置的很大，该值可由配置参数innodb_log_buffer_size控制。   </p>
<p><strong>数据页和索引页</strong>  </p>
<p> Page是Innodb存储的最基本结构，也是Innodb磁盘管理的最小单位，与数据库相关的所有内容都存储在Page结构里。Page分为几种类型，数据页和索引页就是其中最为重要的两种类型。</p>
<p><strong>插入缓冲(Insert Buffer)</strong>  </p>
<p> 我们都知道，在InnoDB引擎上进行插入操作时，一般需要按照主键顺序进行插入，这样才能获得较高的插入性能。当一张表中存在非聚簇的且不唯一的索引时，在插入时，数据页的存放还是按照主键进行顺序存放，但是对于非聚簇索引叶节点的插入不再是顺序的了，这时就需要离散的访问非聚簇索引页，由于随机读取的存在导致插入操作性能下降。<br> InnoDB为此设计了Insert Buffer来进行插入优化。对于非聚簇索引的插入或者更新操作，不是每一次都直接插入到索引页中，而是先判断插入的非聚集索引是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer中。看似数据库这个非聚集的索引已经查到叶节点，而实际没有，这时存放在另外一个位置。然后再以一定的频率和情况进行Insert Buffer和非聚簇索引页子节点的合并操作。这时通常能够将多个插入合并到一个操作中，这样就大大提高了对于非聚簇索引的插入性能。  </p>
<p><strong>两次写(Double Write)</strong>  </p>
<p> 如果说Insert Buffer给InnoDB存储引擎带来了性能上的提升，那么Double Write带给InnoDB存储引擎的是数据页的可靠性。</p>
<p> <img src="/2017/08/06/mysql数据库引擎/innodb2.png" alt="mysql" title="mysql"></p>
<p> 如上图所示，Double Write由两部分组成，一部分是内存中的double write buffer，大小为2MB，另一部分是物理磁盘上共享表空间连续的128个页，大小也为2MB。在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是通过memcpy函数将脏页先复制到内存中的该区域，之后通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免操作系统缓冲写带来的问题。在完成doublewrite页的写入后，再讲doublewirite buffer中的页写入各个表空间文件中。<br> 如果操作系统在将页写入磁盘的过程中发生了崩溃，在恢复过程中，InnoDB存储引擎可以从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件中，再应用重做日志。 </p>
<p><strong>重做日志(Redo Log Buffer)</strong>  </p>
<p> 当缓冲池中的页的版本比磁盘要新时，数据库需要将新版本的页从缓冲池刷新到磁盘。但是如果每次一个页发送变化，就进行刷新，那么性能开发是非常大的，于是InnoDB采用了Write Ahead Log策略，即当事务提交时，先写重做日志，然后再择时将脏页写入磁盘。如果发生宕机导致数据丢失，就通过重做日志进行数据恢复。  </p>
<p> <img src="/2017/08/06/mysql数据库引擎/innodb3.png" alt="mysql" title="mysql"></p>
<p> InnoDB存储引擎会首先将重做日志信息先放入重做日志缓冲中，然后再按照一定频率将其刷新到重做日志文件。重做日志缓冲一般不需要设置得很大，因为一般情况每一秒钟都会讲重做日志缓冲刷新到日志文件中。可通过配置参数innodb_log_buffer_size控制，默认为8MB。<br> 除了每秒刷新机制之外，每次事务提交时重做日志缓冲也会刷新到日志中。InnoDB是事务的存储引擎，其通过Force Log at Commit机制实现事务的持久性，即当事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化，然后事务的提交操作完成才算完成。InnoDB的写入机制大致入下图所示。<br> 为了确保每次日志都写入到重做日志文件，在每次讲重做日志缓冲写入重做日志后，必须调用一次fsync操作，将缓冲文件从文件系统缓存中真正写入磁盘。<br> 可以通过innodb_flush_log_at_trx_commit来控制重做日志刷新到磁盘的策略。该参数默认值为1，表示事务提交必须进行一次fsync操作，还可以设置为0和2。0表示事务提交时不进行写入重做日志操作，该操作只在主线程中完成，2表示提交时写入重做日志，但是只写入文件系统缓存，不进行fsync操作。由此可见，设置为0时，性能最高，但是丧失了事务的一致性。 </p>
<p><strong>自适应哈希索引(Adaptive Hash Index)</strong>  </p>
<p> InnoDB会根据访问的频率和模式，为热点页建立哈希索引，来提高查询效率。InnoDB存储引擎会监控对表上各个索引页的查询，如果观察到建立哈希索引可以带来速度上的提升，则建立哈希索引，所以叫做自适应哈希索引。</p>
<p> 自适应哈希索引是通过缓冲池的B+树页构建而来，因此建立速度很快，而且不需要对整张数据表建立哈希索引。其有一个要求，即对这个页的连续访问模式必须是一样的，也就是说其查询的条件(WHERE)必须完全一样，而且必须是连续的。  </p>
<p><strong>锁信息(lock info)</strong></p>
<p> 我们都知道，InnoDB存储引擎会在行级别上对表数据进行上锁。不过InnoDB也会在数据库内部其他很多地方使用锁，从而允许对多种不同资源提供并发访问。数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。关于锁的具体知识我们之后再进行详细学习。 </p>
<p><strong>数据字典信息(Data Dictionary)</strong></p>
<p> InnoDB有自己的表缓存，可以称为表定义缓存或者数据字典。当InnoDB打开一张表，就增加一个对应的对象到数据字典。<br> 数据字典是对数据库中的数据、库对象、表对象等的元信息的集合。在MySQL中，数据字典信息内容就包括表结构、数据库名或表名、字段的数据类型、视图、索引、表字段信息、存储过程、触发器等内容。MySQL INFORMATION_SCHEMA库提供了对数据局元数据、统计信息、以及有关MySQL server的访问信息（例如：数据库名或表名，字段的数据类型和访问权限等）。该库中保存的信息也可以称为MySQL的数据字典。   </p>
<h4 id="磁盘文件及落盘机制"><a href="#磁盘文件及落盘机制" class="headerlink" title="磁盘文件及落盘机制"></a>磁盘文件及落盘机制</h4><p>任何一个技术都有其底层的关键基础技术，这些关键技术很有可能也是其他技术的关键技术，学习这些底层技术，就可以一通百通，让你很快的掌握其他技术。如何在磁盘上存储数据，如何使用日志文件保证数据不丢失以及如何落盘，不仅是MySQL等数据库的关键技术，也是MQ消息队列或者其他中间件的关键技术之一。</p>
<p> <img src="/2017/08/06/mysql数据库引擎/innodb4.png" alt="mysql" title="mysql"></p>
<p> 上图详细显示了InnoDB存储引擎的体系架构，从图中可见，InnoDB存储引擎由内存池，后台线程和磁盘文件三大部分组成。接下来我们就来简单了解一下磁盘文件相关的概念和原理。<br>    InnoDB的主要的磁盘文件主要分为三大块：一是系统表空间，二是用户表空间，三是redo日志文件和归档文件。二进制文件(binlog)等文件是MySQL Server层维护的文件，所以未列入InnoDB的磁盘文件中。  </p>
<p><strong>系统表空间和用户表空间</strong>  </p>
<p> InnoDB系统表空间包含InnoDB数据字典(元数据以及相关对象)并且doublewrite buffer,change buffer,undo logs的存储区域。系统表空间也默认包含任何用户在系统表空间创建的表数据和索引数据。系统表空间是一个共享的表空间因为它是被多个表共享的<br> 系统表空间是由一个或者多个数据文件组成。默认情况下,1个初始大小为10MB，名为ibdata1的系统数据文件在MySQL的data目录下被创建。用户可以使用innodb_data_file_path对数据文件的大小和数量进行配置。<br> innodb_data_file_path的格式如下：</p>
<pre><code>  innodb_data_file_path=datafile1[,datafile2]...
</code></pre><p> 用户可以通过多个文件组成一个表空间，同时制定文件的属性：</p>
<pre><code>  innodb_data_file_path = /db/ibdata1:1000M;/dr2/db/ibdata2:1000M:autoextend
</code></pre><p> 这里讲/db/ibdata1和/dr2/db/ibdata2两个文件组成系统表空间。如果这两个文件位于不同的磁盘上，磁盘的负载可能被平均，因此可以提高数据库的整体性能。两个文件的文件名之后都跟了属性，表示文件ibdata1的大小为1000MB，文件ibdata2的大小为1000MB，而且用完空间之后可以自动增长(autoextend)。</p>
<p> 设置innodb_data_file_path参数之后，所以基于InnoDB存储引擎的表的数据都会记录到该系统表空间中，如果设置了参数innodb_file_per_table，则用户可以将每个基于InnoDB存储引擎的表产生一个独立的用户表空间。用户表空间的命名规则为：表名.ibd。<br> 通过这种方式，用户不用将所有数据都存放于默认的系统表空间中，但是用户表空只存储该表的数据、索引和插入缓冲BITMAP等信息，其余信息还是存放在默认的表空间中。</p>
<p> <img src="/2017/08/06/mysql数据库引擎/innodb5.png" alt="mysql" title="mysql"></p>
<p> 上图显示InnoDB存储引擎对于文件的存储方式，其中frm文件是表结构定义文件，记录每个表的表结构定义。  </p>
<p><strong>重做日志文件和归档文件</strong>  </p>
<p> 默认情况下，在InnoDB存储引擎的数据目录下会有两个名为ib_logfile0和ib_logfile1的文件，这就是InnoDB的重做日志文件(redo log fiel)，它记录了对于InnoDB存储引擎的事务日志。<br> 当InnoDB的数据存储文件发生错误时，重做日志文件就能派上用场。InnoDB存储引擎可以使用重做日志文件将数据恢复为正确状态，以此来保证数据的正确性和完整性。</p>
<p> 每个InnoDB存储引擎至少有1个重做日志文件组(group)，每个文件组下至少有2个重做日志文件，如默认的ib_logfile0和ib_logfile1。<br> 为了得到更高的可靠性，用户可以设置多个镜像日志组，将不同的文件组放在不同的磁盘上，以此来提高重做日志的高可用性。</p>
<p> 在日志组中每个重做日志文件的大小一致，并以循环写入的方式运行。InnoDB存储引擎先写入重做日志文件1，当文件被写满时，会切换到重做日志文件2，再当重做日志文件2也被写满时，再切换到重做日志文件1。</p>
<p> 用户可以使用innodb_log_file_size来设置重做日志文件的大小，这对InnoDB存储引擎的性能有着非常大的影响。</p>
<p> 如果重做日志文件设置的太大，数据丢失时，恢复时可能需要很长的时间；另一方面，如果设置的太小，重做日志文件太小会导致依据checkpoint的检查需要频繁刷新脏页到磁盘中，导致性能的抖动。<br> 重做日志相关和Checkpoint的机制可以阅读我之前文章的相应章节。MySQL探秘(三):InnoDB的内存结构和特性</p>
<p><strong>重做日志的落盘机制</strong>  </p>
<p> InnoDB对于数据文件和日志文件的刷盘遵守WAL(Write ahead redo log) 和Force-log-at-commit两种规则，二者保证了事务的持久性。WAL要求数据的变更写入到磁盘前，首先必须将内存中的日志写入到磁盘；Force-log-at-commit要求当一个事务提交时，所有产生的日志都必须刷新到磁盘上，如果日志刷新成功后，缓冲池中的数据刷新到磁盘前数据库发生了宕机，那么重启时，数据库可以从日志中恢复数据。</p>
<p>  <img src="/2017/08/06/mysql数据库引擎/innodb6.png" alt="mysql" title="mysql"></p>
<p>如上图所示，InnoDB在缓冲池中变更数据时，会首先将相关变更写入重做日志缓冲中，然后再按时或者当事务提交时写入磁盘，这符合Force-log-at-commit原则；当重做日志写入磁盘后，缓冲池中的变更数据才会依据checkpoint机制择时写入到磁盘中，这符合WAL原则。<br> 在checkpoint择时机制中，就有重做日志文件写满的判断，所以，如前文所述，如果重做日志文件太小，经常被写满，就会频繁导致checkpoint将更改的数据写入磁盘，导致性能抖动。</p>
<p> 操作系统的文件系统是带有缓存的，当InnoDB向磁盘写入数据时，有可能只是写入到了文件系统的缓存中，没有真正的“落袋为安”。<br> InnoDB的innodb_flush_log_at_trx_commit属性可以控制每次事务提交时InnoDB的行为。当属性值为0时，事务提交时，不会对重做日志进行写入操作，而是等待主线程按时写入；当属性值为1时，事务提交时，会将重做日志写入文件系统缓存，并且调用文件系统的fsync，将文件系统缓冲中的数据真正写入磁盘存储，确保不会出现数据丢失；当属性值为2时，事务提交时，也会将日志文件写入文件系统缓存，但是不会调用fsync，而是让文件系统自己去判断何时将缓存写入磁盘。日志的刷盘机制如下图所示。</p>
<p>   <img src="/2017/08/06/mysql数据库引擎/innodb7.png" alt="mysql" title="mysql"></p>
<p> innodb_flush_log_at_commit是InnoDB性能调优的一个基础参数，涉及InnoDB的写入效率和数据安全。当参数值为0时，写入效率最高，但是数据安全最低；参数值为1时，写入效率最低，但是数据安全最高；参数值为2时，二者都是中等水平。一般建议将该属性值设置为1，以获得较高的数据安全性，而且也只有设置为1，才能保证事务的持久性。  </p>
<h4 id="锁的类型和状态查询"><a href="#锁的类型和状态查询" class="headerlink" title="锁的类型和状态查询"></a>锁的类型和状态查询</h4><p>锁是数据库系统区分于文件系统的一个关键特性。数据库使用锁来支持对共享资源进行并发访问，提供数据的完整性和一致性。此外，数据库事务的隔离性也是通过锁实现的。InnoDB在此方面一直优于其他数据库引擎。InnoDB会在行级别上对表数据上锁，而MyISAM只能在表级别上锁，二者性能差异可想而知。</p>
<p>InnoDB存储引擎中的锁<br> InnoDB存储引擎实现了如下两种标准的行级锁：</p>
<p>共享锁(S Lock)，允许事务读取一行</p>
<p>排他锁(X Lock)，允许事务删除或更新一行数据</p>
<p>  如果一个事务T1已经获取了行r的共享锁，那么另外一个事务T2可以立刻获得行r的共享锁，因为读取并不会改变数据，可以进行并发的读取操作；但若其他的事务T3想要获取行r的排他锁，则必须等待事务T1和T2释放行r上的共享锁之后才能继续，因为获取排他锁一般是为了改变数据，所以不能同时进行读取或则其他写入操作。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">X</th>
<th style="text-align:center">S</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">不兼容</td>
<td style="text-align:center">不兼容</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">不兼容</td>
<td style="text-align:center">兼容</td>
</tr>
</tbody>
</table>
</div>
<p> InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种称为意向锁的锁方式。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。</p>
<p> InnoDB存储引擎的意向锁即为表级别的锁。设计目的主要是为了在一个事务中揭示下一行将被请求的锁类型。其支持两种意向锁：</p>
<ul>
<li>意向共享锁(IS Lock)，事务想要获得一张表中某几行的共享锁</li>
<li>意向排他锁(IX Lock)，事务想要获得一张表中某几行的排他锁</li>
</ul>
<p>需要注意的是意向锁是表级别的锁，它不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。故表级别的意向锁和表级别的锁的兼容性如下表所示。  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">IS</th>
<th style="text-align:center">IX</th>
<th style="text-align:center">S</th>
<th>X</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IS</td>
<td style="text-align:center">兼容</td>
<td style="text-align:center">兼容</td>
<td style="text-align:center">兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td style="text-align:center">IX</td>
<td style="text-align:center">兼容</td>
<td style="text-align:center">兼容</td>
<td style="text-align:center">不兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">兼容</td>
<td style="text-align:center">不兼容</td>
<td style="text-align:center">兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">不兼容</td>
<td style="text-align:center">不兼容</td>
<td style="text-align:center">不兼容</td>
<td>不兼容</td>
</tr>
</tbody>
</table>
</div>
<p> 向一个表添加表级X锁的时候(执行ALTER TABLE, DROP TABLE, LOCK TABLES等操作)，如果没有意向锁的话，则需要遍历所有整个表判断是否有行锁的存在，以免发生冲突。如果有了意向锁，只需要判断该意向锁与即将添加的表级锁是否兼容即可。因为意向锁的存在代表了，有行级锁的存在或者即将有行级锁的存在，因而无需遍历整个表，即可获取结果。</p>
<p> <img src="/2017/08/06/mysql数据库引擎/innodb8.png" alt="mysql" title="mysql"></p>
<p> 如果将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象进行上锁，那么首先需要对粗粒度的对象上锁。如上图所示，如果需要对表1的记录m行上X锁，那么需要先对表1加意向IX锁，然后对记录m上X锁。如果其中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成。</p>
<p>InnoDB锁相关状态查询<br> 用户可以使用INFOMATION_SCHEMA库下的INNODB_TRX、INNODB_LOCKS和INNODB_LOCK_WAITS表来监控当前事务并分析可能出现的锁问题。INNODB_TRX的定义如下表所示，其由8个字段组成。</p>
<ul>
<li>trx_id：InnoDB存储引擎内部唯一的事务ID</li>
<li>trx_state：当前事务的状态</li>
<li>trx_started：事务的开始时间</li>
<li>trx_request_lock_id：等待事务的锁ID。如果trx_state的状态为LOCK WAIT,那么该字段代表当前事务等待之前事务占用的锁资源ID</li>
<li>trx_wait_started：事务等待的时间</li>
<li>trx_weight：事务的权重，反映了一个事务修改和锁住的行数，当发生死锁需要回滚时，会选择该数值最小的进行回滚</li>
<li>trx_mysql_thread_id：线程ID，SHOW PROCESSLIST 显示的结果</li>
<li>trx_query：事务运行的SQL语句</li>
</ul>
<pre><code>mysql&gt; SELECT * FROM information_schema.INNODB_TRX\G;    
************** 1.row ***********************     
trx_id:  7311F4  
trx_state: LOCK WAIT  
trx_started: 2010-01-04 10:49:33  
trx_requested_lock_id: 7311F4:96:3:2  
trx_wait_started: 2010-01-04 10:49:33  
trx_weight: 2  
trx_mysql_thread_id: 471719  
trx_query: select * from parent lock in share mode    
</code></pre><p> INNODB_TRX表只能显示当前运行的InnoDB事务，并不能直接判断锁的一些情况。如果需要查看锁，则还需要访问表INNODB_LOCKS，该表的字段组成如下表所示。</p>
<ul>
<li>lock_id：锁的ID</li>
<li>lock_trx_id：事务的ID</li>
<li>lock_mode：锁的模式</li>
<li>lock_type：锁的类型，表锁还是行锁</li>
<li>lock_table：要加锁的表</li>
<li>lock_index：锁住的索引</li>
<li>lock_space：锁住的space id</li>
<li>lock_page：事务锁定页的数量，若是表锁，则该值为NULL</li>
<li>lock_rec：事务锁定行的数量，如果是表锁，则该值为NULL</li>
<li>lock_data：</li>
</ul>
<pre><code>  mysql&gt; SELECT * FROM information_schema.INNODB_LOCKS\G;
  ***************** 1.row ***********************
  lock_id: 7311F4:96:3:2
  lock_trx_id: 7311F4
  lock_mode: S
  lock_type: RECORD
  lock_type: &#39;mytest&#39;.&#39;parent&#39;
  lock_index: &#39;PRIMARY&#39;
  lock_space: 96
  lock_page: 3
  lock_rec: 2
  lock_data: 1
</code></pre><p> 通过表INNODB_LOCKS查看每张表上锁的情况后，用户就可以来判断由此引发的等待情况。当时当事务量非常大，其中锁和等待也时常发生，这个时候就不那么容易判断。但是通过表INNODB_LOCK_WAITS，可以很直观的反应当前事务的等待。表INNODB_LOCK_WAITS由四个字段组成，如下表所示。</p>
<ul>
<li>requesting_trx_id：申请锁资源的事务ID</li>
<li>requesting_lock_id：申请的锁的ID</li>
<li>blocking_trx_id：阻塞的事务ID</li>
<li>blocking_lock_id：阻塞的锁的ID</li>
</ul>
<pre><code>  mysql&gt; SELECT * FROM information_schema.INNODB_LOCK_WAITS\G;
  ******************1.row**************************
  requesting_trx_id: 7311F4
  requesting_lock_id: 7311F4:96:3:2
  blocking_trx_id: 730FEE
  blocking_lock_id: 730FEE:96:3:2

通过上述的SQL语句，用户可以清楚直观地看到哪个事务阻塞了另一个事务，然后使用上述的事务ID和锁ID，去INNODB_TRX和INNDOB_LOCKS表中查看更加详细的信息。
</code></pre><h4 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h4><p>一致性非锁定读(consistent nonlocking read)是指InnoDB存储引擎通过多版本控制(MVVC)读取当前数据库中行数据的方式。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB会去读取行的一个快照。</p>
<p><img src="/2017/08/06/mysql数据库引擎/innodb9.png" alt="mysql" title="mysql"></p>
<p>上图直观地展现了InnoDB一致性非锁定读的机制。之所以称其为非锁定读，是因为不需要等待行上排他锁的释放。快照数据是指该行的之前版本的数据，每行记录可能有多个版本，一般称这种技术为行多版本技术。</p>
<pre><code>由此带来的并发控制，称之为多版本并发控制(Multi Version Concurrency Control, MVVC)。InnoDB是通过undo log来实现MVVC。undo log本身用来在事务中回滚数据，因此快照数据本身是没有额外开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。
</code></pre><p> 一致性非锁定读是InnoDB默认的读取方式，即读取不会占用和等待行上的锁。但是并不是在每个事务隔离级别下都是采用此种方式。此外，即使都是使用一致性非锁定读，但是对于快照数据的定义也各不相同。</p>
<p> 在事务隔离级别READ COMMITTED和REPEATABLE READ下，InnoDB使用一致性非锁定读。然而，对于快照数据的定义却不同。在READ COMMITTED事务隔离级别下，一致性非锁定读总是读取被锁定行的最新一份快照数据。而在REPEATABLE READ事务隔离级别下，则读取事务开始时的行数据版本。</p>
<p> 我们下面举个例子来详细说明一下上述的情况。</p>
<h1 id="session-A"><a href="#session-A" class="headerlink" title="session A"></a>session A</h1><pre><code>mysql&gt; BEGIN;
mysql&gt; SELECT * FROM test WHERE id = 1;
</code></pre><p> 我们首先在会话A中显示地开启一个事务，然后读取test表中的id为1的数据，但是事务并没有结束。于此同时，用户在开启另一个会话B，这样可以模拟并发的操作，然后对会话B做出如下的操作：</p>
<h1 id="session-B"><a href="#session-B" class="headerlink" title="session B"></a>session B</h1><pre><code>mysql&gt; BEGIN;
mysql&gt; UPDATE test SET id = 3 WHERE id = 1;
</code></pre><p> 在会话B的事务中，将test表中id为1的记录修改为id=3，但是事务同样也没有提交，这样id=1的行其实加了一个排他锁。由于InnoDB在READ COMMITTED和REPEATABLE READ事务隔离级别下使用一致性非锁定读，这时如果会话A再次读取id为1的记录，仍然能够读取到相同的数据。此时，READ COMMITTED和REPEATABLE READ事务隔离级别没有任何区别。</p>
<p><img src="/2017/08/06/mysql数据库引擎/innodb10.png" alt="mysql" title="mysql"></p>
<p> 如上图所示，当会话B提交事务后，会话A再次运行SELECT * FROM test WHERE id = 1的SQL语句时，两个事务隔离级别下得到的结果就不一样了。<br> 对于READ COMMITTED的事务隔离级别，它总是读取行的最新版本，如果行被锁定了，则读取该行版本的最新一个快照。因为会话B的事务已经提交，所以在该隔离级别下上述SQL语句的结果集是空的。<br> 对于REPEATABLE READ的事务隔离级别，总是读取事务开始时的行数据，因此，在该隔离级别下，上述SQL语句仍然会获得相同的数据。</p>
<p><strong>MVVC</strong></p>
<p> 我们首先来看一下wiki上对MVVC的定义：</p>
<pre><code>  Multiversion concurrency control (MCC or MVCC), is a concurrency control
  method commonly used by database management systems to provide
  concurrent access to the database and in programming languages to
  implement transactional memory.
</code></pre><p> 由定义可知，MVVC是用于数据库提供并发访问控制的并发控制技术。<br>数据库的并发控制机制有很多，最为常见的就是锁机制。锁机制一般会给竞争资源加锁，阻塞读或者写操作来解决事务之间的竞争条件，最终保证事务的可串行化。</p>
<pre><code>而MVVC则引入了另外一种并发控制，它让读写操作互不阻塞，每一个写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适的结果直接返回，由此解决了事务的竞争条件。
</code></pre><p> 考虑一个现实场景。管理者要查询所有用户的存款总额，假设除了用户A和用户B之外，其他用户的存款总额都为0，A、B用户各有存款1000，所以所有用户的存款总额为2000。但是在查询过程中，用户A会向用户B进行转账操作。转账操作和查询总额操作的时序图如下图所示。</p>
<p><img src="/2017/08/06/mysql数据库引擎/innodb11.png" alt="mysql" title="mysql"></p>
<p> 如果没有任何的并发控制机制，查询总额事务先读取了用户A的账户存款，然后转账事务改变了用户A和用户B的账户存款，最后查询总额事务继续读取了转账后的用户B的账号存款，导致最终统计的存款总额多了100元，发生错误。</p>
<p> 使用锁机制可以解决上述的问题。查询总额事务会对读取的行加锁，等到操作结束后再释放所有行上的锁。因为用户A的存款被锁，导致转账操作被阻塞，直到查询总额事务提交并将所有锁都释放。</p>
<p><img src="/2017/08/06/mysql数据库引擎/innodb12.png" alt="mysql" title="mysql"></p>
<p> 但是这时可能会引入新的问题，当转账操作是从用户B向用户A进行转账时会导致死锁。转账事务会先锁住用户B的数据，等待用户A数据上的锁，但是查询总额的事务却先锁住了用户A数据，等待用户B的数据上的锁。<br>    使用MVVC机制也可以解决这个问题。查询总额事务先读取了用户A的账户存款，然后转账事务会修改用户A和用户B账户存款，查询总额事务读取用户B存款时不会读取转账事务修改后的数据，而是读取本事务开始时的数据副本(在REPEATABLE READ隔离等级下)。</p>
<p><img src="/2017/08/06/mysql数据库引擎/innodb13.png" alt="mysql" title="mysql"></p>
<p> MVCC使得数据库读不会对数据加锁，普通的SELECT请求不会加锁，提高了数据库的并发处理能力。借助MVCC，数据库可以实现READ COMMITTED，REPEATABLE READ等隔离级别，用户可以查看当前数据的前一个或者前几个历史版本，保证了ACID中的I特性（隔离性)</p>
<p><strong>InnoDB的MVVC实现</strong></p>
<p> 多版本并发控制仅仅是一种技术概念，并没有统一的实现标准， 其的核心理念就是数据快照，不同的事务访问不同版本的数据快照，从而实现不同的事务隔离级别。虽然字面上是说具有多个版本的数据快照，但这并不意味着数据库必须拷贝数据，保存多份数据文件，这样会浪费大量的存储空间。InnoDB通过事务的undo日志巧妙地实现了多版本的数据快照。<br> 数据库的事务有时需要进行回滚操作，这时就需要对之前的操作进行undo。因此，在对数据进行修改时，InnoDB会产生undo log。当事务需要进行回滚时，InnoDB可以利用这些undo log将数据回滚到修改之前的样子。<br> 根据行为的不同 undo log 分为两种 insert undo log和update undo log。<br> insert undo log 是在 insert 操作中产生的 undo log。因为 insert 操作的记录只对事务本身可见，对于其它事务此记录是不可见的，所以 insert undo log 可以在事务提交后直接删除而不需要进行 purge 操作。<br> update undo log 是 update 或 delete 操作中产生的 undo log，因为会对已经存在的记录产生影响，为了提供 MVCC机制，因此 update undo log 不能在事务提交时就进行删除，而是将事务提交时放到入 history list 上，等待 purge 线程进行最后的删除操作。<br> 为了保证事务并发操作时，在写各自的undo log时不产生冲突，InnoDB采用回滚段的方式来维护undo log的并发写入和持久化。回滚段实际上是一种 Undo 文件组织方式。<br> InnoDB行记录有三个隐藏字段：分别对应该行的rowid、事务号db_trx_id和回滚指针db_roll_ptr，其中db_trx_id表示最近修改的事务的id，db_roll_ptr指向回滚段中的undo log。如下图所示。</p>
<p> <img src="/2017/08/06/mysql数据库引擎/innodb14.png" alt="mysql" title="mysql"></p>
<p> 当事务2使用UPDATE语句修改该行数据时，会首先使用排他锁锁定改行，将该行当前的值复制到undo log中，然后再真正地修改当前行的值，最后填写事务ID，使用回滚指针指向undo log中修改前的行。如下图所示。</p>
<p><img src="/2017/08/06/mysql数据库引擎/innodb15.png" alt="mysql" title="mysql"></p>
<p> 当事务3进行修改与事务2的处理过程类似，如下图所示。</p>
<p><img src="/2017/08/06/mysql数据库引擎/innodb16.png" alt="mysql" title="mysql"></p>
<p> REPEATABLE READ隔离级别下事务开始后使用MVVC机制进行读取时，会将当时活动的事务id记录下来，记录到Read View中。READ COMMITTED隔离级别下则是每次读取时都创建一个新的Read View。<br> Read View是InnoDB中用于判断记录可见性的数据结构，记录了一些用于判断可见性的属性。</p>
<p>low_limit_id：某行记录的db_trx_id &lt; 该值，则该行对于当前Read View是一定可见的</p>
<p>up_limit_id：某行记录的db_trx_id &gt;= 该值，则该行对于当前read view是一定不可见的</p>
<p>low_limit_no：用于purge操作的判断</p>
<p>rw_trx_ids：读写事务数组</p>
<p> Read View创建后，事务再次进行读操作时比较记录的db_trx_id和Read View中的low_limit_id，up_limit_id和读写事务数组来判断可见性。</p>
<p> 如果该行中的db_trx_id等于当前事务id，说明是事务内部发生的更改，直接返回该行数据。否则的话，如果db_trx_id小于up_limit_id，说明是事务开始前的修改，则该记录对当前Read View是可见的，直接返回该行数据。</p>
<p> 如果db_trx_id大于或者等于low_limit_id，则该记录对于该Read View一定是不可见的。如果db_trx_id位于[up_limit_id, low_limit_id)范围内，需要在活跃读写事务数组(rw_trx_ids)中查找db_trx_id是否存在，如果存在，记录对于当前Read View是不可见的。<br> 如果记录对于Read View不可见，需要通过记录的DB_ROLL_PTR指针遍历undo log，构造对当前Read View可见版本数据。<br> 简单来说，Read View记录读开始时及其之后，所有的活动事务，这些事务所做的修改对于Read View是不可见的。除此之外，所有其他的小于创建Read View的事务号的所有记录均可见。</p>
<p><strong>ACID</strong></p>
<p><strong>A  事务的原子性(Atomicity)：</strong>指一个事务要么全部执行,要么不执行.也就是说一个事务不可能只执行了一半就停止了.比如你从取款机取钱,这个事务可以分成两个步骤:1划卡,2出钱.不可能划了卡,而钱却没出来.这两步必须同时完成.要么就不完成.<br><strong>C 事务的一致性(Consistency)：</strong>指事务的运行并不改变数据库中数据的一致性.例如,完整性约束了a+b=10,一个事务改变了a,那么b也应该随之改变.<br><strong>I 独立性(Isolation）:</strong>事务的独立性也有称作隔离性,是指两个以上的事务不会出现交错执行的状态.因为这样可能会导致数据不一致.<br><strong>D 持久性(Durability）:</strong>事务的持久性是指事务执行成功以后,该事务所对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚.</p>
<h3 id="MyIASM引擎"><a href="#MyIASM引擎" class="headerlink" title="MyIASM引擎"></a>MyIASM引擎</h3><p>　　MyIASM是MySQL默认的引擎，但是它<font color="#e07878">没有提供对数据库事务的支持，也不支持行级锁和外键</font>，因此当<code>INSERT</code>(插入)或<code>UPDATE</code>(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyIASM中存储了表的行数，于是<code>SELECT COUNT(*) FROM TABLE</code>时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。</p>
<h3 id="两种引擎的选择"><a href="#两种引擎的选择" class="headerlink" title="两种引擎的选择"></a>两种引擎的选择</h3><p>　　大尺寸的数据集趋向于选择InnoDB引擎，因为它<font color="#e07878">支持事务处理和故障恢复,支持行级锁和外键</font>。数据库的大小决定了故障恢复的时间长短，InnoDB可以利用事务日志进行数据恢复，这会比较快。主键查询在InnoDB引擎下也会相当快，不过需要注意的是如果主键太长也会导致性能问题，关于这个问题我会在下文中讲到。大批的<code>INSERT</code>语句(在每个<code>INSERT</code>语句中写入多行，批量插入)在MyISAM下会快一些，但是<code>UPDATE</code>语句在InnoDB下则会更快一些，尤其是在并发量大的时候。</p>
<h3 id="Index——索引"><a href="#Index——索引" class="headerlink" title="Index——索引"></a>Index——索引</h3><p>　　索引（Index）是帮助MySQL高效获取数据的数据结构。MyIASM和Innodb都使用了树这种数据结构做为索引。下面我接着讲这两种引擎使用的索引结构，讲到这里，首先应该谈一下B-Tree和B+Tree。</p>
<h4 id="MyIASM引擎的索引结构"><a href="#MyIASM引擎的索引结构" class="headerlink" title="MyIASM引擎的索引结构"></a>MyIASM引擎的索引结构</h4><p>　　MyISAM引擎的索引结构为<code>B+Tree</code>，其中<code>B+Tree</code>的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，只不过是用索引指向了实际的数据，这种索引就是所谓的<strong>非聚集索引</strong>。如下图所示：</p>
<p><img src="/2017/08/06/mysql数据库引擎/MyIasm1.png" alt="mysql" title="mysql"></p>
<p>　　这里设表一共有三列，假设我们以Col1为主键，则上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p>
<p><img src="/2017/08/06/mysql数据库引擎/MyIasm2.png" alt="mysql" title="mysql"></p>
<p>　　同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<h4 id="Innodb引擎的索引结构"><a href="#Innodb引擎的索引结构" class="headerlink" title="Innodb引擎的索引结构"></a>Innodb引擎的索引结构</h4><p>　　与MyISAM引擎的索引结构同样也是<code>B+Tree</code>，但是Innodb的索引文件本身就是数据文件，即<code>B+Tree</code>的数据域存储的就是实际的数据，这种索引就是聚集索引。这个索引的key就是数据表的主键，因此<code>InnoDB</code>表数据文件本身就是主索引。</p>
<p>　　并且和MyISAM不同，InnoDB的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。所以Innodb不建议使用过长的主键，否则会使辅助索引变得过大。建议使用自增的字段作为主键，这样B+Tree的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。</p>
<h3 id="两者区别："><a href="#两者区别：" class="headerlink" title="两者区别："></a>两者区别：</h3><p>　　第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p><img src="/2017/08/06/mysql数据库引擎/Innodb1.png" alt="mysql" title="mysql"></p>
<p>　　上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<p>　　第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：</p>
<p><img src="/2017/08/06/mysql数据库引擎/Innodb2.png" alt="mysql" title="mysql"></p>
<p>　　这里以英文字符的<code>ASCII</code>码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
<p>　　了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调(可能是指“非递增”的意思)的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗<code>B+Tree</code>，非单调(可能是指“非递增”的意思)的主键会造成在插入新记录时数据文件为了维持<code>B+Tree</code>的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>
<p><strong>MyISAM适合：</strong></p>
<p>(1)做很多count 的计算；<br>(2)读多写少，插入不频繁，查询非常频繁；<br>(3)没有事务。 </p>
<p><strong>InnoDB适合：</strong> </p>
<p>(1)可靠性要求比较高，或者要求事务；<br>(2)表更新和查询都相当的频繁，并且表锁定的机会比较大的情况指定数据引擎的创建；<br>(3)支持行级锁，外键。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/mysql.jpg&quot; alt=&quot;mysql&quot; title=&quot;mysql&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;数据库引擎&quot;&gt;&lt;a href=&quot;#数据库引擎&quot; class=&quot;headerlink&quot; title=&quot;数据库引擎&quot;&gt;&lt;/a&gt;数据库引擎&lt;/h2&gt;&lt;p&gt;　　数据库引擎是用于存储、处理和保护数据的核心服务。利用数据库引擎可控制访问权限并快速处理事务，从而满足企业内大多数需要处理大量数据的应用程序的要求。 使用数据库引擎创建用于联机事务处理或联机分析处理数据的关系数据库。这包括创建用于存储数据的表和用于查看、管理和保护数据安全的数据库对象（如索引、视图和存储过程）。&lt;/p&gt;
&lt;h2 id=&quot;数据库引擎任务&quot;&gt;&lt;a href=&quot;#数据库引擎任务&quot; class=&quot;headerlink&quot; title=&quot;数据库引擎任务&quot;&gt;&lt;/a&gt;数据库引擎任务&lt;/h2&gt;&lt;p&gt;在数据库引擎文档中，各主题的顺序遵循用于实现使用数据库引擎进行数据存储的系统的任务的主要顺序。&lt;/p&gt;
&lt;p&gt;设计并创建数据库以保存系统所需的关系或XML文档&lt;br&gt;实现系统以访问和更改数据库中存储的数据。包括实现网站或使用数据的应用程序，还包括生成使用SQL Server工具和实用工具以使用数据的过程。&lt;br&gt;为单位或客户部署实现的系统&lt;br&gt;提供日常管理支持以优化数据库的性能&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://jet-han.oschina.io/categories/mysql/"/>
    
    
      <category term="mysql,MyIsam,Innodb" scheme="http://jet-han.oschina.io/tags/mysql-MyIsam-Innodb/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之线程池ThreadPoolExecutor</title>
    <link href="http://jet-han.oschina.io/2017/08/06/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor/"/>
    <id>http://jet-han.oschina.io/2017/08/06/并发编程之线程池ThreadPoolExecutor/</id>
    <published>2017-08-06T05:32:02.000Z</published>
    <updated>2018-11-13T08:03:50.281Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/08/06/并发编程之线程池ThreadPoolExecutor/java.jpg" alt="java" title="java"></p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>当前越来越多的系统使用多线程来处理任务，但是为每一个任务创建线程并不是合理的方案，原因有2点：一是创建线程的开销很大，一个任务一个线程的方式会有性能上的损失；二是可能导致线程数量的膨胀，不但不易于线程的管理，还可能导致内存被消耗完，导致out of memory（OOM）,从而使系统崩溃。为了解决这个问题，线程池应运而生。线程池有两个作用：一个是限制线程的数量，不会导致线程的膨胀；二是线程复用，线程执行完一个人任务之后，可以接着执行下一个任务，减少了创建线程的开销。 </p>
<p>java中一个运用非常普遍的线程池是ThreadPoolExecutor。下面来探究下ThreadPoolExecutor的功能和实现原理。<br><a id="more"></a><br><strong>ThreadPoolExecutor的功能</strong></p>
<ol>
<li>自定义线程池的核心线程数和最大线程数。如果当前池中的线程数小于核心线程数，则直接为任务创建新线程来执行，如果前池中的线程数大于核心线程数，则把任务放入任务队列中，等待线程池中已有的线程去执行。如果任务队列满了，但是池中的线程数小于最大线程数，则创建新线程执行任务。如果任务队列满了，池中的线程数等于最大线程数，那么执行拒绝任务策略。</li>
<li>可配置拒绝任务策略，ThreadPoolExecutor自带了四种拒绝策略：丢弃当前将要加入队列的任务本身（DiscardPolicy），丢弃任务队列中最旧任务（DiscardOldestPolicy），抛出异常的方式（AbortPolicy），将任务交由调用者线程去执行（CallerRunsPolicy），除了自带的策略之外，用户还可以自定义策略。</li>
<li>线程声明周期管理。如果线程空闲时间超过了配置的时间keepAliveTime，则线程将被销毁。</li>
<li>配置线程工厂，用户可以自定义创建线程的工厂。</li>
<li>配置阻塞队列类型。</li>
<li>线程池生命周期管理。可以强制shutdown线程池，也可以优雅shutdown线程池。</li>
</ol>
<p>为了实现上面的配置管理。ThreadPoolExecutor提供了不同的创建线程池的构造方法，用户可以根据自身实际情况选择。</p>
<p><strong>ThreadPoolExecutor实现原理</strong></p>
<p> ThreadPoolExecutor的属性</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性名</th>
<th>属性说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>volatile int runState</td>
<td><strong>runState</strong>主要提供了生命周期的控制，下面是主要的状态：<br><strong>RUNNING：0。</strong>接收新任务以及处理队列中的任务<br><strong>SHUTDOWN：1。</strong>不再接收新任务，但是处理队列中的任务<br><strong>STOP：2。</strong>不再接收新任务，也不处理队列中的任务，同时中断正在执行的任务<br><strong>TERMINATED：3。</strong>跟STOP相同，同时所有的线程都终止了。</td>
</tr>
<tr>
<td>BlockingQueue<runnable> workQueue</runnable></td>
<td>任务队列</td>
</tr>
<tr>
<td>ReentrantLock mainLock</td>
<td>为poolSize, corePoolSize,maximumPoolSize, runState, and workers属性的set提供同步。</td>
</tr>
<tr>
<td>HashSet<worker> workers</worker></td>
<td>保存线程池中所有的工作线程，只有获得mainLock锁才能访问</td>
</tr>
<tr>
<td>volatile long  keepAliveTime</td>
<td>空闲线程的最大存活时间</td>
</tr>
<tr>
<td>volatile boolean allowCoreThreadTimeOut</td>
<td>核心线程是否也支持最大存活时间管理</td>
</tr>
<tr>
<td>volatile int corePoolSize</td>
<td>线程池核心线程数</td>
</tr>
<tr>
<td>volatile int   maximumPoolSize</td>
<td>线程池最大线程数</td>
</tr>
<tr>
<td>volatile int   poolSize</td>
<td>线程池当前线程数</td>
</tr>
<tr>
<td>int largestPoolSize</td>
<td>线程池峰值线程数</td>
</tr>
<tr>
<td>long completedTaskCount</td>
<td>线程池总共处理的任务数</td>
</tr>
<tr>
<td>volatile RejectedExecutionHandler handler</td>
<td>任务拒绝策略</td>
</tr>
<tr>
<td>volatile ThreadFactory threadFactory</td>
<td>创建线程工厂</td>
</tr>
</tbody>
</table>
</div>
<p>ThreadPoolExecutor的属性，基本上大部分都是构造函数中可配置的，也说明了ThreadPoolExecutor的灵活性。不过通过上面的表大家可能会有点疑惑：怎么没有保存Thread对象集合的属性？不要急，大家应该发现了里面有个HashSet<worker> workers属性。这个集合里Worker对象是ThreadPoolExecutor定义的一个内部类，它包含了thread对象。现在我们来看下Worker对象包含的属性。</worker></p>
<p><strong>Worker对象的属性</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性名称</th>
<th>属性说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>inal ReentrantLock runLock</td>
<td>这个锁的作用是保护取消worker线程的中断，而不是中断正在执行的任务。</td>
</tr>
<tr>
<td>Runnable firstTask</td>
<td>由于线程池创建现在的时候都是为某个任务创建，所以该属性就是记录该刚线程创建时执行的任务</td>
</tr>
<tr>
<td>long completedTasks</td>
<td>这个线程执行的任务数</td>
</tr>
<tr>
<td>Thread thread</td>
<td>本worker运行的线程</td>
</tr>
<tr>
<td>volatile boolean hasRun</td>
<td>本worker对象运行的线程是否执行过该worker的run方法。只有hasRun为true时worker的线程才能被中断。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>ThreadPoolExecutor的任务处理流程</strong></p>
<p>前面介绍了ThreadPoolExecutor的属性以及需要用到的内部类，素材有了，那么下面来看看是如何来把素材加工成成品的吧。在用户创建完线程池之后，需要把任务提交给线程池，线程池提供了submit和execute方法来提交任务，而submit方法最终还是调用的execute方法，它只是把任务封装成futuretask，以便获得任务的返回值。对于没有返回值的任务直接用execute提交就可以了，如果有返回值的任务，用submit提交更好。所以提交任务的核心还是execute方法。现在就来看看execute的实现代码：</p>
<pre><code>1.public void execute(Runnable command) {  
2.        if (command == null)  
3.            throw new NullPointerException();  
4.        if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) {  
5.            if (runState == RUNNING &amp;&amp; workQueue.offer(command)) {  
6.                if (runState != RUNNING || poolSize == 0)  
7.                    ensureQueuedTaskHandled(command);  
8.            }  
9.            else if (!addIfUnderMaximumPoolSize(command))  
10.                reject(command); // is shutdown or saturated  
11.        }  
12.    }  
</code></pre><p>这段代码的主要逻辑如下：</p>
<p>1.如果当选线程数大于等于核心线程数，则直接把任务放到任务队列里，等待已有的线程去执行它。如果当前选线程数小于核心线程数，则为该任务创建新的线程去执行它，这个的功能的实现方法是<code>addIfUnderCorePoolSize(command)</code>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private boolean addIfUnderCorePoolSize(Runnable firstTask) &#123;  </div><div class="line">   Thread t = null;  </div><div class="line">   final ReentrantLock mainLock = this.mainLock;  </div><div class="line">   mainLock.lock();  </div><div class="line">   try &#123;  </div><div class="line">      if (poolSize &lt; corePoolSize &amp;&amp; runState == RUNNING)  </div><div class="line">      t = addThread(firstTask);  </div><div class="line">   &#125; finally &#123;  </div><div class="line">   mainLock.unlock();  </div><div class="line">   &#125;  </div><div class="line">   return t != null;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现，这段源码是如果发现小于corePoolSize就会调用addThread()方法创建一个新的线程，并且调用线程的start()方法将线程运行起来。只有没有创建成功Thread才会返回false，也就是当当前的poolSize &gt; corePoolSize的时候，或线程池已经不是在running状态的时候才会出现。execute对poolSize和corePoolSize的比较只是粗略判断，而addIfUnderCorePoolSize（）内部是加锁后判定的，以得到更为准确的结果，而外部初步判定如果是大于了，就没有必要进入这段有锁的代码了。<br> 2.如果addIfUnderCorePoolSize返回false，说明没有为任务创建线程（原因可能是线程池不是RUNNING状态，或者poolsize大于corepoolsize了）。则需要把任务存放到任务队列中。<br> 3.在任务放到队列之前，先初步判断下此时线程池的状态。如果是running才接受新任务，否则addIfUnderMaximumPoolSize方法精确线程池状态。<br> 4.如果任务可以添加到任务队列，则判调用队列的offer方法，往队列末尾加入任务。由于队列是一个自定义的阻塞队列，可以是有界也可以是无界的。如果加入队列成功，还有先判断下runState != RUNNING || poolSize == 0。前面判断了状态之后为什么还要判断呢？这是因为有时间差，状态随时可以发生改变。记住了这一点在看这样一堆状态判断就不会难以理解了。好了，如果线程池不是RUNNING状态或线程池里没有线程了，则执行<code>ensureQueuedTaskHandled</code>方法处理任务如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">private void ensureQueuedTaskHandled(Runnable command) &#123;  </div><div class="line">        final ReentrantLock mainLock = this.mainLock;  </div><div class="line">        mainLock.lock();  </div><div class="line">        boolean reject = false;  </div><div class="line">        Thread t = null;  </div><div class="line">        try &#123;  </div><div class="line">            int state = runState;  </div><div class="line">            if (state != RUNNING &amp;&amp; workQueue.remove(command))  </div><div class="line">                reject = true;  </div><div class="line">            else if (state &lt; STOP &amp;&amp;  </div><div class="line">                     poolSize &lt; Math.max(corePoolSize, 1) &amp;&amp;  </div><div class="line">                     !workQueue.isEmpty())  </div><div class="line">                t = addThread(null);  </div><div class="line">        &#125; finally &#123;  </div><div class="line">            mainLock.unlock();  </div><div class="line">        &#125;  </div><div class="line">        if (reject)  </div><div class="line">            reject(command);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码是处理拒绝任务的。这里也会加锁来锁定当前的状态和工作队列。如果状态确实不等于running，则把任务从任务列表中移除并执行拒绝策略。如果任务remove失败，并且当前状态为running和shutdown状态，任务队列不为空，并且poolSize小于Math.max(corePoolSize, 1)。则调用addThread为线程池创建一个新线程。但是这个任务并没有直接给新线程执行。为什么要判断poolSize小于Math.max(corePoolSize, 1)，因为corePoolSize可以设置为0.当corePoolSize=0时，需要至少有1个线程去执行任务。前面的几个方法中出现了几次创建addThread的方法，现在来看看这个方法做了哪些事情：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">private Thread addThread(Runnable firstTask) &#123;  </div><div class="line">        Worker w = new Worker(firstTask);  </div><div class="line">        Thread t = threadFactory.newThread(w);  </div><div class="line">        boolean workerStarted = false;  </div><div class="line">        if (t != null) &#123;  </div><div class="line">            if (t.isAlive()) // precheck that t is startable  </div><div class="line">                throw new IllegalThreadStateException();  </div><div class="line">            w.thread = t;  </div><div class="line">            workers.add(w);  </div><div class="line">            int nt = ++poolSize;  </div><div class="line">            if (nt &gt; largestPoolSize)  </div><div class="line">                largestPoolSize = nt;  </div><div class="line">            try &#123;  </div><div class="line">                t.start();  </div><div class="line">                workerStarted = true;  </div><div class="line">            &#125;  </div><div class="line">            finally &#123;  </div><div class="line">                if (!workerStarted)  </div><div class="line">                    workers.remove(w);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        return t;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法的参数名firstTask可能比较难理解。这里详细说明一下：首先在线程池中，一个新线程的创建大多数情况都是为执行某个任务而创建的，这个任务不会加入任务队列，而是通过firstTask传给为他而建的新线程去执行。所以这个任务也就是这个线程执行的第一个任务。如果firstTask设为null，那么线程将去执行任务队列中的任务。下面来分析这个方法的功能，首先先创建一个worker对象，把firstTask初始化这个worker对象。然后通过线程工厂创建一个线程，并检查这个线程的状态，同时跟新线程池的峰值线程数的值。需要注意的是，这个线程不是属于某个具体任务的，而是属于这个worker的，即该线程不是执行某个任务的run，而是执行这个worker的run。最后把worker对象添加到worker队列里面。所以发到这里可以明白了ThreadPoolExecutor为什么没有thread的集合属性了。<br>5.第4点阐述了任务加入队列成功的情况，但是如果队列满了加入队列也可能失败。这时候会去尝试创建新线程来执行该任务。即执行addIfUnderMaximumPoolSize方法。这个方法与addIfUnderCorePoolSize基本一致，只是后者是拿poolSize跟corePoolSize比较，而前者是拿poolSize跟maximumPoolSize比较。如果addIfUnderMaximumPoolSize方法为任务创建线程失败，则执行拒绝策略来处理这个任务。<br>到目前为止，前面讲的5个步骤将了一个任务提交给线程池之后是如何处理的。但是细心的用户可能发现，里面缺失了非常重要的一个功能：任务被添加到任务队列之后是如何被线程池处理掉的？线程处理完它的首个任务之后是如何获取新任务的呢？线程池是不是有类似Timer一样的守护进程不断扫描线程队列和等待队列？还是利用某种锁机制，实现类似wait和notify实现的？ 别急。下面来揭开它的神秘面纱。<br>前面提到了ThreadPoolExecutor的内部类Worker，也在介绍addThread方法的时候提到了线程池的线程是和Worker对象绑定在一起的。所以现在来看看Worker类做了什么事情？通过代码发现Worker的定义也是一个Runnable。addthread方法中调用了这个Worker的start()方法，也就是线程的启动方法，其实也就是调用了Worker的run()方法。现在来看看worker的run方法做了什么事情：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public void run() &#123;  </div><div class="line">            try &#123;  </div><div class="line">                hasRun = true;  </div><div class="line">                Runnable task = firstTask;  </div><div class="line">                firstTask = null;  </div><div class="line">                while (task != null || (task = getTask()) != null) &#123;  </div><div class="line">                   runTask(task);  </div><div class="line">                   task = null;  </div><div class="line">               &#125;  </div><div class="line">            &#125; finally &#123;  </div><div class="line">                workerDone(this);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>woker的run方法主要是通过while循环不断调用getTask()方法去获取任务。然后执行runTask(task)方法来执行任务，最后调用workerDone()方法来执行一些清除操作。</p>
<p> runTask(task)其实做的事情很简单：它的核心就是调用任务的run方法来执行真正的用户任务，除此之外还执行了任务执行前后需要的一些操作，以及统计一下这个worker完成的任务数。这个方法不需要深究，代码也比较简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">private void runTask(Runnable task) &#123;  </div><div class="line">            final ReentrantLock runLock = this.runLock;  </div><div class="line">            runLock.lock();  </div><div class="line">            try &#123;  </div><div class="line">                if ((runState &gt;= STOP ||  </div><div class="line">                    (Thread.interrupted() &amp;&amp; runState &gt;= STOP)) &amp;&amp;  </div><div class="line">                    hasRun)  </div><div class="line">                    thread.interrupt();  </div><div class="line">                boolean ran = false;  </div><div class="line">                beforeExecute(thread, task);  </div><div class="line">                try &#123;  </div><div class="line">                    task.run();  </div><div class="line">                    ran = true;  </div><div class="line">                    afterExecute(task, null);  </div><div class="line">                    ++completedTasks;  </div><div class="line">                &#125; catch (RuntimeException ex) &#123;  </div><div class="line">                    if (!ran)  </div><div class="line">                        afterExecute(task, ex);  </div><div class="line">                    throw ex;  </div><div class="line">                &#125;  </div><div class="line">            &#125; finally &#123;  </div><div class="line">                runLock.unlock();  </div><div class="line">            &#125;  </div><div class="line"> &#125; </div><div class="line">``` </div><div class="line"> </div><div class="line"> worker的润方法真正的核心是如果不断获取任务的。所以这里必须认真解读下getTask()方法，下面是getTask()的代码：</div><div class="line"> </div><div class="line"> </div><div class="line">``` </div><div class="line">Runnable getTask() &#123;  </div><div class="line">        for (;;) &#123;  </div><div class="line">            try &#123;  </div><div class="line">                int state = runState;  </div><div class="line">                if (state &gt; SHUTDOWN)  </div><div class="line">                    return null;  </div><div class="line">                Runnable r;  </div><div class="line">                if (state == SHUTDOWN)  // Help drain queue  </div><div class="line">                    r = workQueue.poll();  </div><div class="line">                else if (poolSize &gt; corePoolSize || allowCoreThreadTimeOut)  </div><div class="line">                    r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);  </div><div class="line">                else  </div><div class="line">                    r = workQueue.take();  </div><div class="line">                if (r != null)  </div><div class="line">                    return r;  </div><div class="line">                if (workerCanExit()) &#123;  </div><div class="line">                    if (runState &gt;= SHUTDOWN) // Wake up others  </div><div class="line">                        interruptIdleWorkers();  </div><div class="line">                    return null;  </div><div class="line">                &#125;  </div><div class="line">                // Else retry  </div><div class="line">            &#125; catch (InterruptedException ie) &#123;  </div><div class="line">                // On interruption, re-check runState  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>你会发现getTask()方法是从workQueue队列中，也就是等待队列中获取一个任务出来并返回！如果没有获得任务，则通过 interruptIdleWorkers()方法去关闭空闲时间超过阈值的空闲线程。</p>
<p>至此，完整的ThreadPoolExecutor线程池处理任务的原理就解读完毕了。其他的一些诸如关闭线程池和获取线程池的状态和统计信息等的接口都比较简单，这里就不一一解释了。</p>
<h2 id="常见线程池"><a href="#常见线程池" class="headerlink" title="常见线程池"></a>常见线程池</h2><p><strong>1. newSingleThreadExecutor。</strong><br>只有一个线程的线程池，即corePoolSize和maximumPoolSize都等于1。<br><strong>2. newCachedThreadPool</strong><br>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。在newCachedThreadPool构造参数中，corePoolSize=0，maximumPoolSize=Integer.MAX_VALUE，即可与无限制的创建线程。但是它使用的是阻塞队列是SynchronousQueue。这个队列比较奇葩，虽然他是无界的，但是里面只能有一个元素。在添加一个任务的时候，必须要有一个线程正在等待一个任务。即通过这个阻塞队列，既可以保证任务能够马上得到线程去运行，同时又能重用已有的空闲线程。<br><strong>3. newFixedThreadPool</strong><br>线程数固定的线程池，即corePoolSize=maximumPoolSize。当线程数达到了corePoolSize时，不能创建新的线程了，所以新的任务只能放到任务队列中，因此这个线程池用的阻塞队列是无界队列LinkedBlockingQueue。<br><strong>4. ScheduledThreadPoolExecutor</strong><br>可以执行延迟固定时间的任务，也可以执行定时任务的线程池。ScheduledThreadPoolExecutor的底层不是基于ThreadPoolExecutor实现的，它有一个自己的实现类。</p>
<p>其实我们的要求很简单，希望线程池能跟连接池一样，能设置最小线程数、最大线程数，当最小数&lt;任务&lt;最大数时，应该分配新的线程处理；当任务&gt;最大数时，应该等待有空闲线程再处理该任务。<br>但线程池的设计思路是，任务应该放到Queue中，当Queue放不下时再考虑用新线程处理，如果Queue满且无法派生新线程，就拒绝该任务。设计导致“先放等执行”、“放不下再执行”、“拒绝不等待”。所以，根据不同的Queue参数，要提高吞吐量不能一味地增大maximumPoolSize。<br>当然，要达到我们的目标，必须对线程池进行一定的封装，幸运的是ThreadPoolExecutor中留了足够的自定义接口以帮助我们达到目标。我们封装的方式是：  </p>
<ol>
<li>以SynchronousQueue作为参数，使maximumPoolSize发挥作用，以防止线程被无限制的分配，同时可以通过提高maximumPoolSize来提高系统吞吐量  </li>
<li>自定义一个RejectedExecutionHandler，当线程数超过maximumPoolSize时进行处理，处理方式为隔一段时间检查线程池是否可以执行新Task，如果可以把拒绝的Task重新放入到线程池，检查的时间依赖keepAliveTime的大小。</li>
</ol>
<h2 id="线程池的两个核心队列"><a href="#线程池的两个核心队列" class="headerlink" title="线程池的两个核心队列"></a>线程池的两个核心队列</h2><ul>
<li>线程等待池，即线程队列BlockingQueue。 </li>
<li>任务处理池（PoolWorker），即正在工作的Thread列表（HashSet）。<br>线程池的核心参数： </li>
<li>核心池大小（corePoolSize），即固定大小，设定好之后，线程池的稳定峰值，达到这个值之后池的线程数大小不会释放。 </li>
<li>最大处理线程池数（maximumPoolSize），当线程池里面的线程数超过corePoolSize，小于maximumPoolSize时会动态创建与回收线程池里面的线程池资源。</li>
</ul>
<p>线程池的运行机制：</p>
<p>举个例子。假如有一个工厂，工厂里面有10个人，每个工人同时只能做一件事情。因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；当10个工人都有任务时，如果还来任务，就把任务进行排队等待。<br>如果说新任务数目增长的速度远远大于工作做任务的速度，那么此时工厂的主管可能就需要采取补救措施了，比如重新招4个工人进来；然后就将任务分配给这4个刚招进来的工人处理。<br>如果说这14个工人做任务的速度还是不够，此时工厂主管就要考虑不再接受新的任务或者抛弃前面的一些任务了。当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管就要考虑辞掉4个临时工了，只保持原来10个工人，比较额外的工人是需要花费的。<br>而这个例子中永远等待干活的10个工人机制就是workerQueue。这个栗子中的corePoolSize就是10，而maximumPoolSize就是14（10+4）。也就是说corePoolSize就是线程池的大小，maximumPoolSize在我看来就是一种线程池任务超过负荷的一种补救措施，即任务量突然过大时的一种补救措施。再看看下面图好好理解一下。工人永远在等待干活，就像workerQueue永远在循环干活一样，除非，整个线程池停止了。<br><img src="/2017/08/06/并发编程之线程池ThreadPoolExecutor/thread1.png" alt="thread" title="thread"></p>
<p>线程池里面的线程的时序图如下图所示：<br><img src="/2017/08/06/并发编程之线程池ThreadPoolExecutor/thread2.png" alt="thread" title="thread"></p>
<p>自定义线程池与ExecutorService<br>自定义线程池需要用到ThreadFactory，本节将通过创建一个线程的例子对ExecutorService及其参数进行详细讲解。<br><strong>1.认识ExecutorService家族 </strong><br>ExecutorService家族成员如下所示：<br><img src="/2017/08/06/并发编程之线程池ThreadPoolExecutor/thread3.png" alt="thread" title="thread"></p>
<p>上图中主要元素说明如下：<br><strong>Executor：</strong>线程池的顶级接口，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。<br><strong>ExecutorService：</strong>真正线程池接口。这个接口继承了<code>Executor</code>接口，并声明了一些方法：<br><code>submit</code>、<code>invokeAll</code>、<code>invokeAny</code>以及<code>shutDown</code>等。<br><strong>ThreadPoolExecutor：</strong>ExecutorService的默认实现，继承了类AbstractExecutorService。<br><strong>ScheduledExecutorService：</strong>与Timer/TimerTask类似，解决那些需要任务重复执行的问题。<br><strong>ScheduledThreadPoolExecutor：</strong>继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。<br>Executors是个线程工厂类，方便我们快速地创建线程池。</p>
<p><strong>2.利用ThreadFactory创建一个线程</strong><br><code>Java.util.concurrent.ThreadFactory</code>提供了一个创建线程的工厂的接口。<br>ThreadFactory源码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface ThreadFactory&#123;</div><div class="line">  @override</div><div class="line">  public Thread newThread(Runnable r);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到上面的接口类中有一个<code>newThread()</code>的方法，为此我们自己手动定义一个线程工厂类，有木有激动啊，呵呵，下面我们就手动写一个自己的线程工厂类吧！  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class MyThreadFactory implements ThreadFactory&#123;</div><div class="line">  @Override</div><div class="line">  public Thread newThread(Runnable r)&#123;</div><div class="line">        return new Thread(r);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面已经创建好了我们自己的线程工厂类，但是啥都没有做，就是直接new了一个Thread就返回回去了，我们一般在创建线程的时候，都需要定义其线程的名字，因为我们在定义了线程的名字之后就能在出现问题的时候根据监视工具来查找错误的来源，所以我们来看下官方实现的<code>ThreadFactory</code>吧！<br>这个类在<code>java.util.concurrent.Executors</code>类中的静态类中<code>DefaultThreadFactory</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">*  The default thread factory</div><div class="line">*/static class DefaultThreadFactory implements ThreadFactory&#123;</div><div class="line">  private static final AtomicInteger poolNumber=new AtomicInteger(1);</div><div class="line">  private final ThreadGroup group;</div><div class="line">  private final AtomicInteger threadNumber=new AtomicInteger(1);</div><div class="line">  private final String namePrefix;</div><div class="line"></div><div class="line">  DefaultThreadFactory()&#123;</div><div class="line">    SecurityManager s=System.getSecurityManager();</div><div class="line">    group=(s!=null)?s.getThreadGroup():Thread.currentThread().getThreadGroup();</div><div class="line">    namePrefix=&quot;pool-&quot;+poolNumber.getAndIncrement()+&quot;-thread-&quot;;</div><div class="line">  &#125;</div><div class="line">  public Thread newThread(Runnable r)&#123;</div><div class="line">      Thread t=new Thread(group,r,namePrefix+threadNumber.getAndIncrement(),0);</div><div class="line">      if((t.isDaemon())</div><div class="line">          t.setDaemon(false);</div><div class="line">      if(t.getPriority()!=Thread.NORM_PRIORITY)</div><div class="line">          t.setPriority(Thread.NORM_PRIORITY);</div><div class="line">      return t;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>3.了解线程池的拒绝策略(RejectExecutionHandler)</strong><br>当调用<code>ThreadPoolExecuto</code>r的<code>execute</code>方法时，而此时线程池处于一个饱和的状态，并且任务队列也已经满了那么就需要做丢弃处理，<code>RejectExecutionHandler</code>就是这样的一个处理接口类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public interface RejectedExecutionHandler &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Method that may be invoked by a &#123;@link ThreadPoolExecutor&#125; when</div><div class="line">     * &#123;@link ThreadPoolExecutor#execute execute&#125; cannot accept a</div><div class="line">     * task.  This may occur when no more threads or queue slots are</div><div class="line">     * available because their bounds would be exceeded, or upon</div><div class="line">     * shutdown of the Executor.</div><div class="line">     *</div><div class="line">     * &lt;p&gt;In the absence of other alternatives, the method may throw</div><div class="line">     * an unchecked &#123;@link RejectedExecutionException&#125;, which will be</div><div class="line">     * propagated to the caller of &#123;@code execute&#125;.</div><div class="line">     *</div><div class="line">     * @param r the runnable task requested to be executed</div><div class="line">     * @param executor the executor attempting to execute this task</div><div class="line">     * @throws RejectedExecutionException if there is no remedy</div><div class="line">     */</div><div class="line">    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在JDK里面有4种拒绝策略，如下图所示：<br><img src="/2017/08/06/并发编程之线程池ThreadPoolExecutor/thread4.png" alt="thread" title="thread"></p>
<ol>
<li><strong>AbortPolicy：</strong>一言不合就抛异常（默认使用策略）。</li>
<li><strong>CallerRunsPolicy：</strong>只用调用者所在线程来运行任务。</li>
<li><strong>DiscardOldestPolicy：</strong>丢弃队列里最近的一个任务，并执行当前任务。</li>
<li><strong>DiscardPolicy：</strong>不处理，直接丢弃。</li>
</ol>
<p>来看下源码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">AbortPolicy : 一言不合就抛异常的</div><div class="line">   /**</div><div class="line">     * A handler for rejected tasks that throws a</div><div class="line">     * &#123;@code RejectedExecutionException&#125;.</div><div class="line">     */</div><div class="line">    public static class AbortPolicy implements RejectedExecutionHandler &#123;</div><div class="line">        /**</div><div class="line">         * Creates an &#123;@code AbortPolicy&#125;.</div><div class="line">         */</div><div class="line">        public AbortPolicy() &#123; &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * Always throws RejectedExecutionException.</div><div class="line">         *</div><div class="line">         * @param r the runnable task requested to be executed</div><div class="line">         * @param e the executor attempting to execute this task</div><div class="line">         * @throws RejectedExecutionException always.</div><div class="line">         */</div><div class="line">        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</div><div class="line">            throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +</div><div class="line">                                                 &quot; rejected from &quot; +</div><div class="line">                                                 e.toString());</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>CallerRunsPolicy：调用者所在线程来运行任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * A handler for rejected tasks that runs the rejected task</div><div class="line"> * directly in the calling thread of the &#123;@code execute&#125; method,</div><div class="line"> * unless the executor has been shut down, in which case the task</div><div class="line"> * is discarded.</div><div class="line"> */</div><div class="line">public static class CallerRunsPolicy implements RejectedExecutionHandler &#123;</div><div class="line">    /**</div><div class="line">     * Creates a &#123;@code CallerRunsPolicy&#125;.</div><div class="line">     */</div><div class="line">    public CallerRunsPolicy() &#123; &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Executes task r in the caller&apos;s thread, unless the executor</div><div class="line">     * has been shut down, in which case the task is discarded.</div><div class="line">     *</div><div class="line">     * @param r the runnable task requested to be executed</div><div class="line">     * @param e the executor attempting to execute this task</div><div class="line">     */</div><div class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</div><div class="line">        if (!e.isShutdown()) &#123;</div><div class="line">            r.run();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DiscardOldestPolicy :丢弃队列里面最近的一个任务,并执行当前任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * A handler for rejected tasks that discards the oldest unhandled</div><div class="line"> * request and then retries &#123;@code execute&#125;, unless the executor</div><div class="line"> * is shut down, in which case the task is discarded.</div><div class="line"> */</div><div class="line">public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123;</div><div class="line">    /**</div><div class="line">     * Creates a &#123;@code DiscardOldestPolicy&#125; for the given executor.</div><div class="line">     */</div><div class="line">    public DiscardOldestPolicy() &#123; &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Obtains and ignores the next task that the executor</div><div class="line">     * would otherwise execute, if one is immediately available,</div><div class="line">     * and then retries execution of task r, unless the executor</div><div class="line">     * is shut down, in which case task r is instead discarded.</div><div class="line">     *</div><div class="line">     * @param r the runnable task requested to be executed</div><div class="line">     * @param e the executor attempting to execute this task</div><div class="line">     */</div><div class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</div><div class="line">        if (!e.isShutdown()) &#123;</div><div class="line">            e.getQueue().poll();</div><div class="line">            e.execute(r);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DiscardPolicy : 不处理，直接丢弃</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * A handler for rejected tasks that silently discards the</div><div class="line">     * rejected task.</div><div class="line">     */</div><div class="line">    public static class DiscardPolicy implements RejectedExecutionHandler &#123;</div><div class="line">        /**</div><div class="line">         * Creates a &#123;@code DiscardPolicy&#125;.</div><div class="line">         */</div><div class="line">        public DiscardPolicy() &#123; &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * Does nothing, which has the effect of discarding task r.</div><div class="line">         *</div><div class="line">         * @param r the runnable task requested to be executed</div><div class="line">         * @param e the executor attempting to execute this task</div><div class="line">         */</div><div class="line">        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>思考问题：<br>为什么有任务拒绝的情况发生呢：<br>这里先假设有一个前提：线程池里面有一个任务队列，用于缓存所有待处理的任务，正在处理的任务将从任务队列中移除。因此，在任务队列长度有限的情况下，就会出现现任务的拒绝情况，需要一种策略来处理发生这种已满无法加入的情况。另外，在线程池关闭的时候，也需要对任务加入队列操作进行额外的协调处理。  </p>
<p><strong>4.ThreadPoolExecutor详解</strong></p>
<p><code>ThreadPoolExecutor</code>类是线程池中最核心的一个类，因此如果要想透彻的了解Java线程池，必须先了解这个大BOSS，下面来看下其源码：</p>
<p>4种构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,TimeUnit unit,</div><div class="line">                      BlockingQueue&lt;Runnable&gt; workQueue) &#123;</div><div class="line">    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,Executors.defaultThreadFactory(), defaultHandler);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,long keepAliveTime,TimeUnit unit,</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory) &#123;</div><div class="line">    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,threadFactory, defaultHandler);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,long keepAliveTime,TimeUnit unit,</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123;</div><div class="line">    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,</div><div class="line">                         BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory,RejectedExecutionHandler handler) &#123;</div><div class="line">    if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0)</div><div class="line">        throw new IllegalArgumentException();</div><div class="line">    if (workQueue == null || threadFactory == null || handler == null)</div><div class="line">        throw new NullPointerException();</div><div class="line">    this.corePoolSize = corePoolSize;</div><div class="line">    this.maximumPoolSize = maximumPoolSize;</div><div class="line">    this.workQueue = workQueue;</div><div class="line">    this.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class="line">    this.threadFactory = threadFactory;</div><div class="line">    this.handler = handler;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过源码我们清楚的看到，最终构造函数调用了最后一个构造函数，后面的那个构造函数才是真正的构造函数，接下来研究一下参数。</p>
<ul>
<li>int corePoolSize：核心池大小，这个参数跟后面讲的线程池原理有很大的关系。在创建了线程池之后，默认情况下，线程池中并没有任何线程，而是等待所有的任务到来之时才进行创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法 ，从这个两个方法的名字可以知道是预创建线程的意思，即在没有任务来临之前先创建好corePoolSize个线程或者一个线程。默认情况下，在创建好线程池之后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数量达到corePoolSize后，就会把达到的任务放到缓存队列中去。 </li>
<li>int maximumPoolSize：线程池最大线程数量，这是个非常重要的参数，它表示在线程池中最多能创建线程的数量；在corePoolSize和maximumPoolSize的线程数会被自动释放，而小于corePoolSize的则不会。 </li>
<li>long keepAliveTime：表示线程没有执行任务时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会生效,直到线程池数量不大于corePoolSize，即只有当线程池数量大于corePoolSize数量，超出这个数量的线程一旦到达keepAliveTime就会终止。但是如果调用了allowCoreThreadTimeout(boolean)方法，即使线程池的线程数量不大于corePoolSize，线程也会在keepAliveTime之后就终止，知道线程池的数量为0为止。 </li>
<li>TimeUnit unit：参数keepAliveTime的时间单位，一个时间单位枚举类。 </li>
<li>BlockingQueue workQueue：一个阻塞队列，用来存储等待执行任务的队列，这个参数选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列就是（ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue；）。 </li>
<li>ThreadFactory ThreadFactory：线程工厂，主要用来创建线程；可以是一个自定义的线程工厂，默认就是Executors.defaultThreadFactory()。用来在线程池中创建线程。 </li>
<li>RejectedExecutionHandler handler：表示当拒绝处理任务时的策略，也是可以自定义的，默认是我们前面的4种取值： </li>
</ul>
<ul>
<li>ThreadPoolExecutor.AbortPolicy（默认的，一言不合即抛异常的） </li>
<li>ThreadPoolExecutor.DiscardPolicy（一言不合就丢弃任务） </li>
<li>ThreadPoolExecutor.DiscardOldestPolicy（一言不合就把最近的任务给抛弃，然后执行当前任务） </li>
<li>ThreadPoolExecutor.CallerRunsPolicy（由调用者所在线程来执行任务）<br>所以想自定义线程池就可以从上面的几个参数入手。接下来具体看下代码,了解一下实现原理：<br> // 默认异常处理机制<br> private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();<br> //任务缓存队列，用来存放等待执行的任务<br> private final BlockingQueue<runnable> workQueue;<br> //线程池的主要状态锁，对线程状态（比如线程大小、runState等）的改变都需要这个锁<br> private final ReentrantLock mainLock = new ReentrantLock();<br> //用来存放工作集<br> private final HashSet<worker> workers = new HashSet<worker>();<br> //volatile 可变变量关键字，写的时候用mainLock做锁，读的时候无锁，高性能<br> private volatile long keepAliveTime;<br> //是否允许核心线程超时<br> private volatile boolean allowCoreThreadTimeOut;<br> //核心线程数量<br> private volatile int corePoolSize;<br> //线程最大线程数量<br> private volatile int maximumPoolSize;<br> //任务拒绝策略<br> private volatile RejectedExcutionHandler handler;<br>结合之前的知识，大概就能猜出里面是怎么实现的了，具体可以参考一下JDK的源代码，这样我们就能做到了解原理又会用了。</worker></worker></runnable></li>
</ul>
<p><strong>5.自定义实现一个简单的Web请求连接池</strong><br>我们来自定义一个简单的Web请求线程池。模仿Web服务的需求场景说明如下：  </p>
<ul>
<li>服务器可容纳的最小请求数是多少。   </li>
<li>可以动态扩充的请求数大小是多少。   </li>
<li>多久回收多余线程数即请求数。   </li>
<li>用户访问量打了怎么处理。   </li>
<li>线程队列机制采取有优先级的排队的执行机制。<br>根据上面的场景，看下这个线程池如何编写？ </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class MyExecutors extends Executors&#123;</div><div class="line">    //利用默认线程工厂和PriorityBlockingQueue队列机制，当然了，我们还可以自定义ThreadFactory和继承queue进行自定义扩展</div><div class="line">   public static ExecutorService newMyWebThreadPool(int minSpareThreads,int maxThreads,int maxIdleTime)&#123;</div><div class="line">    return new ThreadPoolExecutor(minSpareThread,maxThreads,maxIdleTime,TimeUnit.MILLISECONDS，</div><div class="line">          new PriorityBlockingQueue&lt;Runnable&gt;());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>6.线程池在工作中的错误使用</strong><br>(1)分不清楚线程是单例还是多对象。<br>(2)线程池数量设置很大。<br>(3)注意死锁问题  </p>
<p><strong>连接池（org.apache.commons.dbcp.BasicDataSource）</strong><br>在使用org.apache.commons.dbcp.BasicDataSource的时候，因为之前采用了默认配置，所以当访问量大时，通过JMX观察到很多Tomcat线程都阻塞在BasicDataSource使用的Apache ObjectPool的锁上，直接原因当时是因为BasicDataSource连接池的最大连接数设置的太小，默认的BasicDataSource配置，仅使用8个最大连接。<br>我还观察到一个问题，当较长的时间不访问系统，比如2天，DB上的Mysql会断掉所以的连接，导致连接池中缓存的连接不能用。为了解决这些问题，我们充分研究了BasicDataSource，发现了一些优化的点：    </p>
<ul>
<li>Mysql默认支持100个链接，所以每个连接池的配置要根据集群中的机器数进行，如有2台服务器，可每个设置为60  </li>
<li>initialSize：参数是一直打开的连接数  </li>
<li>minEvictableIdleTimeMillis：该参数设置每个连接的空闲时间，超过这个时间连接将被关闭  </li>
<li>timeBetweenEvictionRunsMillis：后台线程的运行周期，用来检测过期连接  </li>
<li>maxActive：最大能分配的连接数  </li>
<li>maxIdle：最大空闲数，当连接使用完毕后发现连接数大于maxIdle，连接将被直接关闭。只有initialSize &lt; x &lt; maxIdle的连接将被定期检测是否超期。这个参数主要用来在峰值访问时提高吞吐量。  </li>
<li>initialSize是如何保持的？经过研究代码发现，BasicDataSource会关闭所有超期的连接，然后再打开initialSize数量的连接，这个特性与minEvictableIdleTimeMillis、timeBetweenEvictionRunsMillis一起保证了所有超期的initialSize连接都会被重新连接，从而避免了Mysql长时间无动作会断掉连接的问题。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017/08/06/并发编程之线程池ThreadPoolExecutor/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;ThreadPoolExecutor&quot;&gt;&lt;a href=&quot;#ThreadPoolExecutor&quot; class=&quot;headerlink&quot; title=&quot;ThreadPoolExecutor&quot;&gt;&lt;/a&gt;ThreadPoolExecutor&lt;/h2&gt;&lt;p&gt;当前越来越多的系统使用多线程来处理任务，但是为每一个任务创建线程并不是合理的方案，原因有2点：一是创建线程的开销很大，一个任务一个线程的方式会有性能上的损失；二是可能导致线程数量的膨胀，不但不易于线程的管理，还可能导致内存被消耗完，导致out of memory（OOM）,从而使系统崩溃。为了解决这个问题，线程池应运而生。线程池有两个作用：一个是限制线程的数量，不会导致线程的膨胀；二是线程复用，线程执行完一个人任务之后，可以接着执行下一个任务，减少了创建线程的开销。 &lt;/p&gt;
&lt;p&gt;java中一个运用非常普遍的线程池是ThreadPoolExecutor。下面来探究下ThreadPoolExecutor的功能和实现原理。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://jet-han.oschina.io/categories/java/"/>
    
    
      <category term="java" scheme="http://jet-han.oschina.io/tags/java/"/>
    
      <category term="thread pool" scheme="http://jet-han.oschina.io/tags/thread-pool/"/>
    
  </entry>
  
  <entry>
    <title>线程的实现方式</title>
    <link href="http://jet-han.oschina.io/2017/08/05/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>http://jet-han.oschina.io/2017/08/05/线程的实现方式/</id>
    <published>2017-08-05T08:32:32.000Z</published>
    <updated>2018-11-13T08:04:59.699Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/08/05/线程的实现方式/java.jpg" alt="java" title="java"></p>
<h2 id="线程实现方式"><a href="#线程实现方式" class="headerlink" title="线程实现方式"></a>线程实现方式</h2><ol>
<li>继承java.lang.Thread类  </li>
<li>实现java.lang.Runnable接口</li>
</ol>
<p><strong>区别：</strong>第一种是继承，第二种是实现<br><strong>好处：</strong>  在实际开发中通常以实现Runnable接口为主，因为实现Runnable接口相比继承Thread类可以避免继承的局限，一个类可以继承多个接口，适合于资源的共享<br><a id="more"></a><br>示例1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">1.class ThreadTest extends Thread&#123;  </div><div class="line">2.  public void run()&#123; </div><div class="line">3.     private int tickets = 100;  </div><div class="line">4.    while(true)&#123;  </div><div class="line">5.      if(ticket &gt; 0)&#123;  </div><div class="line">6.        System.out.println(Thread.currentThread().getName() +  </div><div class="line">7.          &quot;is saling ticket&quot; + ticket--);  </div><div class="line">8.      &#125;else&#123;  </div><div class="line">9.        break;  </div><div class="line">10.      &#125;  </div><div class="line">11.    &#125;  </div><div class="line">12.  &#125;  </div><div class="line">13.&#125;  </div><div class="line"></div><div class="line">#main测试类: </div><div class="line">1.public class ThreadDome1&#123;  </div><div class="line">2.  public static void main(String[] args)&#123;  </div><div class="line">3.    ThreadTest t = new ThreadTest();  </div><div class="line">4.    t.start();  </div><div class="line">5.    t.start();  </div><div class="line">6.    t.start();  </div><div class="line">7.    t.start();  </div><div class="line">8.  &#125;  </div><div class="line">9.&#125;</div></pre></td></tr></table></figure></p>
<p>【说明】一个线程对象只能启动一个线程，无论你调用多少遍start()方法，结果只有一个线程。</p>
<p>示例2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">1.public class ThreadDemo1&#123;  </div><div class="line">2.  public static void main(String[] args)&#123;  </div><div class="line">3.    new ThreadTest().start();  </div><div class="line">4.    new ThreadTest().start();  </div><div class="line">5.    new ThreadTest().start();  </div><div class="line">6.    new ThreadTest().start();  </div><div class="line">7.  &#125;  </div><div class="line">8.&#125;  </div><div class="line"></div><div class="line">1.class ThreadTest extends Thread&#123;  </div><div class="line">2.  public void run()&#123; </div><div class="line">3.     private int tickets = 100;  </div><div class="line">4.    while(true)&#123;  </div><div class="line">5.      if(ticket &gt; 0)&#123;  </div><div class="line">6.        System.out.println(Thread.currentThread().getName() +   </div><div class="line">7.           &quot; is saling ticket&quot; + ticket--);  </div><div class="line">8.      &#125;else&#123;  </div><div class="line">9.        break;  </div><div class="line">10.      &#125;  </div><div class="line">11.    &#125;  </div><div class="line">12.  &#125;  </div><div class="line">13.&#125;</div></pre></td></tr></table></figure></p>
<p>【说明】创建了四个ThreadTest对象，就等于创建了四个资源，每个资源都有100张票，每个线程都在独自处理各自的资源。</p>
<p>示例4：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">1.public class ThreadDemo1&#123;  </div><div class="line">2.  public static void main(String[] args)&#123;  </div><div class="line">3.    ThreadTest t = new ThreadTest();  </div><div class="line">4.    new Thread(t).start();  </div><div class="line">5.    new Thread(t).start();  </div><div class="line">6.    new Thread(t).start();  </div><div class="line">7.    new Thread(t).start();  </div><div class="line">8.  &#125;  </div><div class="line">9.&#125;  </div><div class="line"></div><div class="line">1.class ThreadTest implements Runnable&#123;   </div><div class="line">2.  public void run()&#123; </div><div class="line">3.     private int tickets = 100; //局部变量，如果是成员变量，则所有线程则共享它，会出现问题 </div><div class="line">4.    while(true)&#123;  </div><div class="line">5.      if(tickets &gt; 0)&#123;  </div><div class="line">6.        System.out.println(Thread.currentThread().getName() +  </div><div class="line">7.          &quot; is saling ticket &quot; + tickets--);  </div><div class="line">8.      &#125;  </div><div class="line">9.    &#125;  </div><div class="line">10.  &#125;  </div><div class="line">11.&#125;</div></pre></td></tr></table></figure>
<p>【注意】创建了四个线程，每个线程调用的是同一个ThreadTest对象中的run()方法，访问的是同一个对象中的变量（tickets）的实例<br>　如果一个变量是成员变量，那么多个线程对同一个对象的成员变量进行操作时，它们对该成员变量是彼此影响的，也就是说一个线程对成员变量的改变会影响到另一个线程。<br>　如果一个变量是局部变量，那么每个线程都会有一个该局部变量的拷贝（即便是同一个对象中的方法的局部变量，也会对每一个线程有一个拷贝），一个线程对该局部变量的改变不会影响到其他线程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017/08/05/线程的实现方式/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;线程实现方式&quot;&gt;&lt;a href=&quot;#线程实现方式&quot; class=&quot;headerlink&quot; title=&quot;线程实现方式&quot;&gt;&lt;/a&gt;线程实现方式&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;继承java.lang.Thread类  &lt;/li&gt;
&lt;li&gt;实现java.lang.Runnable接口&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;区别：&lt;/strong&gt;第一种是继承，第二种是实现&lt;br&gt;&lt;strong&gt;好处：&lt;/strong&gt;  在实际开发中通常以实现Runnable接口为主，因为实现Runnable接口相比继承Thread类可以避免继承的局限，一个类可以继承多个接口，适合于资源的共享&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://jet-han.oschina.io/categories/java/"/>
    
    
      <category term="java" scheme="http://jet-han.oschina.io/tags/java/"/>
    
      <category term="thread" scheme="http://jet-han.oschina.io/tags/thread/"/>
    
      <category term="runnable" scheme="http://jet-han.oschina.io/tags/runnable/"/>
    
  </entry>
  
  <entry>
    <title>jvm调优</title>
    <link href="http://jet-han.oschina.io/2017/08/05/jvm%E8%B0%83%E4%BC%98/"/>
    <id>http://jet-han.oschina.io/2017/08/05/jvm调优/</id>
    <published>2017-08-05T08:05:44.000Z</published>
    <updated>2018-11-13T08:09:20.782Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/08/05/jvm调优/java.jpg" alt="java" title="java"></p>
<h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p>1.根据Java虚拟机规范，JVM将内存划分为：<br><strong>New（年轻代）<br>Tenured（年老代）<br>永久代（Perm）</strong><br><a id="more"></a><br><img src="/2017/08/05/jvm调优/jvm2.gif" alt="jvm" title="jvm"><br>  其中New和Tenured属于堆内存，堆内存会从JVM启动参数（-Xmx:3G）指定的内存中分配，Perm不属于堆内存，有虚拟机直接分配，但可以通过-XX:PermSize -XX:MaxPermSize 等参数调整其大小。<br><img src="/2017/08/05/jvm调优/jvm4.jpg" alt="jvm" title="jvm"></p>
<p><strong>年轻代（New）：</strong>年轻代用来存放JVM刚分配的Java对象<br><strong>年老代（Tenured)：</strong>年轻代中经过垃圾回收没有回收掉的对象将被Copy到年老代<br><strong>永久代（Perm）：</strong>永久代存放Class、Method元信息，其大小跟项目的规模、类、方法的量有关，一般设置为128M就足够，设置原则是预留30%的空间。</p>
<p>New又分为几个部分：<br><strong>Eden：</strong>Eden用来存放JVM刚分配的对象<br><strong>Survivor1</strong><br><strong>Survivro2：</strong>两个Survivor空间一样大，当Eden中的对象经过垃圾回收没有被回收掉时，会在两个Survivor之间来回Copy，当满足某个条件，比如Copy次数，就会被Copy到Tenured。显然，Survivor只是增加了对象在年轻代中的逗留时间，增加了被垃圾回收的可能性。</p>
<p><strong>各代如何设置比例</strong><br><strong>堆大小设置</strong><br>JVM 中最大堆大小有三方面限制：相关操作系统的数据模型（32-bt还是64-bit）限制；系统的可用虚拟内存限制；系统的可用物理内存限制。32位系统下，一般限制在1.5G~2G；64为操作系统对内存无限制。我在Windows Server 2003 系统，3.5G物理内存，JDK5.0下测试，最大可设置为1478m。<br><strong>典型设置：</strong><br>- java -Xmx3550m -Xms3550m -Xmn2g -Xss128k<br>- -Xmx3550m：设置JVM最大可用内存为3550M。<br>- -Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。<br>- -Xmn2g：设置年轻代大小为2G。整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。<br>- -Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。<br>- java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0<br>- -XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5<br>- -XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6<br>- -XX:MaxPermSize=16m:设置持久代大小为16m。<br>- -XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。 </p>
<p>如果程序确实需要大量的线程，现有的设置不能达到要求，那么可以通过修改MaxProcessMemory，JVMMemory，ThreadStackSize这三个因素，来增加能创建的线程数：<br>a. MaxProcessMemory 使用64位JVM<br>    经测试在，64位jvm下生成的线程数不受上述公式的制约，值为63260，这个数值应该足够用了，<br>    测试数据如下, (指令|能启动的线程数量)</p>
<p>java -Xms512M -Xmx2G -cp . TestNativeOutOfMemoryError  | 63389<br>java -Xms512M -Xmx8G -cp . TestNativeOutOfMemoryError  | 63260<br>java -Xms512M -Xmx16G -cp . TestNativeOutOfMemoryError  | 63385<br>java -Xms512M -Xmx32G -cp . TestNativeOutOfMemoryError  | 63380<br>java -Xms512M -Xmx64G -cp . TestNativeOutOfMemoryError  |63387</p>
<p>b. JVMMemory   减少JVMMemory的分配(即减少xms/xmx的大小)<br>c. ThreadStackSize  减小单个线程的栈大小 (-Xss)</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>垃圾回收算法可以分为三类，都基于标记-清除（复制）算法：<br><strong>Serial算法（单线程）<br>并行算法<br>并发算法</strong><br>JVM会根据机器的硬件配置对每个内存代选择适合的回收算法，比如，如果机器多于1个核，会对年轻代选择并行算法，关于选择细节请参考JVM调优文档。 </p>
<p>稍微解释下的是，并行算法是用多线程进行垃圾回收，回收期间会暂停程序的执行，而并发算法，也是多线程回收，但期间不停止应用执行。所以，并发算法适用于交互性高的一些程序。经过观察，并发算法会减少年轻代的大小，其实就是使用了一个大的年老代，这反过来跟并行算法相比吞吐量相对较低。  </p>
<p><strong>还有一个问题是，垃圾回收动作何时执行？</strong></p>
<ul>
<li>当年轻代内存满时，会引发一次普通GC，该GC仅回收年轻代。需要强调的时，年轻代满是指Eden代满，Survivor满不会引发GC</li>
<li>当年老代满时会引发Full GC，Full GC将会同时回收年轻代、年老代</li>
<li>当永久代满时也会引发Full GC，会导致Class、Method元信息的卸载<br>另一个问题是，何时会抛出OutOfMemoryException，并不是内存被耗空的时候才抛出</li>
<li>JVM98%的时间都花费在内存回收</li>
<li>每次回收的内存小于2%<br>满足这两个条件将触发OutOfMemoryException，这将会留给系统一个微小的间隙以做一些Down之前的操作，比如手动打印Heap Dump。</li>
</ul>
<h2 id="内存泄漏及解决方法"><a href="#内存泄漏及解决方法" class="headerlink" title="内存泄漏及解决方法"></a>内存泄漏及解决方法</h2><p><img src="/2017/08/05/jvm调优/jvm.jpeg" alt="jvm" title="jvm"><br><img src="/2017/08/05/jvm调优/jvm内存溢出.png" alt="jvm" title="jvm"><br>1.系统崩溃前的一些现象：</p>
<ul>
<li>每次垃圾回收的时间越来越长，由之前的10ms延长到50ms左右，FullGC的时间也有之前的0.5s延长到4、5s</li>
<li>FullGC的次数越来越多，最频繁时隔不到1分钟就进行一次FullGC</li>
<li>年老代的内存越来越大并且每次FullGC后年老代没有内存被释放<br>之后系统会无法响应新的请求，逐渐到达OutOfMemoryError的临界值。</li>
</ul>
<p>2.生成堆的dump文件<br> 通过JMX的MBean生成当前的Heap信息，大小为一个3G（整个堆的大小）的hprof文件，如果没有启动JMX可以通过Java的jmap命令来生成该文件。<br> <img src="/2017/08/05/jvm调优/jmap.png" alt="jvm" title="jvm"></p>
<p>3.分析dump文件<br> 下面要考虑的是如何打开这个3G的堆信息文件，显然一般的Window系统没有这么大的内存，必须借助高配置的Linux。当然我们可以借助X-Window把Linux上的图形导入到Window。我们考虑用下面几种工具打开该文件：</p>
<ul>
<li>Visual VM  </li>
<li>IBM HeapAnalyzer  </li>
<li>JDK 自带的Hprof工具  </li>
</ul>
<p>使用这些工具时为了确保加载速度，建议设置最大内存为6G。使用后发现，这些工具都无法直观地观察到内存泄漏，Visual VM虽能观察到对象大小，但看不到调用堆栈；HeapAnalyzer虽然能看到调用堆栈，却无法正确打开一个3G的文件。因此，我们又选用了Eclipse专门的静态内存分析工具：Mat。</p>
<p>4.分析内存泄漏<br> 通过Mat我们能清楚地看到，哪些对象被怀疑为内存泄漏，哪些对象占的空间最大及对象的调用关系。针对本案，在ThreadLocal中有很多的JbpmContext实例，经过调查是JBPM的Context没有关闭所致。<br> 另，通过Mat或JMX我们还可以分析线程状态，可以观察到线程被阻塞在哪个对象上，从而判断系统的瓶颈。  </p>
<p>5.回归问题<br>   Q：<strong>为什么崩溃前垃圾回收的时间越来越长？</strong><br>   A:根据内存模型和垃圾回收算法，垃圾回收分两部分：内存标记、清除（复制），标记部分只要内存大小固定时间是不变的，变的是复制部分，因为每次垃圾回收都有一些回收不掉的内存，所以增加了复制量，导致时间延长。所以，垃圾回收的时间也可以作为判断内存泄漏的依据<br>   Q：<strong>为什么Full GC的次数越来越多？</strong><br>   A：因此内存的积累，逐渐耗尽了年老代的内存，导致新对象分配没有更多的空间，从而导致频繁的垃圾回收<br>   Q:<strong>为什么年老代占用的内存越来越大？</strong><br>   A:因为年轻代的内存无法被回收，越来越多地被Copy到年老代  </p>
<h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><p> 除了上述内存泄漏外，我们还发现CPU长期不足3%，系统吞吐量不够，针对8core×16G、64bit的Linux服务器来说，是严重的资源浪费。<br> 在CPU负载不足的同时，偶尔会有用户反映请求的时间过长，我们意识到必须对程序及JVM进行调优。从以下几个方面进行：  </p>
<ul>
<li>线程池：解决用户响应时间长的问题  </li>
<li>连接池  </li>
<li>JVM启动参数：调整各代的内存比例和垃圾回收算法，提高吞吐量  </li>
<li>程序算法：改进程序逻辑算法提高性能</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017/08/05/jvm调优/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;JVM内存模型&quot;&gt;&lt;a href=&quot;#JVM内存模型&quot; class=&quot;headerlink&quot; title=&quot;JVM内存模型&quot;&gt;&lt;/a&gt;JVM内存模型&lt;/h2&gt;&lt;p&gt;1.根据Java虚拟机规范，JVM将内存划分为：&lt;br&gt;&lt;strong&gt;New（年轻代）&lt;br&gt;Tenured（年老代）&lt;br&gt;永久代（Perm）&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://jet-han.oschina.io/categories/java/"/>
    
    
      <category term="java" scheme="http://jet-han.oschina.io/tags/java/"/>
    
      <category term="jvm" scheme="http://jet-han.oschina.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>web.xml加载顺序</title>
    <link href="http://jet-han.oschina.io/2017/08/05/web-xml%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/"/>
    <id>http://jet-han.oschina.io/2017/08/05/web-xml加载顺序/</id>
    <published>2017-08-05T06:42:06.000Z</published>
    <updated>2018-11-13T08:10:39.666Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/08/05/web-xml加载顺序/java.jpg" alt="java" title="java"></p>
<p><strong>web.xml 的加载顺序:</strong><br>ServletContext-&gt; context-param -&gt;listener -&gt; filter -&gt; servlet，而同个类型之间的实际程序调用的时候的顺序是根据对应的 mapping 的顺序进行调用的。ServletContext即Servlet上下文对象，该对象表示当前的web应用环境信息，一个Web应用只会创建一个ServletContext对象。</p>
<p>Web容器启动的时候，它会为每个Web应用程序都创建一个对应的ServletContext对象，它代表当前的web应用。<br>[注意]由于一个Web应用中的所有Servlet共享一个ServletContext对象，所以多个Servlet通过ServletContext对象实现数据共享，ServletContext对象通常称为Context域对象。<br><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017/08/05/web-xml加载顺序/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;web.xml 的加载顺序:&lt;/strong&gt;&lt;br&gt;ServletContext-&amp;gt; context-param -&amp;gt;listener -&amp;gt; filter -&amp;gt; servlet，而同个类型之间的实际程序调用的时候的顺序是根据对应的 mapping 的顺序进行调用的。ServletContext即Servlet上下文对象，该对象表示当前的web应用环境信息，一个Web应用只会创建一个ServletContext对象。&lt;/p&gt;
&lt;p&gt;Web容器启动的时候，它会为每个Web应用程序都创建一个对应的ServletContext对象，它代表当前的web应用。&lt;br&gt;[注意]由于一个Web应用中的所有Servlet共享一个ServletContext对象，所以多个Servlet通过ServletContext对象实现数据共享，ServletContext对象通常称为Context域对象。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://jet-han.oschina.io/categories/java/"/>
    
    
      <category term="java" scheme="http://jet-han.oschina.io/tags/java/"/>
    
      <category term="web" scheme="http://jet-han.oschina.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>sping之IOC，AOP</title>
    <link href="http://jet-han.oschina.io/2017/08/05/sping%E4%B9%8BIOC%EF%BC%8CAOP/"/>
    <id>http://jet-han.oschina.io/2017/08/05/sping之IOC，AOP/</id>
    <published>2017-08-05T06:34:04.000Z</published>
    <updated>2018-11-13T08:14:28.877Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/08/05/sping之IOC，AOP/spring.jpg" alt="spring" title="spring"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Spring AOP和IOC个人理解<br><strong>IOC inversion of control 控制反转</strong><br>将new对象的权力由调用者转移到spring容器（即xml文件），Struts2与Spring整合（scope=”prototype”）由spring来维护struts的生命周期，在启动web容器时spring容器创建action实例对象，又分两种方式：<br>第一种xml方式 需要set方法为被调用的属性赋值，xml中需要<code>ref</code>注入被调要的对象。<br>第二种注解方式 不需要set方法为被调用属性赋值，但需要在action层service层dao层的类上对应写上<br><code>@Controller,@Service,@Repository</code>通过在属性上加上<code>@Resource(name=&quot;&quot;)</code>来为属性赋值，这一步相当于xml方式的<code>ref</code>。<br>事务管理器<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;txManager&quot;class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt; </div><div class="line">&lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;&gt;&lt;/property&gt;  </div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>相当于切面需要注入<code>sessionFactory</code></p>
<p><strong>AOP Aspect Oriented Programming 面向切面编程</strong><br>通过代理的方式在需要的时候通过切入点给指定位置的程序添加逻辑代码或功能。声明事务处理分为两种方式：<br><strong>第一种xml方式:</strong> 需要在xml中配置事务的通知<code>&lt;tx:advice&gt;</code>里面放增删改查等方法的<code>isolation=&quot;DEFAULT&quot;        propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot;&lt;/tx:advice&gt;）</code><br>用切面关联通知，然后再用通知关联切入点<code>&lt;aop:config&gt;</code>（即事务操作业务层）切入地点是所有service 包及其子包下类的所有方法。<br><strong>第二种注解方式:</strong> 使用注解的方式配置声明式事务处理，在Service层类中，<code>@Transcational</code>(事务处理的)     <code>&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;</code><br>不需要关联通知也不需要通知关联切入点</p>
<h2 id="spring的基本框架主要包含六大模块：DAO、ORM、AOP、JEE、WEB、CORE"><a href="#spring的基本框架主要包含六大模块：DAO、ORM、AOP、JEE、WEB、CORE" class="headerlink" title="spring的基本框架主要包含六大模块：DAO、ORM、AOP、JEE、WEB、CORE"></a>spring的基本框架主要包含六大模块：DAO、ORM、AOP、JEE、WEB、CORE</h2><p><img src="/2017/08/05/sping之IOC，AOP/spring-structure.png" alt="spring" title="spring"></p>
<p><strong>Spring DAO：</strong>Spring提供了对JDBC的操作支持：JdbcTemplate模板工具类 。<br><strong>Spring ORM：</strong>Spring可以与ORM框架整合。例如Spring整合Hibernate框架，其中Spring还提供  HibernateDaoSupport工具类，简化了Hibernate的操作 。<br><strong>Spring WEB：</strong>Spring提供了对Struts、Springmvc的支持，支持WEB开发。与此同时Spring自身也提供了基于MVC的解决方案 。<br><strong>Spring  AOP：</strong>Spring提供面向切面的编程，可以给某一层提供事务管理，例如在Service层添加事物控制 。<br><strong>Spring   JEE：</strong>J2EE开发规范的支持，例如EJB 。<br><strong>8Spring Core：</strong>提供IOC容器对象的创建和处理依赖对象关系 。  </p>
<h2 id="Spring下IOC容器和DI-依赖注入Dependency-injection"><a href="#Spring下IOC容器和DI-依赖注入Dependency-injection" class="headerlink" title="Spring下IOC容器和DI(依赖注入Dependency injection)"></a>Spring下IOC容器和DI(依赖注入Dependency injection)</h2><p>　　<strong>IOC容器：</strong>就是具有依赖注入功能的容器，是可以创建对象的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。通常new一个实例，控制权由程序员控制，而”控制反转”是指new实例工作不由程序员来做而是交给Spring容器来做。。在Spring中BeanFactory是IOC容器的实际代表者。<br>　　<strong>DI(依赖注入Dependency injection) ：</strong>在容器创建对象后，处理对象的依赖关系。<br>依赖注入spring的注入方式： </p>
<p><strong>set注入方式<br>静态工厂注入方式<br>构造方法注入方式<br>基于注解的方式 </strong><br>1、 set注入方式：<br>控制层代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private OrderServiceImp orderService;</div><div class="line">    public void setOrderService(OrderServiceImp orderService) &#123;</div><div class="line">       this.orderService = orderService;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Spring配置XML文件：其中配置声明OrderAction类存在属性orderService。程式运行时候，会将已经实例化的orderService对象调用setOrderService方式注入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;bean name=&quot;orderAction&quot; class=&quot;com.pec.action.OrderAction&quot;&gt;</div><div class="line">        &lt;property name=&quot;orderService&quot; ref=&quot;orderService&quot;&gt;&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line">&lt;bean name=&quot;orderService&quot; class=&quot;com.pec.service.imp.OrderServiceImp&quot;&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>2、 构造器注入方式：<br>控制层代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private OrderServiceImp orderService;</div><div class="line">    public OrderAction(OrderServiceImp orderService) &#123;</div><div class="line">        this.orderService = orderService;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>Spring配置XML文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;bean name=&quot;orderAction&quot; class=&quot;com.pec.action.OrderAction&quot;&gt;</div><div class="line">      &lt;constructor-arg ref=&quot;orderService&quot;&gt;&lt;/constructor-arg&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line">&lt;bean name=&quot;orderService&quot; class=&quot;com.pec.service.imp.OrderServiceImp&quot;&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>3、基于注解的方式 （推荐使用，比较便捷少配置）<br>控制层代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@Autowired   //@Resourceprivate OrderServiceImp orderService;</div></pre></td></tr></table></figure></p>
<p>服务层代码：</p>
<pre><code>    @Service(&quot;orderService&quot;)
    public class OrderServiceImp implements IOrderService {

    @Autowired
    private JavaOrderMDaoImp javaOrderMDao;

    @Autowired
    private JavaOrderDDaoImp javaOrderDDao;

    @Override
    public List&lt;JavaOrderMList&gt; findOrderM(OrderSearch search) {
        return javaOrderMDao.findJavaOrderM(search);
    }

    @Override
    public List&lt;JavaOrderDList&gt; findOrderD(OrderSearch search) {
        return javaOrderDDao.findJavaOrderD(search);
    }

}
</code></pre><p> DAO层代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Repository(&quot;javaOrderMDao&quot;)</div><div class="line">public class JavaOrderMDaoImp extends BaseHibernateDAO&lt;JavaOrderM, Serializable&gt; implements IJavaOrderMDao &#123;...&#125;</div><div class="line">@Repository(&quot;javaOrderDDao&quot;)</div><div class="line">public class JavaOrderDDaoImp extendsBaseHibernateDAO&lt;JavaOrderD, Serializable&gt; implements IJavaOrderDDao &#123;...&#125;</div></pre></td></tr></table></figure></p>
<p>【注意点】<br>⑴ 持久层DAO层注解Repository中规定了名称，在Service层中声明名称必须一致。<br>⑵ 服务层Service层注解Service中规定了名称，在控制层中声明的名称必须一致。<br>⑶ 注解方式注入依赖注解：</p>
<p><strong>@Component </strong>        把对象加入ioc容器，对象引用名称是类名，第一个字母小写<br><strong>@Component(“name”)</strong> 把指定名称的对象，加入ioc容器<br><strong>@Repository</strong>        主要用于标识加入容器的对象是一个持久层的组件(类)<br><strong>@Service</strong>           主要用于标识加入容器的对象是一个业务逻辑层的组件<br><strong>@Controller </strong>       主要用于标识加入容器的对象是一个控制层的组件<br><strong>@Resource </strong>         注入属性(DI), 会从容器中找对象注入到@Resource修饰的对象上<br><strong>@Autowired </strong>        注入属性(DI), 会从容器中找对象注入到@Autowired修饰的对象上</p>
<p><strong>开启注解</strong><br><code>&lt;mvc:annotation-driven/&gt;</code><br><strong>静态资源由WEB服务器默认的Servlet来处理    ，必须和<mvc:annotation-driven>一起</mvc:annotation-driven></strong><br><code>&lt;mvc:default-servlet-handler/&gt;</code><br><strong>包扫描路径</strong><br><code>&lt;context:component-scan base-package=&quot;com.fh.controller&quot; /&gt;</code></p>
<p>注解可以简化配置，提升开发效率，但是也不利于后期维护。</p>
<ol>
<li>@Autowired与@Resource都可以用来装配bean. 都可以写在字段上,或写在setter方法上。   </li>
<li><p>@Autowired默认按类型装配（这个注解是属业spring的），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@Autowired() @Qualifier(&quot;baseDao&quot;)     </div><div class="line">private BaseDao baseDao;</div></pre></td></tr></table></figure>
</li>
<li><p>@Resource（这个注解属于J2EE的），默认安照名称进行装配，名称可以通过name属性进行指定，<br>如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。 当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@Resource(name=&quot;baseDao&quot;)     </div><div class="line">private BaseDao baseDao;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>我喜欢用 @Resource注解在字段上，且这个注解是属于J2EE的，减少了与spring的耦合。最重要的这样代码看起就比较优雅。  </p>
<h2 id="Spring面向切面编程-AOP-和事务管理配置"><a href="#Spring面向切面编程-AOP-和事务管理配置" class="headerlink" title="Spring面向切面编程(AOP)和事务管理配置"></a>Spring面向切面编程(AOP)和事务管理配置</h2><p>AOP就是纵向的编程，如业务1和业务2都需要一个共同的操作，与其往每个业务中都添加同样的代码，不如写一遍代码，让两个业务共同使用这段代码。在日常有订单管理、商品管理、资金管理、库存管理等业务，都会需要到类似日志记录、事务控制、权限控制、性能统计、异常处理及事务处理等。AOP把所有共有代码全部抽取出来，放置到某个地方集中管理，然后在具体运行时，再由容器动态织入这些共有代码。<br><img src="/2017/08/05/sping之IOC，AOP/aop.png" alt="spring" title="spring"></p>
<p>AOP涉及名称：<br><strong>切面（Aspect）：</strong>其实就是共有功能的实现。如日志切面、权限切面、事务切面等。在实际应用中通常是一个存放共有功能实现的普通Java类，之所以能被AOP容器识别成切面，是在配置中指定的。<br><strong>通知（Advice）：</strong>是切面的具体实现。以目标方法为参照点，根据放置的地方不同，可分为前置通知（Before）、后置通知（AfterReturning）、异常通知（AfterThrowing）、最终通知（After）与环绕通知（Around）5种。在实际应用中通常是切面类中的一个方法，具体属于哪类通知，同样是在配置中指定的。<br><strong>连接点（Joinpoint）：</strong>就是程序在运行过程中能够插入切面的地点。例如，方法调用、异常抛出或字段修改等，但Spring只支持方法级的连接点。<br><strong>切入点（Pointcut）：</strong>用于定义通知应该切入到哪些连接点上。不同的通知通常需要切入到不同的连接点上，这种精准的匹配是由切入点的正则表达式来定义的。<br><strong>目标对象（Target）：</strong>就是那些即将切入切面的对象，也就是那些被通知的对象。这些对象中已经只剩下干干净净的核心业务逻辑代码了，所有的共有功能代码等待AOP容器的切入。<br><strong>代理对象（Proxy）：</strong>将通知应用到目标对象之后被动态创建的对象。可以简单地理解为，代理对象的功能等于目标对象的核心业务逻辑功能加上共有功能。代理对象对于使用者而言是透明的，是程序运行过程中的产物。<br><strong>织入（Weaving）：</strong>将切面应用到目标对象从而创建一个新的代理对象的过程。这个过程可以发生在编译期、类装载期及运行期，当然不同的发生点有着不同的前提条件。譬如发生在编译期的话，就要求有一个支持这种AOP实现的特殊编译器；发生在类装载期，就要求有一个支持AOP实现的特殊类装载器；只有发生在运行期，则可直接通过Java语言的反射机制与动态代理机制来动态实现。<br> Spring配置文件中关于事务配置总是由三个组成部分，分别是DataSource、TransactionManager和代理机制这三部分，无论哪种配置方式，一般变化的只是代理机制这部分。<br>  DataSource、TransactionManager这两部分只是会根据数据访问方式有所变化，比如使用hibernate进行数据访问时，DataSource实际为SessionFactory，TransactionManager的实现为HibernateTransactionManager。<br><img src="/2017/08/05/sping之IOC，AOP/spring.gif" alt="spring" title="spring"><br>根据代理机制的不同，总结了五种Spring事务的配置方式，配置文件如下：<br>第一种方式：每个Bean都有一个代理  </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-2.5.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd&quot;&gt;

&lt;bean id=&quot;sessionFactory&quot;  
        class=&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&gt;  
    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot; /&gt;  
    &lt;property name=&quot;configurationClass&quot; value=&quot;org.hibernate.cfg.AnnotationConfiguration&quot; /&gt;
&lt;/bean&gt;  

&lt;!-- 定义事务管理器（声明式的事务） --&gt;  
&lt;bean id=&quot;transactionManager&quot;
    class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;
&lt;/bean&gt;

&lt;!-- 配置DAO --&gt;
&lt;bean id=&quot;userDaoTarget&quot; class=&quot;com.bluesky.spring.dao.UserDaoImpl&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userDao&quot;  
    class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&gt;  
       &lt;!-- 配置事务管理器 --&gt;  
       &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot; /&gt;     
    &lt;property name=&quot;target&quot; ref=&quot;userDaoTarget&quot; /&gt;  
     &lt;property name=&quot;proxyInterfaces&quot; value=&quot;com.bluesky.spring.dao.GeneratorDao&quot; /&gt;
    &lt;!-- 配置事务属性 --&gt;  
    &lt;property name=&quot;transactionAttributes&quot;&gt;  
        &lt;props&gt;  
            &lt;prop key=&quot;*&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;/props&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;  
&lt;/beans&gt;
</code></pre><p>第二种方式：所有Bean共享一个代理基类</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-2.5.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd&quot;&gt;

&lt;bean id=&quot;sessionFactory&quot;  
        class=&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&gt;  
    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot; /&gt;  
    &lt;property name=&quot;configurationClass&quot; value=&quot;org.hibernate.cfg.AnnotationConfiguration&quot; /&gt;
&lt;/bean&gt;  

&lt;!-- 定义事务管理器（声明式的事务） --&gt;  
&lt;bean id=&quot;transactionManager&quot;
    class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;transactionBase&quot;  
        class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;  
        lazy-init=&quot;true&quot; abstract=&quot;true&quot;&gt;  
    &lt;!-- 配置事务管理器 --&gt;  
    &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot; /&gt;  
    &lt;!-- 配置事务属性 --&gt;  
    &lt;property name=&quot;transactionAttributes&quot;&gt;  
        &lt;props&gt;  
            &lt;prop key=&quot;*&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt;  
        &lt;/props&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;    

&lt;!-- 配置DAO --&gt;
&lt;bean id=&quot;userDaoTarget&quot; class=&quot;com.bluesky.spring.dao.UserDaoImpl&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userDao&quot; parent=&quot;transactionBase&quot; &gt;  
    &lt;property name=&quot;target&quot; ref=&quot;userDaoTarget&quot; /&gt;   
&lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>第三种方式：使用拦截器</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-2.5.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd&quot;&gt;

&lt;bean id=&quot;sessionFactory&quot;  
        class=&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&gt;  
    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot; /&gt;  
    &lt;property name=&quot;configurationClass&quot; value=&quot;org.hibernate.cfg.AnnotationConfiguration&quot; /&gt;
&lt;/bean&gt;  

&lt;!-- 定义事务管理器（声明式的事务） --&gt;  
&lt;bean id=&quot;transactionManager&quot;
    class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;
&lt;/bean&gt; 

&lt;bean id=&quot;transactionInterceptor&quot;  
    class=&quot;org.springframework.transaction.interceptor.TransactionInterceptor&quot;&gt;  
    &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot; /&gt;  
    &lt;!-- 配置事务属性 --&gt;  
    &lt;property name=&quot;transactionAttributes&quot;&gt;  
        &lt;props&gt;  
            &lt;prop key=&quot;*&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt;  
        &lt;/props&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;

&lt;bean class=&quot;org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator&quot;&gt;  
    &lt;property name=&quot;beanNames&quot;&gt;  
        &lt;list&gt;  
            &lt;value&gt;*Dao&lt;/value&gt;
        &lt;/list&gt;  
    &lt;/property&gt;  
    &lt;property name=&quot;interceptorNames&quot;&gt;  
        &lt;list&gt;  
            &lt;value&gt;transactionInterceptor&lt;/value&gt;  
        &lt;/list&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;  

&lt;!-- 配置DAO --&gt;
&lt;bean id=&quot;userDao&quot; class=&quot;com.bluesky.spring.dao.UserDaoImpl&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;
&lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>第四种方式：使用tx标签配置的拦截器</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-2.5.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd
       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&quot;&gt;

&lt;context:annotation-config /&gt;
&lt;context:component-scan base-package=&quot;com.bluesky&quot; /&gt;

&lt;bean id=&quot;sessionFactory&quot;  
        class=&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&gt;  
    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot; /&gt;  
    &lt;property name=&quot;configurationClass&quot; value=&quot;org.hibernate.cfg.AnnotationConfiguration&quot; /&gt;
&lt;/bean&gt;  

&lt;!-- 定义事务管理器（声明式的事务） --&gt;  
&lt;bean id=&quot;transactionManager&quot;
    class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;
&lt;/bean&gt;

&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; /&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;

&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;interceptorPointCuts&quot;
        expression=&quot;execution(* com.bluesky.spring.dao.*.*(..))&quot; /&gt;
    &lt;aop:advisor advice-ref=&quot;txAdvice&quot;
        pointcut-ref=&quot;interceptorPointCuts&quot; /&gt;        
&lt;/aop:config&gt;      
&lt;/beans&gt;
</code></pre><p>第五种方式：全注解</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-2.5.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd
       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&quot;&gt;

&lt;context:annotation-config /&gt;
&lt;context:component-scan base-package=&quot;com.bluesky&quot; /&gt;

&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;

&lt;bean id=&quot;sessionFactory&quot;  
        class=&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&gt;  
    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot; /&gt;  
    &lt;property name=&quot;configurationClass&quot; value=&quot;org.hibernate.cfg.AnnotationConfiguration&quot; /&gt;
&lt;/bean&gt;  

&lt;!-- 定义事务管理器（声明式的事务） --&gt;  
&lt;bean id=&quot;transactionManager&quot;
    class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;
&lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>此时在DAO上需加上@Transactional注解，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.bluesky.spring.dao;</div><div class="line"></div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">import org.hibernate.SessionFactory;</div><div class="line">import org.springframework.beans.factory.annotation.Autowired;</div><div class="line">import org.springframework.orm.hibernate3.support.HibernateDaoSupport;</div><div class="line">import org.springframework.stereotype.Component;</div><div class="line"></div><div class="line">import com.bluesky.spring.domain.User;</div><div class="line"></div><div class="line">@Transactional</div><div class="line">@Component(&quot;userDao&quot;)</div><div class="line">public class UserDaoImpl extends HibernateDaoSupport implements UserDao &#123;</div><div class="line"></div><div class="line">    public List&lt;User&gt; listUsers() &#123;</div><div class="line">        return this.getSession().createQuery(&quot;from User&quot;).list();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017/08/05/sping之IOC，AOP/spring.jpg&quot; alt=&quot;spring&quot; title=&quot;spring&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Spring AOP和IOC个人理解&lt;br&gt;&lt;strong&gt;IOC inversion of control 控制反转&lt;/strong&gt;&lt;br&gt;将new对象的权力由调用者转移到spring容器（即xml文件），Struts2与Spring整合（scope=”prototype”）由spring来维护struts的生命周期，在启动web容器时spring容器创建action实例对象，又分两种方式：&lt;br&gt;第一种xml方式 需要set方法为被调用的属性赋值，xml中需要&lt;code&gt;ref&lt;/code&gt;注入被调要的对象。&lt;br&gt;第二种注解方式 不需要set方法为被调用属性赋值，但需要在action层service层dao层的类上对应写上&lt;br&gt;&lt;code&gt;@Controller,@Service,@Repository&lt;/code&gt;通过在属性上加上&lt;code&gt;@Resource(name=&amp;quot;&amp;quot;)&lt;/code&gt;来为属性赋值，这一步相当于xml方式的&lt;code&gt;ref&lt;/code&gt;。&lt;br&gt;事务管理器&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="spring" scheme="http://jet-han.oschina.io/categories/spring/"/>
    
    
      <category term="spring" scheme="http://jet-han.oschina.io/tags/spring/"/>
    
      <category term="IOC" scheme="http://jet-han.oschina.io/tags/IOC/"/>
    
      <category term="AOP" scheme="http://jet-han.oschina.io/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>spring事务的传播属性和隔离级别</title>
    <link href="http://jet-han.oschina.io/2017/08/05/spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://jet-han.oschina.io/2017/08/05/spring事务的传播属性和隔离级别/</id>
    <published>2017-08-05T04:03:28.000Z</published>
    <updated>2017-08-13T01:45:26.091Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/spring.jpg" alt="spring" title="spring"></p>
<h2 id="spring事务传播属性"><a href="#spring事务传播属性" class="headerlink" title="spring事务传播属性"></a>spring事务传播属性</h2><p><strong>Propagation（事务的传播属性） ：</strong>key属性确定代理应该给哪个方法增加事务行为。这样的属性最重要的部份是传播行为。有以下选项可供使用：<br><strong>PROPAGATION_REQUIRED</strong>—支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。<br><strong>PROPAGATION_SUPPORTS</strong>—支持当前事务，如果当前没有事务，就以非事务方式执行。<br><strong>PROPAGATION_MANDATORY</strong>—支持当前事务，如果当前没有事务，就抛出异常。<br><strong>PROPAGATION_REQUIRES_NEW</strong>—新建事务，如果当前存在事务，把当前事务挂起。<br><strong>PROPAGATION_NOT_SUPPORTED</strong>—以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br><strong>PROPAGATION_NEVER</strong>—以非事务方式执行，如果当前存在事务，则抛出异常。<br><a id="more"></a></p>
<ol>
<li>PROPAGATION_REQUIRED<br>加入当前正要执行的事务不在另外一个事务里，那么就起一个新的事务<br>比如说，ServiceB.methodB的事务级别定义为PROPAGATION_REQUIRED, 那么由于执行ServiceA.methodA的时候，<br>ServiceA.methodA已经起了事务，这时调用ServiceB.methodB，ServiceB.methodB看到自己已经运行在ServiceA.methodA<br>的事务内部，就不再起新的事务。而假如ServiceA.methodA运行的时候发现自己没有在事务中，他就会为自己分配一个事务。<br>这样，在ServiceA.methodA或者在ServiceB.methodB内的任何地方出现异常，事务都会被回滚。即使ServiceB.methodB的事务已经被<br>提交，但是ServiceA.methodA在接下来fail要回滚，ServiceB.methodB也要回滚</li>
<li>PROPAGATION_SUPPORTS<br>如果当前在事务中，即以事务的形式运行，如果当前不再一个事务中，那么就以非事务的形式运行</li>
<li>PROPAGATION_MANDATORY<br>必须在一个事务中运行。也就是说，他只能被一个父事务调用。否则，他就要抛出异常</li>
<li>PROPAGATION_REQUIRES_NEW<br>这个就比较绕口了。 比如我们设计ServiceA.methodA的事务级别为PROPAGATION_REQUIRED，ServiceB.methodB的事务级别为PROPAGATION_REQUIRES_NEW，<br>那么当执行到ServiceB.methodB的时候，ServiceA.methodA所在的事务就会挂起，ServiceB.methodB会起一个新的事务，等待ServiceB.methodB的事务完成以后，<br>他才继续执行。他与PROPAGATION_REQUIRED 的事务区别在于事务的回滚程度了。因为ServiceB.methodB是新起一个事务，那么就是存在<br>两个不同的事务。如果ServiceB.methodB已经提交，那么ServiceA.methodA失败回滚，ServiceB.methodB是不会回滚的。如果ServiceB.methodB失败回滚，<br>如果他抛出的异常被ServiceA.methodA捕获，ServiceA.methodA事务仍然可能提交。</li>
<li>PROPAGATION_NOT_SUPPORTED<br>当前不支持事务。比如ServiceA.methodA的事务级别是PROPAGATION_REQUIRED ，而ServiceB.methodB的事务级别是PROPAGATION_NOT_SUPPORTED ，<br>那么当执行到ServiceB.methodB时，ServiceA.methodA的事务挂起，而他以非事务的状态运行完，再继续ServiceA.methodA的事务。</li>
<li>PROPAGATION_NEVER<br>不能在事务中运行。假设ServiceA.methodA的事务级别是PROPAGATION_REQUIRED， 而ServiceB.methodB的事务级别是PROPAGATION_NEVER ，<br>那么ServiceB.methodB就要抛出异常了。</li>
<li>PROPAGATION_NESTED<br>理解Nested的关键是savepoint。他与PROPAGATION_REQUIRES_NEW的区别是，PROPAGATION_REQUIRES_NEW另起一个事务，将会与他的父事务相互独立，<br>而Nested的事务和他的父事务是相依的，他的提交是要等和他的父事务一块提交的。也就是说，如果父事务最后回滚，他也要回滚的。<br>而Nested事务的好处是他有一个savepoint。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ServiceA &#123;</div><div class="line">/**</div><div class="line">* 事务属性配置为 PROPAGATION_REQUIRED</div><div class="line">*/</div><div class="line">void methodA() &#123;</div><div class="line">try &#123;</div><div class="line">//savepoint</div><div class="line">ServiceB.methodB(); //PROPAGATION_NESTED 级别</div><div class="line">&#125; catch (SomeException) &#123;</div><div class="line">// 执行其他业务, 如 ServiceC.methodC();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说ServiceB.methodB失败回滚，那么ServiceA.methodA也会回滚到savepoint点上，ServiceA.methodA可以选择另外一个分支，比如<br>ServiceC.methodC，继续执行，来尝试完成自己的事务。<br>但是这个事务并没有在EJB标准中定义。</p>
<h2 id="Spring事务的隔离级别"><a href="#Spring事务的隔离级别" class="headerlink" title="Spring事务的隔离级别"></a>Spring事务的隔离级别</h2><ol>
<li><strong>ISOLATION_DEFAULT：</strong> 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.<br>  另外四个与JDBC的隔离级别相对应  </li>
<li><strong>ISOLATION_READ_UNCOMMITTED：</strong> 这是事务最低的隔离级别，它充许令外一个事务可以看到这个事务未提交的数据。<br>  这种隔离级别会产生脏读，不可重复读和幻像读。</li>
<li><strong>ISOLATION_READ_COMMITTED：</strong> 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据</li>
<li><strong>ISOLATION_REPEATABLE_READ：</strong> 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。<br>  它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。</li>
<li><strong>ISOLATION_SERIALIZABLE:</strong> 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。</li>
</ol>
<p><strong>事务的四个特性</strong>  </p>
<ol>
<li><strong>原子性（Atomicity）</strong><br>　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</li>
<li><strong>一致性（Consistency）</strong><br>　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。<br>　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</li>
<li><strong>隔离性（Isolation）</strong><br>　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。<br>　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。<br>　　关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。</li>
<li><strong>持久性（Durability）</strong><br>　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。<br>　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。<br>　　以上介绍完事务的四大特性(简称ACID)，现在重点来说明下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题：  <ol>
<li><strong>脏读:</strong> 指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据， 那么另外一<br>个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。  </li>
<li><strong>不可重复读:</strong> 指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。<br>那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据<br>可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。  </li>
<li><strong>幻觉读:</strong> 指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及<br>到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，<br>以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</li>
</ol>
</li>
</ol>
<p>除了防止脏读，不可重复读外，还避免了幻像读，需要设置事务隔离级别</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/spring.jpg&quot; alt=&quot;spring&quot; title=&quot;spring&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;spring事务传播属性&quot;&gt;&lt;a href=&quot;#spring事务传播属性&quot; class=&quot;headerlink&quot; title=&quot;spring事务传播属性&quot;&gt;&lt;/a&gt;spring事务传播属性&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Propagation（事务的传播属性） ：&lt;/strong&gt;key属性确定代理应该给哪个方法增加事务行为。这样的属性最重要的部份是传播行为。有以下选项可供使用：&lt;br&gt;&lt;strong&gt;PROPAGATION_REQUIRED&lt;/strong&gt;—支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。&lt;br&gt;&lt;strong&gt;PROPAGATION_SUPPORTS&lt;/strong&gt;—支持当前事务，如果当前没有事务，就以非事务方式执行。&lt;br&gt;&lt;strong&gt;PROPAGATION_MANDATORY&lt;/strong&gt;—支持当前事务，如果当前没有事务，就抛出异常。&lt;br&gt;&lt;strong&gt;PROPAGATION_REQUIRES_NEW&lt;/strong&gt;—新建事务，如果当前存在事务，把当前事务挂起。&lt;br&gt;&lt;strong&gt;PROPAGATION_NOT_SUPPORTED&lt;/strong&gt;—以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。&lt;br&gt;&lt;strong&gt;PROPAGATION_NEVER&lt;/strong&gt;—以非事务方式执行，如果当前存在事务，则抛出异常。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://jet-han.oschina.io/categories/java/"/>
    
    
      <category term="spring" scheme="http://jet-han.oschina.io/tags/spring/"/>
    
      <category term="事务传播属性" scheme="http://jet-han.oschina.io/tags/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7/"/>
    
      <category term="隔离级别" scheme="http://jet-han.oschina.io/tags/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>乐观锁与悲观锁及应用举例</title>
    <link href="http://jet-han.oschina.io/2017/08/05/%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%E5%8F%8A%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B/"/>
    <id>http://jet-han.oschina.io/2017/08/05/乐观锁与悲观锁及应用举例/</id>
    <published>2017-08-05T03:53:43.000Z</published>
    <updated>2017-08-13T01:45:26.093Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/mysql.jpg" alt="mysql" title="mysql"></p>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>   正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）的修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。<br>  以常用的mysql InnoDB存储引擎为例：加入商品表items表中有一个字段status，status=1表示该商品未被下单，status=2表示该商品已经被下单，那么我们对每个商品下单前必须确保此商品的status=1。假设有一件商品，其id为10000；如果不使用锁，那么操作方法如下:<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//查出商品状态</div><div class="line">select status from items where id=10000;</div><div class="line">//根据商品信息生成订单</div><div class="line">insert into orders(id,item_id) values(null,10000);</div><div class="line">//修改商品状态为2</div><div class="line">update Items set status=2 where id=10000;</div></pre></td></tr></table></figure>
<p><strong>上述场景在高并发环境下可能出现问题：</strong><br>前面已经提到只有商品的status=1是才能对它进行下单操作，上面第一步操作中，查询出来的商品status为1。但是当我们执行第三步update操作的时候，有可能出现其他人先一步对商品下单把Item的status修改为2了，但是我们并不知道数据已经被修改了，这样就可能造成同一个商品被下单2次，使得数据不一致。所以说这种方式是不安全的。<br>使用悲观锁来实现：在上面的场景中，商品信息从查询出来到修改，中间有一个处理订单的过程，使用悲观锁的原理就是，当我们在查询出items信息后就把当前的数据锁定，直到我们修改完毕后再解锁。那么在这个过程中，因为items被锁定了，就不会出现有第三者来对其进行修改了。<br>注：要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。我们可以使用命令设置MySQL为非autocommit模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">set autocommit=0;</div><div class="line">设置完autocommit后，我们就可以执行我们的正常业务了。具体如下：</div><div class="line">//开始事务</div><div class="line">begin;/begin work;/start transaction; (三者选一就可以)</div><div class="line">//查询出商品信息</div><div class="line">select status from items where id=10000 for update;</div><div class="line">//根据商品信息生成订单</div><div class="line">insert into orders (id,item_id) values (null,10000);</div><div class="line">//修改商品status为2</div><div class="line">update items set status=2 where id=10000;</div><div class="line">//提交事务</div><div class="line">commit;/commit work;</div></pre></td></tr></table></figure></p>
<p>注：上面的begin/commit为事务的开始和结束，因为在前一步我们关闭了mysql的autocommit，所以需要手动控制事务的提交，在这里就不细表了。<br>上面的第一步我们执行了一次查询操作：select status from items where id=10000 for update;与普通查询不一样的是，我们使用了select…for update的方式，这样就通过数据库实现了悲观锁。此时在items表中，id为10000的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。<br>注：需要注意的是，在事务中，只有SELECT … FOR UPDATE 或LOCK IN SHARE MODE 同一笔数据时会等待其它事务结束后才执行，一般SELECT … 则不受此影响。拿上面的实例来说，当我执行select status from items where id=10000 for update;后。我在另外的事务中如果再次执行select status from items where id=10000 for update;则第二个事务会一直等待第一个事务的提交，此时第二个查询处于阻塞的状态，但是如果我是在第二个事务中执行select status from items where id=10000;则能正常查询出数据，不会受第一个事务的影响。<br>上面我们提到，使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认Row-Level Lock，所以只有明确地指定主键，MySQL 才会执行Row lock (只锁住被选取的数据) ，否则MySQL 将会执行Table Lock (将整个数据表单给锁住)。除了主键外，使用索引也会影响数据库的锁定级别。<br>悲观锁并不是适用于任何场景，它也有它存在的一些不足，因为悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。如果加锁的时间过长，其他用户长时间无法访问，影响了程序的并发访问性，同时这样对数据库性能开销影响也很大，特别是对长事务而言，这样的开销往往无法承受。</p>
<h2 id="乐观锁（-Optimistic-Locking-）"><a href="#乐观锁（-Optimistic-Locking-）" class="headerlink" title="乐观锁（ Optimistic Locking ）"></a>乐观锁（ Optimistic Locking ）</h2><p>相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。那么我们如何实现乐观锁呢，一般来说有以下2种方式：  </p>
<ol>
<li><p>使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值+1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。<br>如果更新操作顺序执行，则数据的版本（version）依次递增，不会产生冲突。但是如果发生有不同的业务操作对同一版本的数据进行修改，那么，先提交的操作（图中B）会把数据version更新为2，当A在B之后提交更新时发现数据的version已经被修改了，那么A的更新操作会失败。</p>
</li>
<li><p>乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似（其实不用新加字段，用需要修改的字段作为条件进行修改操作即可），也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。<br>以mysql InnoDB存储引擎为例，还是拿之前的例子商品表items表中有一个字段status，status=1表示该商品未被下单，status=2表示该商品已经被下单，那么我们对每个商品下单前必须确保此商品的status=1。假设有一件商品，其id为10000；<br>下单操作包括3步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//查询出商品信息</div><div class="line">select (status,version) from items where id=#&#123;id&#125;</div><div class="line">//根据商品信息生成订单</div><div class="line">//修改商品status为2</div><div class="line">update items set status=2,version=version+1 where id=#&#123;id&#125; and version=#&#123;version&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>为了使用乐观锁，我们需要首先修改items表，增加一个version字段，数据默认version可设为1；<br>其实我们周围的很多产品都有乐观锁的使用，比如我们经常使用的分布式存储引擎Tair，Tair中存储的每个数据都有版本号，版本号在每次更新后都会递增，相应的，在Tair put接口中也有此version参数，这个参数是为了解决并发更新同一个数据而设置的，这其实就是乐观锁；<br>很多情况下，更新数据是先get，修改get回来的数据，然后put回系统。如果有多个客户端get到同一份数据，都对其修改并保存，那么先保存的修改就会被后到达的修改覆盖，从而导致数据一致性问题,在大部分情况下应用能够接受，但在少量特殊情况下，这个是我们不希望发生的。<br>比如系统中有一个值”1”, 现在A和B客户端同时都取到了这个值。之后A和B客户端都想改动这个值，假设A要改成12，B要改成13，如果不加控制的话，无论A和B谁先更新成功，它的更新都会被后到的更新覆盖。Tair引入的乐观锁机制避免了这样的问题。刚刚的例子中，假设A和B同时取到数据，当时版本号是10，A先更新，更新成功后，值为12，版本为11。当B更新的时候，由于其基于的版本号是10，此时服务器会拒绝更新，返回version error，从而避免A的更新被覆盖。B可以选择get新版本的value，然后在其基础上修改，也可以选择强行更新。<br>当然了，乐观锁也是要精心挑选的，主要的目的就是避免锁的失败率过高又要规避ABA问题。关于锁力度太大导致接口操作失败率过高。<br>商品库存扣减时，尤其是在秒杀、聚划算这种高并发的场景下，若采用version号作为乐观锁，则每次只有一个事务能更新成功，业务感知上就是大量操作失败。<br>若挑选以库存数作为乐观锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">update item </div><div class="line">set </div><div class="line">    quantity=quantity-#sub_quantity# </div><div class="line">where </div><div class="line">    item_id = #id# </div><div class="line">    and quantity-#sub_quantity# &gt; 0</div></pre></td></tr></table></figure></p>
<p>通过挑选乐观锁，可以减小锁力度，从而提升吞吐<br>乐观锁需要灵活运用,现在互联网高并发的架构中，受到fail-fast思路的影响，悲观锁已经非常少见了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/mysql.jpg&quot; alt=&quot;mysql&quot; title=&quot;mysql&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;悲观锁&quot;&gt;&lt;a href=&quot;#悲观锁&quot; class=&quot;headerlink&quot; title=&quot;悲观锁&quot;&gt;&lt;/a&gt;悲观锁&lt;/h2&gt;&lt;p&gt;   正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）的修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。&lt;br&gt;  以常用的mysql InnoDB存储引擎为例：加入商品表items表中有一个字段status，status=1表示该商品未被下单，status=2表示该商品已经被下单，那么我们对每个商品下单前必须确保此商品的status=1。假设有一件商品，其id为10000；如果不使用锁，那么操作方法如下:&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://jet-han.oschina.io/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://jet-han.oschina.io/tags/mysql/"/>
    
      <category term="乐观锁" scheme="http://jet-han.oschina.io/tags/%E4%B9%90%E8%A7%82%E9%94%81/"/>
    
      <category term="悲观锁" scheme="http://jet-han.oschina.io/tags/%E6%82%B2%E8%A7%82%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>mysql事务隔离级别</title>
    <link href="http://jet-han.oschina.io/2017/08/04/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://jet-han.oschina.io/2017/08/04/mysql事务隔离级别/</id>
    <published>2017-08-04T03:58:09.000Z</published>
    <updated>2018-12-11T09:00:58.661Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/08/04/mysql事务隔离级别/mysql.jpg" alt="mysql" title="mysql"></p>
<h1 id="mysql事务隔离级别"><a href="#mysql事务隔离级别" class="headerlink" title="mysql事务隔离级别"></a>mysql事务隔离级别</h1><h2 id="第1级别：Read-Uncommitted-读取未提交内容"><a href="#第1级别：Read-Uncommitted-读取未提交内容" class="headerlink" title="第1级别：Read Uncommitted(读取未提交内容)"></a>第1级别：Read Uncommitted(读取未提交内容)</h2><p>1.所有事务都可以看到其他未提交事务的执行结果<br>2.本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少<br>3.该级别引发的问题是——脏读(Dirty Read)：读取到了未提交的数据<br><a id="more"></a></p>
<pre><code>#首先，修改隔离级别
set tx_isolation=&#39;READ-UNCOMMITTED&#39;;  
select @@tx_isolation; 
| @@tx_isolation |
| READ-UNCOMMITTED |
#事务A：启动一个事务  
start transaction;  
select * from tx;  
| id   | num  |  
|    1 |    1 |  
|    2 |    2 |  
|    3 |    3 |  

#事务B：也启动一个事务(那么两个事务交叉了)  
#在事务B中执行更新语句，且不提交
start transaction;   
update tx set num=10 where id=1;  
select * from tx;
| id   | num  |  
|    1 |   10 |  
|    2 |    2 |  
|    3 |    3 | 

#事务A：那么这时候事务A能看到这个更新了的数据吗?  
select * from tx;  
| id   | num  |  
|    1 |   10 |   ---&gt;可以看到！说明我们读到了事务B还没有提交的数据  
|    2 |    2 |  
|    3 |    3 |  

#事务B：事务B回滚,仍然未提交  
rollback;  
select * from tx;  
| id   | num  |  
|    1 |    1 |  
|    2 |    2 |  
|    3 |    3 |  

#事务A：在事务A里面看到的也是B没有提交的数据
select * from tx;  
| id   | num  |  
|    1 |    1 |      ---&gt;脏读意味着我在这个事务中(A中)，事务B虽然没有提交，但它任何一条数据变化，我都可以看到！  
|    2 |    2 |  
|    3 |    3 |  
</code></pre><h2 id="第2级别：Read-Committed-读取提交内容"><a href="#第2级别：Read-Committed-读取提交内容" class="headerlink" title="第2级别：Read Committed(读取提交内容)"></a>第2级别：Read Committed(读取提交内容)</h2><p>1.这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）<br>2.它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变<br>3.这种隔离级别出现的问题是——不可重复读(Nonrepeatable Read)：不可重复读意味着我们在同一个事务中执行完全相同的select语句时可能看到不一样的结果。<br> ——&gt;导致这种情况的原因可能有：<br> (1)有一个交叉的事务有新的commit，导致了数据的改变;<br> (2)一个数据库被多个实例操作时,同一事务的其他实例在该实例处理其间可能会有新的commit</p>
<pre><code>  #首先修改隔离级别
  set tx_isolation=&#39;read-committed&#39;;  
  select @@tx_isolation;  
  | @@tx_isolation |  
  | READ-COMMITTED |  

  #事务A：启动一个事务
  start transaction;  
  select * from tx;  
  | id   | num  |  
  |    1 |    1 |  
  |    2 |    2 |  
  |    3 |    3 |  

  #事务B：也启动一个事务(那么两个事务交叉了)
  #在这事务中更新数据，且未提交
  start transaction;  
  update tx set num=10 where id=1;  
  select * from tx; 
  | id   | num  |  
  |    1 |   10 |  
  |    2 |    2 |  
  |    3 |    3 |  

  #事务A：这个时候我们在事务A中能看到数据的变化吗?
  select * from tx;
  | id   | num  |  
  |    1 |    1 |---&gt;并不能看到！  
  |    2 |    2 |                 
  |    3 |    3 |     
  |——&gt;相同的select语句，结果却不一样

  #事务B：如果提交了事务B呢?           
  commit;                          

  #事务A:                           
  select * from tx;  
  | id   | num  |  
  |    1 |   10 |---&gt;因为事务B已经提交了，所以在A中我们看到了数据变化  
  |    2 |    2 |  
  |    3 |    3 |  
</code></pre><h2 id="第3级别：Repeatable-Read-可重读"><a href="#第3级别：Repeatable-Read-可重读" class="headerlink" title="第3级别：Repeatable Read(可重读)"></a>第3级别：Repeatable Read(可重读)</h2><p>1.这是MySQL的默认事务隔离级别<br>2.它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行<br>3.此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行<br>4.InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题  </p>
<pre><code>    #首先，更改隔离级别  
    set tx_isolation=&#39;repeatable-read&#39;;  
    select @@tx_isolation;  
    | @@tx_isolation  |
    +------+------+
    | REPEATABLE-READ |
    +------+------+

    #事务A：启动一个事务
    start transaction;  
    select * from tx;  
    | id   | num  |
    +------+------+
    |    1 |    1 |
    |    2 |    2 |
    |    3 |    3 |
    +------+------+

    #事务B：开启一个新事务(那么这两个事务交叉了)
    #在事务B中更新数据，并提交
    start transaction;  
    update tx set num=10 where id=1;  
    select * from tx;  
    +------+------+  
    | id   | num  |  
    +------+------+  
    |    1 |   10 |  
    |    2 |    2 |  
    |    3 |    3 |  
    +------+------+  
    commit;  

    #事务A：这时候即使事务B已经提交了,但A能不能看到数据变化？
    select * from tx;+------+------+  
    | id   | num  |  
    +------+------+  
    |    1 |    1 | ---&gt;还是看不到的！(这个级别2不一样，也说明级别3解决了不可重复读问题)  
    |    2 |    2 |  
    |    3 |    3 |  
    +------+------+  

    #事务A：只有当事务A也提交了，它才能够看到数据变化
    commit;select * from tx;  
    +------+------+  
    | id   | num  |  
    +------+------+  
    |    1 |   10 |  
    |    2 |    2 |  
    |    3 |    3 |  
    +------+------+  
</code></pre><h2 id="第4级别：Serializable-可串行化"><a href="#第4级别：Serializable-可串行化" class="headerlink" title="第4级别：Serializable(可串行化)"></a>第4级别：Serializable(可串行化)</h2><p>1.这是最高的隔离级别<br>2.它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁。<br>3.在这个级别，可能导致大量的超时现象和锁竞争</p>
<pre><code>    #首先修改隔离界别
    set tx_isolation=&#39;serializable&#39;;  
    select @@tx_isolation;  
    +----------------+  
    | @@tx_isolation |  
    +----------------+  
    | SERIALIZABLE   |  
    +----------------+  

    #事务A：开启一个新事务  
    start transaction;  

    #事务B：在A没有commit之前，这个交叉事务是不能更改数据的  
    start transaction;  
    insert tx values(&#39;4&#39;,&#39;4&#39;);  
    ERROR 1205 (HY000): Lock wait timeout exceeded;   
    try restarting transactionupdate tx set num=10 where id=1;ERROR 1205 (HY000): Lock wait timeout exceeded;   
    try restarting transaction  
</code></pre><p><img src="/2017/08/04/mysql事务隔离级别/transaction.jpg" alt="transaction" title="transaction"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017/08/04/mysql事务隔离级别/mysql.jpg&quot; alt=&quot;mysql&quot; title=&quot;mysql&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;mysql事务隔离级别&quot;&gt;&lt;a href=&quot;#mysql事务隔离级别&quot; class=&quot;headerlink&quot; title=&quot;mysql事务隔离级别&quot;&gt;&lt;/a&gt;mysql事务隔离级别&lt;/h1&gt;&lt;h2 id=&quot;第1级别：Read-Uncommitted-读取未提交内容&quot;&gt;&lt;a href=&quot;#第1级别：Read-Uncommitted-读取未提交内容&quot; class=&quot;headerlink&quot; title=&quot;第1级别：Read Uncommitted(读取未提交内容)&quot;&gt;&lt;/a&gt;第1级别：Read Uncommitted(读取未提交内容)&lt;/h2&gt;&lt;p&gt;1.所有事务都可以看到其他未提交事务的执行结果&lt;br&gt;2.本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少&lt;br&gt;3.该级别引发的问题是——脏读(Dirty Read)：读取到了未提交的数据&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://jet-han.oschina.io/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://jet-han.oschina.io/tags/mysql/"/>
    
      <category term="事务隔离级别" scheme="http://jet-han.oschina.io/tags/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>equals、==和hashCode</title>
    <link href="http://jet-han.oschina.io/2017/08/01/equals%E3%80%81-%E5%92%8ChashCode/"/>
    <id>http://jet-han.oschina.io/2017/08/01/equals、-和hashCode/</id>
    <published>2017-08-01T15:47:00.000Z</published>
    <updated>2018-11-04T05:23:40.415Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/java.jpg" alt="java" title="java"></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><strong>equals：</strong>是否同一个对象实例。注意，是“实例”。比如String s = new String(“test”);  s.equals(s), 这就是同一个对象实例的比较；</p>
<p><strong>等号(==)：</strong>对比对象实例的内存地址（也即对象实例的ID），来判断是否是同一对象实例；又可以说是判断对象实例是否物理相等；</p>
<p><strong>Hashcode：</strong>我觉得可以这样理解：并不是对象的内存地址，而是利用hash算法，对对象实例的一种描述符（或者说对象存储位置的hash算法映射）——对象实例的哈希码。</p>
<ul>
<li><p>对于==，比较的是值是否相等</p>
<p> 如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；</p>
</li>
</ul>
<p>　　如果作用于引用类型的变量，则比较的是所指向的对象的地址</p>
<ul>
<li>对于equals方法，注意：equals方法不能作用于基本数据类型的变量，equals继承Object类，比较的是是否是同一个对象</li>
</ul>
<p>　　如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；</p>
<p>　　诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。</p>
<p>==比较的是对象的地址<br>String重写的equals比较的是字符串的内容值<br>String重写的hashCode已经不是对象内存地址的hash码，是根据内容产生的，因为a、b是两个完全不同的对象，也满足这条规律“equals相等的两个对象，hashCode也相等”。<br>System.identityHashCode是未被重写的获取对象内存地址hash码的函数，new出来的String对象的内存地址是不一样的，所以hash值也不一样<br><a id="more"></a></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">  public static void main(String[] args) &#123;</div><div class="line">     String a=new String(&quot;foo&quot;);</div><div class="line">     String b=new String(&quot;foo&quot;);</div><div class="line"></div><div class="line">     String c=&quot;hello&quot;;</div><div class="line">     String d=&quot;hello&quot;;</div><div class="line"></div><div class="line">     System.out.println(&quot;memory address hashcode a:&quot;+System.identityHashCode(a));</div><div class="line">     System.out.println(&quot;memory address hashcode a:&quot;+System.identityHashCode(b));</div><div class="line">     System.out.println(&quot;String hashcode a:        &quot;+a.hashCode());</div><div class="line">     System.out.println(&quot;String hashcode a:        &quot;+b.hashCode());</div><div class="line">     System.out.println(&quot;a==b:                     &quot;+(a==b));</div><div class="line">     System.out.println(&quot;a.equals(b):              &quot;+a.equals(b));</div><div class="line"></div><div class="line">     System.out.println(&quot;&quot;);</div><div class="line"></div><div class="line">     System.out.println(&quot;memory address hashcode c:&quot;+System.identityHashCode(c));</div><div class="line">     System.out.println(&quot;memory address hashcode d:&quot;+System.identityHashCode(d));</div><div class="line">     System.out.println(&quot;String hashcode c:        &quot;+c.hashCode());</div><div class="line">     System.out.println(&quot;String hashcode d:        &quot;+d.hashCode());</div><div class="line">     System.out.println(&quot;c==d:                     &quot;+(c==d));</div><div class="line">     System.out.println(&quot;c.equals(d):              &quot;+c.equals(d));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>结果：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">memory address hashcode a:8222510</div><div class="line">memory address hashcode a:18581223</div><div class="line">String hashcode a:        101574</div><div class="line">String hashcode a:        101574</div><div class="line">a==b:                     false</div><div class="line">a.equals(b):              true</div><div class="line">memory address hashcode c:3526198</div><div class="line">memory address hashcode d:3526198</div><div class="line">String hashcode c:        99162322</div><div class="line">String hashcode d:        99162322</div><div class="line">c==d:                     true</div><div class="line">c.equals(d):              true</div></pre></td></tr></table></figure></p>
<h2 id="从Java集合的常用需求为什么需要使用Hashcode"><a href="#从Java集合的常用需求为什么需要使用Hashcode" class="headerlink" title="从Java集合的常用需求为什么需要使用Hashcode"></a>从Java集合的常用需求为什么需要使用Hashcode</h2><p>Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？这就是 Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。</p>
<p>于是，Java采用了哈希表的原理。哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。可以这样简单理解，hashCode方法实际上返回的就是对象存储位置的映像。</p>
<p>这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就能定位到它应该放置的bucket存储位置。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就表示发生冲突了，散列表对于冲突有具体的解决办法，但最终还会将新元素保存在适当的位置。这样一来，实际调用equals方法的次数就大大降低了，几乎只需要一两次。</p>
<p>简单归纳，hashmap的深入理解：</p>
<p>HashMap的数据结构是基于<font color="#c00">数组和链表</font>的。（以数组存储元素，如有hash相同的元素，在数组结构中，创建链表结构，再把hash相同的元素放到链表的下一个节点）</p>
<p>hashMap的结构类似这样<br>  元素0—&gt;[hashCode=0, key.value=x1的数据]<br>  元素1—&gt;[hashCode=1, key.value=y1的数据]<br>  。。。。。。<br>  元素n—&gt;[hashCode=n, key.value=z1的数据]</p>
<p>假设没有hashCode=1的元素加入，但是有两个hashCode=0的数据，它的结构就变成这样<br>  元素0—&gt;[hashCode=0, key.value=x1的数据].next—&gt;[hashCode=0, key.value=x2的数据]<br>  元素1—&gt;[null]<br>  ……<br>  元素n—&gt;[hashCode=n, key.value=z1的数据]</p>
<p>put和get都首先会调用hashcode方法，去查找相关的key，当有冲突时，再调用equals（这也是为什么刚开始就重温hashcode和equals的原因）！<br>HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。</p>
<p>当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。</p>
<p><strong>HashMap的工作原理</strong><br>HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。</p>
<p>当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。</p>
<h2 id="重写-equals-的时候必须重写-hashCode"><a href="#重写-equals-的时候必须重写-hashCode" class="headerlink" title="重写 equals 的时候必须重写 hashCode"></a>重写 equals 的时候必须重写 hashCode</h2><p>SUN官方的文档中规定”如果重定义equals方法，就必须重定义hashCode方法,以便用户可以将对象插入到散列(哈希)表中” </p>
<p>那么 SUN 公司是出于什么考虑做了这个规定呢？ </p>
<p>在集合框架中的HashSet，HashTable和HashMap都使用哈希表的形式存储数据，而hashCode计算出来的哈希码便是它们的身份证。哈希码的存在便可以： </p>
<p>快速定位对象，提高哈希表集合的性能。<br>只有当哈希表中对象的索引即hashCode和对象的属性即equals同时相等时，才能够判断两个对象相等。<br>从上面可以看出，哈希码主要是为哈希表服务的，其实如果不需要使用哈希表，也可以不重写hashCode。但是SUN公司应该是出于对程序扩展性的考虑（万一以后需要将对象放入哈希表集合中），才会规定重写equals的同时需要重写hashCode，以避免后续开发不必要的麻烦。  </p>
<p><strong>重写equals的注意事项</strong>  </p>
<p>Java语言规范要求equals需要具有如下的特性： </p>
<p><strong>自反性：</strong>对于任何非空引用 x，x.equals() 应该返回 true。<br><strong>对称性：</strong>对于任何引用 x 和 y，当且仅当 y.equals(x) 返回 true，x.equals(y) 也应该返回 true。<br><strong>传递性：</strong>对于任何引用 x、y 和 z，如果 x.equals(y)返回 true，y.equals(z) 也应返回同样的结果。<br><strong>一致性：</strong>如果 x 和 y 引用的对象没有发生变化，反复调用 x.equals(y) 应该返回同样的结果。<br>对于任意非空引用 x，x.equals(null) 应该返回 false。<br>在对象比较时，我们应该如何编写出一个符合特性的 equals 方法呢，《Core Java》中提出了如下建议：</p>
<p>显式参数命名为 otherObject，稍后将它转换成另一个叫做 other 的变量。<br>检测 this 与 otherObject 是否引用同一个对象： </p>
<p>if (this == otherObject) return true;<br>计算这个等式可以避免一个个比较类中的域，实现优化。</p>
<p>检测 otherObject 是否为 null，如果为 null，返回 false。进行非空校验是十分重要的。</p>
<p>比较 this 与 otherObject 是否属于同一个类。</p>
<p>如果每个子类都重写了 equals，使用 getClass 检验：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (getClass() != otherObject.getClass()) </div><div class="line">    return false;</div></pre></td></tr></table></figure></p>
<p>如果所有子类都使用同一个 equals，就用 instanceof 检验：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (!(otherObject instanceof ClassName))</div><div class="line">    return false;</div></pre></td></tr></table></figure></p>
<p>将 otherObject 转换为相应的类型变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ClassName other = (ClassName) otherObject;</div></pre></td></tr></table></figure></p>
<p>现在可以对所有需要比较的域进行比较了。</p>
<p>基本类型使用 == 比较<br>对象使用 equals 比较<br>数组类型的域可以使用静态方法 Arrays.equals检测相应数组元素是否相等<br>如果所有域匹配，则返回 true<br>注意：子类重写父类 equals 方法时，必须完全覆盖父类方法，不能因为类型错误或者其他原因定义了一个完全无关的方法。可以使用 @Override 注解对覆盖父类的方法进行标记，这样编译器便会检测到覆盖过程中的错误。</p>
<p><strong>重写 hashCode 的注意事项</strong><br>散列码（hash code）是由对象导出的一个整型值。散列码没有规律，在不同的对象中通过不同的算法生成，Java中生成 hashCode 的策略为（以下说明均摘自 Java API 8）：</p>
<p><strong>String 类的 hashCode 根据其字符串内容，使用算法计算后返回哈希码。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Returns a hash code for this string. The hash code for a String object is computed as s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</div></pre></td></tr></table></figure></p>
<p><strong>Integer 类返回的哈希码为其包含的整数数值。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Returns: a hash code value for this object, equal to the primitive int value represented by this Integer object.</div></pre></td></tr></table></figure></p>
<p><strong>Object 类的 hashCode 返回对象的内存地址经过处理后的数值。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Returns a hash code value for the object. This method is supported for the benefit of hash tables such as those provided by HashMap.</div></pre></td></tr></table></figure></p>
<p>在自己的类中想要重写 hashCode 的话一般怎么做呢？建议合理地组合实例域的散列码，让各个不同对象产生的散列码更加均匀。例如我们现在有一个 Cat 对象，它有 name、size 和 color 三个不同域，那么可以重写 hashCode 方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Cat &#123;</div><div class="line">    ......</div><div class="line">    public int hashCode() &#123;</div><div class="line">        //hashCode是可以返回负值的</div><div class="line">        return 6 * name.hashCode()</div><div class="line">            + 8 * new Double(size).hashCode()</div><div class="line">            + 10 * color.hashCode();</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然还有更好的做法，我们可以直接调用静态方法 Objects.hash 并提供多个参数。这个方法会对各个参数调用 Object.hashCode，并组合返回的散列码。故以上的方法可以缩写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public int hashCode() &#123;</div><div class="line">    return Objects.hash(name, size, color);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>【注意】 <font color="#c00">equals与hashCode的定义必须一致，两个对象equals为true，就必须有相同的hashCode。</font>例如：如果定义的equals比较的是小猫的 name，那么hashCode就需要散列该 name，而不是小猫的 color 或 size。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;equals：&lt;/strong&gt;是否同一个对象实例。注意，是“实例”。比如String s = new String(“test”);  s.equals(s), 这就是同一个对象实例的比较；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;等号(==)：&lt;/strong&gt;对比对象实例的内存地址（也即对象实例的ID），来判断是否是同一对象实例；又可以说是判断对象实例是否物理相等；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hashcode：&lt;/strong&gt;我觉得可以这样理解：并不是对象的内存地址，而是利用hash算法，对对象实例的一种描述符（或者说对象存储位置的hash算法映射）——对象实例的哈希码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于==，比较的是值是否相等&lt;/p&gt;
&lt;p&gt; 如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　如果作用于引用类型的变量，则比较的是所指向的对象的地址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于equals方法，注意：equals方法不能作用于基本数据类型的变量，equals继承Object类，比较的是是否是同一个对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；&lt;/p&gt;
&lt;p&gt;　　诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。&lt;/p&gt;
&lt;p&gt;==比较的是对象的地址&lt;br&gt;String重写的equals比较的是字符串的内容值&lt;br&gt;String重写的hashCode已经不是对象内存地址的hash码，是根据内容产生的，因为a、b是两个完全不同的对象，也满足这条规律“equals相等的两个对象，hashCode也相等”。&lt;br&gt;System.identityHashCode是未被重写的获取对象内存地址hash码的函数，new出来的String对象的内存地址是不一样的，所以hash值也不一样&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://jet-han.oschina.io/categories/java/"/>
    
    
      <category term="java" scheme="http://jet-han.oschina.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>HashMap工作原理</title>
    <link href="http://jet-han.oschina.io/2017/07/28/HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://jet-han.oschina.io/2017/07/28/HashMap工作原理/</id>
    <published>2017-07-28T08:05:02.000Z</published>
    <updated>2018-12-07T02:54:44.220Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/07/28/HashMap工作原理/java.jpg" alt="java" title="java"></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>HashMap的工作原理是近年来常见的Java面试题。几乎每个Java程序员都知道HashMap，都知道哪里要用HashMap，知道Hashtable和HashMap之间的区别，那么为何这道面试题如此特殊呢？是因为这道题考察的深度很深。这题经常出现在高级或中高级面试中。投资银行更喜欢问这个问题，甚至会要求你实现HashMap来考察你的编程能力。ConcurrentHashMap和其它同步集合的引入让这道题变得更加复杂。让我们开始探索的旅程吧！<br><a id="more"></a></p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><strong>“你用过HashMap吗？” “什么是HashMap？你为什么用到它？”</strong></p>
<p>几乎每个人都会回答“是的”，然后回答HashMap的一些特性，譬如HashMap可以接受null键值和值，而Hashtable则不能；HashMap是非synchronized;HashMap很快；以及HashMap储存的是键值对等等。这显示出你已经用过HashMap，而且对它相当的熟悉。但是面试官来个急转直下，从此刻开始问出一些刁钻的问题，关于HashMap的更多基础的细节。面试官可能会问出下面的问题：</p>
<p><strong>“你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？”</strong><br>你也许会回答“我没有详查标准的Java API，你可以看看Java源代码或者Open JDK。”“我可以用Google找到答案。”</p>
<p>但一些面试者可能可以给出答案，“HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用<code>get(key)</code>从HashMap中获取对象。当我们给<code>put()</code>方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry。这一点有助于理解获取对象的逻辑。如果你没有意识到这一点，或者错误的认为仅仅只在bucket中存储值的话，你将不会回答如何从HashMap中获取对象的逻辑。这个答案相当的正确，也显示出面试者确实知道hashing以及HashMap的工作原理。但是这仅仅是故事的开始，当面试官加入一些Java程序员每天要碰到的实际场景的时候，错误的答案频现。下个问题可能是关于HashMap中的碰撞探测(collision detection)以及碰撞的解决方法：</p>
<p>“当两个对象的hashcode相同会发生什么？” 从这里开始，真正的困惑开始了，一些面试者会回答因为hashcode相同，所以两个对象是相等的，HashMap将会抛出异常，或者不会存储它们。然后面试官可能会提醒他们有equals()和hashCode()两个方法，并告诉他们两个对象就算hashcode相同，但是它们可能并不相等。一些面试者可能就此放弃，而另外一些还能继续挺进，他们回答“因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。”这个答案非常的合理，虽然有很多种处理碰撞的方法，这种方法是最简单的，也正是HashMap的处理方法。但故事还没有完结，面试官会继续问：</p>
<p>“如果两个键的hashcode相同，你如何获取值对象？” 面试者会回答：当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。面试官提醒他如果有两个值对象储存在同一个bucket，他给出答案:将会遍历链表直到找到值对象。面试官会问因为你并没有值对象去比较，你是如何确定确定找到值对象的？除非面试者知道HashMap在链表中存储的是键值对，否则他们不可能回答出这一题。</p>
<p>其中一些记得这个重要知识点的面试者会说，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。完美的答案！</p>
<p>许多情况下，面试者会在这个环节中出错，因为他们混淆了<code>hashCode()</code>和<code>equals()</code>方法。因为在此之前hashCode()屡屡出现，而equals()方法仅仅在获取值对象的时候才出现。一些优秀的开发者会指出使用不可变的、声明作final的对象，并且采用合适的<code>equals()</code>和<code>hashCode()</code>方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。</p>
<p>如果你认为到这里已经完结了，那么听到下面这个问题的时候，你会大吃一惊。“如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？”除非你真正知道HashMap的工作原理，否则你将回答不出这道题。默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。</p>
<p>如果你能够回答这道问题，下面的问题来了：“你了解重新调整HashMap大小存在什么问题吗？”你可能回答不上来，这时面试官会提醒你当多线程的情况下，可能产生条件竞争(race condition)。</p>
<p>当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？：）</p>
<p>为什么<code>String</code>, <code>Interger</code>这样的<code>wrapper</code>类适合作为键？ String, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且<code>String</code>最为常用。因为String是不可变的，也是final的，而且已经重写了<code>equals()</code>和<code>hashCode()</code>方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算<code>hashCode()</code>，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。<br>我们可以使用自定义的对象作为键吗？ 这是前一个问题的延伸。当然你可能使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。<br>我们可以使用CocurrentHashMap来代替Hashtable吗？这是另外一个很热门的面试题，因为ConcurrentHashMap越来越多人用了。我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。看看这篇博客查看Hashtable和ConcurrentHashMap的区别。<br>我个人很喜欢这个问题，因为这个问题的深度和广度，也不直接的涉及到不同的概念。让我们再来看看这些问题设计哪些知识点：</p>
<p>hashing的概念<br>HashMap中解决碰撞的方法<br><code>equals()</code>和<code>hashCode()</code>的应用，以及它们在HashMap中的重要性<br>不可变对象的好处<br>HashMap多线程的条件竞争<br>重新调整HashMap的大小</p>
<h3 id="HashMap的工作原理"><a href="#HashMap的工作原理" class="headerlink" title="HashMap的工作原理"></a>HashMap的工作原理</h3><p><code>HashMap</code> 里面是一个数组，然后数组中每个元素是一个单向链表,存储的是<code>Entry</code>对象，包含四个属性：key, value, hash 值和用于单向链表的 next。<br><code>capacity</code>：当前数组容量，始终保持 <code>2^n</code>，可以扩容，扩容后数组大小为当前的 2 倍。<br><code>loadFactor</code>：负载因子，默认为 0.75。<br><code>threshold</code>：扩容的阈值，等于 capacity * loadFactor</p>
<p>HashMap基于hashing原理，我们通过<code>put()</code>和<code>get()</code>方法储存和获取对象。当我们将键值对传递给<code>put()</code>方法时，它调用键对象的<code>hashCode()</code>方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的<code>equals()</code>方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。</p>
<p>当两个不同的键对象的<code>hashcode</code>相同时会发生什么？ 它们会储存在同一个<code>bucket位置的链表中。键对象的</code>equals()<code>方法用来找到键值对</code>。</p>
<p>因为HashMap的好处非常多，我曾经在电子商务的应用中使用HashMap作为缓存。因为金融领域非常多的运用Java，也出于性能的考虑，我们会经常用到<code>HashMap</code>和<code>ConcurrentHashMap</code>。</p>
<p>简单归纳，hashmap的深入理解：</p>
<p>HashMap的数据结构是基于<font color="#c00">数组和链表</font>的。（以数组存储元素，如有hash相同的元素，在数组结构中，创建链表结构，再把hash相同的元素放到链表的下一个节点）</p>
<p>hashMap的结构类似这样<br>  元素0—&gt;[hashCode=0, key.value=x1的数据]<br>  元素1—&gt;[hashCode=1, key.value=y1的数据]<br>  。。。。。。<br>  元素n—&gt;[hashCode=n, key.value=z1的数据]  </p>
<p>假设没有hashCode=1的元素加入，但是有两个hashCode=0的数据，它的结构就变成这样<br>  元素0—&gt;[hashCode=0, key.value=x1的数据].next—&gt;[hashCode=0, key.value=x2的数据]<br>  元素1—&gt;[null]<br>  ……<br>  元素n—&gt;[hashCode=n, key.value=z1的数据]  </p>
<p><code>put</code>和<code>get</code>都首先会调用<code>hashcode</code>方法，去查找相关的<code>key</code>，当有冲突时，再调用<code>equals</code>（这也是为什么刚开始就重温<code>hashcode</code>和<code>equals</code>的原因）！</p>
<h4 id="put过程"><a href="#put过程" class="headerlink" title="put过程"></a>put过程</h4><pre><code>public V put(K key, V value) {
    // 当插入第一个元素的时候，需要先初始化数组大小
    if (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
    // 如果 key 为 null，感兴趣的可以往里看，最终会将这个 entry 放到 table[0] 中
    if (key == null)
        return putForNullKey(value);
    // 1. 求 key 的 hash 值
    int hash = hash(key);
    // 2. 找到对应的数组下标
    int i = indexFor(hash, table.length);
    // 3. 遍历一下对应下标处的链表，看是否有重复的 key 已经存在，
    //    如果有，直接覆盖，put 方法返回旧值就结束了
    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }
    modCount++;
    // 4. 不存在重复的 key，将此 entry 添加到链表中，细节后面说
    addEntry(hash, key, value, i);
    return null;
}
</code></pre><h4 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h4><p>在第一个元素插入 HashMap 的时候做一次数组的初始化，就是先确定初始的数组大小，并计算数组扩容的阈值。</p>
<pre><code>private void inflateTable(int toSize) {
    // 保证数组大小一定是 2 的 n 次方。
    // 比如这样初始化：new HashMap(20)，那么处理成初始数组大小是 32
    int capacity = roundUpToPowerOf2(toSize);
    // 计算扩容阈值：capacity * loadFactor
    threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);
    // 算是初始化数组吧
    table = new Entry[capacity];
    initHashSeedAsNeeded(capacity); //ignore
}
</code></pre><p>这里有一个将数组大小保持为 2 的 n 次方的做法，Java7 和 Java8 的 HashMap 和 ConcurrentHashMap 都有相应的要求，只不过实现的代码稍微有些不同，后面再看到的时候就知道了。</p>
<h4 id="计算具体数组位置"><a href="#计算具体数组位置" class="headerlink" title="计算具体数组位置"></a>计算具体数组位置</h4><p>这个简单，我们自己也能 YY 一个：使用 key 的 hash 值对数组长度进行取模就可以了。</p>
<pre><code>static int indexFor(int hash, int length) {
    // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;
    return hash &amp; (length-1);
}
</code></pre><p>这个方法很简单，简单说就是取 hash 值的低 n 位。如在数组长度为 32 的时候，其实取的就是 key 的 hash 值的低 5 位，作为它在数组中的下标位置。</p>
<h4 id="添加节点到链表中"><a href="#添加节点到链表中" class="headerlink" title="添加节点到链表中"></a>添加节点到链表中</h4><p>找到数组下标后，会先进行 key 判重，如果没有重复，就准备将新值放入到链表的表头。</p>
<pre><code>void addEntry(int hash, K key, V value, int bucketIndex) {
    // 如果当前 HashMap 大小已经达到了阈值，并且新值要插入的数组位置已经有元素了，那么要扩容
    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {
        // 扩容，后面会介绍一下
        resize(2 * table.length);
        // 扩容以后，重新计算 hash 值
        hash = (null != key) ? hash(key) : 0;
        // 重新计算扩容后的新的下标
        bucketIndex = indexFor(hash, table.length);
    }
    // 往下看
    createEntry(hash, key, value, bucketIndex);
}
// 这个很简单，其实就是将新值放到链表的表头，然后 size++
void createEntry(int hash, K key, V value, int bucketIndex) {
    Entry&lt;K,V&gt; e = table[bucketIndex];
    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);
    size++;
}
</code></pre><p>这个方法的主要逻辑就是先判断是否需要扩容，需要的话先扩容，然后再将这个新的数据插入到扩容后的数组的相应位置处的链表的表头。</p>
<h4 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h4><p>前面我们看到，在插入新值的时候，如果当前的 size 已经达到了阈值，并且要插入的数组位置上已经有元素，那么就会触发扩容，扩容后，数组大小为原来的 2 倍。</p>
<p>当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。   </p>
<p>那么<code>hashmap</code>什么时候进行扩容呢？当<code>hashmap</code>中的元素个数超过数组大小 * loadFactor时，就会进行数组扩容，<code>loadFactor</code>的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当<code>hashmap</code>中元素个数超过16 * 0.75=12的时候，就把数组的大小扩展为2 * 16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75 *  1000 &lt; 1000, 也就是说为了让0.75 * size &gt; 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&amp;的问题，也避免了resize的问题。</p>
<pre><code>void resize(int newCapacity) {
    Entry[] oldTable = table;
    int oldCapacity = oldTable.length;
    if (oldCapacity == MAXIMUM_CAPACITY) {
        threshold = Integer.MAX_VALUE;
        return;
    }
    // 新的数组
    Entry[] newTable = new Entry[newCapacity];
    // 将原来数组中的值迁移到新的更大的数组中
    transfer(newTable, initHashSeedAsNeeded(newCapacity));
    table = newTable;
    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
}
</code></pre><p>扩容就是用一个新的大数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。</p>
<p>由于是双倍扩容，迁移过程中，会将原来 table[i] 中的链表的所有节点，分拆到新的数组的 newTable[i] 和 newTable[i + oldLength] 位置上。如原来数组长度是 16，那么扩容后，原来 table[0] 处的链表中的所有元素会被分配到新数组中 newTable[0] 和 newTable[16] 这两个位置。代码比较简单，这里就不展开了。</p>
<h4 id="get过程"><a href="#get过程" class="headerlink" title="get过程"></a>get过程</h4><p>相对于 put 过程，get 过程是非常简单的。<br>根据 key 计算 hash 值。<br>找到相应的数组下标：hash &amp; (length – 1)。<br>遍历该数组位置处的链表，直到找到相等(==或equals)的 key。</p>
<pre><code>public V get(Object key) {
    // 之前说过，key 为 null 的话，会被放到 table[0]，所以只要遍历下 table[0] 处的链表就可以了
    if (key == null)
        return getForNullKey();
    Entry&lt;K,V&gt; entry = getEntry(key);
    return null == entry ? null : entry.getValue();
}
getEntry(key):
final Entry&lt;K,V&gt; getEntry(Object key) {
        return null;
    }
    int hash = (key == null) ? 0 : hash(key);
    // 确定数组下标，然后从头开始遍历链表，直到找到为止
    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];
         e != null;
         e = e.next) {
        Object k;
        if (e.hash == hash &amp;&amp;
            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
            return e;
    }
    return null;
}
</code></pre><h3 id="Java7-ConcurrentHashMap"><a href="#Java7-ConcurrentHashMap" class="headerlink" title="Java7 ConcurrentHashMap"></a>Java7 ConcurrentHashMap</h3><p><code>ConcurrentHashMap</code> 和 <code>HashMap</code> 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。</p>
<p>整个 <code>ConcurrentHashMap</code> 由一个个 <code>Segment</code> 组成，<code>Segment</code> 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个 <code>segmen</code>t。</p>
<p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p>
<p><img src="/2017/07/28/HashMap工作原理/concurrentHashMap.png" alt="ConcurrentHashMap" title="ConcurrentHashMap"></p>
<p>concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。</p>
<p>再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><code>initialCapacity</code>：初始容量，这个值指的是整个 <code>ConcurrentHashMap</code> 的初始容量，实际操作的时候需要平均分给每个 <code>Segment</code>。</p>
<p><code>loadFactor</code>：负载因子，之前我们说了，<code>Segment</code> 数组不可以扩容，所以这个负载因子是给每个 <code>Segment</code> 内部使用的。</p>
<pre><code>public ConcurrentHashMap(int initialCapacity,
                         float loadFactor, int concurrencyLevel) {

    if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)
        throw new IllegalArgumentException();
    if (concurrencyLevel &gt; MAX_SEGMENTS)
        concurrencyLevel = MAX_SEGMENTS;
    // Find power-of-two sizes best matching arguments
    int sshift = 0;
    int ssize = 1;
    // 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方
    while (ssize &lt; concurrencyLevel) {
        ++sshift;
        ssize &lt;&lt;= 1;
    }
    // 我们这里先不要那么烧脑，用默认值，concurrencyLevel 为 16，sshift 为 4
    // 那么计算出 segmentShift 为 28，segmentMask 为 15，后面会用到这两个值
    this.segmentShift = 32 - sshift;
    this.segmentMask = ssize - 1;
    if (initialCapacity &gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    // initialCapacity 是设置整个 map 初始的大小，
    // 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小
    // 如 initialCapacity 为 64，那么每个 Segment 或称之为&quot;槽&quot;可以分到 4 个
    int c = initialCapacity / ssize;
    if (c * ssize &lt; initialCapacity)
        ++c;
    // 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上，
    // 插入一个元素不至于扩容，插入第二个的时候才会扩容
    int cap = MIN_SEGMENT_TABLE_CAPACITY; 
    while (cap &lt; c)
        cap &lt;&lt;= 1;
    // 创建 Segment 数组，
    // 并创建数组的第一个元素 segment[0]
    Segment&lt;K,V&gt; s0 =
        new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),
                         (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);
    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];
    // 往数组写入 segment[0]
    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]
    this.segments = ss;
}
</code></pre><p>初始化完成，我们得到了一个 <code>Segment</code> 数组。</p>
<p>我们就当是用 <code>new ConcurrentHashMap()</code> 无参构造函数进行初始化的，那么初始化完成后：</p>
<ul>
<li><code>Segment</code> 数组长度为 16，不可以扩容</li>
<li><code>Segment[i]</code> 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容</li>
<li>这里初始化了 <code>segment[0]</code>，其他位置还是 <code>null</code>，至于为什么要初始化 segment[0]，后面的代码会介绍</li>
<li>当前 <code>segmentShift</code> 的值为 32 – 4 = 28，<code>segmentMask</code> 为 16 – 1 = 15，姑且把它们简单翻译为移位数和掩码，这两个值马上就会用到</li>
</ul>
<h4 id="put-过程分析"><a href="#put-过程分析" class="headerlink" title="put 过程分析"></a>put 过程分析</h4><p>我们先看 put 的主流程，对于其中的一些关键细节操作，后面会进行详细介绍。</p>
<pre><code>  public V put(K key, V value) {

      Segment&lt;K,V&gt; s;

      if (value == null)

          throw new NullPointerException();

      // 1. 计算 key 的 hash 值

      int hash = hash(key);

      // 2. 根据 hash 值找到 Segment 数组中的位置 j

      //    hash 是 32 位，无符号右移 segmentShift(28) 位，剩下低 4 位，

      //    然后和 segmentMask(15) 做一次与操作，也就是说 j 是 hash 值的最后 4 位，也就是槽的数组下标

      int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;

      // 刚刚说了，初始化的时候初始化了 segment[0]，但是其他位置还是 null，

      // ensureSegment(j) 对 segment[j] 进行初始化

      if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck

           (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment

          s = ensureSegment(j);

      // 3. 插入新值到 槽 s 中

      return s.put(key, hash, value, false);

  }
</code></pre><p>第一层皮很简单，根据 hash 值很快就能找到相应的 Segment，之后就是 Segment 内部的 put 操作了。<br>Segment 内部是由 数组+链表 组成的。</p>
<pre><code>final V put(K key, int hash, V value, boolean onlyIfAbsent) {
    // 在往该 segment 写入前，需要先获取该 segment 的独占锁
    //    先看主流程，后面还会具体介绍这部分内容
    HashEntry&lt;K,V&gt; node = tryLock() ? null :
        scanAndLockForPut(key, hash, value);
    V oldValue;
    try {
        // 这个是 segment 内部的数组
        HashEntry&lt;K,V&gt;[] tab = table;
        // 再利用 hash 值，求应该放置的数组下标
        int index = (tab.length - 1) &amp; hash;
        // first 是数组该位置处的链表的表头
        HashEntry&lt;K,V&gt; first = entryAt(tab, index);
        // 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况
        for (HashEntry&lt;K,V&gt; e = first;;) {
            if (e != null) {
                K k;
                if ((k = e.key) == key ||
                    (e.hash == hash &amp;&amp; key.equals(k))) {
                    oldValue = e.value;
                    if (!onlyIfAbsent) {
                        // 覆盖旧值
                        e.value = value;
                        ++modCount;
                    }
                    break;
                }
                // 继续顺着链表走
                e = e.next;
            }
            else {
                // node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。
                // 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。
                if (node != null)
                    node.setNext(first);
                else
                    node = new HashEntry&lt;K,V&gt;(hash, key, value, first);
                int c = count + 1;
                // 如果超过了该 segment 的阈值，这个 segment 需要扩容
                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)
                    rehash(node); // 扩容后面也会具体分析
                else
                    // 没有达到阈值，将 node 放到数组 tab 的 index 位置，
                    // 其实就是将新的节点设置成原链表的表头
                    setEntryAt(tab, index, node);
                ++modCount;
                count = c;
                oldValue = null;
                break;
            }
        }
    } finally {
        // 解锁
        unlock();
    }
    return oldValue;
}
</code></pre><p>整体流程还是比较简单的，由于有独占锁的保护，所以 <code>segment</code> 内部的操作并不复杂。至于这里面的并发问题，我们稍后再进行介绍。</p>
<p>到这里 <code>put</code> 操作就结束了，接下来，我们说一说其中几步关键的操作。</p>
<p>初始化槽: <code>ensureSegment</code></p>
<p><code>ConcurrentHashMap</code> 初始化的时候会初始化第一个槽 <code>segment[0]</code>，对于其他槽来说，在插入第一个值的时候进行初始化。</p>
<p>这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽 <code>segment[k]</code>，不过只要有一个成功了就可以。</p>
<pre><code>private Segment&lt;K,V&gt; ensureSegment(int k) {

    final Segment&lt;K,V&gt;[] ss = this.segments;

    long u = (k &lt;&lt; SSHIFT) + SBASE; // raw offset

    Segment&lt;K,V&gt; seg;

    if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) {

        // 这里看到为什么之前要初始化 segment[0] 了，

        // 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]

        // 为什么要用“当前”，因为 segment[0] 可能早就扩容过了

        Segment&lt;K,V&gt; proto = ss[0];

        int cap = proto.table.length;

        float lf = proto.loadFactor;

        int threshold = (int)(cap * lf);



        // 初始化 segment[k] 内部的数组

        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])new HashEntry[cap];

        if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))

            == null) { // 再次检查一遍该槽是否被其他线程初始化了。



            Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab);

            // 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出

            while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))

                   == null) {

                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))

                    break;

            }

        }

    }

    return seg;

}
</code></pre><p>总的来说，<code>ensureSegment(int k)</code> 比较简单，对于并发操作使用 <code>CAS</code> 进行控制。</p>
<p>我没搞懂这里为什么要搞一个 while 循环，CAS 失败不就代表有其他线程成功了吗，为什么要再进行判断？</p>
<p>获取写入锁: <code>scanAndLockForPut</code></p>
<p>前面我们看到，在往某个 segment 中 put 的时候，首先会调用 node = tryLock() ? null : scanAndLockForPut(key, hash, value)，也就是说先进行一次 tryLock() 快速获取该 segment 的独占锁，如果失败，那么进入到 scanAndLockForPut 这个方法来获取锁。</p>
<p>下面我们来具体分析这个方法中是怎么控制加锁的。</p>
<pre><code>private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) {

    HashEntry&lt;K,V&gt; first = entryForHash(this, hash);

    HashEntry&lt;K,V&gt; e = first;

    HashEntry&lt;K,V&gt; node = null;

    int retries = -1; // negative while locating node



    // 循环获取锁

    while (!tryLock()) {

        HashEntry&lt;K,V&gt; f; // to recheck first below

        if (retries &lt; 0) {

            if (e == null) {

                if (node == null) // speculatively create node

                    // 进到这里说明数组该位置的链表是空的，没有任何元素

                    // 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置

                    node = new HashEntry&lt;K,V&gt;(hash, key, value, null);

                retries = 0;

            }

            else if (key.equals(e.key))

                retries = 0;

            else

                // 顺着链表往下走

                e = e.next;

        }

        // 重试次数如果超过 MAX_SCAN_RETRIES（单核1多核64），那么不抢了，进入到阻塞队列等待锁

        //    lock() 是阻塞方法，直到获取锁后返回

        else if (++retries &gt; MAX_SCAN_RETRIES) {

            lock();

            break;

        }

        else if ((retries &amp; 1) == 0 &amp;&amp;

                 // 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头

                 //     所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法

                 (f = entryForHash(this, hash)) != first) {

            e = first = f; // re-traverse if entry changed

            retries = -1;

        }

    }

    return node;

}
</code></pre><p>这个方法有两个出口，一个是 tryLock() 成功了，循环终止，另一个就是重试次数超过了 MAX_SCAN_RETRIES，进到 lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。</p>
<p>这个方法就是看似复杂，但是其实就是做了一件事，那就是获取该 segment 的独占锁，如果需要的话顺便实例化了一下 node。</p>
<h4 id="扩容-rehash"><a href="#扩容-rehash" class="headerlink" title="扩容: rehash"></a>扩容: rehash</h4><p>重复一下，<code>segment</code> 数组不能扩容，扩容是 <code>segment</code> 数组某个位置内部的数组 <code>HashEntry\[]</code> 进行扩容，扩容后，容量为原来的 2 倍。</p>
<p>首先，我们要回顾一下触发扩容的地方，put 的时候，如果判断该值的插入会导致该 segment 的元素个数超过阈值，那么先进行扩容，再插值，读者这个时候可以回去 put 方法看一眼。</p>
<p>该方法不需要考虑并发，因为到这里的时候，是持有该 segment 的独占锁的。<br>// 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。</p>
<pre><code>private void rehash(HashEntry&lt;K,V&gt; node) {

    HashEntry&lt;K,V&gt;[] oldTable = table;

    int oldCapacity = oldTable.length;

    // 2 倍

    int newCapacity = oldCapacity &lt;&lt; 1;

    threshold = (int)(newCapacity * loadFactor);

    // 创建新数组

    HashEntry&lt;K,V&gt;[] newTable =

        (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];

    // 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘000...00011111’

    int sizeMask = newCapacity - 1;



    // 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置

    for (int i = 0; i &lt; oldCapacity ; i++) {

        // e 是链表的第一个元素

        HashEntry&lt;K,V&gt; e = oldTable[i];

        if (e != null) {

            HashEntry&lt;K,V&gt; next = e.next;

            // 计算应该放置在新数组中的位置，

            // 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 = 19

            int idx = e.hash &amp; sizeMask;

            if (next == null)   // 该位置处只有一个元素，那比较好办

                newTable[idx] = e;

            else { // Reuse consecutive sequence at same slot

                // e 是链表表头

                HashEntry&lt;K,V&gt; lastRun = e;

                // idx 是当前链表的头结点 e 的新位置

                int lastIdx = idx;



                // 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的

                for (HashEntry&lt;K,V&gt; last = next;

                     last != null;

                     last = last.next) {

                    int k = last.hash &amp; sizeMask;

                    if (k != lastIdx) {

                        lastIdx = k;

                        lastRun = last;

                    }

                }

                // 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置

                newTable[lastIdx] = lastRun;

                // 下面的操作是处理 lastRun 之前的节点，

                //    这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中

                for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) {

                    V v = p.value;

                    int h = p.hash;

                    int k = h &amp; sizeMask;

                    HashEntry&lt;K,V&gt; n = newTable[k];

                    newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);

                }

            }

        }

    }

    // 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部

    int nodeIndex = node.hash &amp; sizeMask; // add the new node

    node.setNext(newTable[nodeIndex]);

    newTable[nodeIndex] = node;

    table = newTable;

}
</code></pre><p>这里的扩容比之前的 <code>HashMap</code> 要复杂一些，代码难懂一点。上面有两个挨着的 <code>for</code> 循环，第一个 <code>for</code> 有什么用呢？</p>
<p>仔细一看发现，如果没有第一个 for 循环，也是可以工作的，但是，这个 for 循环下来，如果 <code>lastRun</code> 的后面还有比较多的节点，那么这次就是值得的。因为我们只需要克隆 <code>lastRun</code> 前面的节点，后面的一串节点跟着 lastRun 走就是了，不需要做任何操作。</p>
<p>我觉得 Doug Lea 的这个想法也是挺有意思的，不过比较坏的情况就是每次 lastRun 都是链表的最后一个元素或者很靠后的元素，那么这次遍历就有点浪费了。不过 Doug Lea 也说了，根据统计，如果使用默认的阈值，大约只有 1/6 的节点需要克隆。</p>
<h4 id="get-过程分析"><a href="#get-过程分析" class="headerlink" title="get 过程分析"></a>get 过程分析</h4><p>相对于 <code>put</code> 来说，<code>get</code> 真的不要太简单。<br>计算 <code>hash</code> 值，找到 <code>segment</code> 数组中的具体位置，或我们前面用的“槽”<br>槽中也是一个数组，根据 <code>hash</code> 找到数组中具体的位置<br>到这里是链表了，顺着链表进行查找即可</p>
<pre><code>public V get(Object key) {

    Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead

    HashEntry&lt;K,V&gt;[] tab;

    // 1. hash 值

    int h = hash(key);

    long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;

    // 2. 根据 hash 找到对应的 segment

    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;

        (tab = s.table) != null) {

        // 3. 找到segment 内部数组相应位置的链表，遍历

        for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile

                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);

             e != null; e = e.next) {

            K k;

            if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))

                return e.value;

        }

    }

    return null;

}
</code></pre><h4 id="并发问题分析"><a href="#并发问题分析" class="headerlink" title="并发问题分析"></a>并发问题分析</h4><p>现在我们已经说完了 put 过程和 get 过程，我们可以看到 get 过程中是没有加锁的，那自然我们就需要去考虑并发问题。</p>
<p>添加节点的操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所以它们之间自然不会有问题，我们需要考虑的问题就是 get 的时候在同一个 segment 中发生了 put 或 remove 操作。</p>
<h4 id="put-操作的线程安全性"><a href="#put-操作的线程安全性" class="headerlink" title="put 操作的线程安全性"></a>put 操作的线程安全性</h4><ul>
<li>初始化槽，这个我们之前就说过了，使用了 CAS 来初始化 Segment 中的数组。</li>
<li>添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 setEntryAt 方法中使用的 UNSAFE.putOrderedObject。</li>
<li>扩容。扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果 get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么 put 操作的可见性保证就是 table 使用了 volatile 关键字。</li>
</ul>
<h4 id="remove-操作的线程安全性"><a href="#remove-操作的线程安全性" class="headerlink" title="remove 操作的线程安全性"></a>remove 操作的线程安全性</h4><p><code>remove</code> 操作我们没有分析源码，所以这里说的读者感兴趣的话还是需要到源码中去求实一下的。</p>
<ul>
<li><code>get</code> 操作需要遍历链表，但是 <code>remove</code> 操作会”破坏”链表。</li>
<li>如果 <code>remove</code> 破坏的节点 <code>get</code> 操作已经过去了，那么这里不存在任何问题。</li>
<li>如果 <code>remove</code> 先破坏了一个节点，分两种情况考虑。<br>1、如果此节点是头结点，那么需要将头结点的 <code>next</code> 设置为数组该位置的元素，<code>table</code> 虽然使用了 <code>volatile</code> 修饰，但是 <code>volatile</code> 并不能提供数组内部操作的可见性保证，所以源码中使用了 <code>UNSAFE</code> 来操作数组，请看方法 <code>setEntryAt</code>。<br>2、如果要删除的节点不是头结点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 <code>next</code> 属性是 <code>volatile</code> 的。</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>要知道hashmap是什么，首先要搞清楚它的数据结构，在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，hashmap也不例外。Hashmap实际上是一个数组和链表的结合体（在数据结构中，一般称之为“链表散列“），请看下图（横排表示数组，纵排表示数组元素【实际上是一个链表】）。 </p>
<p><img src="/2017/07/28/HashMap工作原理/hashmap1.jpg" alt="java" title="java"></p>
<p>从图中我们可以看到一个hashmap就是一个数组结构，当新建一个hashmap的时候，就会初始化一个数组。我们来看看java代码： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/** </div><div class="line">* The table, resized as necessary. Length MUST Always be a power of two. </div><div class="line">*  FIXME 这里需要注意这句话，至于原因后面会讲到 </div><div class="line">*/  </div><div class="line">transient Entry[] table;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;  </div><div class="line">final K key;  </div><div class="line">V value;  </div><div class="line">final int hash;  </div><div class="line">Entry&lt;K,V&gt; next;  </div><div class="line">..........  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的Entry就是数组中的元素，它持有一个指向下一个元素的引用，这就构成了链表。<br>当我们往hashmap中put元素的时候，先根据key的hash值得到这个元素在数组中的位置（即下标），然后就可以把这个元素放到对应的位置中了。如果这个元素所在的位子上已经存放有其他元素了，那么在同一个位子上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。<br>从hashmap中get元素时，首先计算key的hashcode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。从这里我们可以想象得到，如果每个位置上的链表只有一个元素，那么hashmap的get效率将是最高的，但是理想总是美好的，现实总是有困难需要我们去克服  </p>
<h3 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h3><p>我们可以看到在hashmap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过hashmap的数据结构是数组和链表的结合，所以我们当然希望这个hashmap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。   </p>
<p>所以我们首先想到的就是把hashcode对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，能不能找一种更快速，消耗更小的方式那？java中是这样做的， </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static int indexFor(int h, int length) &#123;  </div><div class="line">       return h &amp; (length-1);  </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>首先算得key得hashcode值，然后跟数组的长度-1做一次“与”运算（<code>&amp;</code>）。看上去很简单，其实比较有玄机。比如数组的长度是2的4次方，那么hashcode就会和2的4次方-1做“与”运算。很多人都有这个疑问，为什么hashmap的数组初始化大小都是2的次方大小时，hashmap的效率最高，我以2的4次方举例，来解释一下为什么数组大小为2的幂时hashmap访问的性能最高。 </p>
<p>看下图，左边两组是数组长度为16（2的4次方），右边两组是数组长度为15。两组的hashcode均为8和9，但是很明显，当它们和1110“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到同一个链表上，那么查询的时候就需要遍历这个链表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hashcode的值会与14（1110）进行“与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！ </p>
<p><img src="/2017/07/28/HashMap工作原理/hashmap2.jpg" alt="java" title="java"></p>
<p>所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。<br>说到这里，我们再回头看一下hashmap中默认的数组大小是多少，查看源代码可以得知是16，为什么是16，而不是15，也不是20呢，看到上面annegu的解释之后我们就清楚了吧，显然是因为16是2的整数次幂的原因，在小数据量的情况下16比15和20更能减少key之间的碰撞，而加快查询的效率。   </p>
<p>所以，在存储大容量数据的时候，最好预先指定hashmap的size为2的整数次幂次方。就算不指定的话，也会以大于且最接近指定值大小的2次幂来初始化的，代码如下(HashMap的构造方法中)： </p>
<pre><code>// Find a power of 2 &gt;= initialCapacity  
int capacity = 1;  
while (capacity &lt; initialCapacity)   
capacity &lt;&lt;= 1;
</code></pre><h3 id="key的hashcode与equals方法改写"><a href="#key的hashcode与equals方法改写" class="headerlink" title="key的hashcode与equals方法改写"></a>key的hashcode与equals方法改写</h3><p>在第一部分hashmap的数据结构中，annegu就写了get方法的过程：首先计算key的hashcode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。所以，hashcode与equals方法对于找到对应元素是两个关键方法。     </p>
<p>Hashmap的key可以是任何类型的对象，例如User这种对象，为了保证两个具有相同属性的user的hashcode相同，我们就需要改写hashcode方法，比方把hashcode值的计算与User对象的id关联起来，那么只要user对象拥有相同id，那么他们的hashcode也能保持一致了，这样就可以找到在hashmap数组中的位置了。如果这个位置上有多个元素，还需要用key的equals方法在对应位置的链表中找到需要的元素，所以只改写了hashcode方法是不够的，equals方法也是需要改写滴~当然啦，按正常思维逻辑，equals方法一般都会根据实际的业务内容来定义，例如根据user对象的id来判断两个user是否相等。<br>在改写equals方法的时候，需要满足以下三点：<br>(1)    自反性：就是说a.equals(a)必须为true。<br>(2)    对称性：就是说a.equals(b)=true的话，b.equals(a)也必须为true。<br>(3)    传递性：就是说a.equals(b)=true，并且b.equals(c)=true的话，a.equals(c)也必须为true。<br>通过改写key对象的equals和hashcode方法，我们可以将任意的业务对象作为map的key(前提是你确实有这样的需要)。   </p>
<p>本文主要描述了HashMap的结构，和hashmap中hash函数的实现，以及该实现的特性，同时描述了hashmap中resize带来性能消耗的根本原因，以及将普通的域模型对象作为key的基本要求。尤其是hash函数的实现，可以说是整个HashMap的精髓所在，只有真正理解了这个hash函数，才可以说对HashMap有了一定的理解。</p>
<p><a href="http://www.iteye.com/topic/754887" target="_blank" rel="external">参考链接</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017/07/28/HashMap工作原理/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;HashMap的工作原理是近年来常见的Java面试题。几乎每个Java程序员都知道HashMap，都知道哪里要用HashMap，知道Hashtable和HashMap之间的区别，那么为何这道面试题如此特殊呢？是因为这道题考察的深度很深。这题经常出现在高级或中高级面试中。投资银行更喜欢问这个问题，甚至会要求你实现HashMap来考察你的编程能力。ConcurrentHashMap和其它同步集合的引入让这道题变得更加复杂。让我们开始探索的旅程吧！&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://jet-han.oschina.io/categories/java/"/>
    
    
      <category term="hashmap" scheme="http://jet-han.oschina.io/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>volatile用法</title>
    <link href="http://jet-han.oschina.io/2017/07/28/volatile%E7%94%A8%E6%B3%95/"/>
    <id>http://jet-han.oschina.io/2017/07/28/volatile用法/</id>
    <published>2017-07-28T07:39:33.000Z</published>
    <updated>2018-11-13T08:30:45.032Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/07/28/volatile用法/java.jpg" alt="java" title="java"></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>volatile这个关键字可能很多朋友都听说过，或许也都用过。在Java 5之前，它是一个备受争议的关键字，因为在程序中使用它往往会导致出人意料的结果。在Java 5之后，volatile关键字才得以重获生机。</p>
<p>volatile关键字虽然从字面上理解起来比较简单，但是要用好不是一件容易的事情。由于volatile关键字是与Java的内存模型有关的，因此在讲述volatile关键之前，我们先来了解一下与内存模型相关的概念和知识，然后分析了volatile关键字的实现原理，最后给出了几个使用volatile关键字的场景。</p>
<p>在Java中除了long和double类型的基本类型变量的赋值和读取操作外都是原子操作，也就是说，对于变量值的简单读取操作没有必要进行同步。</p>
<p>count++不是原子操作，是3个原子操作组合<br>1.读取主存中的count值，赋值给一个局部成员变量tmp<br>2.tmp+1<br>3.将tmp赋值给count<br><a id="more"></a></p>
<h2 id="long和double的赋值操作"><a href="#long和double的赋值操作" class="headerlink" title="long和double的赋值操作"></a>long和double的赋值操作</h2><p>Java中的原子操作包括：<br>1）除long和double之外的基本类型的<strong>赋值和读取操作</strong><br>2）所有引用reference的<strong>赋值操作</strong><br>3）java.concurrent.Atomic.* 包中所有类的一切操作。</p>
<p>long和double占用的字节数都是8，也就是64bits。在32位操作系统上对64位的数据的读写要分两步完成，每一步取32位数据。这样对double和long的赋值操作就会有问题：如果有两个线程同时写一个变量内存，一个进程写低32位，而另一个写高32位，这样将导致获取的64位数据是失效的数据。因此需要使用volatile关键字来防止此类现象。volatile本身不保证获取和设置操作的原子性，仅仅保持修改的可见性。但是java的内存模型保证声明为volatile的long和double变量的get和set操作是原子的。</p>
<p>在当前的Java内存模型下，线程可以把变量保存在本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。 </p>
<p>要解决这个问题，只需要像在本程序中的这样，把该变量声明为volatile（不稳定的）即可，这就指示JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。一般说来，多任务环境下各任务间共享的标志都应该加volatile修饰。 </p>
<p>Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。 </p>
<p>Java语言规范中指出：为了获得最佳速度，允许线程保存共享成员变量的私有拷贝，而且只当线程进入或者离开同步代码块时才与共享成员变量的原始值对比。 </p>
<p>这样当多个线程同时与某个对象交互时，就必须要注意到要让线程及时的得到共享成员变量的变化。 </p>
<p>而volatile关键字就是提示VM：对于这个成员变量不能保存它的私有拷贝，而应直接与共享成员变量交互。 </p>
<p>使用建议：在两个或者更多的线程访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，不必使用。 </p>
<p>由于使用volatile屏蔽掉了VM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>public class UnatomicLong implements Runnable {
    private static long test = 0;

    private final long val;

    public UnatomicLong(long val) {
        this.val = val;
    }

    @Override
    public void run() {
        while (!Thread.interrupted()) {
            test = val; //两个线程都试图将自己的私有变量val赋值给类私有静态变量test
        }
    }

    public static void main(String[] args) {
        Thread t1 = new Thread(new UnatomicLong(-1));
        Thread t2 = new Thread(new UnatomicLong(0));

        System.out.println(Long.toBinaryString(-1));
        System.out.println(pad(Long.toBinaryString(0), 64));

        t1.start();
        t2.start();

        long val;
        while ((val = test) == -1 || val == 0) { 
       //如果静态成员test的值是-1或0，说明两个线程操作没有交叉
        }

        System.out.println(pad(Long.toBinaryString(val), 64));
        System.out.println(val);

        t1.interrupt();
        t2.interrupt();
    }

    // prepend 0s to the string to make it the target length
    private static String pad(String s, int targetLength) {
        int n = targetLength - s.length();
        for (int x = 0; x &lt; n; x++) {
            s = &quot;0&quot; + s;
        }
        return s;
    }
}
</code></pre><p>运行发现程序在while循环时进入了死循环，这是因为使用的JVM是64bits。在64位JVM中double和long的赋值操作是原子操作。<br>在eclipse中修改jre为一个32bit的JVM地址，则会有如下运行结果：<br>1111111111111111111111111111111111111111111111111111111111111111<br>0000000000000000000000000000000000000000000000000000000000000000<br>0000000000000000000000000000000011111111111111111111111111111111<br>//很明显test的值被破坏了<br>4294967295</p>
<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。</p>
<p>也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：</p>
<pre><code>    i = i + 1;
</code></pre><p>当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p>
<p>这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p>
<p>比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？</p>
<p>可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p>
<p>最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p>
<p>也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p>
<p><strong>为了解决缓存不一致性问题，通常来说有以下2种解决方法(硬件层面)：</strong></p>
<p>1) 通过在总线加LOCK#锁的方式</p>
<p>2) 通过缓存一致性协议</p>
<p>在早期的CPU当中，是通过在<strong>总线上加LOCK#锁</strong>的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p>
<p>但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</p>
<p>所以就出现了<strong>缓存一致性协议</strong>。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
<p><img src="/2017/07/28/volatile用法/cpu.jpg" alt="java" title="java"></p>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p>在并发编程中，我们通常会遇到以下三个问题：<strong>原子性问题，可见性问题，有序性问题</strong>。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>一个很经典的例子就是银行账户转账问题：</p>
<p>比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p>
<p>试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p>
<p>所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p>
<p>同样地反映到并发编程中会出现什么结果呢？</p>
<p>举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？</p>
<pre><code>i = 9;
</code></pre><p>假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。</p>
<p>那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>举个简单的例子，看下面这段代码：</p>
<pre><code>  //线程1执行的代码
  int i = 0;
  i = 10;

  //线程2执行的代码
  j = i;
</code></pre><p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p>
<p>此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p>
<p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p>
<pre><code>  int i = 0;              
  boolean flag = false;
  i = 1;                //语句1  
  flag = true;          //语句2
</code></pre><p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p>
<p>下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>
<p>比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p>
<p>但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p>
<pre><code>  int a = 10;    //语句1
  int r = 2;    //语句2
  a = a + 3;    //语句3
  r = a*a;     //语句4
</code></pre><p>这段代码有4个语句，那么可能的一个执行顺序是：语句2  语句1   语句3  语句4</p>
<p>那么可不可能是这个执行顺序呢： 语句2   语句1    语句4   语句3</p>
<p>不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p>
<p>虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p>
<pre><code>  //线程1:
  context = loadContext();   //语句1
  inited = true;             //语句2

  //线程2:
  while(!inited ){
    sleep()
  }
  doSomethingwithconfig(context);
</code></pre><p>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p>
<p>从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p>
<p><strong>要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</strong></p>
<h2 id="内存模型-1"><a href="#内存模型-1" class="headerlink" title="内存模型"></a>内存模型</h2><p>在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。</p>
<p>在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</p>
<p>Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>
<p>举个简单的例子：在java中，执行下面这个语句：</p>
<pre><code>  i  = 10;
</code></pre><p>执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p>
<p>那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p>
<p><strong>原子性</strong></p>
<p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p>
<p>上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p>
<p>请分析以下哪些操作是原子性操作：</p>
<pre><code>  x = 10;         //语句1，原子操作
  y = x;         //语句2，非原子操作
  x++;           //语句3，非原子操作
  x = x + 1;     //语句4，非原子操作
</code></pre><p>咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>
<p>语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p>
<p>语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p>
<p>同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>
<p>所以上面4个语句只有语句1的操作具备原子性。</p>
<p><strong>只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</strong></p>
<p>不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。如<a href="http://jet-han.oschina.io/2017/07/28/volatile%E7%94%A8%E6%B3%95/#long和double的赋值操作">long和double</a>但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p>
<p>从上面可以看出<strong>Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</strong></p>
<p><strong>可见性</strong></p>
<p>对于可见性，Java提供了volatile关键字来保证可见性。</p>
<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<p><strong>有序性</strong></p>
<p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>
<p>另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>
<p>下面就来具体介绍下happens-before原则（先行发生原则）：</p>
<p>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作<br>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作<br>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作<br>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C<br>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作<br>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生<br>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行<br>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始<br>这8条原则摘自《深入理解Java虚拟机》。</p>
<p>这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p>
<p>下面我们来解释一下前4条规则：</p>
<p>对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</p>
<p>第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果处于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</p>
<p>第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p>
<p>第四条规则实际上就是体现happens-before原则具备传递性。</p>
<h2 id="深入剖析"><a href="#深入剖析" class="headerlink" title="深入剖析"></a>深入剖析</h2><p>在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。</p>
<p><strong>volatile关键字的两层语义</strong></p>
<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<p>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>
<p>2）禁止进行指令重排序。</p>
<p>先看一段代码，假如线程1先执行，线程2后执行：</p>
<pre><code>  //线程1
  boolean stop = false;
  while(!stop){
      doSomething();
  }

  //线程2
  stop = true;
</code></pre><p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>
<p>下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>
<p>那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>
<p>但是用volatile修饰之后就变得不一样了：</p>
<p>**第一：使用volatile关键字会强制将修改的值立即写入主存；   </p>
<p>**第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；  </p>
<p><strong>第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</strong></p>
<p>那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>
<p>那么线程1读取到的就是最新的正确的值。</p>
<p><strong>volatile保证原子性吗？</strong></p>
<p>从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？</p>
<p>下面看一个例子：</p>
<pre><code>  public class Test {
      public volatile int inc = 0;

      public void increase() {
          inc++;
      }

      public static void main(String[] args) {
          final Test test = new Test();
          for(int i=0;i&lt;10;i++){
              new Thread(){
                  public void run() {
                      for(int j=0;j&lt;1000;j++)
                          test.increase();
                  };
              }.start();
          }

          while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完
              Thread.yield();
          System.out.println(test.inc);
      }
  }
</code></pre><p>大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>
<p>(但是这里有个坑，如果在单核cpu下执行这段代码，运行结果同样是每次都是10000，所以本地测试时小心哈，不过一般情况下也不会，我的开发环境在虚拟机下，所以设置的处理器数量为1，改大了后正常)</p>
<p>可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>
<p>这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>
<p>在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>
<p>假如某个时刻变量inc的值为10，</p>
<p>线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>
<p>然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>
<p>然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>
<p>那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>
<p><strong>解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</strong></p>
<p>根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p>
<p>把上面的代码改成以下任何一种都可以达到效果：</p>
<p><strong>采用synchronized：</strong></p>
<pre><code>public class Test {
    public  int inc = 0;

    public synchronized void increase() {
        inc++;
    }

    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&lt;1000;j++)
                        test.increase();
                };
            }.start();
        }

        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
</code></pre><p><strong>采用Lock：</strong></p>
<pre><code>public class Test {
    public  int inc = 0;
    Lock lock = new ReentrantLock();

    public  void increase() {
        lock.lock();
        try {
            inc++;
        } finally{
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&lt;1000;j++)
                        test.increase();
                };
            }.start();
        }

        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
</code></pre><p><strong>采用AtomicInteger：</strong></p>
<pre><code>public class Test {
    public  AtomicInteger inc = new AtomicInteger();

    public  void increase() {
        inc.getAndIncrement();
    }

    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&lt;1000;j++)
                        test.increase();
                };
            }.start();
        }

        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
</code></pre><p>在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>
<p><strong>volatile能保证有序性吗？</strong></p>
<p>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p>
<p>volatile关键字禁止指令重排序有两层意思：</p>
<p>1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>
<p>2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p>
<p>可能上面说的比较绕，举个简单的例子：</p>
<pre><code>  //x、y为非volatile变量
  //flag为volatile变量

  x = 2;        //语句1
  y = 0;        //语句2
  flag = true;  //语句3
  x = 4;         //语句4
  y = -1;       //语句5
</code></pre><p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会将语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p>
<p>并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p>
<p>那么我们回到前面举的一个例子：</p>
<pre><code>  //线程1:
  context = loadContext();   //语句1
  inited = true;             //语句2

  //线程2:
  while(!inited ){
    sleep()
  }
  doSomethingwithconfig(context);
</code></pre><p>前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么就可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>
<p>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>
<p><strong>volatile的原理和实现机制</strong></p>
<p>前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p>
<p>下面这段话摘自《深入理解Java虚拟机》：</p>
<p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>
<p>lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>
<p>1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p>
<p>2）它会强制将对缓存的修改操作立即写入主存；</p>
<p>3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>
<p>1）对变量的写操作不依赖于当前值</p>
<p>2）该变量没有包含在具有其他变量的不变式中</p>
<p>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>
<p>事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p>
<p>下面列举几个Java中使用volatile的几个场景。</p>
<p><strong>状态标记量</strong>  </p>
<pre><code>volatile boolean flag = false;

while(!flag){
    doSomething();
}

public void setFlag() {
    flag = true;
}
</code></pre><p><strong>double check</strong></p>
<pre><code>class Singleton{
    private volatile static Singleton instance = null;

    private Singleton() {

    }

    public static Singleton getInstance() {
        if(instance==null) {
            synchronized (Singleton.class) {
                if(instance==null)
                    instance = new Singleton();
            }
        }
        return instance;
    }
}
</code></pre><p><a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="external">原文链接</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017/07/28/volatile用法/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;volatile这个关键字可能很多朋友都听说过，或许也都用过。在Java 5之前，它是一个备受争议的关键字，因为在程序中使用它往往会导致出人意料的结果。在Java 5之后，volatile关键字才得以重获生机。&lt;/p&gt;
&lt;p&gt;volatile关键字虽然从字面上理解起来比较简单，但是要用好不是一件容易的事情。由于volatile关键字是与Java的内存模型有关的，因此在讲述volatile关键之前，我们先来了解一下与内存模型相关的概念和知识，然后分析了volatile关键字的实现原理，最后给出了几个使用volatile关键字的场景。&lt;/p&gt;
&lt;p&gt;在Java中除了long和double类型的基本类型变量的赋值和读取操作外都是原子操作，也就是说，对于变量值的简单读取操作没有必要进行同步。&lt;/p&gt;
&lt;p&gt;count++不是原子操作，是3个原子操作组合&lt;br&gt;1.读取主存中的count值，赋值给一个局部成员变量tmp&lt;br&gt;2.tmp+1&lt;br&gt;3.将tmp赋值给count&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://jet-han.oschina.io/categories/java/"/>
    
    
      <category term="volatile" scheme="http://jet-han.oschina.io/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>java常量池</title>
    <link href="http://jet-han.oschina.io/2017/07/28/java%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
    <id>http://jet-han.oschina.io/2017/07/28/java常量池/</id>
    <published>2017-07-28T04:36:43.000Z</published>
    <updated>2018-11-13T08:31:51.631Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/07/28/java常量池/java.jpg" alt="java" title="java"></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>接上一篇文章继续探索string类牵带出的常量池</p>
<h2 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h2><p><strong>程序计数器：</strong><br>1.在IDE上编译的Java代码运行时都会被转译成字节码。程序计数器的就是给编译好的字节码添加行号，这样这些字节码就以程序计数器的编号来作为调度时候的标识了。</p>
<p>2.在程序运行时，诸如循环，跳转，异常处理这些功能都必须依赖于字节码来完。</p>
<p>我的理解：字节码是二进制文件，所以识别起来很难，代表一个功能的字节码数量巨大。如果在编译的时候就将其在程序计数器上进行编号，则后期调用的时候就可以按照程序员在IDE上用高级语言编译时候的顺序进行分条执行了。<br><a id="more"></a><br><strong>栈：</strong><br>栈不灵活，但是很严格，是安全的，易于管理。因为只要上面的引用没有销毁，下面引用就一定还在，在大部分程序中，都是先定义的变量、引用先进栈，后定义的后进栈，同时，区块内部的变量、引用在进入区块时压栈，区块结束时出栈，理解了这种机制，我们就可以很方便地理解各种编程语言的作用域的概念了，同时这也是栈的优点——错误的引用逻辑在编译时就可以被发现，主要存放引用和基本数据类型。包括：<br>&ensp;&ensp;&ensp;<strong>1.本地方法栈：</strong>是jvm调用操作系统方法所使用的栈。</p>
<p>&ensp;&ensp;&ensp;<strong>2.虚拟机栈：</strong>是jvm执行java代码所使用的栈。</p>
<p><strong>方法区：</strong>存放了一些常量、静态变量、类信息等，可以理解成class文件在内存中的存放位置。</p>
<p><strong>虚拟机堆：</strong><br>堆很灵活，但是不安全。对于对象，我们要动态地创建、销毁，不能说后创建的对象没有销毁，先前创建的对象就不能销毁，那样的话我们的程序就寸步难行，所以Java中用堆来存储对象。而一旦堆中的对象被销毁，我们继续引用这个对象的话，就会出现著名的 NullPointerException，这就是堆的缺点——错误的引用逻辑只有在运行时才会被发现。主要用来存放 new 出来的对象实例。</p>
<p><strong>Java中的常量池：</strong>，实际上分为两种形态：静态常量池和运行时常量池。</p>
<p>&ensp;&ensp;&ensp;<strong>1.静态常量池：</strong>，即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。</p>
<p>&ensp;&ensp;&ensp;<strong>2.运行时常量池：</strong>，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。</p>
<p>接下来我们引用一些网络上流行的常量池例子，然后借以讲解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">String s1 = &quot;Hello&quot;;  </div><div class="line">String s2 = &quot;Hello&quot;;  </div><div class="line">String s3 = &quot;Hel&quot; + &quot;lo&quot;;  </div><div class="line">String s4 = &quot;Hel&quot; + new String(&quot;lo&quot;);  </div><div class="line">String s5 = new String(&quot;Hello&quot;);  </div><div class="line">String s6 = s5.intern();  </div><div class="line">String s7 = &quot;H&quot;;  </div><div class="line">String s8 = &quot;ello&quot;;  </div><div class="line">String s9 = s7 + s8;  </div><div class="line">            </div><div class="line">System.out.println(s1 == s2);  // true  </div><div class="line">System.out.println(s1 == s3);  // true  </div><div class="line">System.out.println(s1 == s4);  // false  </div><div class="line">System.out.println(s1 == s9);  // false  </div><div class="line">System.out.println(s4 == s5);  // false  </div><div class="line">System.out.println(s1 == s6);  // true</div></pre></td></tr></table></figure></p>
<p> 在上节中提到，在java 中，直接使用==操作符，比较的是两个字符串的引用地址，并不是比较内容，比较内容请用equals()方法。</p>
<p>s1 == s2这个非常好理解，s1、s2在赋值时，均使用的字符串字面量，说白话点，就是直接把字符串写死，在编译期间，这种字面量会直接放入class文件的常量池中，从而实现复用，载入运行时常量池后，s1、s2指向的是同一个内存地址，所以相等。</p>
<p>s1 == s3这个地方有个坑，s3虽然是动态拼接出来的字符串，但是所有参与拼接的部分都是已知的字面量，在编译期间，这种拼接会被优化，编译器直接帮你拼好，因此String s3 = “Hel” + “lo”;在class文件中被优化成String s3 = “Hello”;，所以s1 == s3成立。</p>
<p>s1 == s4当然不相等，s4虽然也是拼接出来的，但new String(“lo”)这部分不是已知字面量，是一个不可预料的部分，编译器不会优化，必须等到运行时才可以确定结果，结合字符串不变定理，鬼知道s4被分配到哪去了，所以地址肯定不同。配上一张简图理清思路：</p>
<p><img src="/2017/07/28/java常量池/string1.jpg" alt="java字符串不变" title="java字符串不变"></p>
<p>s1 == s9也不相等，道理差不多，虽然s7、s8在赋值的时候使用的字符串字面量，但是拼接成s9的时候，s7、s8作为两个变量，都是不可预料的，编译器毕竟是编译器，不可能当解释器用，所以不做优化，等到运行时，s7、s8拼接成的新字符串，在堆中地址不确定，不可能与方法区常量池中的s1地址相同。</p>
<p><img src="/2017/07/28/java常量池/string2.png" alt="jvm常量池，堆，栈内存分布" title="jvm常量池，堆，栈内存分布"></p>
<p>s4 == s5已经不用解释了，绝对不相等，二者都在堆中，但地址不同。</p>
<p>s1 == s6这两个相等完全归功于intern方法，s5在堆中，内容为Hello ，intern方法会尝试将Hello字符串添加到常量池中，并返回其在常量池中的地址，因为常量池中已经有了Hello字符串，所以intern方法直接返回地址；而s1在编译期就已经指向常量池了，因此s1和s6指向同一地址，相等。</p>
<p>至此，我们可以得出三个非常重要的结论：</p>
<p>&ensp;&ensp;&ensp;<strong>必须要关注编译期的行为，才能更好的理解常量池。</strong></p>
<p>&ensp;&ensp;&ensp;<strong>运行时常量池中的常量，基本来源于各个class文件中的常量池。</strong></p>
<p>&ensp;&ensp;&ensp;<strong>程序运行时，除非手动向常量池中添加常量(比如调用intern方法)，否则jvm不会自动添加常量到常量池。</strong></p>
<p>以上所讲仅涉及字符串常量池，实际上还有整型常量池、浮点型常量池等等，但都大同小异，只不过数值类型的常量池不可以手动添加常量，程序启动时常量池中的常量就已经确定了，比如整型常量池中的常量范围：-128~127，只有这个范围的数字可以用到常量池。</p>
<p>说了这么多理论，接下来让我们触摸一下真正的常量池。</p>
<p>前文提到过，class文件中存在一个静态常量池，这个常量池是由编译器生成的，用来存储java源文件中的字面量(本文仅仅关注字面量)，假设我们有如下java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String s = &quot;hi&quot;;</div></pre></td></tr></table></figure></p>
<p>为了方便起见，就这么简单，没错！将代码编译成class文件后，用UE打开二进制格式的class文件。如图：</p>
<p><img src="/2017/07/28/java常量池/string3.png" alt="二进制格式的class文件" title="二进制格式的class文件"></p>
<p>在命令行我们通过javap工具来查看一个class文件的字节码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javap -v test</div></pre></td></tr></table></figure></p>
<p>如图所示：</p>
<p><img src="/2017/07/28/java常量池/string4.png" alt="二进制格式的class文件" title="二进制格式的class文件"></p>
<p>简单讲解一下class文件的结构，开头的4个字节是class文件魔数，用来标识这是一个class文件，说白话点就是文件头，既：CA FE BA BE。</p>
<p>紧接着4个字节是java的版本号，这里的版本号是34，因为笔者是用jdk8编译的，版本号的高低和jdk版本的高低相对应，高版本可以兼容低版本，但低版本无法执行高版本。所以，如果哪天读者想知道别人的class文件是用什么jdk版本编译的，就可以看这4个字节，对应关系如下：</p>
<p>jdk1.4 对应48 （00 30）,<br>jdk1.5 对应49,（00 31）,<br>jdk1.6 对应50,（00 32）,<br>jdk1.7 对应51,（00 33）,<br>jdk1.8 对应52,（00 34）, </p>
<p>接下来就是常量池入口，入口处用2个字节标识常量池常量数量，本例中数值为00 13，翻译成十进制是19，也就是有18个常量，其中第0个常量是特殊值，所以只有18个常量。</p>
<p>常量池中存放了各种类型的常量，他们都有自己的类型，并且都有自己的存储规范，本文只关注字符串常量  </p>
<p>01 00 02 68 69 ，其中01代表的是“utf-8编码的字符串”，00 02代表的是这个字符串的长度是2个字节，68 69这2个字节代表的就是这个字符串的内容，因为是<a href="http://www.ascii.net.cn/" target="_blank" rel="external"><font color="#0366d6">ascii码</font></a>，每个字节对应一个字符，翻译过来就是hi</p>
<p>接下来再说说运行时常量池，由于运行时常量池在方法区中，我们可以通过jvm参数：-XX:PermSize、-XX:MaxPermSize来设置方法区大小，从而间接限制常量池大小。</p>
<p>假设jvm启动参数为：-XX:PermSize＝2M -XX:MaxPermSize＝2M，然后运行如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//保持引用，防止自动垃圾回收</div><div class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line">        </div><div class="line">int i = 0;</div><div class="line">        </div><div class="line">while(true)&#123;</div><div class="line">    //通过intern方法向常量池中手动添加常量</div><div class="line">    list.add(String.valueOf(i++).intern());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>程序立刻会抛出：Exception in thread “main” java.lang.outOfMemoryError: PermGen space异常。PermGen space正是方法区，足以说明常量池在方法区中。</p>
<p>在jdk8中，移除了方法区，转而用Metaspace区域替代，所以我们需要使用新的jvm参数：-XX:MaxMetaspaceSize=2M，依然运行如上代码，抛出：java.lang.OutOfMemoryError: Metaspace异常。同理说明运行时常量池是划分在Metaspace区域中。具体关于Metaspace区域的知识，请读者自行搜索。</p>
<p>本文所有代码均在jdk7、jdk8下测试通过，其他版本jdk可能会略有差异，请读者自行探索。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017/07/28/java常量池/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;接上一篇文章继续探索string类牵带出的常量池&lt;/p&gt;
&lt;h2 id=&quot;jvm&quot;&gt;&lt;a href=&quot;#jvm&quot; class=&quot;headerlink&quot; title=&quot;jvm&quot;&gt;&lt;/a&gt;jvm&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;程序计数器：&lt;/strong&gt;&lt;br&gt;1.在IDE上编译的Java代码运行时都会被转译成字节码。程序计数器的就是给编译好的字节码添加行号，这样这些字节码就以程序计数器的编号来作为调度时候的标识了。&lt;/p&gt;
&lt;p&gt;2.在程序运行时，诸如循环，跳转，异常处理这些功能都必须依赖于字节码来完。&lt;/p&gt;
&lt;p&gt;我的理解：字节码是二进制文件，所以识别起来很难，代表一个功能的字节码数量巨大。如果在编译的时候就将其在程序计数器上进行编号，则后期调用的时候就可以按照程序员在IDE上用高级语言编译时候的顺序进行分条执行了。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://jet-han.oschina.io/categories/java/"/>
    
    
      <category term="常量池" scheme="http://jet-han.oschina.io/tags/%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>string比较之‘’equals‘’和‘’==‘’</title>
    <link href="http://jet-han.oschina.io/2017/07/28/string%E6%AF%94%E8%BE%83%E4%B9%8B%E2%80%98%E2%80%99equals%E2%80%98%E2%80%99%E5%92%8C%E2%80%98%E2%80%99==%E2%80%98%E2%80%99/"/>
    <id>http://jet-han.oschina.io/2017/07/28/string比较之‘’equals‘’和‘’==‘’/</id>
    <published>2017-07-28T03:06:56.000Z</published>
    <updated>2017-08-13T01:45:26.093Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/java.jpg" alt="java" title="java"></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>最近我发现了一个事情，那就是在面试笔试中，好多公司都喜欢在String字符串上出问题，涉及到方方面面的知识，包括其中的一些常用方法。在此，我总结下关于String类中的equals方法，以备应对以后的笔试面试。</p>
<h2 id="equals和”-”"><a href="#equals和”-”" class="headerlink" title="equals和”==”"></a>equals和”==”</h2><p>string是一个final class，两种声明方法 :<br>1.通过new关键字，创建一个新对象，分配一块新的、独立的内存堆<br>String s1 = new String(“Hello”);<br>2.直接赋值，创建一个”Hello”字符串放入字符串常量池里面,s2只是这个字符串的引用.<br>String s2 = “Hello”;</p>
<p>这里s2属于字符串字面量，下一节会详细介绍</p>
<p>在java 中，string重写了equals和hashCode方法，都是以字符串内容复写的，直接使用”==”操作符，比较的是两个字符串的引用是否指向同一个对象，并不是比较内容，”equals”方法比较的是字符串内容，所以如果”==”返回true则”equals”一定为true,反之则不然。<br><a id="more"></a><br>下面来看具体例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">String s1 = new String(&quot;Hello&quot;);</div><div class="line">String s2 = new String(&quot;Hello&quot;);</div><div class="line">System.out.println(s1 == s2);// false</div><div class="line">System.out.println(s1.equals(s2)); //true</div><div class="line"></div><div class="line">String s3 = new String(&quot;Hello&quot;);</div><div class="line">String s4 = s3;</div><div class="line">System.out.println(s3 == s4);// true</div><div class="line">System.out.println(s3.equals(s4));// true</div><div class="line"></div><div class="line">String s5 = &quot;Hello&quot;;</div><div class="line">String s6 = &quot;Hello&quot;;</div><div class="line">System.out.println(s5 == s6);// true</div><div class="line">System.out.println(s5.equals(s6));// true</div><div class="line"></div><div class="line">String s7 = &quot;Hello&quot;;</div><div class="line">String s8 = new String(&quot;Hello&quot;);</div><div class="line">System.out.println(s7 == s8);// false，</div><div class="line">System.out.println(s7.equals(s8));// true</div><div class="line"></div><div class="line">String s9 = s3.intern();</div><div class="line">System.out.println(s7 == s9);// true，</div><div class="line">System.out.println(s7.equals(s9));// true</div></pre></td></tr></table></figure></p>
<p>intern方法会尝试将Hello字符串添加到常量池中，并返回其在常量池中的地址，因为常量池中已经有了Hello字符串，所以intern方法直接返回地址；而s7在编译期就已经指向常量池了，因此s7和s9指向同一地址，相等。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>假设有一个类，它有一个记录消息的方法，这个方法记录用户传来的消息(假设消息内容可能较大，并且重复率较高)，并且把消息按接收顺序记录在一个列表中。我想有些朋友会这样设计：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class Messages &#123;</div><div class="line"></div><div class="line">ArrayList messages = new ArrayList();</div><div class="line"></div><div class="line">public void record(String msg) &#123;</div><div class="line">messages.add(msg);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public List getMessages() &#123;</div><div class="line">return messages;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种设计方案好吗？假设我们重复的发送给record()方法同一个消息(消息来自不同的用户，所以可以视每个消息为一个new String(“…”))，并且消息内容较大，那么这个设计将会大大浪费内存空间，因为消息列表中记录的都是新创建的、独立的String对象，虽然它们的内容都相同。那么怎么样可以对其进行优化呢，其实很简单，请看如下优化后的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class Messages &#123;</div><div class="line"></div><div class="line">ArrayList messages = new ArrayList();</div><div class="line"></div><div class="line">public void record(String msg) &#123;</div><div class="line">messages.add(msg.intern());</div><div class="line">&#125;</div><div class="line"></div><div class="line">public List getMessages() &#123;</div><div class="line">return messages;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正如你所看到的，原先record()方法中的messages.add(msg);代码段变成了messages.add(msg.intern());，仅仅对msg参数调用了intern()方法，这样将对重复的消息进行共享机制，从而降低了内存消耗，提高了性能。</p>
<p>自己写一个类MyString，里边有一个char[ ]  value，实现里边的equalsString方法，要求可以比较两个MyString类的对象。相等返回0，大于返回1，小于返回-1，若比较的不是MyString类型的对象，则返回-100。</p>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">package cn.ywq.test;  </div><div class="line">  </div><div class="line">class MyString &#123;  </div><div class="line">      </div><div class="line">    char[] value;  </div><div class="line">    public MyString(char[] value) &#123;  </div><div class="line">        this.value=value;  //通过构造方法将字符传入  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">      </div><div class="line">    public int equalsString(Object obj) &#123;  </div><div class="line">        if(this==obj)&#123;  </div><div class="line">            return 0;  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        //若该对象是MyString类型的  </div><div class="line">        if(obj instanceof MyString)&#123;  </div><div class="line">            MyString string =(MyString) obj;  </div><div class="line">            int n=this.value.length;  </div><div class="line">            if (n&gt;string.value.length) &#123;  //先判断长度的关系  </div><div class="line">                return 1;  </div><div class="line">            &#125;else if(n&lt;string.value.length)&#123;  </div><div class="line">                return -1;  </div><div class="line">            &#125;else&#123;   //若长度相等  </div><div class="line">                 char v1[] = this.value;  </div><div class="line">                 char v2[] = string.value;  </div><div class="line">                    int i = 0;  </div><div class="line">                    while (n-- != 0) &#123;  //按照数组的每一位进行比较  </div><div class="line">                        if (v1[i] &gt; v2[i])&#123;  </div><div class="line">                            return 1;  </div><div class="line">                        &#125;else if(v1[i] &lt; v2[i])&#123;  </div><div class="line">                            return -1;  </div><div class="line">                        &#125;  </div><div class="line">                                  </div><div class="line">                        i++;  </div><div class="line">                    &#125;  </div><div class="line">                    return 0;  //若while循环正常结束，则说明相等，返回0  </div><div class="line">  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        return -100;  //若传入的不是MyString类型的对象  </div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;  </div><div class="line">#测试代码：</div><div class="line">package cn.ywq.test;  </div><div class="line">  </div><div class="line">public class Test &#123;  </div><div class="line">  public static void main(String[] args) &#123;  </div><div class="line">       char[] value=&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;&#125;;  </div><div class="line">       char[] value2=&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;&#125;;  </div><div class="line">       char[] value3=&#123;&apos;c&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;&#125;;  </div><div class="line">       char[] value4=&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&#125;;  </div><div class="line">          </div><div class="line">       MyString myString = new MyString(value);  </div><div class="line">       MyString s=new MyString(value4);  </div><div class="line">       int i = myString.equalsString(s);   </div><div class="line">       System.out.println(i);  </div><div class="line">   &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;最近我发现了一个事情，那就是在面试笔试中，好多公司都喜欢在String字符串上出问题，涉及到方方面面的知识，包括其中的一些常用方法。在此，我总结下关于String类中的equals方法，以备应对以后的笔试面试。&lt;/p&gt;
&lt;h2 id=&quot;equals和”-”&quot;&gt;&lt;a href=&quot;#equals和”-”&quot; class=&quot;headerlink&quot; title=&quot;equals和”==”&quot;&gt;&lt;/a&gt;equals和”==”&lt;/h2&gt;&lt;p&gt;string是一个final class，两种声明方法 :&lt;br&gt;1.通过new关键字，创建一个新对象，分配一块新的、独立的内存堆&lt;br&gt;String s1 = new String(“Hello”);&lt;br&gt;2.直接赋值，创建一个”Hello”字符串放入字符串常量池里面,s2只是这个字符串的引用.&lt;br&gt;String s2 = “Hello”;&lt;/p&gt;
&lt;p&gt;这里s2属于字符串字面量，下一节会详细介绍&lt;/p&gt;
&lt;p&gt;在java 中，string重写了equals和hashCode方法，都是以字符串内容复写的，直接使用”==”操作符，比较的是两个字符串的引用是否指向同一个对象，并不是比较内容，”equals”方法比较的是字符串内容，所以如果”==”返回true则”equals”一定为true,反之则不然。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://jet-han.oschina.io/categories/java/"/>
    
    
      <category term="string" scheme="http://jet-han.oschina.io/tags/string/"/>
    
      <category term="==" scheme="http://jet-han.oschina.io/tags//"/>
    
      <category term="equals" scheme="http://jet-han.oschina.io/tags/equals/"/>
    
  </entry>
  
</feed>
