<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>学海无涯</title>
  <subtitle>技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jet-han.oschina.io/"/>
  <updated>2017-08-19T01:43:49.206Z</updated>
  <id>http://jet-han.oschina.io/</id>
  
  <author>
    <name>Jet</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis安装及使用</title>
    <link href="http://jet-han.oschina.io/2017/08/17/redis%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://jet-han.oschina.io/2017/08/17/redis安装及使用/</id>
    <published>2017-08-17T06:02:45.000Z</published>
    <updated>2017-08-19T01:43:49.206Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/redis.jpg" alt="redis" title="redis"></p>
<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>最近公司一台主要的redis服务器出现了异常，无限制的启动很多进程，导致系统资源耗尽，ssh很卡，redis及其他定时异常，想办法杀死了僵尸进程，但是最终还有一千六百多个crond进程和python进程处于D状态无法kill掉，庆幸的是进程数没有暴增了，可以继续使用，但是特别卡机。所以只能决定重启服务器，不过担心重启后起不来的情况，即使起来了所有实时数据都丢失，因为redis没开启持久化和主从读写分离备份，而且公司业务数据实时性要求非常高，最终办法是重新开启一台服务器多实例运行redis，两个原有端口不变先进行程序写入测试，另两个端口则设置从库从原有服务器对应端口实例同步数据，并且将现有redis和其他crontab定时迁移过去，并且开启数据持久化，让其他所有往这台服务器写数据的程序都同时重写一份进新服务器，读取还是从原有服务器，因为数据是按当天实时的，所以等待一天后，新服务器的数据就同步了，再将读也切换到新服务器，重启旧服务器，问题解决，吸取教训，重新配置主从和开启从库持久化，下面将整个过程介绍一下。<br><a id="more"></a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>一、在线源安装</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[op@bogon yum.repos.d]$ yum install redis</div><div class="line">Loaded plugins: fastestmirror</div><div class="line">Loading mirror speeds from cached hostfile</div><div class="line">* base: mirrors.btte.net</div><div class="line">* extras: mirrors.btte.net</div><div class="line">* updates: mirrors.btte.net</div><div class="line">base                                                     | 3.7 kB     00:00</div><div class="line">extras                                                   | 3.5 kB     00:00</div><div class="line">updates                                                  | 3.5 kB     00:00</div><div class="line">updates/primary_db                                       | 4.6 MB     00:25</div><div class="line">Setting up Install Process</div><div class="line">No package redis available.</div><div class="line">Error: Nothing to do</div></pre></td></tr></table></figure>
<p>实际上redia位于第三方的yum源里面，不在centos官方yum源里面，如何解决呢？</p>
<p>1、去下面的网站下载EPEL对应的版本：（epel是fedora维护的yum源，里面软件众多）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://fedoraproject.org/wiki/EPEL</div></pre></td></tr></table></figure>
<p>2、我下载的是这个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm</div></pre></td></tr></table></figure>
<p>3、安装epel：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rpm -ivh epel-release-6-8.noarch.rpm</div><div class="line">warning: epel-release-6-8.noarch.rpm: Header V3 RSA/SHA256 Signature, key ID 0608b895: NOKEY</div><div class="line">Preparing...                ########################################### [100%]</div><div class="line">   1:epel-release           ########################################### [100%]</div></pre></td></tr></table></figure>
<p>4、安装redis：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">[op@bogon yum.repos.d]$ yum install redis</div><div class="line">Loaded plugins: fastestmirror</div><div class="line">Loading mirror speeds from cached hostfile</div><div class="line">epel/metalink                                            | 4.1 kB     00:00</div><div class="line">* base: mirrors.btte.net</div><div class="line">* epel: mirrors.sohu.com</div><div class="line">* extras: mirrors.btte.net</div><div class="line">* updates: mirrors.btte.net</div><div class="line">epel                                                     | 4.3 kB     00:00</div><div class="line">epel/primary_db                                          | 5.0 MB     00:43</div><div class="line">Setting up Install Process</div><div class="line">Resolving Dependencies</div><div class="line">--&gt; Running transaction check</div><div class="line">---&gt; Package redis.x86_64 0:2.4.10-1.el6 will be installed</div><div class="line">--&gt; Finished Dependency Resolution</div><div class="line">Dependencies Resolved</div><div class="line">================================================================================</div><div class="line">Package         Arch             Version                  Repository      Size</div><div class="line">================================================================================</div><div class="line">Installing:</div><div class="line">redis           x86_64           2.4.10-1.el6             epel           213 k</div><div class="line">Transaction Summary</div><div class="line">================================================================================</div><div class="line">Install       1 Package(s)</div><div class="line">Total download size: 213 k</div><div class="line">Installed size: 668 k</div><div class="line">Is this ok [y/N]:y</div></pre></td></tr></table></figure>
<p>查看版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[op@bogon yum.repos.d]$ redis-server -v</div><div class="line">Redis server version 2.4.10 (00000000:0)</div></pre></td></tr></table></figure>
<p><strong>二、软件包安装</strong></p>
<p>1)  下载redis安装包</p>
<p>可去<a href="http://redis.io" target="_blank" rel="external">官网</a> 下载，也可通过wget命令，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://download.redis.io/redis-stable.tar.gz</div></pre></td></tr></table></figure>
<p>2)  解压</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar –zxvf redis-stable.tar.gz</div></pre></td></tr></table></figure>
<p>3)  编译、安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd redis-stable</div><div class="line">make&amp;&amp;make install</div></pre></td></tr></table></figure>
<p>如果提示<code>gcc command</code>不识别，请自行安装<code>gcc</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yum install gcc -y</div><div class="line">yum install gcc-g++ -y</div></pre></td></tr></table></figure>
<p>如果提示<code>couldn’t execute tcl : no such file or dicrectory</code>，请自行安装<code>tcl</code>;<br>如果提示: <code>erroo:jmalloc/jemalloc.h:no such file or dicrectory</code><br>请执行<code>make distclean</code>，然后再<code>make</code></p>
<p>注意：若此时执行<code>redis-server –v</code> (查看版本命令)，若提示<code>redis-server command not found</code>，查看环境变量：<code>echo $PATH</code>，使用<code>whereis redis-server</code>查看<code>redis-server</code>命令目录，使用<code>ln -s redis-server命令目录/redis-server 环境变量bin目录/redis-server</code>创建软链接，客户端命令相同；</p>
<p>如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo ln -s /usr/local/bin/redis-server /usr/sbin/redis-server</div><div class="line">sudo ln -s /usr/local/bin/redis-cli /usr/sbin/redis-cli</div></pre></td></tr></table></figure>
<p><code>/usr/sbin/redis-server</code>环境变量中的命令，不存在<br><code>/usr/local/bin/redis-server</code>是<code>make install</code>后创建的</p>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[op@bogon ~]$ ll /usr/sbin/redis-server</div><div class="line">lrwxrwxrwx. 1 root root 27 Aug 18 15:17 /usr/sbin/redis-server -&gt; /usr/local/bin/redis-server</div></pre></td></tr></table></figure>
<p>或者直接将<code>/usr/local/bin</code>目录加到环境变量，如何添加，此处不做详细介绍，可查看修改/etc/profile。</p>
<p>二．配置redis多实例环境</p>
<ol>
<li>创建配置文件目录，dump file 目录，进程pid目录，log目录等</li>
</ol>
<p>这里配置多实例环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /data</div><div class="line">mkdir -p redis/conf redis/log redis/pid redis/dump</div></pre></td></tr></table></figure>
<p>注意各个目录的权限和所属用户及用户组,否则启动会报错<br>dump和pid两个目录必须属于redis</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[op@bogon redis]$ ll</div><div class="line">total 20</div><div class="line">drwxrwxr-x. 2 op    op   4096 Aug 18 11:52 conf</div><div class="line">drwxr-xr-x. 2 redis root 4096 Aug 18 11:26 dump</div><div class="line">drwxr-xr-x. 2 op    op   4096 Aug 18 11:25 logs</div><div class="line">-rw-------. 1 root  root    0 Aug 18 11:52 nohup.out</div><div class="line">drwxr-xr-x. 2 redis root 4096 Aug 18 11:52 pid</div><div class="line">-rwxr-xr-x. 1 op    op    171 Aug 18 11:50 start.sh</div></pre></td></tr></table></figure>
<ol>
<li>修改配置文件，配置参数</li>
</ol>
<p>软件源安装配置文件在/etc/redis.conf<br>软件包安装配置文件在redis-stable/redis.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cp /etc/redis.conf /data/redis/conf/redis-6380.conf</div><div class="line">cp /etc/redis.conf /data/redis/conf/redis-6381.conf</div></pre></td></tr></table></figure>
<p>建立日志文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vi redis/log/redis-6380.log //建立日志空文件并保存</div><div class="line">vi redis/log/redis-6381.log</div></pre></td></tr></table></figure>
<p>这里以端口6380为例进行配置</p>
<p>打开redis-6380.conf文件<br>修改端口(默认6379)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># Accept connections on the specified port, default is 6379.</div><div class="line"># If port 0 is specified Redis will not listen on a TCP socket.</div><div class="line">port 6380</div></pre></td></tr></table></figure>
<p>修改pid目录为新建目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># When running daemonized, Redis writes a pid file in /var/run/redis.pid by</div><div class="line"># default. You can specify a custom pid file location here.</div><div class="line">pidfile /data/redis/pid/redis-6380.pid</div></pre></td></tr></table></figure>
<p>修改dump目录为新建目录及文件名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># The working directory.</div><div class="line">#</div><div class="line"># The DB will be written inside this directory, with the filename specified</div><div class="line"># above using the &apos;dbfilename&apos; configuration directive.</div><div class="line">#</div><div class="line"># Also the Append Only File will be created inside this directory.</div><div class="line">#</div><div class="line"># Note that you must specify a directory here, not a file name.</div><div class="line">dir /data/redis/dump/</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># The filename where to dump the DB</div><div class="line">dbfilename dump-6380.rdb</div></pre></td></tr></table></figure>
<p>修改log存储目录为新建目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Specify the log file name. Also &apos;stdout&apos; can be used to force</div><div class="line"># Redis to log on the standard output. Note that if you use standard</div><div class="line"># output for logging but daemonize, logs will be sent to /dev/null</div><div class="line">logfile /data/redis/logs/redis-6380.log</div></pre></td></tr></table></figure>
<p>修改redis后台运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># By default Redis does not run as a daemon. Use &apos;yes&apos; if you need it.</div><div class="line"># Note that Redis will write a pid file in /var/run/redis.pid when daemonized.</div><div class="line">daemonize yes</div></pre></td></tr></table></figure>
<ol>
<li>持久化</li>
</ol>
<p>默认rdb，可选择是否开启aof，若开启，修改配置文件appendonly</p>
<ol>
<li>编写启动脚本，一次性启动</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi start.sh</div></pre></td></tr></table></figure>
<p>脚本内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">nohup redis-server /data/redis/conf/redis-6380.conf &amp;</div><div class="line">nohup redis-server /data/redis/conf/redis-6381.conf &amp;</div></pre></td></tr></table></figure>
<ol>
<li>启动redis，查看各目录下文件</li>
</ol>
<p>查看进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@bogon conf]# ps aux | grep redis</div><div class="line">root     22900  0.0  0.0  39944  2632 ?        Ssl  Aug14   0:24 redis-server /data/redis/conf/redis-6381.conf</div><div class="line">root     22901  0.0  0.0  39944  3748 ?        Ssl  Aug14   0:25 redis-server /data/redis/conf/redis-6380.conf</div><div class="line">root     39320  0.0  0.0 103332   876 pts/0    S+   15:41   0:00 grep redis</div></pre></td></tr></table></figure>
<p>关闭redis服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@bogon conf]# redis-cli shutdown</div></pre></td></tr></table></figure>
<p>查看dump信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -al /data/redis/dump</div></pre></td></tr></table></figure>
<p>若配置了aof持久化方式，data目录下还会有aof的相关文件，后面会详细介绍</p>
<ol>
<li>客户端连接redis</li>
</ol>
<p>本机连接，不指定则连接默认端口6379</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-cli</div></pre></td></tr></table></figure>
<p>其他客户机连接，需要指定ip和要连接的端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-cli -h 192.168.132.25 -p 6380</div></pre></td></tr></table></figure>
<p>如若是拒绝连接，则是因为redis配置默认是只允许本机连接的，所以要开启其他客户机访问，就将所有<code>bind</code>信息注释掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># If you want you can bind a single interface, if the bind option is not</div><div class="line"># specified all the interfaces will listen for incoming connections.</div><div class="line">#</div><div class="line">#bind 127.0.0.1</div><div class="line">#bind 192.168.132.25</div></pre></td></tr></table></figure>
<p>若是没有路由，则是防火墙问题，防火墙添加路由，或者直接关闭防火墙</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo service iptables status #查看防火墙状态</div><div class="line">sudo service iptables stop #关闭防火墙服务</div></pre></td></tr></table></figure>
<h2 id="数据备份与恢复"><a href="#数据备份与恢复" class="headerlink" title="数据备份与恢复"></a>数据备份与恢复</h2><p>前面的配置提到了两种持久化方式，接下来详细介绍</p>
<h3 id="RDB方式-默认"><a href="#RDB方式-默认" class="headerlink" title="RDB方式(默认)"></a>RDB方式(默认)</h3><p>RDB方式的持久化是通过快照（snapshotting）完成的，当符合一定条件时Redis会自动将内存中的所有数据进行快照并存储在硬盘上。进行快照的条件可以由用户在配置文件中自定义，由两个参数构成：时间和改动的键的个数。当在指定的时间内被更改的键的个数大于指定的数值时就会进行快照。RDB是redis默认采用的持久化方式，在配置文件中已经预置了3个条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">save 900 1    # 900秒内有至少1个键被更改则进行快照</div><div class="line">save 300 10   # 300秒内有至少10个键被更改则进行快照</div><div class="line">save 60 10000 # 60秒内有至少10000个键被更改则进行快照</div></pre></td></tr></table></figure>
<p>可以存在多个条件，条件之间是“或”的关系，只要满足其中一个条件，就会进行快照。 如果想要禁用自动快照，只需要将所有的save参数删除即可。</p>
<p>Redis默认会将快照文件存储在<code>/var/lib/redis/</code>目录(可CONFIG GET dir来查看)的dump.rdb文件中，可以通过配置dir和dbfilename两个参数分别指定快照文件的存储路径和文件名。</p>
<p>Redis实现快照的过程</p>
<p>Redis使用fork函数复制一份当前进程（父进程）的副本（子进程）；<br>父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件；<br>当子进程写入完所有数据后会用该临时文件替换旧的RDB文件，至此一次快照操作完成。<br>在执行fork的时候操作系统（类Unix操作系统）会使用写时复制（copy-on-write）策略，即fork函数发生的一刻父子进程共享同一内存数据，当父进程要更改其中某片数据时（如执行一个写命令 ），操作系统会将该片数据复制一份以保证子进程的数据不受影响，所以新的RDB文件存储的是执行fork一刻的内存数据。</p>
<p>Redis在进行快照的过程中不会修改RDB文件，只有快照结束后才会将旧的文件替换成新的，也就是说任何时候RDB文件都是完整的。这使得我们可以通过定时备份RDB文件来实 现Redis数据库备份。RDB文件是经过压缩（可以配置rdbcompression参数以禁用压缩节省CPU占用）的二进制格式，所以占用的空间会小于内存中的数据大小，更加利于传输。</p>
<p>除了自动快照，还可以手动发送SAVE或BGSAVE命令让Redis执行快照，两个命令的区别在于，前者是由主进程进行快照操作，会阻塞住其他请求，后者会通过fork子进程进行快照操作。 Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将一个记录一千万个字符串类型键、大小为1GB的快照文件载入到内 存中需要花费20～30秒钟。 通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。如果数据很重要以至于无法承受任何损失，则可以考虑使用AOF方式进行持久化。</p>
<p>手动备份与恢复</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; SAVE   #redis 备份目录中创建dump.rdb文件</div><div class="line"></div><div class="line">redis 127.0.0.1:6379&gt; CONFIG GET dir #获取rdb存放目录</div><div class="line">1) &quot;dir&quot;</div><div class="line">2) &quot;/data/redis/dump/&quot;</div></pre></td></tr></table></figure>
<p>恢复，将备份文件dump.rdb放到对应的dir目录，重启redis服务即可恢复rdb数据</p>
<h3 id="AOF方式"><a href="#AOF方式" class="headerlink" title="AOF方式"></a>AOF方式</h3><p>默认情况下Redis没有开启AOF(append only file)方式的持久化，可以在redis.conf中通过appendonly参数开启：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">appendonly yes</div></pre></td></tr></table></figure>
<p>在启动时Redis会逐个执行AOF文件中的命令来将硬盘中的数据载入到内存中，载入的速度相较RDB会慢一些</p>
<p>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是<code>appendonly.aof</code>，可以通过<code>appendfilename</code>参数修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">appendfilename appendonly.aof</div></pre></td></tr></table></figure>
<p>配置redis自动重写AOF文件的条件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">auto-aof-rewrite-percentage 100  # 当目前的AOF文件大小超过上一次重写时的AOF文件大小的百分之多少时会再次进行重写，如果之前没有重写过，则以启动时的AOF文件大小为依据</div><div class="line">auto-aof-rewrite-min-size 64mb   # 允许重写的最小AOF文件大小配置写入AOF文件后，要求系统刷新硬盘缓存的机制</div><div class="line"></div><div class="line"># appendfsync always   # 每次执行写入都会执行同步，最安全也最慢</div><div class="line">appendfsync everysec   # 每秒执行一次同步操作</div><div class="line"># appendfsync no       # 不主动进行同步操作，而是完全交由操作系统来做（即每30秒一次），最快也最不</div></pre></td></tr></table></figure>
<p>Redis允许同时开启AOF和RDB，既保证了数据安全又使得进行备份等操作十分容易。此时重新启动Redis后Redis会使用AOF文件来恢复数据，因为AOF方式的持久化可能丢失的数据更少</p>
<h3 id="主从同步-复制"><a href="#主从同步-复制" class="headerlink" title="主从同步(复制)"></a>主从同步(复制)</h3><p>通过持久化功能，Redis保证了即使在服务器重启的情况下也不会损失（或少量损失）数据。但是由于数据是存储在一台服务器上的，如果这台服务器的硬盘出现故障，也会导致数据丢失。为了避免单点故障，我们希望将数据库复制多个副本以部署在不同的服务器上，即使有一台服务器出现故障其他服务器依然可以继续提供服务。这就要求当一台服务器上的数据库更新后，可以自动将更新的数据同步到其他服务器上，Redis提供了复制（replication）功能可以自动实现同步的过程。</p>
<p>配置方法</p>
<p>通过配置文件 从数据库的配置文件中加入<code>slaveof master-ip master-port</code>，主数据库无需配置</p>
<p>通过命令行参数 启动redis-server的时候，使用命令行参数<code>--slaveof master-ip master port</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-server --port 6380 --slaveof 192.168.133.25 6379</div></pre></td></tr></table></figure>
<p>从数据库启动以后再设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">slaveof master-ip master-port</div></pre></td></tr></table></figure>
<p>如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">192.168.133.24:6380&gt; slaveof 192.168.133.25 6379</div><div class="line">OK</div></pre></td></tr></table></figure>
<p>查看从库状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">info</div></pre></td></tr></table></figure>
<p>从库info</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">192.168.133.24:6380&gt; info</div><div class="line"># Server</div><div class="line">redis_version:2.8.19</div><div class="line">redis_git_sha1:00000000</div><div class="line">redis_git_dirty:0</div><div class="line">redis_build_id:4a607fa14f74d354</div><div class="line">redis_mode:standalone</div><div class="line">os:Linux 2.6.32-358.el6.x86_64 x86_64</div><div class="line">arch_bits:64</div><div class="line">...</div><div class="line"># Replication</div><div class="line">role:slave #角色是从</div><div class="line">master_host:192.168.133.25</div><div class="line">master_port:6379</div><div class="line">master_link_status:up #状态是up</div><div class="line">master_last_io_seconds_ago:0</div><div class="line">master_sync_in_progress:0</div><div class="line">slave_repl_offset:1323763642</div><div class="line">slave_priority:100</div><div class="line">slave_read_only:1</div><div class="line">connected_slaves:0</div><div class="line">master_repl_offset:0</div><div class="line">repl_backlog_active:0</div><div class="line">repl_backlog_size:1048576</div><div class="line">repl_backlog_first_byte_offset:0</div><div class="line">repl_backlog_histlen:0</div></pre></td></tr></table></figure>
<p>查看主库状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">192.168.133.25:6379&gt; info</div><div class="line"># Server</div><div class="line">redis_version:2.8.19</div><div class="line">redis_git_sha1:00000000</div><div class="line">redis_git_dirty:0</div><div class="line">redis_build_id:4a607fa14f74d354</div><div class="line">redis_mode:standalone</div><div class="line">os:Linux 2.6.32-358.el6.x86_64 x86_64</div><div class="line">arch_bits:64</div><div class="line">...</div><div class="line"># Replication</div><div class="line">role:master</div><div class="line">connected_slaves:1</div><div class="line">slave0:ip=192.168.133.25,port=6380,state=online,offset=1426459508,lag=0</div><div class="line">master_repl_offset:1426478361</div><div class="line">repl_backlog_active:1</div><div class="line">repl_backlog_size:1048576</div><div class="line">repl_backlog_first_byte_offset:1425429786</div><div class="line">repl_backlog_histlen:1048576</div></pre></td></tr></table></figure>
<p>查看数据同步情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">192.168.133.24:6380&gt; dbsize</div><div class="line">(integer) 58562</div><div class="line"></div><div class="line">192.168.133.25:6379&gt; dbsize</div><div class="line">(integer) 58562</div></pre></td></tr></table></figure>
<p>从数据库停止接收其他数据库的同步转主数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SLAVEOF NO ONE</div></pre></td></tr></table></figure>
<p>如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">192.168.133.24:6380&gt; slaveof no one</div><div class="line">OK</div></pre></td></tr></table></figure>
<p>结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># Replication</div><div class="line">role:master</div><div class="line">connected_slaves:0</div><div class="line">master_repl_offset:1722534164</div><div class="line">repl_backlog_active:0</div><div class="line">repl_backlog_size:1048576</div><div class="line">repl_backlog_first_byte_offset:0</div><div class="line">repl_backlog_histlen:0</div></pre></td></tr></table></figure>
<p>优点及应用场景</p>
<p>读写分离 通过复制可以实现读写分离以提高服务器的负载能力。在常见的场景中，读的频率大于写，当单机的Redis无法应付大量的读请求时（尤其是较耗资源的请求，比如SORT命令等）可以通过复制功能建立多个从数据库，主数据库只进行写操作，而从数据库负责读操作。</p>
<p>从数据库持久化 持久化通常相对比较耗时，为了提高性能，可以通过复制功能建立一个（或若干个）从数据库，并在从数据库中启用持久化，同时在主数据库禁用持久化。当从数据库崩溃时重启后主数据库会自动将数据同步过来，所以无需担心数据丢失。而当主数据库崩溃时，需要在从数据库中使用SLAVEOF NO ONE命令将从数据库提升成主数据库继续服务，并在原来的主数据库启动后使用SLAVEOF命令将其设置成新的主数据库的从数据库，即可将数据同步回来。</p>
<h2 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h2><p><a href="http://www.redis.net.cn" target="_blank" rel="external">更多资料查看</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/redis.jpg&quot; alt=&quot;redis&quot; title=&quot;redis&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;最近公司一台主要的redis服务器出现了异常，无限制的启动很多进程，导致系统资源耗尽，ssh很卡，redis及其他定时异常，想办法杀死了僵尸进程，但是最终还有一千六百多个crond进程和python进程处于D状态无法kill掉，庆幸的是进程数没有暴增了，可以继续使用，但是特别卡机。所以只能决定重启服务器，不过担心重启后起不来的情况，即使起来了所有实时数据都丢失，因为redis没开启持久化和主从读写分离备份，而且公司业务数据实时性要求非常高，最终办法是重新开启一台服务器多实例运行redis，两个原有端口不变先进行程序写入测试，另两个端口则设置从库从原有服务器对应端口实例同步数据，并且将现有redis和其他crontab定时迁移过去，并且开启数据持久化，让其他所有往这台服务器写数据的程序都同时重写一份进新服务器，读取还是从原有服务器，因为数据是按当天实时的，所以等待一天后，新服务器的数据就同步了，再将读也切换到新服务器，重启旧服务器，问题解决，吸取教训，重新配置主从和开启从库持久化，下面将整个过程介绍一下。&lt;br&gt;
    
    </summary>
    
      <category term="redis" scheme="http://jet-han.oschina.io/categories/redis/"/>
    
    
      <category term="nosql" scheme="http://jet-han.oschina.io/tags/nosql/"/>
    
      <category term="cache" scheme="http://jet-han.oschina.io/tags/cache/"/>
    
      <category term="redis" scheme="http://jet-han.oschina.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://jet-han.oschina.io/2017/08/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jet-han.oschina.io/2017/08/08/设计模式/</id>
    <published>2017-08-08T06:34:34.000Z</published>
    <updated>2017-08-13T01:45:26.109Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/java.jpg" alt="java" title="java"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>设计模式简介</strong><br>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 </p>
<p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。<br><a id="more"></a><br><strong>什么是 GOF（四人帮，全拼 Gang of Four）？</strong><br>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。<br>四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。<br>对接口编程而不是对实现编程。<br>优先使用对象组合而不是继承。<br><strong>设计模式的使用</strong><br>设计模式在软件开发中的两个主要用途。<br><strong>开发人员的共同平台</strong><br>设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。<br><strong>最佳的实践</strong><br>设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。<br><strong>设计模式的类型</strong><br>根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th>模式&amp;描述</th>
<th>包含</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td><strong>创建型模式</strong><br>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑<br>的方式，而不是使用 new 运算符直接实例化对象。这<br>使得程序在判断针对某个给定实例需要创建哪些对象时<br>更加灵活。</td>
<td>工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td><strong>结构型模式</strong><br>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td>
<td>适配器模式（Adapter Pattern）<br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td><strong>行为型模式</strong><br>这些设计模式特别关注对象之间的通信。</td>
<td>责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td><strong>J2EE 模式</strong><br>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</td>
<td>MVC 模式（MVC Pattern）<br>业务代表模式（Business Delegate Pattern）<br>组合实体模式（Composite Entity Pattern）<br>数据访问对象模式（Data Access Object Pattern）<br>前端控制器模式（Front Controller Pattern）<br>拦截过滤器模式（Intercepting Filter Pattern）<br>服务定位器模式（Service Locator Pattern）<br>传输对象模式（Transfer Object Pattern）</td>
</tr>
</tbody>
</table>
</div>
<p>下面用一个图片来整体描述一下设计模式之间的关系：<br><img src="http://jet-han.oschina.io/img/设计模式/design-patterns.jpg" alt="design-patterns" title="design-patterns"></p>
<p><strong>设计模式的六大原则</strong>  </p>
<ol>
<li><strong>开闭原则（Open Close Principle）</strong><br>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。  </li>
<li><strong>里氏代换原则（Liskov Substitution Principle）</strong><br>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。  </li>
<li><strong>依赖倒转原则（Dependence Inversion Principle）</strong><br>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。  </li>
<li><strong>接口隔离原则（Interface Segregation Principle）</strong><br>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。  </li>
<li><strong>迪米特法则，又称最少知道原则（Demeter Principle）</strong><br>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</li>
<li><strong>合成复用原则（Composite Reuse Principle）</strong><br>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</li>
</ol>
<h2 id="java常用设计模式"><a href="#java常用设计模式" class="headerlink" title="java常用设计模式"></a>java常用设计模式</h2><p>通俗一点讲就是：<br>一个程序员对设计模式的理解:<br>“不懂”为什么要把很简单的东西搞得那么复杂。后来随着软件开发经验的增加才开始明白我所看到的“复杂”恰恰就是设计模式的精髓所在，我所理解的“简单”就是一把钥匙开一把锁的模式，目的仅仅是着眼于解决现在的问题，而设计模式的“复杂”就在于它是要构造一个“万能钥匙”，目的是提出一种对所有锁的开锁方案。在真正理解设计模式之前我一直在编写“简单”的代码.<br>这个“简单”不是功能的简单，而是设计的简单。简单的设计意味着缺少灵活性，代码很钢硬，只在这个项目里有用，拿到其它的项目中就是垃圾，我将其称之为“一次性代码”。</p>
<p>要使代码可被反复使用,请用’设计模式’对你的代码进行设计。 </p>
<p>很多我所认识的程序员在接触到设计模式之后，都有一种相见恨晚的感觉，有人形容学习了设计模式之后感觉自己好像已经脱胎换骨，达到了新的境界，还有人甚至把是否了解设计模式作为程序员划分水平的标准。<br>我们也不能陷入模式的陷阱，为了使用模式而去套模式，那样会陷入形式主义。我们在使用模式的时候，一定要注意模式的意图（intent），而不要过多的去关注模式的实现细节，因为这些实现细节在特定情况下，可能会发生一些改变。不要顽固地认为设计模式一书中的类图或实现代码就代表了模式本身。  </p>
<p>设计原则：(重要)</p>
<ol>
<li>逻辑代码独立到单独的方法中，注重封装性—易读，易复用。<br>不要在一个方法中，写下上百行的逻辑代码。把各小逻辑代码独立出来，写于其它方法中，易读其可重复调用。</li>
<li>写类，写方法，写功能时，应考虑其移植性，复用性：防止一次性代码！<br>是否可以拿到其它同类事物中应该？是否可以拿到其它系统中应该？</li>
<li>熟练运用继承的思想：<br>找出应用中相同之处，且不容易发生变化的东西，把它们抽取到抽象类中，让子类去继承它们；<br>继承的思想，也方便将自己的逻辑建立于别人的成果之上。如ImageField extends JTextField；<br>熟练运用接口的思想：<br>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li>
</ol>
<p><strong>把很简单的东西搞得那么复杂，一次性代码，设计模式优势的实例说明：（策略模式）</strong><br>说明：<br>模拟鸭子游戏的应用程序，要求：游戏中会出现各种颜色外形的鸭子，一边游泳戏水，一边呱呱叫。<br><strong>1、 一次性代码 </strong><br>直接编写出各种鸭子的类：MallardDuck//野鸭，RedheadDuck//红头鸭，各类有三个方法：<br>quack()：叫的方法<br>swim()：游水的方法<br>display()：外形的方法<br><strong>2、运用继承的特性，将其中共同的部分提升出来，避免重复编程。</strong><br>即：设计一个鸭子的超类（Superclass）,并让各种鸭子继承这个超类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Duck&#123;</div><div class="line">     public void quack()&#123;  //呱呱叫</div><div class="line">              System.out.println(&quot;呱呱叫&quot;);</div><div class="line">      &#125;</div><div class="line">     public void swim()&#123;   //游泳</div><div class="line">            System.out.println(&quot; 游泳&quot;);</div><div class="line">      &#125;    </div><div class="line">     public  abstratact void display(); /*因为外观不一样，让子类自己去决定了。*/</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于它的子类只需简单的继承就可以了，并实现自己的display()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//野鸭</div><div class="line"> public class MallardDuck extends Duck&#123;</div><div class="line">     public void display()&#123;</div><div class="line">          System.out.println(&quot;野鸭的颜色...&quot;);</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line">//红头鸭</div><div class="line"> public class RedheadDuck extends Duck&#123;</div><div class="line">     public void display()&#123;</div><div class="line">          System.out.println(&quot;红头鸭的颜色...&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不幸的是，现在客户又提出了新的需求，想让鸭子飞起来。这个对于我们OO程序员，在简单不过了，在超类中在加一个方法就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Duck&#123;</div><div class="line">   public void quack()&#123;  //呱呱叫</div><div class="line">      System.out.println(&quot;呱呱叫&quot;);</div><div class="line">     &#125;</div><div class="line">   public void swim()&#123;   //游泳</div><div class="line">      System.out.println(&quot; 游泳&quot;);</div><div class="line">   &#125;    </div><div class="line">   public  abstract void display(); /*因为外观不一样，让子类自己去决定了。*/</div><div class="line">   public void fly()&#123;</div><div class="line">      System.out.println(&quot;飞吧！鸭子&quot;); </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于不能飞的鸭子，在子类中只需简单的覆盖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//残废鸭</div><div class="line"> public class DisabledDuck extends Duck&#123;</div><div class="line">    public void display()&#123;</div><div class="line">       System.out.println(&quot;残废鸭的颜色...&quot;);</div><div class="line">   &#125;</div><div class="line">   public void fly()&#123;</div><div class="line">    //覆盖，变成什么事都不做。 </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其它会飞的鸭子不用覆盖。<br>这样所有的继承这个超类的鸭子都会fly了。但是问题又出来了，客户又提出有的鸭子会飞，有的不能飞。</p>
<p><strong>对于上面的设计，你可能发现一些弊端，如果超类有新的特性，子类都必须变动，这是我们开发最不喜欢看到的，一个类变让另一个类也跟着变，这有点不符合OO设计了。这样很显然的耦合了一起。利用继承—&gt;耦合度太高了.</strong></p>
<p><strong>3、用接口改进</strong><br>我们把容易引起变化的部分提取出来并封装之，来应付以后的变法。虽然代码量加大了，但可用性提高了，耦合度也降低了。<br>我们把Duck中的fly方法和quack提取出来。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> public interface Flyable&#123;</div><div class="line">    public void fly(); </div><div class="line">&#125;</div><div class="line"> public interface Quackable&#123;</div><div class="line">   public void quack();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  最后Duck的设计成为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class Duck&#123;</div><div class="line">     public void swim()&#123;   //游泳</div><div class="line">            System.out.println(&quot; 游泳&quot;);</div><div class="line">    &#125;    </div><div class="line">    public  abstract void display(); /*因为外观不一样，让子类自 己去决定了。*/</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 而MallardDuck,RedheadDuck,DisabledDuck 就可以写成为：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">//野鸭</div><div class="line"> public class MallardDuck extends Duck implements Flyable,Quackable&#123;</div><div class="line">     public void display()&#123;</div><div class="line">          System.out.println(&quot;野鸭的颜色...&quot;);</div><div class="line">   &#125;</div><div class="line">   public void fly()&#123;</div><div class="line">    //实现该方法</div><div class="line">  &#125;</div><div class="line">   public void quack()&#123;</div><div class="line">    //实现该方法</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line">//红头鸭</div><div class="line"> public class RedheadDuck extends Duck implements Flyable,Quackable&#123;</div><div class="line">     public void display()&#123;</div><div class="line">          System.out.println(&quot;红头鸭的颜色...&quot;);</div><div class="line">   &#125;</div><div class="line">   public void fly()&#123;</div><div class="line">    //实现该方法</div><div class="line">  &#125;</div><div class="line">   public void quack()&#123;</div><div class="line">    //实现该方法</div><div class="line">  &#125;</div><div class="line">&#125; </div><div class="line">//残废鸭 只实现Quackable（能叫不能飞）</div><div class="line"> public class DisabledDuck extends Duck implements Quackable&#123;</div><div class="line">     public void display()&#123;</div><div class="line">          System.out.println(&quot;残废鸭的颜色...&quot;);</div><div class="line">   &#125;</div><div class="line">   public void quack()&#123;</div><div class="line">    //实现该方法</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好处:<br>这样已设计，我们的程序就降低了它们之间的耦合。<br>不足:<br>Flyable和 Quackable接口一开始似乎还挺不错的，解决了问题（只有会飞到鸭子才实现 Flyable），但是Java接口不具有实现代码，所以<strong>实现接口无法达到代码的复用</strong>。</p>
<p><strong>继承的好处:</strong>让共同部分,可以复用.避免重复编程.<br><strong>继承的不好:</strong>耦合性高.一旦超类添加一个新方法,子类都继承,拥有此方法,若子类相当部分不实现此方法,则要进行大批量修改.继承时,子类就不可继承其它类了.<br><strong>接口的好处:</strong>解决了继承耦合性高的问题,且可让实现类,继承或实现其它类或接口.<br><strong>接口的不好:</strong>不能真正实现代码的复用.可用以下的策略模式来解决.</p>
<h2 id="strategy-策略模式"><a href="#strategy-策略模式" class="headerlink" title="strategy(策略模式)"></a>strategy(策略模式)</h2><p>我们有一个设计原则：<br>找出应用中相同之处，且不容易发生变化的东西，把它们抽取到抽象类中，让子类去继承它们；<br>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。   </p>
<p>现在，为了要分开“变化和不变化的部分”，我们准备建立两组类（完全远离Duck类），一个是”fly”相关的，另一个是“quack”相关的，每一组类将实现各自的动作。比方说，我们可能有一个类实现“呱呱叫”，另一个类实现“吱吱叫”，还有一个类实现“安静”。<br>首先写两个接口。<br>FlyBehavior(飞行行为)和QuackBehavior（叫的行为）.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public interface FlyBehavior&#123;</div><div class="line">   public void fly();     </div><div class="line">&#125;</div><div class="line">public interface QuackBehavior&#123;</div><div class="line">   public void quack();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在定义一些针对FlyBehavior的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class FlyWithWings implements FlyBehavior&#123;</div><div class="line">   public void  fly()&#123;</div><div class="line">     //实现了所有有翅膀的鸭子飞行行为。</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line">public class FlyNoWay implements FlyBehavior&#123;</div><div class="line">   public void  fly()&#123;</div><div class="line">      //什么都不做，不会飞</div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>针对QuackBehavior的几种具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Quack implements QuackBehavior&#123;</div><div class="line">   public void quack()&#123;</div><div class="line">      //实现呱呱叫的鸭子</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public class Squeak implements QuackBehavior&#123;</div><div class="line">   public void quack()&#123;</div><div class="line">      //实现吱吱叫的鸭子 </div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public class MuteQuack implements QuackBehavior&#123;</div><div class="line">   public void quack()&#123;</div><div class="line">      //什么都不做，不会叫</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>点评一:<br>这样的设计，可以让飞行和呱呱叫的动作被其他的对象复用，因为这些行为已经与鸭子类无关了。而我们增加一些新的行为，不会影响到既有的行为类，也不会影响“使用”到飞行行为的鸭子类。<br>最后我们看看Duck 如何设计。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Duck&#123;        ---------&gt;在抽象类中,声明各接口,定义各接口对应的方法.</div><div class="line">   FlyBehavior flyBehavior;//接口</div><div class="line">   QuackBehavior quackBehavior;//接口</div><div class="line">   public Duck()&#123;&#125;</div><div class="line">   public abstract void display();</div><div class="line">   public void swim()&#123;</div><div class="line">     //实现游泳的行为</div><div class="line">   &#125;</div><div class="line">   public void performFly()&#123;</div><div class="line">      flyBehavior.fly();  --&gt;由于是接口,会根据继承类实现的方式,而调用相应的方法.</div><div class="line">   &#125;</div><div class="line">   public void performQuack()&#123;</div><div class="line">      quackBehavior.quack();();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看看MallardDuck如何实现<br>通过构造方法,生成’飞’,’叫’具体实现类的实例,从而指定’飞’,’叫’的具体属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class MallardDuck extends Duck&#123;</div><div class="line">   public MallardDuck &#123;       </div><div class="line">      flyBehavior = new FlyWithWings ();</div><div class="line">      quackBehavior = new Quack(); </div><div class="line">     //因为MallardDuck 继承了Duck，所有具有flyBehavior 与quackBehavior 实例变量</div><div class="line">  &#125;</div><div class="line">   public void display()&#123;</div><div class="line">    //实现</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就满足了即可以飞，又可以叫，同时展现自己的颜色了。<br>这样的设计我们可以看到是把flyBehavior ，quackBehavior 的实例化写在子类了。我们还可以动态的来决定。<br>我们只需在Duck中加上两个方法。</p>
<p>在构造方法中对属性进行赋值与用属性的setter的区别：<br><strong>构造方法中对属性进行赋值：固定，不可变；<br>用属性的setter，可以在实例化对象后，动态的变化，比较灵活。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Duck&#123;</div><div class="line">   FlyBehavior flyBehavior;//接口</div><div class="line">   QuackBehavior quackBehavior;//接口</div><div class="line">   public void setFlyBehavior(FlyBehavior flyBehavior)&#123;</div><div class="line">      this.flyBehavior = flyBehavior;</div><div class="line">   &#125;</div><div class="line">   public void setQuackBehavior(QuackBehavior quackBehavior  &#123;</div><div class="line">      this.quackBehavior= quackBehavior;</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。<br><strong>意图：</strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。<br><strong>主要解决：</strong>主要解决接口选择的问题。<br><strong>何时使用：</strong>我们明确地计划不同条件下创建不同实例时。<br><strong>如何解决：</strong>让其子类实现工厂接口，返回的也是一个抽象的产品。<br><strong>关键代码：</strong>创建过程在其子类执行。<br><strong>应用实例：</strong> 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。<br><strong>优点：</strong> 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。<br><strong>缺点：</strong>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。<br><strong>注意事项：</strong>作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。<br><strong>实现</strong><br>我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。<br>FactoryPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。<br><img src="http://jet-han.oschina.io/img/设计模式/factory_pattern_uml_diagram.jpg" alt="factory_pattern" title="factory_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口:</p>
<p>Shape.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Shape &#123;</div><div class="line">   void draw();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类:  </p>
<p>Rectangle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Rectangle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Square.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Square implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Square::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Circle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Circle::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建一个工厂，生成基于给定信息的实体类的对象:</p>
<p>ShapeFactory.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class ShapeFactory &#123;</div><div class="line">	</div><div class="line">   //使用 getShape 方法获取形状类型的对象</div><div class="line">   public Shape getShape(String shapeType)&#123;</div><div class="line">      if(shapeType == null)&#123;</div><div class="line">         return null;</div><div class="line">      &#125;		</div><div class="line">      if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123;</div><div class="line">         return new Circle();</div><div class="line">      &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123;</div><div class="line">         return new Rectangle();</div><div class="line">      &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123;</div><div class="line">         return new Square();</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用该工厂，通过传递类型信息来获取实体类的对象:</p>
<p>FactoryPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class FactoryPatternDemo &#123;</div><div class="line"></div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      ShapeFactory shapeFactory = new ShapeFactory();</div><div class="line"></div><div class="line">      //获取 Circle 的对象，并调用它的 draw 方法</div><div class="line">      Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);</div><div class="line"></div><div class="line">      //调用 Circle 的 draw 方法</div><div class="line">      shape1.draw();</div><div class="line"></div><div class="line">      //获取 Rectangle 的对象，并调用它的 draw 方法</div><div class="line">      Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);</div><div class="line"></div><div class="line">      //调用 Rectangle 的 draw 方法</div><div class="line">      shape2.draw();</div><div class="line"></div><div class="line">      //获取 Square 的对象，并调用它的 draw 方法</div><div class="line">      Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);</div><div class="line"></div><div class="line">      //调用 Square 的 draw 方法</div><div class="line">      shape3.draw();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Inside Circle::draw() method.</div><div class="line">Inside Rectangle::draw() method.</div><div class="line">Inside Square::draw() method.</div></pre></td></tr></table></figure>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。<br>介绍<br>意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br>主要解决：主要解决接口选择的问题。<br>何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。<br>如何解决：在一个产品族里面，定义多个产品。<br>关键代码：在一个工厂里聚合多个同类产品。<br>应用实例：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。<br>优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。<br>缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。<br>使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。<br>注意事项：产品族难扩展，产品等级易扩展。<br>实现<br>我们将创建 Shape 和 Color 接口和实现这些接口的实体类。下一步是创建抽象工厂类 AbstractFactory。接着定义工厂类 ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory。然后创建一个工厂创造器/生成器类 FactoryProducer。<br>AbstractFactoryPatternDemo，我们的演示类使用 FactoryProducer 来获取 AbstractFactory 对象。它将向 AbstractFactory 传递形状信息 Shape（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。同时它还向 AbstractFactory 传递颜色信息 Color（RED / GREEN / BLUE），以便获取它所需对象的类型。<br><img src="http://jet-han.oschina.io/img/设计模式/abstractfactory_pattern_uml_diagram.jpg" alt="abstractfactory_pattern" title="abstractfactory_pattern"></p>
<p><strong>步骤 1</strong> </p>
<p>为形状创建一个接口。</p>
<p>Shape.java</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Shape &#123;</div><div class="line">   void draw();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>Rectangle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Rectangle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Square.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Square implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Square::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Circle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Circle::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>为颜色创建一个接口。</p>
<p>Color.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Color &#123;</div><div class="line">   void fill();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤4</strong> </p>
<p>创建实现接口的实体类。  </p>
<p>Red.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Red implements Color &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void fill() &#123;</div><div class="line">      System.out.println(&quot;Inside Red::fill() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Green.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Green implements Color &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void fill() &#123;</div><div class="line">      System.out.println(&quot;Inside Green::fill() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Blue.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Blue implements Color &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void fill() &#123;</div><div class="line">      System.out.println(&quot;Inside Blue::fill() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong>  </p>
<p>为 Color 和 Shape 对象创建抽象类来获取工厂。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">AbstractFactory.java</div><div class="line">public abstract class AbstractFactory &#123;</div><div class="line">   abstract Color getColor(String color);</div><div class="line">   abstract Shape getShape(String shape) ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。</p>
<p>ShapeFactory.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class ShapeFactory extends AbstractFactory &#123;</div><div class="line">	</div><div class="line">   @Override</div><div class="line">   public Shape getShape(String shapeType)&#123;</div><div class="line">      if(shapeType == null)&#123;</div><div class="line">         return null;</div><div class="line">      &#125;		</div><div class="line">      if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123;</div><div class="line">         return new Circle();</div><div class="line">      &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123;</div><div class="line">         return new Rectangle();</div><div class="line">      &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123;</div><div class="line">         return new Square();</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @Override</div><div class="line">   Color getColor(String color) &#123;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ColorFactory.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class ColorFactory extends AbstractFactory &#123;</div><div class="line">	</div><div class="line">   @Override</div><div class="line">   public Shape getShape(String shapeType)&#123;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @Override</div><div class="line">   Color getColor(String color) &#123;</div><div class="line">      if(color == null)&#123;</div><div class="line">         return null;</div><div class="line">      &#125;		</div><div class="line">      if(color.equalsIgnoreCase(&quot;RED&quot;))&#123;</div><div class="line">         return new Red();</div><div class="line">      &#125; else if(color.equalsIgnoreCase(&quot;GREEN&quot;))&#123;</div><div class="line">         return new Green();</div><div class="line">      &#125; else if(color.equalsIgnoreCase(&quot;BLUE&quot;))&#123;</div><div class="line">         return new Blue();</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 7</strong>  </p>
<p>创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。</p>
<p>FactoryProducer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class FactoryProducer &#123;</div><div class="line">   public static AbstractFactory getFactory(String choice)&#123;</div><div class="line">      if(choice.equalsIgnoreCase(&quot;SHAPE&quot;))&#123;</div><div class="line">         return new ShapeFactory();</div><div class="line">      &#125; else if(choice.equalsIgnoreCase(&quot;COLOR&quot;))&#123;</div><div class="line">         return new ColorFactory();</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 8</strong></p>
<p>使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。  </p>
<p>AbstractFactoryPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class AbstractFactoryPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      //获取形状工厂</div><div class="line">      AbstractFactory shapeFactory = FactoryProducer.getFactory(&quot;SHAPE&quot;);</div><div class="line"></div><div class="line">      //获取形状为 Circle 的对象</div><div class="line">      Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);</div><div class="line"></div><div class="line">      //调用 Circle 的 draw 方法</div><div class="line">      shape1.draw();</div><div class="line"></div><div class="line">      //获取形状为 Rectangle 的对象</div><div class="line">      Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);</div><div class="line"></div><div class="line">      //调用 Rectangle 的 draw 方法</div><div class="line">      shape2.draw();</div><div class="line">      </div><div class="line">      //获取形状为 Square 的对象</div><div class="line">      Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);</div><div class="line"></div><div class="line">      //调用 Square 的 draw 方法</div><div class="line">      shape3.draw();</div><div class="line"></div><div class="line">      //获取颜色工厂</div><div class="line">      AbstractFactory colorFactory = FactoryProducer.getFactory(&quot;COLOR&quot;);</div><div class="line"></div><div class="line">      //获取颜色为 Red 的对象</div><div class="line">      Color color1 = colorFactory.getColor(&quot;RED&quot;);</div><div class="line"></div><div class="line">      //调用 Red 的 fill 方法</div><div class="line">      color1.fill();</div><div class="line"></div><div class="line">      //获取颜色为 Green 的对象</div><div class="line">      Color color2 = colorFactory.getColor(&quot;Green&quot;);</div><div class="line"></div><div class="line">      //调用 Green 的 fill 方法</div><div class="line">      color2.fill();</div><div class="line"></div><div class="line">      //获取颜色为 Blue 的对象</div><div class="line">      Color color3 = colorFactory.getColor(&quot;BLUE&quot;);</div><div class="line"></div><div class="line">      //调用 Blue 的 fill 方法</div><div class="line">      color3.fill();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 9</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Inside Circle::draw() method.</div><div class="line">Inside Rectangle::draw() method.</div><div class="line">Inside Square::draw() method.</div><div class="line">Inside Red::fill() method.</div><div class="line">Inside Green::fill() method.</div><div class="line">Inside Blue::fill() method.</div></pre></td></tr></table></figure>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。<br>注意：<br>1、单例类只能有一个实例。<br>2、单例类必须自己创建自己的唯一实例。<br>3、单例类必须给所有其他对象提供这一实例。<br><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。<br><strong>何时使用：</strong>当您想控制实例数目，节省系统资源的时候。<br><strong>如何解决：</strong>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。<br><strong>关键代码：</strong>构造函数是私有的。<br><strong>优点： </strong>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。<br><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。<br><strong>使用场景：</strong> 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。<br><strong>注意事项：</strong>getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。<br><strong>实现</strong><br>我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。<br>SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。<br><img src="http://jet-han.oschina.io/img/设计模式/singleton_pattern_uml_diagram.jpg" alt="singleton_pattern" title="singleton_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个 Singleton 类。</p>
<p>SingleObject.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class SingleObject &#123;</div><div class="line"></div><div class="line">   //创建 SingleObject 的一个对象</div><div class="line">   private static SingleObject instance = new SingleObject();</div><div class="line"></div><div class="line">   //让构造函数为 private，这样该类就不会被实例化</div><div class="line">   private SingleObject()&#123;&#125;</div><div class="line"></div><div class="line">   //获取唯一可用的对象</div><div class="line">   public static SingleObject getInstance()&#123;</div><div class="line">      return instance;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void showMessage()&#123;</div><div class="line">      System.out.println(&quot;Hello World!&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>从 singleton 类获取唯一的对象。</p>
<p>SingletonPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class SingletonPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      //不合法的构造函数</div><div class="line">      //编译时错误：构造函数 SingleObject() 是不可见的</div><div class="line">      //SingleObject object = new SingleObject();</div><div class="line"></div><div class="line">      //获取唯一可用的对象</div><div class="line">      SingleObject object = SingleObject.getInstance();</div><div class="line"></div><div class="line">      //显示消息</div><div class="line">      object.showMessage();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello World!</div></pre></td></tr></table></figure>
<p><strong>单例模式的几种实现方式</strong><br>单例模式的实现有多种方式，如下所示：<br><strong>1、懒汉式，线程不安全</strong><br><strong>是否 Lazy 初始化</strong>：是<br><strong>是否多线程安全：</strong>否<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。<br>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。<br><strong>代码实例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">    private static Singleton instance;  </div><div class="line">    private Singleton ()&#123;&#125;  </div><div class="line">  </div><div class="line">    public static Singleton getInstance() &#123;  </div><div class="line">    if (instance == null) &#123;  </div><div class="line">        instance = new Singleton();  </div><div class="line">    &#125;  </div><div class="line">    return instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。  </p>
<p><strong>2、懒汉式，线程安全</strong><br><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。<br><strong>优点：</strong>第一次调用才初始化，避免内存浪费。<br><strong>缺点：</strong>必须加锁 synchronized 才能保证单例，但加锁会影响效率。<br>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。<br><strong>代码实例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">    private static Singleton instance;  </div><div class="line">    private Singleton ()&#123;&#125;  </div><div class="line">    public static synchronized Singleton getInstance() &#123;  </div><div class="line">    if (instance == null) &#123;  </div><div class="line">        instance = new Singleton();  </div><div class="line">    &#125;  </div><div class="line">    return instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>3、饿汉式</strong><br><strong>是否 Lazy 初始化：</strong>否<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种方式比较常用，但容易产生垃圾对象。<br><strong>优点：</strong>没有加锁，执行效率会提高。<br><strong>缺点：</strong>类加载时就初始化，浪费内存。<br>它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。<br><strong>代码实例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">    private static Singleton instance = new Singleton();  </div><div class="line">    private Singleton ()&#123;&#125;  </div><div class="line">    public static Singleton getInstance() &#123;  </div><div class="line">    return instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>4、双检锁/双重校验锁（DCL，即 double-checked locking）</strong><br><strong>JDK 版本：</strong>JDK1.5 起<br><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>较复杂<br><strong>描述：</strong>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance() 的性能对应用程序很关键。<br><strong>代码实例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">    private volatile static Singleton singleton;  </div><div class="line">    private Singleton ()&#123;&#125;  </div><div class="line">    public static Singleton getSingleton() &#123;  </div><div class="line">    if (singleton == null) &#123;  </div><div class="line">        synchronized (Singleton.class) &#123;  </div><div class="line">        if (singleton == null) &#123;  </div><div class="line">            singleton = new Singleton();  </div><div class="line">        &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    return singleton;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>5、登记式/静态内部类</strong><br><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全</strong>：是<br><strong>实现难度：</strong>一般<br><strong>描述：</strong>这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<br>这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有显示通过调用 getInstance 方法时，才会显示装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。<br><strong>代码实例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">    private static class SingletonHolder &#123;  </div><div class="line">    private static final Singleton INSTANCE = new Singleton();  </div><div class="line">    &#125;  </div><div class="line">    private Singleton ()&#123;&#125;  </div><div class="line">    public static final Singleton getInstance() &#123;  </div><div class="line">    return SingletonHolder.INSTANCE;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>6、枚举</strong><br><strong>JDK 版本：</strong>JDK1.5 起<br><strong>是否 Lazy 初始化：</strong>否<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。<br>不能通过 reflection attack 来调用私有构造方法。<br><strong>代码实例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public enum Singleton &#123;  </div><div class="line">    INSTANCE;  </div><div class="line">    public void whateverMethod() &#123;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>经验之谈：</strong>一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。   </p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。<br>意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br><strong>主要解决：</strong>主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。<br><strong>何时使用：</strong>一些基本部件不会变，而其组合经常变化的时候。<br><strong>如何解决：</strong>将变与不变分离开。<br><strong>关键代码：</strong>建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。<br><strong>应用实例：</strong> 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。 2、JAVA 中的 StringBuilder。<br><strong>优点：</strong> 1、建造者独立，易扩展。 2、便于控制细节风险。<br><strong>缺点：</strong> 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。<br><strong>使用场景：</strong> 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。<br><strong>注意事项：</strong>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。<br><strong>实现</strong><br>我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。<br>我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。<br>然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo，我们的演示类使用 MealBuilder 来创建一个 Meal。<br><img src="http://jet-han.oschina.io/img/设计模式/builder_pattern_uml_diagram.jpg" alt="builder_pattern" title="builder_pattern"></p>
<p><strong>步骤 1</strong>  </p>
<p>创建一个表示食物条目和食物包装的接口。</p>
<p>Item.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface Item &#123;</div><div class="line">   public String name();</div><div class="line">   public Packing packing();</div><div class="line">   public float price();	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Packing.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Packing &#123;</div><div class="line">   public String pack();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现 Packing 接口的实体类。</p>
<p>Wrapper.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Wrapper implements Packing &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String pack() &#123;</div><div class="line">      return &quot;Wrapper&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Bottle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Bottle implements Packing &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String pack() &#123;</div><div class="line">      return &quot;Bottle&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实现 Item 接口的抽象类，该类提供了默认的功能。</p>
<p>Burger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public abstract class Burger implements Item &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public Packing packing() &#123;</div><div class="line">      return new Wrapper();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public abstract float price();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ColdDrink.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public abstract class ColdDrink implements Item &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Packing packing() &#123;</div><div class="line">       return new Bottle();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public abstract float price();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建扩展了 Burger 和 ColdDrink 的实体类。</p>
<p>VegBurger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class VegBurger extends Burger &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public float price() &#123;</div><div class="line">      return 25.0f;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String name() &#123;</div><div class="line">      return &quot;Veg Burger&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ChickenBurger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class ChickenBurger extends Burger &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public float price() &#123;</div><div class="line">      return 50.5f;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String name() &#123;</div><div class="line">      return &quot;Chicken Burger&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Coke.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Coke extends ColdDrink &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public float price() &#123;</div><div class="line">      return 30.0f;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String name() &#123;</div><div class="line">      return &quot;Coke&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Pepsi.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Pepsi extends ColdDrink &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public float price() &#123;</div><div class="line">      return 35.0f;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String name() &#123;</div><div class="line">      return &quot;Pepsi&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>创建一个 Meal 类，带有上面定义的 Item 对象。</p>
<p>Meal.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class Meal &#123;</div><div class="line">   private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;();	</div><div class="line"></div><div class="line">   public void addItem(Item item)&#123;</div><div class="line">      items.add(item);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public float getCost()&#123;</div><div class="line">      float cost = 0.0f;</div><div class="line">      for (Item item : items) &#123;</div><div class="line">         cost += item.price();</div><div class="line">      &#125;		</div><div class="line">      return cost;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void showItems()&#123;</div><div class="line">      for (Item item : items) &#123;</div><div class="line">         System.out.print(&quot;Item : &quot;+item.name());</div><div class="line">         System.out.print(&quot;, Packing : &quot;+item.packing().pack());</div><div class="line">         System.out.println(&quot;, Price : &quot;+item.price());</div><div class="line">      &#125;		</div><div class="line">   &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。</p>
<p>MealBuilder.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class MealBuilder &#123;</div><div class="line"></div><div class="line">   public Meal prepareVegMeal ()&#123;</div><div class="line">      Meal meal = new Meal();</div><div class="line">      meal.addItem(new VegBurger());</div><div class="line">      meal.addItem(new Coke());</div><div class="line">      return meal;</div><div class="line">   &#125;   </div><div class="line"></div><div class="line">   public Meal prepareNonVegMeal ()&#123;</div><div class="line">      Meal meal = new Meal();</div><div class="line">      meal.addItem(new ChickenBurger());</div><div class="line">      meal.addItem(new Pepsi());</div><div class="line">      return meal;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 7</strong></p>
<p>BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern）。</p>
<p>BuilderPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class BuilderPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      MealBuilder mealBuilder = new MealBuilder();</div><div class="line"></div><div class="line">      Meal vegMeal = mealBuilder.prepareVegMeal();</div><div class="line">      System.out.println(&quot;Veg Meal&quot;);</div><div class="line">      vegMeal.showItems();</div><div class="line">      System.out.println(&quot;Total Cost: &quot; +vegMeal.getCost());</div><div class="line"></div><div class="line">      Meal nonVegMeal = mealBuilder.prepareNonVegMeal();</div><div class="line">      System.out.println(&quot;\n\nNon-Veg Meal&quot;);</div><div class="line">      nonVegMeal.showItems();</div><div class="line">      System.out.println(&quot;Total Cost: &quot; +nonVegMeal.getCost());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 8</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Veg Meal</div><div class="line">Item : Veg Burger, Packing : Wrapper, Price : 25.0</div><div class="line">Item : Coke, Packing : Bottle, Price : 30.0</div><div class="line">Total Cost: 55.0</div><div class="line"></div><div class="line">Non-Veg Meal</div><div class="line">Item : Chicken Burger, Packing : Wrapper, Price : 50.5</div><div class="line">Item : Pepsi, Packing : Bottle, Price : 35.0</div><div class="line">Total Cost: 85.5</div></pre></td></tr></table></figure>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。<br><strong>意图：</strong>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br><strong>主要解决：</strong>在运行期建立和删除原型。<br><strong>何时使用：</strong> 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。<br><strong>如何解决：</strong>利用已有的一个原型对象，快速地生成和原型对象一样的实例。<br><strong>关键代码：</strong> 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口。<br><strong>应用实例：</strong> 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。<br><strong>优点：</strong> 1、性能提高。 2、逃避构造函数的约束。<br><strong>缺点：</strong> 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。 3、逃避构造函数的约束。<br><strong>使用场景：</strong> 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。   5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。<br>注意事项：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。<br><strong>实现 </strong><br>我们将创建一个抽象类 Shape 和扩展了 Shape 类的实体类。下一步是定义类 ShapeCache，该类把 shape 对象存储在一个 Hashtable 中，并在请求的时候返回它们的克隆。<br>PrototypPatternDemo，我们的演示类使用 ShapeCache 类来获取 Shape 对象<br><img src="http://jet-han.oschina.io/img/设计模式/prototype_pattern_uml_diagram.jpg" alt="prototype_pattern" title="prototype_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个实现了 Clonable 接口的抽象类。</p>
<p>Shape.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public abstract class Shape implements Cloneable &#123;</div><div class="line">   </div><div class="line">   private String id;</div><div class="line">   protected String type;</div><div class="line">   </div><div class="line">   abstract void draw();</div><div class="line">   </div><div class="line">   public String getType()&#123;</div><div class="line">      return type;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   public String getId() &#123;</div><div class="line">      return id;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   public void setId(String id) &#123;</div><div class="line">      this.id = id;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   public Object clone() &#123;</div><div class="line">      Object clone = null;</div><div class="line">      try &#123;</div><div class="line">         clone = super.clone();</div><div class="line">      &#125; catch (CloneNotSupportedException e) &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">      return clone;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建扩展了上面抽象类的实体类。</p>
<p>Rectangle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Rectangle extends Shape &#123;</div><div class="line"></div><div class="line">   public Rectangle()&#123;</div><div class="line">     type = &quot;Rectangle&quot;;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Square.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Square extends Shape &#123;</div><div class="line"></div><div class="line">   public Square()&#123;</div><div class="line">     type = &quot;Square&quot;;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Square::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Circle extends Shape &#123;</div><div class="line"></div><div class="line">   public Circle()&#123;</div><div class="line">     type = &quot;Circle&quot;;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Inside Circle::draw() method.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建一个类，从数据库获取实体类，并把它们存储在一个 Hashtable 中。</p>
<p>ShapeCache.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">import java.util.Hashtable;</div><div class="line"></div><div class="line">public class ShapeCache &#123;</div><div class="line">	</div><div class="line">   private static Hashtable&lt;String, Shape&gt; shapeMap </div><div class="line">      = new Hashtable&lt;String, Shape&gt;();</div><div class="line"></div><div class="line">   public static Shape getShape(String shapeId) &#123;</div><div class="line">      Shape cachedShape = shapeMap.get(shapeId);</div><div class="line">      return (Shape) cachedShape.clone();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // 对每种形状都运行数据库查询，并创建该形状</div><div class="line">   // shapeMap.put(shapeKey, shape);</div><div class="line">   // 例如，我们要添加三种形状</div><div class="line">   public static void loadCache() &#123;</div><div class="line">      Circle circle = new Circle();</div><div class="line">      circle.setId(&quot;1&quot;);</div><div class="line">      shapeMap.put(circle.getId(),circle);</div><div class="line"></div><div class="line">      Square square = new Square();</div><div class="line">      square.setId(&quot;2&quot;);</div><div class="line">      shapeMap.put(square.getId(),square);</div><div class="line"></div><div class="line">      Rectangle rectangle = new Rectangle();</div><div class="line">      rectangle.setId(&quot;3&quot;);</div><div class="line">      shapeMap.put(rectangle.getId(),rectangle);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>PrototypePatternDemo 使用 ShapeCache 类来获取存储在 Hashtable 中的形状的克隆。</p>
<p>PrototypePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class PrototypePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      ShapeCache.loadCache();</div><div class="line"></div><div class="line">      Shape clonedShape = (Shape) ShapeCache.getShape(&quot;1&quot;);</div><div class="line">      System.out.println(&quot;Shape : &quot; + clonedShape.getType());		</div><div class="line"></div><div class="line">      Shape clonedShape2 = (Shape) ShapeCache.getShape(&quot;2&quot;);</div><div class="line">      System.out.println(&quot;Shape : &quot; + clonedShape2.getType());		</div><div class="line"></div><div class="line">      Shape clonedShape3 = (Shape) ShapeCache.getShape(&quot;3&quot;);</div><div class="line">      System.out.println(&quot;Shape : &quot; + clonedShape3.getType());		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Shape : Circle</div><div class="line">Shape : Square</div><div class="line">Shape : Rectangle</div></pre></td></tr></table></figure>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。<br>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。<br>我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。<br><strong>意图：</strong>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>主要解决：主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。<br><strong>何时使用：</strong> 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）<br><strong>如何解决：</strong>继承或依赖（推荐）。<br><strong>关键代码：</strong>适配器继承或依赖已有的对象，实现想要的目标接口。<br><strong>应用实例：</strong> 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。<br><strong>优点：</strong> 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。<br><strong>缺点：</strong> 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。<br><strong>使用场景：</strong>有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。<br><strong>注意事项：</strong>适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。<br><strong>实现</strong><br>我们有一个 MediaPlayer 接口和一个实现了 MediaPlayer 接口的实体类 AudioPlayer。默认情况下，AudioPlayer 可以播放 mp3 格式的音频文件。<br>我们还有另一个接口 AdvancedMediaPlayer 和实现了 AdvancedMediaPlayer 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。<br>我们想要让 AudioPlayer 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 MediaPlayer 接口的适配器类 MediaAdapter，并使用 AdvancedMediaPlayer 对象来播放所需的格式。<br>AudioPlayer 使用适配器类 MediaAdapter 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。AdapterPatternDemo，我们的演示类使用 AudioPlayer 类来播放各种格式。<br><img src="http://jet-han.oschina.io/img/设计模式/adapter_pattern_uml_diagram.jpg" alt="adapter_pattern" title="adapter_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>为媒体播放器和更高级的媒体播放器创建接口。</p>
<p>MediaPlayer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public interface MediaPlayer &#123;</div><div class="line">   public void play(String audioType, String fileName);</div><div class="line">&#125;</div><div class="line">AdvancedMediaPlayer.java</div><div class="line">public interface AdvancedMediaPlayer &#123;	</div><div class="line">   public void playVlc(String fileName);</div><div class="line">   public void playMp4(String fileName);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现了 AdvancedMediaPlayer 接口的实体类。</p>
<p>VlcPlayer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class VlcPlayer implements AdvancedMediaPlayer&#123;</div><div class="line">   @Override</div><div class="line">   public void playVlc(String fileName) &#123;</div><div class="line">      System.out.println(&quot;Playing vlc file. Name: &quot;+ fileName);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void playMp4(String fileName) &#123;</div><div class="line">      //什么也不做</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Mp4Player.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Mp4Player implements AdvancedMediaPlayer&#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void playVlc(String fileName) &#123;</div><div class="line">      //什么也不做</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void playMp4(String fileName) &#123;</div><div class="line">      System.out.println(&quot;Playing mp4 file. Name: &quot;+ fileName);		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实现了 MediaPlayer 接口的适配器类。</p>
<p>MediaAdapter.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class MediaAdapter implements MediaPlayer &#123;</div><div class="line"></div><div class="line">   AdvancedMediaPlayer advancedMusicPlayer;</div><div class="line"></div><div class="line">   public MediaAdapter(String audioType)&#123;</div><div class="line">      if(audioType.equalsIgnoreCase(&quot;vlc&quot;) )&#123;</div><div class="line">         advancedMusicPlayer = new VlcPlayer();			</div><div class="line">      &#125; else if (audioType.equalsIgnoreCase(&quot;mp4&quot;))&#123;</div><div class="line">         advancedMusicPlayer = new Mp4Player();</div><div class="line">      &#125;	</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void play(String audioType, String fileName) &#123;</div><div class="line">      if(audioType.equalsIgnoreCase(&quot;vlc&quot;))&#123;</div><div class="line">         advancedMusicPlayer.playVlc(fileName);</div><div class="line">      &#125;else if(audioType.equalsIgnoreCase(&quot;mp4&quot;))&#123;</div><div class="line">         advancedMusicPlayer.playMp4(fileName);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建实现了 MediaPlayer 接口的实体类。</p>
<p>AudioPlayer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class AudioPlayer implements MediaPlayer &#123;</div><div class="line">   MediaAdapter mediaAdapter; </div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void play(String audioType, String fileName) &#123;		</div><div class="line"></div><div class="line">      //播放 mp3 音乐文件的内置支持</div><div class="line">      if(audioType.equalsIgnoreCase(&quot;mp3&quot;))&#123;</div><div class="line">         System.out.println(&quot;Playing mp3 file. Name: &quot;+ fileName);			</div><div class="line">      &#125; </div><div class="line">      //mediaAdapter 提供了播放其他文件格式的支持</div><div class="line">      else if(audioType.equalsIgnoreCase(&quot;vlc&quot;) </div><div class="line">         || audioType.equalsIgnoreCase(&quot;mp4&quot;))&#123;</div><div class="line">         mediaAdapter = new MediaAdapter(audioType);</div><div class="line">         mediaAdapter.play(audioType, fileName);</div><div class="line">      &#125;</div><div class="line">      else&#123;</div><div class="line">         System.out.println(&quot;Invalid media. &quot;+</div><div class="line">            audioType + &quot; format not supported&quot;);</div><div class="line">      &#125;</div><div class="line">   &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>使用 AudioPlayer 来播放不同类型的音频格式。</p>
<p>AdapterPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class AdapterPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      AudioPlayer audioPlayer = new AudioPlayer();</div><div class="line"></div><div class="line">      audioPlayer.play(&quot;mp3&quot;, &quot;beyond the horizon.mp3&quot;);</div><div class="line">      audioPlayer.play(&quot;mp4&quot;, &quot;alone.mp4&quot;);</div><div class="line">      audioPlayer.play(&quot;vlc&quot;, &quot;far far away.vlc&quot;);</div><div class="line">      audioPlayer.play(&quot;avi&quot;, &quot;mind me.avi&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Playing mp3 file. Name: beyond the horizon.mp3</div><div class="line">Playing mp4 file. Name: alone.mp4</div><div class="line">Playing vlc file. Name: far far away.vlc</div><div class="line">Invalid media. avi format not supported</div></pre></td></tr></table></figure>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。<br>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。<br>我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。<br><strong>意图：</strong>将抽象部分与实现部分分离，使它们都可以独立的变化。<br><strong>主要解决：</strong>在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。<br><strong>何时使用：</strong>实现系统可能有多个角度分类，每一种角度都可能变化。<br><strong>如何解决：</strong>把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。<br><strong>关键代码：</strong>抽象类依赖实现类。<br><strong>应用实例：</strong> 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。<br><strong>优点：</strong> 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。<br><strong>缺点：</strong>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。<br><strong>使用场景：</strong> 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。<br><strong>注意事项：</strong>对于两个独立变化的维度，使用桥接模式再适合不过了。<br><strong>实现 </strong><br>我们有一个作为桥接实现的 DrawAPI 接口和实现了 DrawAPI 接口的实体类 RedCircle、GreenCircle。Shape 是一个抽象类，将使用 DrawAPI 的对象。BridgePatternDemo，我们的演示类使用 Shape 类来画出不同颜色的圆。<br><img src="http://jet-han.oschina.io/img/设计模式/bridge_pattern_uml_diagram.jpg" alt="bridge_pattern" title="bridge_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建桥接实现接口。</p>
<p>DrawAPI.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface DrawAPI &#123;</div><div class="line">   public void drawCircle(int radius, int x, int y);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现了 DrawAPI 接口的实体桥接实现类。</p>
<p>RedCircle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class RedCircle implements DrawAPI &#123;</div><div class="line">   @Override</div><div class="line">   public void drawCircle(int radius, int x, int y) &#123;</div><div class="line">      System.out.println(&quot;Drawing Circle[ color: red, radius: &quot;</div><div class="line">         + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>GreenCircle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class GreenCircle implements DrawAPI &#123;</div><div class="line">   @Override</div><div class="line">   public void drawCircle(int radius, int x, int y) &#123;</div><div class="line">      System.out.println(&quot;Drawing Circle[ color: green, radius: &quot;</div><div class="line">         + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>使用 DrawAPI 接口创建抽象类 Shape。</p>
<p>Shape.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public abstract class Shape &#123;</div><div class="line">   protected DrawAPI drawAPI;</div><div class="line">   protected Shape(DrawAPI drawAPI)&#123;</div><div class="line">      this.drawAPI = drawAPI;</div><div class="line">   &#125;</div><div class="line">   public abstract void draw();	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建实现了 Shape 接口的实体类。</p>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Circle extends Shape &#123;</div><div class="line">   private int x, y, radius;</div><div class="line"></div><div class="line">   public Circle(int x, int y, int radius, DrawAPI drawAPI) &#123;</div><div class="line">      super(drawAPI);</div><div class="line">      this.x = x;  </div><div class="line">      this.y = y;  </div><div class="line">      this.radius = radius;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void draw() &#123;</div><div class="line">      drawAPI.drawCircle(radius,x,y);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>使用 Shape 和 DrawAPI 类画出不同颜色的圆。</p>
<p>BridgePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class BridgePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Shape redCircle = new Circle(100,100, 10, new RedCircle());</div><div class="line">      Shape greenCircle = new Circle(100,100, 10, new GreenCircle());</div><div class="line"></div><div class="line">      redCircle.draw();</div><div class="line">      greenCircle.draw();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Drawing Circle[ color: red, radius: 10, x: 100, 100]</div><div class="line">Drawing Circle[  color: green, radius: 10, x: 100, 100]</div></pre></td></tr></table></figure>
<h2 id="过滤器模式"><a href="#过滤器模式" class="headerlink" title="过滤器模式"></a>过滤器模式</h2><p>过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。<br><strong>实现</strong><br>我们将创建一个 Person 对象、Criteria 接口和实现了该接口的实体类，来过滤 Person 对象的列表。CriteriaPatternDemo，我们的演示类使用 Criteria 对象，基于各种标准和它们的结合来过滤 Person 对象的列表。<br><img src="http://jet-han.oschina.io/img/设计模式/filter_pattern_uml_diagram.jpg" alt="filter_pattern" title="filter_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个类，在该类上应用标准。</p>
<p>Person.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Person &#123;</div><div class="line">	</div><div class="line">   private String name;</div><div class="line">   private String gender;</div><div class="line">   private String maritalStatus;</div><div class="line"></div><div class="line">   public Person(String name,String gender,String maritalStatus)&#123;</div><div class="line">      this.name = name;</div><div class="line">      this.gender = gender;</div><div class="line">      this.maritalStatus = maritalStatus;		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getName() &#123;</div><div class="line">      return name;</div><div class="line">   &#125;</div><div class="line">   public String getGender() &#123;</div><div class="line">      return gender;</div><div class="line">   &#125;</div><div class="line">   public String getMaritalStatus() &#123;</div><div class="line">      return maritalStatus;</div><div class="line">   &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>为标准（Criteria）创建一个接口。</p>
<p>Criteria.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public interface Criteria &#123;</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实现了 Criteria 接口的实体类。</p>
<p>CriteriaMale.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class CriteriaMale implements Criteria &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123;</div><div class="line">      List&lt;Person&gt; malePersons = new ArrayList&lt;Person&gt;(); </div><div class="line">      for (Person person : persons) &#123;</div><div class="line">         if(person.getGender().equalsIgnoreCase(&quot;MALE&quot;))&#123;</div><div class="line">            malePersons.add(person);</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      return malePersons;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CriteriaFemale.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class CriteriaFemale implements Criteria &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123;</div><div class="line">      List&lt;Person&gt; femalePersons = new ArrayList&lt;Person&gt;(); </div><div class="line">      for (Person person : persons) &#123;</div><div class="line">         if(person.getGender().equalsIgnoreCase(&quot;FEMALE&quot;))&#123;</div><div class="line">            femalePersons.add(person);</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      return femalePersons;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CriteriaSingle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class CriteriaSingle implements Criteria &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123;</div><div class="line">      List&lt;Person&gt; singlePersons = new ArrayList&lt;Person&gt;(); </div><div class="line">      for (Person person : persons) &#123;</div><div class="line">         if(person.getMaritalStatus().equalsIgnoreCase(&quot;SINGLE&quot;))&#123;</div><div class="line">            singlePersons.add(person);</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      return singlePersons;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AndCriteria.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class AndCriteria implements Criteria &#123;</div><div class="line"></div><div class="line">   private Criteria criteria;</div><div class="line">   private Criteria otherCriteria;</div><div class="line"></div><div class="line">   public AndCriteria(Criteria criteria, Criteria otherCriteria) &#123;</div><div class="line">      this.criteria = criteria;</div><div class="line">      this.otherCriteria = otherCriteria; </div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123;</div><div class="line">      List&lt;Person&gt; firstCriteriaPersons = criteria.meetCriteria(persons);		</div><div class="line">      return otherCriteria.meetCriteria(firstCriteriaPersons);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OrCriteria.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class OrCriteria implements Criteria &#123;</div><div class="line"></div><div class="line">   private Criteria criteria;</div><div class="line">   private Criteria otherCriteria;</div><div class="line"></div><div class="line">   public OrCriteria(Criteria criteria, Criteria otherCriteria) &#123;</div><div class="line">      this.criteria = criteria;</div><div class="line">      this.otherCriteria = otherCriteria; </div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123;</div><div class="line">      List&lt;Person&gt; firstCriteriaItems = criteria.meetCriteria(persons);</div><div class="line">      List&lt;Person&gt; otherCriteriaItems = otherCriteria.meetCriteria(persons);</div><div class="line"></div><div class="line">      for (Person person : otherCriteriaItems) &#123;</div><div class="line">         if(!firstCriteriaItems.contains(person))&#123;</div><div class="line">	        firstCriteriaItems.add(person);</div><div class="line">         &#125;</div><div class="line">      &#125;	</div><div class="line">      return firstCriteriaItems;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤4</strong></p>
<p>使用不同的标准（Criteria）和它们的结合来过滤 Person 对象的列表。</p>
<p>CriteriaPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList; </div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class CriteriaPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;();</div><div class="line"></div><div class="line">      persons.add(new Person(&quot;Robert&quot;,&quot;Male&quot;, &quot;Single&quot;));</div><div class="line">      persons.add(new Person(&quot;John&quot;,&quot;Male&quot;, &quot;Married&quot;));</div><div class="line">      persons.add(new Person(&quot;Laura&quot;,&quot;Female&quot;, &quot;Married&quot;));</div><div class="line">      persons.add(new Person(&quot;Diana&quot;,&quot;Female&quot;, &quot;Single&quot;));</div><div class="line">      persons.add(new Person(&quot;Mike&quot;,&quot;Male&quot;, &quot;Single&quot;));</div><div class="line">      persons.add(new Person(&quot;Bobby&quot;,&quot;Male&quot;, &quot;Single&quot;));</div><div class="line"></div><div class="line">      Criteria male = new CriteriaMale();</div><div class="line">      Criteria female = new CriteriaFemale();</div><div class="line">      Criteria single = new CriteriaSingle();</div><div class="line">      Criteria singleMale = new AndCriteria(single, male);</div><div class="line">      Criteria singleOrFemale = new OrCriteria(single, female);</div><div class="line"></div><div class="line">      System.out.println(&quot;Males: &quot;);</div><div class="line">      printPersons(male.meetCriteria(persons));</div><div class="line"></div><div class="line">      System.out.println(&quot;\nFemales: &quot;);</div><div class="line">      printPersons(female.meetCriteria(persons));</div><div class="line"></div><div class="line">      System.out.println(&quot;\nSingle Males: &quot;);</div><div class="line">      printPersons(singleMale.meetCriteria(persons));</div><div class="line"></div><div class="line">      System.out.println(&quot;\nSingle Or Females: &quot;);</div><div class="line">      printPersons(singleOrFemale.meetCriteria(persons));</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public static void printPersons(List&lt;Person&gt; persons)&#123;</div><div class="line">      for (Person person : persons) &#123;</div><div class="line">         System.out.println(&quot;Person : [ Name : &quot; + person.getName() </div><div class="line">            +&quot;, Gender : &quot; + person.getGender() </div><div class="line">            +&quot;, Marital Status : &quot; + person.getMaritalStatus()</div><div class="line">            +&quot; ]&quot;);</div><div class="line">      &#125;</div><div class="line">   &#125;      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Males: </div><div class="line">Person : [ Name : Robert, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : John, Gender : Male, Marital Status : Married ]</div><div class="line">Person : [ Name : Mike, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]</div><div class="line"></div><div class="line">Females: </div><div class="line">Person : [ Name : Laura, Gender : Female, Marital Status : Married ]</div><div class="line">Person : [ Name : Diana, Gender : Female, Marital Status : Single ]</div><div class="line"></div><div class="line">Single Males: </div><div class="line">Person : [ Name : Robert, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Mike, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]</div><div class="line"></div><div class="line">Single Or Females: </div><div class="line">Person : [ Name : Robert, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Diana, Gender : Female, Marital Status : Single ]</div><div class="line">Person : [ Name : Mike, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]</div><div class="line">Person : [ Name : Laura, Gender : Female, Marital Status : Married ]</div></pre></td></tr></table></figure>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。<br>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。<br>我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。<br>意图：将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。<br><strong>主要解决：</strong>它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。<br><strong>何时使用：</strong> 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。<br><strong>如何解决：</strong>树枝和叶子实现统一接口，树枝内部组合该接口。<br>关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。<br><strong>应用实例：</strong> 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作树、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。<br><strong>优点：</strong> 1、高层模块调用简单。 2、节点自由增加。<br><strong>缺点：</strong>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。<br><strong>使用场景：</strong>部分、整体场景，如树形菜单，文件、文件夹的管理。<br><strong>注意事项：</strong>定义时为具体类。<br><strong>实现</strong><br>我们有一个类 Employee，该类被当作组合模型类。CompositePatternDemo，我们的演示类使用 Employee 类来添加部门层次结构，并打印所有员工。<br><img src="http://jet-han.oschina.io/img/设计模式/composite_pattern_uml_diagram.jpg" alt="composite_pattern" title="composite_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建 Employee 类，该类带有 Employee 对象的列表。</p>
<p>Employee.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class Employee &#123;</div><div class="line">   private String name;</div><div class="line">   private String dept;</div><div class="line">   private int salary;</div><div class="line">   private List&lt;Employee&gt; subordinates;</div><div class="line"></div><div class="line">   //构造函数</div><div class="line">   public Employee(String name,String dept, int sal) &#123;</div><div class="line">      this.name = name;</div><div class="line">      this.dept = dept;</div><div class="line">      this.salary = sal;</div><div class="line">      subordinates = new ArrayList&lt;Employee&gt;();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void add(Employee e) &#123;</div><div class="line">      subordinates.add(e);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void remove(Employee e) &#123;</div><div class="line">      subordinates.remove(e);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public List&lt;Employee&gt; getSubordinates()&#123;</div><div class="line">     return subordinates;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String toString()&#123;</div><div class="line">      return (&quot;Employee :[ Name : &quot;+ name </div><div class="line">      +&quot;, dept : &quot;+ dept + &quot;, salary :&quot;</div><div class="line">      + salary+&quot; ]&quot;);</div><div class="line">   &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>使用 Employee 类来创建和打印员工的层次结构。</p>
<p>CompositePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class CompositePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Employee CEO = new Employee(&quot;John&quot;,&quot;CEO&quot;, 30000);</div><div class="line"></div><div class="line">      Employee headSales = new Employee(&quot;Robert&quot;,&quot;Head Sales&quot;, 20000);</div><div class="line"></div><div class="line">      Employee headMarketing = new Employee(&quot;Michel&quot;,&quot;Head Marketing&quot;, 20000);</div><div class="line"></div><div class="line">      Employee clerk1 = new Employee(&quot;Laura&quot;,&quot;Marketing&quot;, 10000);</div><div class="line">      Employee clerk2 = new Employee(&quot;Bob&quot;,&quot;Marketing&quot;, 10000);</div><div class="line"></div><div class="line">      Employee salesExecutive1 = new Employee(&quot;Richard&quot;,&quot;Sales&quot;, 10000);</div><div class="line">      Employee salesExecutive2 = new Employee(&quot;Rob&quot;,&quot;Sales&quot;, 10000);</div><div class="line"></div><div class="line">      CEO.add(headSales);</div><div class="line">      CEO.add(headMarketing);</div><div class="line"></div><div class="line">      headSales.add(salesExecutive1);</div><div class="line">      headSales.add(salesExecutive2);</div><div class="line"></div><div class="line">      headMarketing.add(clerk1);</div><div class="line">      headMarketing.add(clerk2);</div><div class="line"></div><div class="line">      //打印该组织的所有员工</div><div class="line">      System.out.println(CEO); </div><div class="line">      for (Employee headEmployee : CEO.getSubordinates()) &#123;</div><div class="line">         System.out.println(headEmployee);</div><div class="line">         for (Employee employee : headEmployee.getSubordinates()) &#123;</div><div class="line">            System.out.println(employee);</div><div class="line">         &#125;</div><div class="line">      &#125;		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Employee :[ Name : John, dept : CEO, salary :30000 ]</div><div class="line">Employee :[ Name : Robert, dept : Head Sales, salary :20000 ]</div><div class="line">Employee :[ Name : Richard, dept : Sales, salary :10000 ]</div><div class="line">Employee :[ Name : Rob, dept : Sales, salary :10000 ]</div><div class="line">Employee :[ Name : Michel, dept : Head Marketing, salary :20000 ]</div><div class="line">Employee :[ Name : Laura, dept : Marketing, salary :10000 ]</div><div class="line">Employee :[ Name : Bob, dept : Marketing, salary :10000 ]</div></pre></td></tr></table></figure>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。<br>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。<br>我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。<br><strong>意图：</strong>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。<br>主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。<br><strong>何时使用：</strong>在不想增加很多子类的情况下扩展类。<br><strong>如何解决：</strong>将具体功能职责划分，同时继承装饰者模式。<br><strong>关键代码：</strong> 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。<br><strong>应用实例：</strong> 1、孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。<br><strong>优点：</strong>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。<br><strong>缺点：</strong>多层装饰比较复杂。<br><strong>使用场景：</strong> 1、扩展一个类的功能。 2、动态增加功能，动态撤销。<br><strong>注意事项：</strong>可代替继承。<br><strong>实现</strong><br>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。<br>RedShapeDecorator 是实现了 ShapeDecorator 的实体类。<br>DecoratorPatternDemo，我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象<br><img src="http://jet-han.oschina.io/img/设计模式/decorator_pattern_uml_diagram.jpg" alt="decorator_pattern" title="decorator_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口。</p>
<p>Shape.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Shape &#123;</div><div class="line">   void draw();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>Rectangle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Rectangle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Shape: Rectangle&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Circle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Shape: Circle&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实现了 Shape 接口的抽象装饰类。</p>
<p>ShapeDecorator.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public abstract class ShapeDecorator implements Shape &#123;</div><div class="line">   protected Shape decoratedShape;</div><div class="line"></div><div class="line">   public ShapeDecorator(Shape decoratedShape)&#123;</div><div class="line">      this.decoratedShape = decoratedShape;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void draw()&#123;</div><div class="line">      decoratedShape.draw();</div><div class="line">   &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建扩展了 ShapeDecorator 类的实体装饰类。</p>
<p>RedShapeDecorator.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class RedShapeDecorator extends ShapeDecorator &#123;</div><div class="line"></div><div class="line">   public RedShapeDecorator(Shape decoratedShape) &#123;</div><div class="line">      super(decoratedShape);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      decoratedShape.draw();	       </div><div class="line">      setRedBorder(decoratedShape);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private void setRedBorder(Shape decoratedShape)&#123;</div><div class="line">      System.out.println(&quot;Border Color: Red&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>使用 RedShapeDecorator 来装饰 Shape 对象。</p>
<p>DecoratorPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class DecoratorPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      Shape circle = new Circle();</div><div class="line"></div><div class="line">      Shape redCircle = new RedShapeDecorator(new Circle());</div><div class="line"></div><div class="line">      Shape redRectangle = new RedShapeDecorator(new Rectangle());</div><div class="line">      System.out.println(&quot;Circle with normal border&quot;);</div><div class="line">      circle.draw();</div><div class="line"></div><div class="line">      System.out.println(&quot;\nCircle of red border&quot;);</div><div class="line">      redCircle.draw();</div><div class="line"></div><div class="line">      System.out.println(&quot;\nRectangle of red border&quot;);</div><div class="line">      redRectangle.draw();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Circle with normal border</div><div class="line">Shape: Circle</div><div class="line"></div><div class="line">Circle of red border</div><div class="line">Shape: Circle</div><div class="line">Border Color: Red</div><div class="line"></div><div class="line">Rectangle of red border</div><div class="line">Shape: Rectangle</div><div class="line">Border Color: Red</div></pre></td></tr></table></figure>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。<br>这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。<br><strong>意图：</strong>为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br><strong>主要解决：</strong>降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。<br><strong>何时使用：</strong> 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。 2、定义系统的入口。<br><strong>如何解决：</strong>客户端不与系统耦合，外观类与系统耦合。<br><strong>关键代码：</strong>在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。<br><strong>应用实例：</strong> 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、JAVA 的三层开发模式。<br><strong>优点：</strong> 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。<br><strong>缺点：</strong>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。<br><strong>使用场景： </strong>1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。<br><strong>注意事项：</strong>在层次化结构中，可以使用外观模式定义系统中每一层的入口。<br><strong>实现</strong><br>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。下一步是定义一个外观类 ShapeMaker。<br>ShapeMaker 类使用实体类来代表用户对这些类的调用。FacadePatternDemo，我们的演示类使用 ShapeMaker 类来显示结果。<br><img src="http://jet-han.oschina.io/img/设计模式/facade_pattern_uml_diagram.jpg" alt="facade_pattern" title="facade_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口。</p>
<p>Shape.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Shape &#123;</div><div class="line">   void draw();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>Rectangle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Rectangle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Rectangle::draw()&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Square.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Square implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Square::draw()&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Circle implements Shape &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Circle::draw()&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建一个外观类。</p>
<p>ShapeMaker.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class ShapeMaker &#123;</div><div class="line">   private Shape circle;</div><div class="line">   private Shape rectangle;</div><div class="line">   private Shape square;</div><div class="line"></div><div class="line">   public ShapeMaker() &#123;</div><div class="line">      circle = new Circle();</div><div class="line">      rectangle = new Rectangle();</div><div class="line">      square = new Square();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void drawCircle()&#123;</div><div class="line">      circle.draw();</div><div class="line">   &#125;</div><div class="line">   public void drawRectangle()&#123;</div><div class="line">      rectangle.draw();</div><div class="line">   &#125;</div><div class="line">   public void drawSquare()&#123;</div><div class="line">      square.draw();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用该外观类画出各种类型的形状。</p>
<p>FacadePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class FacadePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      ShapeMaker shapeMaker = new ShapeMaker();</div><div class="line"></div><div class="line">      shapeMaker.drawCircle();</div><div class="line">      shapeMaker.drawRectangle();</div><div class="line">      shapeMaker.drawSquare();		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Circle::draw()</div><div class="line">Rectangle::draw()</div><div class="line">Square::draw()</div></pre></td></tr></table></figure>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。<br>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对象。<br><strong>意图：</strong>运用共享技术有效地支持大量细粒度的对象。<br>主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。<br><strong>何时使用：</strong> 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。<br><strong>如何解决：</strong>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。<br><strong>关键代码：</strong>用 HashMap 存储这些对象。<br><strong>应用实例：</strong> 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。<br><strong>优点：</strong>大大减少对象的创建，降低系统的内存，使效率提高。<br><strong>缺点：</strong>提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。<br><strong>使用场景：</strong> 1、系统有大量相似对象。 2、需要缓冲池的场景。<br><strong>注意事项：</strong> 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。<br><strong>实现</strong><br>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类 Circle。下一步是定义工厂类 ShapeFactory。<br>ShapeFactory 有一个 Circle 的 HashMap，其中键名为 Circle 对象的颜色。无论何时接收到请求，都会创建一个特定颜色的圆。ShapeFactory 检查它的 HashMap 中的 circle 对象，如果找到 Circle 对象，则返回该对象，否则将创建一个存储在 hashmap 中以备后续使用的新对象，并把该对象返回到客户端。<br>FlyWeightPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（red / green / blue/ black / white），以便获取它所需对象的颜色。<br><img src="http://jet-han.oschina.io/img/设计模式/flyweight_pattern_uml_diagram-1.jpg" alt="flyweight_pattern" title="flyweight_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口。</p>
<p>Shape.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Shape &#123;</div><div class="line">   void draw();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>Circle.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class Circle implements Shape &#123;</div><div class="line">   private String color;</div><div class="line">   private int x;</div><div class="line">   private int y;</div><div class="line">   private int radius;</div><div class="line"></div><div class="line">   public Circle(String color)&#123;</div><div class="line">      this.color = color;		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setX(int x) &#123;</div><div class="line">      this.x = x;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setY(int y) &#123;</div><div class="line">      this.y = y;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setRadius(int radius) &#123;</div><div class="line">      this.radius = radius;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void draw() &#123;</div><div class="line">      System.out.println(&quot;Circle: Draw() [Color : &quot; + color </div><div class="line">         +&quot;, x : &quot; + x +&quot;, y :&quot; + y +&quot;, radius :&quot; + radius);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建一个工厂，生成基于给定信息的实体类的对象。</p>
<p>ShapeFactory.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import java.util.HashMap;</div><div class="line"></div><div class="line">public class ShapeFactory &#123;</div><div class="line">   private static final HashMap&lt;String, Shape&gt; circleMap = new HashMap();</div><div class="line"></div><div class="line">   public static Shape getCircle(String color) &#123;</div><div class="line">      Circle circle = (Circle)circleMap.get(color);</div><div class="line"></div><div class="line">      if(circle == null) &#123;</div><div class="line">         circle = new Circle(color);</div><div class="line">         circleMap.put(color, circle);</div><div class="line">         System.out.println(&quot;Creating circle of color : &quot; + color);</div><div class="line">      &#125;</div><div class="line">      return circle;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用该工厂，通过传递颜色信息来获取实体类的对象。</p>
<p>FlyweightPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class FlyweightPatternDemo &#123;</div><div class="line">   private static final String colors[] = </div><div class="line">      &#123; &quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot;, &quot;White&quot;, &quot;Black&quot; &#125;;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      for(int i=0; i &lt; 20; ++i) &#123;</div><div class="line">         Circle circle = </div><div class="line">            (Circle)ShapeFactory.getCircle(getRandomColor());</div><div class="line">         circle.setX(getRandomX());</div><div class="line">         circle.setY(getRandomY());</div><div class="line">         circle.setRadius(100);</div><div class="line">         circle.draw();</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">   private static String getRandomColor() &#123;</div><div class="line">      return colors[(int)(Math.random()*colors.length)];</div><div class="line">   &#125;</div><div class="line">   private static int getRandomX() &#123;</div><div class="line">      return (int)(Math.random()*100 );</div><div class="line">   &#125;</div><div class="line">   private static int getRandomY() &#123;</div><div class="line">      return (int)(Math.random()*100);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Creating circle of color : Black</div><div class="line">Circle: Draw() [Color : Black, x : 36, y :71, radius :100</div><div class="line">Creating circle of color : Green</div><div class="line">Circle: Draw() [Color : Green, x : 27, y :27, radius :100</div><div class="line">Creating circle of color : White</div><div class="line">Circle: Draw() [Color : White, x : 64, y :10, radius :100</div><div class="line">Creating circle of color : Red</div><div class="line">Circle: Draw() [Color : Red, x : 15, y :44, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 19, y :10, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 94, y :32, radius :100</div><div class="line">Circle: Draw() [Color : White, x : 69, y :98, radius :100</div><div class="line">Creating circle of color : Blue</div><div class="line">Circle: Draw() [Color : Blue, x : 13, y :4, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 21, y :21, radius :100</div><div class="line">Circle: Draw() [Color : Blue, x : 55, y :86, radius :100</div><div class="line">Circle: Draw() [Color : White, x : 90, y :70, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 78, y :3, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 64, y :89, radius :100</div><div class="line">Circle: Draw() [Color : Blue, x : 3, y :91, radius :100</div><div class="line">Circle: Draw() [Color : Blue, x : 62, y :82, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 97, y :61, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 86, y :12, radius :100</div><div class="line">Circle: Draw() [Color : Green, x : 38, y :93, radius :100</div><div class="line">Circle: Draw() [Color : Red, x : 76, y :82, radius :100</div><div class="line">Circle: Draw() [Color : Blue, x : 95, y :82, radius :100</div></pre></td></tr></table></figure>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。<br>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。<br><strong>意图：</strong>为其他对象提供一种代理以控制对这个对象的访问。<br><strong>主要解决：</strong>在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。<br><strong>何时使用：</strong>想在访问一个类时做一些控制。<br><strong>如何解决：</strong>增加中间层。<br>关键代码：实现与被代理类组合。<br><strong>应用实例：</strong> 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。<br><strong>优点：</strong> 1、职责清晰。 2、高扩展性。 3、智能化。<br><strong>缺点：</strong> 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。<br><strong>使用场景：</strong>按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。<br><strong>注意事项：</strong> 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。<br><strong>实现</strong><br>我们将创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。<br>ProxyPatternDemo，我们的演示类使用 ProxyImage 来获取要加载的 Image 对象，并按照需求进行显示。<br><img src="http://jet-han.oschina.io/img/设计模式/proxy_pattern_uml_diagram.jpg" alt="proxy_pattern" title="proxy_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口。</p>
<p>Image.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Image &#123;</div><div class="line">   void display();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>RealImage.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class RealImage implements Image &#123;</div><div class="line"></div><div class="line">   private String fileName;</div><div class="line"></div><div class="line">   public RealImage(String fileName)&#123;</div><div class="line">      this.fileName = fileName;</div><div class="line">      loadFromDisk(fileName);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void display() &#123;</div><div class="line">      System.out.println(&quot;Displaying &quot; + fileName);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private void loadFromDisk(String fileName)&#123;</div><div class="line">      System.out.println(&quot;Loading &quot; + fileName);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ProxyImage.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class ProxyImage implements Image&#123;</div><div class="line"></div><div class="line">   private RealImage realImage;</div><div class="line">   private String fileName;</div><div class="line"></div><div class="line">   public ProxyImage(String fileName)&#123;</div><div class="line">      this.fileName = fileName;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void display() &#123;</div><div class="line">      if(realImage == null)&#123;</div><div class="line">         realImage = new RealImage(fileName);</div><div class="line">      &#125;</div><div class="line">      realImage.display();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>当被请求时，使用 ProxyImage 来获取 RealImage 类的对象。</p>
<p>ProxyPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class ProxyPatternDemo &#123;</div><div class="line">	</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Image image = new ProxyImage(&quot;test_10mb.jpg&quot;);</div><div class="line"></div><div class="line">      //图像将从磁盘加载</div><div class="line">      image.display(); </div><div class="line">      System.out.println(&quot;&quot;);</div><div class="line">      //图像将无法从磁盘加载</div><div class="line">      image.display(); 	</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Loading test_10mb.jpg</div><div class="line">Displaying test_10mb.jpg</div><div class="line"></div><div class="line">Displaying test_10mb.jpg</div></pre></td></tr></table></figure>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。<br>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。<br><strong>意图：</strong>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。<br><strong>主要解决：</strong>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。<br><strong>何时使用：</strong>在处理消息的时候以过滤很多道。<br><strong>如何解决：</strong>拦截的类都实现统一接口。<br><strong>关键代码：</strong>Handler 里面聚合它自己，在 HanleRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。<br><strong>应用实例：</strong> 1、红楼梦中的”击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。<br><strong>优点：</strong> 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。<br><strong>缺点：</strong> 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。<br><strong>使用场景：</strong> 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。<br>注意事项：在 JAVA WEB 中遇到很多应用。<br><strong>实现 </strong><br>我们创建抽象类 AbstractLogger，带有详细的日志记录级别。然后我们创建三种类型的记录器，都扩展了 AbstractLogger。每个记录器消息的级别是否属于自己的级别，如果是则相应地打印出来，否则将不打印并把消息传给下一个记录器。<br><img src="http://jet-han.oschina.io/img/设计模式/chain_pattern_uml_diagram.jpg" alt="chain_pattern" title="chain_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建抽象的记录器类。</p>
<p>AbstractLogger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public abstract class AbstractLogger &#123;</div><div class="line">   public static int INFO = 1;</div><div class="line">   public static int DEBUG = 2;</div><div class="line">   public static int ERROR = 3;</div><div class="line"></div><div class="line">   protected int level;</div><div class="line"></div><div class="line">   //责任链中的下一个元素</div><div class="line">   protected AbstractLogger nextLogger;</div><div class="line"></div><div class="line">   public void setNextLogger(AbstractLogger nextLogger)&#123;</div><div class="line">      this.nextLogger = nextLogger;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void logMessage(int level, String message)&#123;</div><div class="line">      if(this.level &lt;= level)&#123;</div><div class="line">         write(message);</div><div class="line">      &#125;</div><div class="line">      if(nextLogger !=null)&#123;</div><div class="line">         nextLogger.logMessage(level, message);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   abstract protected void write(String message);</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建扩展了该记录器类的实体类。</p>
<p>ConsoleLogger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class ConsoleLogger extends AbstractLogger &#123;</div><div class="line"></div><div class="line">   public ConsoleLogger(int level)&#123;</div><div class="line">      this.level = level;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   protected void write(String message) &#123;		</div><div class="line">      System.out.println(&quot;Standard Console::Logger: &quot; + message);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ErrorLogger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class ErrorLogger extends AbstractLogger &#123;</div><div class="line"></div><div class="line">   public ErrorLogger(int level)&#123;</div><div class="line">      this.level = level;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   protected void write(String message) &#123;		</div><div class="line">      System.out.println(&quot;Error Console::Logger: &quot; + message);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>FileLogger.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class FileLogger extends AbstractLogger &#123;</div><div class="line"></div><div class="line">   public FileLogger(int level)&#123;</div><div class="line">      this.level = level;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   protected void write(String message) &#123;		</div><div class="line">      System.out.println(&quot;File::Logger: &quot; + message);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建不同类型的记录器。赋予它们不同的错误级别，并在每个记录器中设置下一个记录器。每个记录器中的下一个记录器代表的是链的一部分。</p>
<p>ChainPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class ChainPatternDemo &#123;</div><div class="line">	</div><div class="line">   private static AbstractLogger getChainOfLoggers()&#123;</div><div class="line"></div><div class="line">      AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR);</div><div class="line">      AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG);</div><div class="line">      AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO);</div><div class="line"></div><div class="line">      errorLogger.setNextLogger(fileLogger);</div><div class="line">      fileLogger.setNextLogger(consoleLogger);</div><div class="line"></div><div class="line">      return errorLogger;	</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      AbstractLogger loggerChain = getChainOfLoggers();</div><div class="line"></div><div class="line">      loggerChain.logMessage(AbstractLogger.INFO, </div><div class="line">         &quot;This is an information.&quot;);</div><div class="line"></div><div class="line">      loggerChain.logMessage(AbstractLogger.DEBUG, </div><div class="line">         &quot;This is an debug level information.&quot;);</div><div class="line"></div><div class="line">      loggerChain.logMessage(AbstractLogger.ERROR, </div><div class="line">         &quot;This is an error information.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Standard Console::Logger: This is an information.</div><div class="line">File::Logger: This is an debug level information.</div><div class="line">Standard Console::Logger: This is an debug level information.</div><div class="line">Error Console::Logger: This is an error information.</div><div class="line">File::Logger: This is an error information.</div><div class="line">Standard Console::Logger: This is an error information.</div></pre></td></tr></table></figure>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。<br><strong>意图：</strong>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。<br><strong>主要解决：</strong>在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。<br><strong>何时使用：</strong>在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。<br><strong>如何解决：</strong>通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。<br><strong>关键代码：</strong>定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口<br><strong>应用实例：</strong>struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。<br><strong>优点：</strong> 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。<br><strong>缺点：</strong>使用命令模式可能会导致某些系统有过多的具体命令类。<br><strong>使用场景：</strong>认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。<br><strong>注意事项：</strong>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。<br><strong>实现</strong><br>我们首先创建作为命令的接口 Order，然后创建作为请求的 Stock 类。实体命令类 BuyStock 和 SellStock，实现了 Order 接口，将执行实际的命令处理。创建作为调用对象的类 Broker，它接受订单并能下订单。<br>Broker 对象使用命令模式，基于命令的类型确定哪个对象执行哪个命令。CommandPatternDemo，我们的演示类使用 Broker 类来演示命令模式。<br><img src="http://jet-han.oschina.io/img/设计模式/command_pattern_uml_diagram.jpg" alt="command_pattern" title="command_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个命令接口。</p>
<p>Order.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Order &#123;</div><div class="line">   void execute();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建一个请求类。</p>
<p>Stock.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Stock &#123;</div><div class="line">	</div><div class="line">   private String name = &quot;ABC&quot;;</div><div class="line">   private int quantity = 10;</div><div class="line"></div><div class="line">   public void buy()&#123;</div><div class="line">      System.out.println(&quot;Stock [ Name: &quot;+name+&quot;, </div><div class="line">         Quantity: &quot; + quantity +&quot; ] bought&quot;);</div><div class="line">   &#125;</div><div class="line">   public void sell()&#123;</div><div class="line">      System.out.println(&quot;Stock [ Name: &quot;+name+&quot;, </div><div class="line">         Quantity: &quot; + quantity +&quot; ] sold&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实现了 Order 接口的实体类。</p>
<p>BuyStock.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class BuyStock implements Order &#123;</div><div class="line">   private Stock abcStock;</div><div class="line"></div><div class="line">   public BuyStock(Stock abcStock)&#123;</div><div class="line">      this.abcStock = abcStock;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void execute() &#123;</div><div class="line">      abcStock.buy();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SellStock.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class SellStock implements Order &#123;</div><div class="line">   private Stock abcStock;</div><div class="line"></div><div class="line">   public SellStock(Stock abcStock)&#123;</div><div class="line">      this.abcStock = abcStock;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void execute() &#123;</div><div class="line">      abcStock.sell();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建命令调用类。</p>
<p>Broker.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">   public class Broker &#123;</div><div class="line">   private List&lt;Order&gt; orderList = new ArrayList&lt;Order&gt;(); </div><div class="line"></div><div class="line">   public void takeOrder(Order order)&#123;</div><div class="line">      orderList.add(order);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void placeOrders()&#123;</div><div class="line">      for (Order order : orderList) &#123;</div><div class="line">         order.execute();</div><div class="line">      &#125;</div><div class="line">      orderList.clear();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>使用 Broker 类来接受并执行命令。</p>
<p>CommandPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class CommandPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Stock abcStock = new Stock();</div><div class="line"></div><div class="line">      BuyStock buyStockOrder = new BuyStock(abcStock);</div><div class="line">      SellStock sellStockOrder = new SellStock(abcStock);</div><div class="line"></div><div class="line">      Broker broker = new Broker();</div><div class="line">      broker.takeOrder(buyStockOrder);</div><div class="line">      broker.takeOrder(sellStockOrder);</div><div class="line"></div><div class="line">      broker.placeOrders();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Stock [ Name: ABC, Quantity: 10 ] bought</div><div class="line">Stock [ Name: ABC, Quantity: 10 ] sold</div></pre></td></tr></table></figure>
<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。<br>意图：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。<br><strong>主要解决：</strong>对于一些固定文法构建一个解释句子的解释器。<br><strong>何时使用：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。  
</strong>如何解决：<strong>构件语法树，定义终结符与非终结符。  
</strong>关键代码：<strong>构件环境类，包含解释器之外的一些全局信息，一般是 HashMap。  
</strong>应用实例：<strong>编译器、运算表达式计算。  
</strong>优点：<strong> 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。  
</strong>缺点：<strong> 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。  
</strong>使用场景：<strong> 1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 2、一些重复出现的问题可以用一种简单的语言来进行表达。 3、一个简单语法需要解释的场景。<br>注意事项：可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。  
</strong>实现 **<br>我们将创建一个接口 Expression 和实现了 Expression 接口的实体类。定义作为上下文中主要解释器的 TerminalExpression 类。其他的类 OrExpression、AndExpression 用于创建组合式表达式。<br>InterpreterPatternDemo，我们的演示类使用 Expression 类创建规则和演示表达式的解析。<br><img src="http://jet-han.oschina.io/img/设计模式/interpreter_pattern_uml_diagram.jpg" alt="interpreter_pattern" title="interpreter_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个表达式接口。</p>
<p>Expression.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Expression &#123;</div><div class="line">   public boolean interpret(String context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现了上述接口的实体类。</p>
<p>TerminalExpression.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class TerminalExpression implements Expression &#123;</div><div class="line">	</div><div class="line">   private String data;</div><div class="line"></div><div class="line">   public TerminalExpression(String data)&#123;</div><div class="line">      this.data = data; </div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public boolean interpret(String context) &#123;</div><div class="line">      if(context.contains(data))&#123;</div><div class="line">         return true;</div><div class="line">      &#125;</div><div class="line">      return false;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OrExpression.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class OrExpression implements Expression &#123;</div><div class="line">	 </div><div class="line">   private Expression expr1 = null;</div><div class="line">   private Expression expr2 = null;</div><div class="line"></div><div class="line">   public OrExpression(Expression expr1, Expression expr2) &#123; </div><div class="line">      this.expr1 = expr1;</div><div class="line">      this.expr2 = expr2;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public boolean interpret(String context) &#123;		</div><div class="line">      return expr1.interpret(context) || expr2.interpret(context);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AndExpression.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class AndExpression implements Expression &#123;</div><div class="line">	 </div><div class="line">   private Expression expr1 = null;</div><div class="line">   private Expression expr2 = null;</div><div class="line"></div><div class="line">   public AndExpression(Expression expr1, Expression expr2) &#123; </div><div class="line">      this.expr1 = expr1;</div><div class="line">      this.expr2 = expr2;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public boolean interpret(String context) &#123;		</div><div class="line">      return expr1.interpret(context) &amp;&amp; expr2.interpret(context);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong><br>InterpreterPatternDemo 使用 Expression 类来创建规则，并解析它们。</p>
<p>InterpreterPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class InterpreterPatternDemo &#123;</div><div class="line"></div><div class="line">   //规则：Robert 和 John 是男性</div><div class="line">   public static Expression getMaleExpression()&#123;</div><div class="line">      Expression robert = new TerminalExpression(&quot;Robert&quot;);</div><div class="line">      Expression john = new TerminalExpression(&quot;John&quot;);</div><div class="line">      return new OrExpression(robert, john);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //规则：Julie 是一个已婚的女性</div><div class="line">   public static Expression getMarriedWomanExpression()&#123;</div><div class="line">      Expression julie = new TerminalExpression(&quot;Julie&quot;);</div><div class="line">      Expression married = new TerminalExpression(&quot;Married&quot;);</div><div class="line">      return new AndExpression(julie, married);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Expression isMale = getMaleExpression();</div><div class="line">      Expression isMarriedWoman = getMarriedWomanExpression();</div><div class="line"></div><div class="line">      System.out.println(&quot;John is male? &quot; + isMale.interpret(&quot;John&quot;));</div><div class="line">      System.out.println(&quot;Julie is a married women? &quot; </div><div class="line">      + isMarriedWoman.interpret(&quot;Married Julie&quot;));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">John is male? true</div><div class="line">Julie is a married women? true</div></pre></td></tr></table></figure>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。<br>迭代器模式属于行为型模式。<br><strong>意图：</strong>提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。<br><strong>主要解决：</strong>不同的方式来遍历整个整合对象。<br><strong>何时使用：</strong>遍历一个聚合对象。<br><strong>如何解决：</strong>把在元素之间游走的责任交给迭代器，而不是聚合对象。<br><strong>关键代码：</strong>定义接口：hasNext, next。<br><strong>应用实例：</strong>JAVA 中的 iterator。<br><strong>优点：</strong> 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。<br><strong>缺点：</strong>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。<br>使用场景： 1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口。<br><strong>注意事项：</strong>迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。<br><strong>实现</strong><br>我们将创建一个叙述导航方法的 Iterator 接口和一个返回迭代器的 Container 接口。实现了 Container 接口的实体类将负责实现 Iterator 接口。<br>IteratorPatternDemo，我们的演示类使用实体类 NamesRepository 来打印 NamesRepository 中存储为集合的 Names。<br><img src="http://jet-han.oschina.io/img/设计模式/iterator_pattern_uml_diagram.jpg" alt="iterator_pattern" title="iterator_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建接口。</p>
<p>Iterator.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface Iterator &#123;</div><div class="line">   public boolean hasNext();</div><div class="line">   public Object next();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Container.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Container &#123;</div><div class="line">   public Iterator getIterator();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现了 Container 接口的实体类。该类有实现了 Iterator 接口的内部类 NameIterator。</p>
<p>NameRepository.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class NameRepository implements Container &#123;</div><div class="line">   public String names[] = &#123;&quot;Robert&quot; , &quot;John&quot; ,&quot;Julie&quot; , &quot;Lora&quot;&#125;;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public Iterator getIterator() &#123;</div><div class="line">      return new NameIterator();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private class NameIterator implements Iterator &#123;</div><div class="line"></div><div class="line">      int index;</div><div class="line"></div><div class="line">      @Override</div><div class="line">      public boolean hasNext() &#123;</div><div class="line">         if(index &lt; names.length)&#123;</div><div class="line">            return true;</div><div class="line">         &#125;</div><div class="line">         return false;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      @Override</div><div class="line">      public Object next() &#123;</div><div class="line">         if(this.hasNext())&#123;</div><div class="line">            return names[index++];</div><div class="line">         &#125;</div><div class="line">         return null;</div><div class="line">      &#125;		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>使用 NameRepository 来获取迭代器，并打印名字。</p>
<p>IteratorPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class IteratorPatternDemo &#123;</div><div class="line">	</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      NameRepository namesRepository = new NameRepository();</div><div class="line"></div><div class="line">      for(Iterator iter = namesRepository.getIterator(); iter.hasNext();)&#123;</div><div class="line">         String name = (String)iter.next();</div><div class="line">         System.out.println(&quot;Name : &quot; + name);</div><div class="line">      &#125; 	</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Name : Robert</div><div class="line">Name : John</div><div class="line">Name : Julie</div><div class="line">Name : Lora</div></pre></td></tr></table></figure>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。<br><strong>意图：</strong>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br><strong>主要解决：</strong>对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。<br><strong>何时使用：</strong>多个类相互耦合，形成了网状结构。<br><strong>如何解决：</strong>将上述网状结构分离为星型结构。<br><strong>关键代码：</strong>对象 Colleague 之间的通信封装到一个类中单独处理。<br><strong>应用实例：</strong> 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。<br><strong>优点：</strong> 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。<br><strong>缺点：</strong>中介者会庞大，变得复杂难以维护。<br>使用场景： 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。<br>注意事项：不应当在职责混乱的时候使用。<br><strong>实现</strong><br>我们通过聊天室实例来演示中介者模式。实例中，多个用户可以向聊天室发送消息，聊天室向所有的用户显示消息。我们将创建两个类 ChatRoom 和 User。User 对象使用 ChatRoom 方法来分享他们的消息。<br>MediatorPatternDemo，我们的演示类使用 User 对象来显示他们之间的通信。<br><img src="http://jet-han.oschina.io/img/设计模式/mediator_pattern_uml_diagram.jpg" alt="mediator_pattern" title="mediator_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建中介类。</p>
<p>ChatRoom.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import java.util.Date;</div><div class="line"></div><div class="line">public class ChatRoom &#123;</div><div class="line">   public static void showMessage(User user, String message)&#123;</div><div class="line">      System.out.println(new Date().toString()</div><div class="line">         + &quot; [&quot; + user.getName() +&quot;] : &quot; + message);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建 user 类。</p>
<p>User.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class User &#123;</div><div class="line">   private String name;</div><div class="line"></div><div class="line">   public String getName() &#123;</div><div class="line">      return name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setName(String name) &#123;</div><div class="line">      this.name = name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public User(String name)&#123;</div><div class="line">      this.name  = name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void sendMessage(String message)&#123;</div><div class="line">      ChatRoom.showMessage(this,message);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>使用 User 对象来显示他们之间的通信。</p>
<p>MediatorPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class MediatorPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      User robert = new User(&quot;Robert&quot;);</div><div class="line">      User john = new User(&quot;John&quot;);</div><div class="line"></div><div class="line">      robert.sendMessage(&quot;Hi! John!&quot;);</div><div class="line">      john.sendMessage(&quot;Hello! Robert!&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Thu Jan 31 16:05:46 IST 2013 [Robert] : Hi! John!</div><div class="line">Thu Jan 31 16:05:46 IST 2013 [John] : Hello! Robert!</div></pre></td></tr></table></figure>
<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。<br><strong>意图：</strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。<br><strong>主要解决：</strong>所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。<br><strong>何时使用：</strong>很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。<br><strong>如何解决：</strong>通过一个备忘录类专门存储对象状态。<br><strong>关键代码：</strong>客户不与备忘录类耦合，与备忘录管理类耦合。<br><strong>应用实例：</strong> 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、IE 中的后退。 4、数据库的事务管理。<br><strong>优点：</strong> 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。<br><strong>缺点：</strong>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。<br><strong>使用场景：</strong> 1、需要保存/恢复数据的相关状态场景。 2、提供一个可回滚的操作。<br><strong>注意事项：</strong> 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。<br><strong>实现</strong><br>备忘录模式使用三个类 Memento、Originator 和 CareTaker。Memento 包含了要被恢复的对象的状态。  Originator 创建并在 Memento 对象中存储状态。Caretaker 对象负责从 Memento 中恢复对象的状态。<br>MementoPatternDemo，我们的演示类使用 CareTaker 和 Originator 对象来显示对象的状态恢复。<br><img src="http://jet-han.oschina.io/img/设计模式/memento_pattern_uml_diagram.jpg" alt="memento_pattern" title="memento_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建 Memento 类。</p>
<p>Memento.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Memento &#123;</div><div class="line">   private String state;</div><div class="line"></div><div class="line">   public Memento(String state)&#123;</div><div class="line">      this.state = state;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getState()&#123;</div><div class="line">      return state;</div><div class="line">   &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建 Originator 类。</p>
<p>Originator.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Originator &#123;</div><div class="line">   private String state;</div><div class="line"></div><div class="line">   public void setState(String state)&#123;</div><div class="line">      this.state = state;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getState()&#123;</div><div class="line">      return state;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public Memento saveStateToMemento()&#123;</div><div class="line">      return new Memento(state);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void getStateFromMemento(Memento Memento)&#123;</div><div class="line">      state = Memento.getState();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建 CareTaker 类。</p>
<p>CareTaker.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class CareTaker &#123;</div><div class="line">   private List&lt;Memento&gt; mementoList = new ArrayList&lt;Memento&gt;();</div><div class="line"></div><div class="line">   public void add(Memento state)&#123;</div><div class="line">      mementoList.add(state);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public Memento get(int index)&#123;</div><div class="line">      return mementoList.get(index);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 CareTaker 和 Originator 对象。</p>
<p>MementoPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class MementoPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Originator originator = new Originator();</div><div class="line">      CareTaker careTaker = new CareTaker();</div><div class="line">      originator.setState(&quot;State #1&quot;);</div><div class="line">      originator.setState(&quot;State #2&quot;);</div><div class="line">      careTaker.add(originator.saveStateToMemento());</div><div class="line">      originator.setState(&quot;State #3&quot;);</div><div class="line">      careTaker.add(originator.saveStateToMemento());</div><div class="line">      originator.setState(&quot;State #4&quot;);</div><div class="line"></div><div class="line">      System.out.println(&quot;Current State: &quot; + originator.getState());		</div><div class="line">      originator.getStateFromMemento(careTaker.get(0));</div><div class="line">      System.out.println(&quot;First saved State: &quot; + originator.getState());</div><div class="line">      originator.getStateFromMemento(careTaker.get(1));</div><div class="line">      System.out.println(&quot;Second saved State: &quot; + originator.getState());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Current State: State #4</div><div class="line">First saved State: State #2</div><div class="line">Second saved State: State #3</div></pre></td></tr></table></figure>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。<br>意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。<br><strong>主要解决：</strong>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。<br><strong>何时使用：</strong>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。<br><strong>如何解决：</strong>使用面向对象技术，可以将这种依赖关系弱化。<br><strong>关键代码：</strong>在抽象类里有一个 ArrayList 存放观察者们。<br><strong>应用实例：</strong> 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。<br><strong>优点：</strong> 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。<br><strong>缺点：</strong> 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。<br><strong>使用场景：</strong> 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。<br><strong>注意事项：</strong> 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。<br><strong>实现</strong><br>观察者模式使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。我们创建 Subject 类、Observer 抽象类和扩展了抽象类 Observer 的实体类。<br>ObserverPatternDemo，我们的演示类使用 Subject 和实体类对象来演示观察者模式。<br><img src="http://jet-han.oschina.io/img/设计模式/observer_pattern_uml_diagram.jpg" alt="observer_pattern" title="observer_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建 Subject 类。</p>
<p>Subject.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class Subject &#123;</div><div class="line">	</div><div class="line">   private List&lt;Observer&gt; observers </div><div class="line">      = new ArrayList&lt;Observer&gt;();</div><div class="line">   private int state;</div><div class="line"></div><div class="line">   public int getState() &#123;</div><div class="line">      return state;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setState(int state) &#123;</div><div class="line">      this.state = state;</div><div class="line">      notifyAllObservers();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void attach(Observer observer)&#123;</div><div class="line">      observers.add(observer);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void notifyAllObservers()&#123;</div><div class="line">      for (Observer observer : observers) &#123;</div><div class="line">         observer.update();</div><div class="line">      &#125;</div><div class="line">   &#125; 	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建 Observer 类。</p>
<p>Observer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public abstract class Observer &#123;</div><div class="line">   protected Subject subject;</div><div class="line">   public abstract void update();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实体观察者类。</p>
<p>BinaryObserver.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class BinaryObserver extends Observer&#123;</div><div class="line"></div><div class="line">   public BinaryObserver(Subject subject)&#123;</div><div class="line">      this.subject = subject;</div><div class="line">      this.subject.attach(this);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void update() &#123;</div><div class="line">      System.out.println( &quot;Binary String: &quot; </div><div class="line">      + Integer.toBinaryString( subject.getState() ) ); </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OctalObserver.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class OctalObserver extends Observer&#123;</div><div class="line"></div><div class="line">   public OctalObserver(Subject subject)&#123;</div><div class="line">      this.subject = subject;</div><div class="line">      this.subject.attach(this);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void update() &#123;</div><div class="line">     System.out.println( &quot;Octal String: &quot; </div><div class="line">     + Integer.toOctalString( subject.getState() ) ); </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>HexaObserver.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class HexaObserver extends Observer&#123;</div><div class="line"></div><div class="line">   public HexaObserver(Subject subject)&#123;</div><div class="line">      this.subject = subject;</div><div class="line">      this.subject.attach(this);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void update() &#123;</div><div class="line">      System.out.println( &quot;Hex String: &quot; </div><div class="line">      + Integer.toHexString( subject.getState() ).toUpperCase() ); </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 Subject 和实体观察者对象。</p>
<p>ObserverPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class ObserverPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Subject subject = new Subject();</div><div class="line"></div><div class="line">      new HexaObserver(subject);</div><div class="line">      new OctalObserver(subject);</div><div class="line">      new BinaryObserver(subject);</div><div class="line"></div><div class="line">      System.out.println(&quot;First state change: 15&quot;);	</div><div class="line">      subject.setState(15);</div><div class="line">      System.out.println(&quot;Second state change: 10&quot;);	</div><div class="line">      subject.setState(10);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">First state change: 15</div><div class="line">Hex String: F</div><div class="line">Octal String: 17</div><div class="line">Binary String: 1111</div><div class="line">Second state change: 10</div><div class="line">Hex String: A</div><div class="line">Octal String: 12</div><div class="line">Binary String: 1010</div></pre></td></tr></table></figure>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。<br>在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。<br>介绍<br><strong>意图：</strong>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。<br><strong>主要解决：</strong>对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。<br><strong>何时使用：</strong>代码中包含大量与对象状态有关的条件语句。<br><strong>如何解决：</strong>将各种具体的状态类抽象出来。<br><strong>关键代码：</strong>通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。<br><strong>应用实例：</strong> 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。<br><strong>优点：</strong> 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。<br><strong>缺点：</strong> 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。<br><strong>使用场景：</strong> 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。<br><strong>注意事项：</strong>在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。<br><strong>实现</strong><br>我们将创建一个 State 接口和实现了 State 接口的实体状态类。Context 是一个带有某个状态的类。<br>StatePatternDemo，我们的演示类使用 Context 和状态对象来演示 Context 在状态改变时的行为变化。<br><img src="http://jet-han.oschina.io/img/设计模式/state_pattern_uml_diagram.jpg" alt="state_pattern" title="state_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口。</p>
<p>State.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface State &#123;</div><div class="line">   public void doAction(Context context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>StartState.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class StartState implements State &#123;</div><div class="line"></div><div class="line">   public void doAction(Context context) &#123;</div><div class="line">      System.out.println(&quot;Player is in start state&quot;);</div><div class="line">      context.setState(this);	</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String toString()&#123;</div><div class="line">      return &quot;Start State&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>StopState.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class StopState implements State &#123;</div><div class="line"></div><div class="line">   public void doAction(Context context) &#123;</div><div class="line">      System.out.println(&quot;Player is in stop state&quot;);</div><div class="line">      context.setState(this);	</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String toString()&#123;</div><div class="line">      return &quot;Stop State&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建 Context 类。</p>
<p>Context.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Context &#123;</div><div class="line">   private State state;</div><div class="line"></div><div class="line">   public Context()&#123;</div><div class="line">      state = null;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setState(State state)&#123;</div><div class="line">      this.state = state;		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public State getState()&#123;</div><div class="line">      return state;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 Context 来查看当状态 State 改变时的行为变化。</p>
<p>StatePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class StatePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Context context = new Context();</div><div class="line"></div><div class="line">      StartState startState = new StartState();</div><div class="line">      startState.doAction(context);</div><div class="line"></div><div class="line">      System.out.println(context.getState().toString());</div><div class="line"></div><div class="line">      StopState stopState = new StopState();</div><div class="line">      stopState.doAction(context);</div><div class="line"></div><div class="line">      System.out.println(context.getState().toString());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Player is in start state</div><div class="line">Start State</div><div class="line">Player is in stop state</div><div class="line">Stop State</div></pre></td></tr></table></figure>
<h2 id="空对象模式"><a href="#空对象模式" class="headerlink" title="空对象模式"></a>空对象模式</h2><p>在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。<br>在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。<br><strong>实现</strong><br>我们将创建一个定义操作（在这里，是客户的名称）的 AbstractCustomer 抽象类，和扩展了 AbstractCustomer 类的实体类。工厂类 CustomerFactory 基于客户传递的名字来返回 RealCustomer 或 NullCustomer 对象。<br>NullPatternDemo，我们的演示类使用 CustomerFactory 来演示空对象模式的用法。<br><img src="http://jet-han.oschina.io/img/设计模式/null_pattern_uml_diagram.jpg" alt="null_pattern" title="null_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个抽象类。</p>
<p>AbstractCustomer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public abstract class AbstractCustomer &#123;</div><div class="line">   protected String name;</div><div class="line">   public abstract boolean isNil();</div><div class="line">   public abstract String getName();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建扩展了上述类的实体类。</p>
<p>RealCustomer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class RealCustomer extends AbstractCustomer &#123;</div><div class="line"></div><div class="line">   public RealCustomer(String name) &#123;</div><div class="line">      this.name = name;		</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @Override</div><div class="line">   public String getName() &#123;</div><div class="line">      return name;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @Override</div><div class="line">   public boolean isNil() &#123;</div><div class="line">      return false;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>NullCustomer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class NullCustomer extends AbstractCustomer &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String getName() &#123;</div><div class="line">      return &quot;Not Available in Customer Database&quot;;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public boolean isNil() &#123;</div><div class="line">      return true;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建 CustomerFactory 类。</p>
<p>CustomerFactory.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class CustomerFactory &#123;</div><div class="line">	</div><div class="line">   public static final String[] names = &#123;&quot;Rob&quot;, &quot;Joe&quot;, &quot;Julie&quot;&#125;;</div><div class="line"></div><div class="line">   public static AbstractCustomer getCustomer(String name)&#123;</div><div class="line">      for (int i = 0; i &lt; names.length; i++) &#123;</div><div class="line">         if (names[i].equalsIgnoreCase(name))&#123;</div><div class="line">            return new RealCustomer(name);</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      return new NullCustomer();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 CustomerFactory，基于客户传递的名字，来获取 RealCustomer 或 NullCustomer 对象。</p>
<p>NullPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class NullPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      AbstractCustomer customer1 = CustomerFactory.getCustomer(&quot;Rob&quot;);</div><div class="line">      AbstractCustomer customer2 = CustomerFactory.getCustomer(&quot;Bob&quot;);</div><div class="line">      AbstractCustomer customer3 = CustomerFactory.getCustomer(&quot;Julie&quot;);</div><div class="line">      AbstractCustomer customer4 = CustomerFactory.getCustomer(&quot;Laura&quot;);</div><div class="line"></div><div class="line">      System.out.println(&quot;Customers&quot;);</div><div class="line">      System.out.println(customer1.getName());</div><div class="line">      System.out.println(customer2.getName());</div><div class="line">      System.out.println(customer3.getName());</div><div class="line">      System.out.println(customer4.getName());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Customers</div><div class="line">Rob</div><div class="line">Not Available in Customer Database</div><div class="line">Julie</div><div class="line">Not Available in Customer Database</div></pre></td></tr></table></figure>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。<br>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。<br><strong>意图：</strong>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。<br><strong>主要解决：</strong>在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。<br><strong>何时使用：</strong>一个系统有许多许多类，而区分它们的只是他们直接的行为。<br><strong>如何解决：</strong>将这些算法封装成一个一个的类，任意地替换。<br><strong>关键代码：</strong>实现同一个接口。<br><strong>应用实例：</strong> 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。<br><strong>优点：</strong> 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。<br><strong>缺点：</strong> 1、策略类会增多。 2、所有策略类都需要对外暴露。<br><strong>使用场景：</strong> 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。<br>注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。<br><strong>实现 </strong><br>我们将创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。<br>StrategyPatternDemo，我们的演示类使用 Context 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。<br><img src="http://jet-han.oschina.io/img/设计模式/strategy_pattern_uml_diagram.jpg" alt="strategy_pattern" title="strategy_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个接口。</p>
<p>Strategy.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Strategy &#123;</div><div class="line">   public int doOperation(int num1, int num2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实现接口的实体类。</p>
<p>OperationAdd.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class OperationAdd implements Strategy&#123;</div><div class="line">   @Override</div><div class="line">   public int doOperation(int num1, int num2) &#123;</div><div class="line">      return num1 + num2;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OperationSubstract.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class OperationSubstract implements Strategy&#123;</div><div class="line">   @Override</div><div class="line">   public int doOperation(int num1, int num2) &#123;</div><div class="line">      return num1 - num2;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OperationMultiply.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class OperationMultiply implements Strategy&#123;</div><div class="line">   @Override</div><div class="line">   public int doOperation(int num1, int num2) &#123;</div><div class="line">      return num1 * num2;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建 Context 类。</p>
<p>Context.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Context &#123;</div><div class="line">   private Strategy strategy;</div><div class="line"></div><div class="line">   public Context(Strategy strategy)&#123;</div><div class="line">      this.strategy = strategy;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public int executeStrategy(int num1, int num2)&#123;</div><div class="line">      return strategy.doOperation(num1, num2);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 Context 来查看当它改变策略 Strategy 时的行为变化。</p>
<p>StrategyPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class StrategyPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Context context = new Context(new OperationAdd());		</div><div class="line">      System.out.println(&quot;10 + 5 = &quot; + context.executeStrategy(10, 5));</div><div class="line"></div><div class="line">      context = new Context(new OperationSubstract());		</div><div class="line">      System.out.println(&quot;10 - 5 = &quot; + context.executeStrategy(10, 5));</div><div class="line"></div><div class="line">      context = new Context(new OperationMultiply());		</div><div class="line">      System.out.println(&quot;10 * 5 = &quot; + context.executeStrategy(10, 5));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">10 + 5 = 15</div><div class="line">10 - 5 = 5</div><div class="line">10 * 5 = 50</div></pre></td></tr></table></figure>
<h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。<br>意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br><strong>主要解决：</strong>一些方法通用，却在每一个子类都重新写了这一方法。<br><strong>何时使用：</strong>有一些通用的方法。<br><strong>如何解决：</strong>将这些通用算法抽象出来。<br><strong>关键代码：</strong>在抽象类实现，其他步骤在子类实现。<br><strong>应用实例：</strong> 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。<br><strong>优点：</strong> 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。<br><strong>缺点：</strong>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。<br><strong>使用场景：</strong> 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。<br><strong>注意事项：</strong>为防止恶意操作，一般模板方法都加上 final 关键词。<br><strong>实现</strong><br>我们将创建一个定义操作的 Game 抽象类，其中，模板方法设置为 final，这样它就不会被重写。Cricket 和 Football 是扩展了 Game 的实体类，它们重写了抽象类的方法。<br>TemplatePatternDemo，我们的演示类使用 Game 来演示模板模式的用法。<br><img src="http://jet-han.oschina.io/img/设计模式/template_pattern_uml_diagram.jpg" alt="template_pattern" title="template_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建一个抽象类，它的模板方法被设置为 final。</p>
<p>Game.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public abstract class Game &#123;</div><div class="line">   abstract void initialize();</div><div class="line">   abstract void startPlay();</div><div class="line">   abstract void endPlay();</div><div class="line"></div><div class="line">   //模板</div><div class="line">   public final void play()&#123;</div><div class="line"></div><div class="line">      //初始化游戏</div><div class="line">      initialize();</div><div class="line"></div><div class="line">      //开始游戏</div><div class="line">      startPlay();</div><div class="line"></div><div class="line">      //结束游戏</div><div class="line">      endPlay();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建扩展了上述类的实体类。</p>
<p>Cricket.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Cricket extends Game &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   void endPlay() &#123;</div><div class="line">      System.out.println(&quot;Cricket Game Finished!&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   void initialize() &#123;</div><div class="line">      System.out.println(&quot;Cricket Game Initialized! Start playing.&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   void startPlay() &#123;</div><div class="line">      System.out.println(&quot;Cricket Game Started. Enjoy the game!&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Football.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Football extends Game &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   void endPlay() &#123;</div><div class="line">      System.out.println(&quot;Football Game Finished!&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   void initialize() &#123;</div><div class="line">      System.out.println(&quot;Football Game Initialized! Start playing.&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   void startPlay() &#123;</div><div class="line">      System.out.println(&quot;Football Game Started. Enjoy the game!&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>使用 Game 的模板方法 play() 来演示游戏的定义方式。</p>
<p>TemplatePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class TemplatePatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      Game game = new Cricket();</div><div class="line">      game.play();</div><div class="line">      System.out.println();</div><div class="line">      game = new Football();</div><div class="line">      game.play();		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Cricket Game Initialized! Start playing.</div><div class="line">Cricket Game Started. Enjoy the game!</div><div class="line">Cricket Game Finished!</div><div class="line"></div><div class="line">Football Game Initialized! Start playing.</div><div class="line">Football Game Started. Enjoy the game!</div><div class="line">Football Game Finished!</div></pre></td></tr></table></figure>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。<br>意图：主要将数据结构与数据操作分离。<br><strong> 主要解决：</strong> 稳定的数据结构和易变的操作耦合问题。<br><strong> 何时使用：</strong> 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。<br><strong> 如何解决：</strong> 在被访问的类里面加一个对外提供接待访问者的接口。<br><strong> 关键代码：</strong> 在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。<br><strong> 应用实例：</strong> 您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。<br><strong> 优点：</strong>  1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。<br><strong> 缺点：</strong>  1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。<br><strong> 使用场景：</strong>  1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。<br><strong> 注意事项：</strong> 访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。<br><strong> 实现</strong><br>我们将创建一个定义接受操作的 ComputerPart 接口。Keyboard、Mouse、Monitor 和 Computer 是实现了 ComputerPart 接口的实体类。我们将定义另一个接口 ComputerPartVisitor，它定义了访问者类的操作。Computer 使用实体访问者来执行相应的动作。<br>VisitorPatternDemo，我们的演示类使用 Computer、ComputerPartVisitor 类来演示访问者模式的用法。<br><img src="http://jet-han.oschina.io/img/设计模式/visitor_pattern_uml_diagram.jpg" alt="visitor_pattern" title="visitor_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>定义一个表示元素的接口。</p>
<p>ComputerPart.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface ComputerPart &#123;</div><div class="line">   public void accept(ComputerPartVisitor computerPartVisitor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建扩展了上述类的实体类。</p>
<p>Keyboard.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Keyboard  implements ComputerPart &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void accept(ComputerPartVisitor computerPartVisitor) &#123;</div><div class="line">      computerPartVisitor.visit(this);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Monitor.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Monitor  implements ComputerPart &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void accept(ComputerPartVisitor computerPartVisitor) &#123;</div><div class="line">      computerPartVisitor.visit(this);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Mouse.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Mouse  implements ComputerPart &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void accept(ComputerPartVisitor computerPartVisitor) &#123;</div><div class="line">      computerPartVisitor.visit(this);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Computer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Computer implements ComputerPart &#123;</div><div class="line">	</div><div class="line">   ComputerPart[] parts;</div><div class="line"></div><div class="line">   public Computer()&#123;</div><div class="line">      parts = new ComputerPart[] &#123;new Mouse(), new Keyboard(), new Monitor()&#125;;		</div><div class="line">   &#125; </div><div class="line"></div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void accept(ComputerPartVisitor computerPartVisitor) &#123;</div><div class="line">      for (int i = 0; i &lt; parts.length; i++) &#123;</div><div class="line">         parts[i].accept(computerPartVisitor);</div><div class="line">      &#125;</div><div class="line">      computerPartVisitor.visit(this);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>定义一个表示访问者的接口。</p>
<p>ComputerPartVisitor.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public interface ComputerPartVisitor &#123;</div><div class="line">	public void visit(Computer computer);</div><div class="line">	public void visit(Mouse mouse);</div><div class="line">	public void visit(Keyboard keyboard);</div><div class="line">	public void visit(Monitor monitor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建实现了上述类的实体访问者。</p>
<p>ComputerPartDisplayVisitor.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class ComputerPartDisplayVisitor implements ComputerPartVisitor &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void visit(Computer computer) &#123;</div><div class="line">      System.out.println(&quot;Displaying Computer.&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void visit(Mouse mouse) &#123;</div><div class="line">      System.out.println(&quot;Displaying Mouse.&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void visit(Keyboard keyboard) &#123;</div><div class="line">      System.out.println(&quot;Displaying Keyboard.&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void visit(Monitor monitor) &#123;</div><div class="line">      System.out.println(&quot;Displaying Monitor.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>使用 ComputerPartDisplayVisitor 来显示 Computer 的组成部分。</p>
<p>VisitorPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class VisitorPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      ComputerPart computer = new Computer();</div><div class="line">      computer.accept(new ComputerPartDisplayVisitor());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Displaying Mouse.</div><div class="line">Displaying Keyboard.</div><div class="line">Displaying Monitor.</div><div class="line">Displaying Computer.</div></pre></td></tr></table></figure>
<h2 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC 模式"></a>MVC 模式</h2><p>MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。<br><strong>Model（模型）</strong> - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。<br><strong>View（视图） </strong>- 视图代表模型包含的数据的可视化。<br><strong>Controller（控制器）</strong> - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。<br><strong>实现</strong><br>我们将创建一个作为模型的 Student 对象。StudentView 是一个把学生详细信息输出到控制台的视图类，StudentController 是负责存储数据到 Student 对象中的控制器类，并相应地更新视图 StudentView。<br>MVCPatternDemo，我们的演示类使用 StudentController 来演示 MVC 模式的用法。</p>
<p><img src="http://jet-han.oschina.io/img/设计模式/mvc_pattern_uml_diagram.jpg" alt="mvc_pattern" title="mvc_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建模型。</p>
<p>Student.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Student &#123;</div><div class="line">   private String rollNo;</div><div class="line">   private String name;</div><div class="line">   public String getRollNo() &#123;</div><div class="line">      return rollNo;</div><div class="line">   &#125;</div><div class="line">   public void setRollNo(String rollNo) &#123;</div><div class="line">      this.rollNo = rollNo;</div><div class="line">   &#125;</div><div class="line">   public String getName() &#123;</div><div class="line">      return name;</div><div class="line">   &#125;</div><div class="line">   public void setName(String name) &#123;</div><div class="line">      this.name = name;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建视图。</p>
<p>StudentView.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class StudentView &#123;</div><div class="line">   public void printStudentDetails(String studentName, String studentRollNo)&#123;</div><div class="line">      System.out.println(&quot;Student: &quot;);</div><div class="line">      System.out.println(&quot;Name: &quot; + studentName);</div><div class="line">      System.out.println(&quot;Roll No: &quot; + studentRollNo);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建控制器。</p>
<p>StudentController.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class StudentController &#123;</div><div class="line">   private Student model;</div><div class="line">   private StudentView view;</div><div class="line"></div><div class="line">   public StudentController(Student model, StudentView view)&#123;</div><div class="line">      this.model = model;</div><div class="line">      this.view = view;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setStudentName(String name)&#123;</div><div class="line">      model.setName(name);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getStudentName()&#123;</div><div class="line">      return model.getName();		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setStudentRollNo(String rollNo)&#123;</div><div class="line">      model.setRollNo(rollNo);		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getStudentRollNo()&#123;</div><div class="line">      return model.getRollNo();		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void updateView()&#123;				</div><div class="line">      view.printStudentDetails(model.getName(), model.getRollNo());</div><div class="line">   &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 StudentController 方法来演示 MVC 设计模式的用法。</p>
<p>MVCPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class MVCPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      //从数据可获取学生记录</div><div class="line">      Student model  = retriveStudentFromDatabase();</div><div class="line"></div><div class="line">      //创建一个视图：把学生详细信息输出到控制台</div><div class="line">      StudentView view = new StudentView();</div><div class="line"></div><div class="line">      StudentController controller = new StudentController(model, view);</div><div class="line"></div><div class="line">      controller.updateView();</div><div class="line"></div><div class="line">      //更新模型数据</div><div class="line">      controller.setStudentName(&quot;John&quot;);</div><div class="line"></div><div class="line">      controller.updateView();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private static Student retriveStudentFromDatabase()&#123;</div><div class="line">      Student student = new Student();</div><div class="line">      student.setName(&quot;Robert&quot;);</div><div class="line">      student.setRollNo(&quot;10&quot;);</div><div class="line">      return student;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Student: </div><div class="line">Name: Robert</div><div class="line">Roll No: 10</div><div class="line">Student: </div><div class="line">Name: John</div><div class="line">Roll No: 10</div></pre></td></tr></table></figure>
<h2 id="业务代表模式"><a href="#业务代表模式" class="headerlink" title="业务代表模式"></a>业务代表模式</h2><p>业务代表模式（Business Delegate Pattern）用于对表示层和业务层解耦。它基本上是用来减少通信或对表示层代码中的业务层代码的远程查询功能。在业务层中我们有以下实体。<br><strong>客户端（Client）</strong> - 表示层代码可以是 JSP、servlet 或 UI java 代码。<br><strong>业务代表（Business Delegate）</strong> - 一个为客户端实体提供的入口类，它提供了对业务服务方法的访问。<br><strong>查询服务（LookUp Service）</strong> - 查找服务对象负责获取相关的业务实现，并提供业务对象对业务代表对象的访问。<br><strong>业务服务（Business Service）</strong> - 业务服务接口。实现了该业务服务的实体类，提供了实际的业务实现逻辑。<br><strong>实现</strong><br>我们将创建 Client、BusinessDelegate、BusinessService、LookUpService、JMSService 和 EJBService 来表示业务代表模式中的各种实体。<br>BusinessDelegatePatternDemo，我们的演示类使用 BusinessDelegate 和 Client 来演示业务代表模式的用法。<br><img src="http://jet-han.oschina.io/img/设计模式/business_delegate_pattern_uml_diagram.jpg" alt="business_delegate_pattern" title="business_delegate_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建 BusinessService 接口。</p>
<p>BusinessService.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface BusinessService &#123;</div><div class="line">   public void doProcessing();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实体服务类。</p>
<p>EJBService.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class EJBService implements BusinessService &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void doProcessing() &#123;</div><div class="line">      System.out.println(&quot;Processing task by invoking EJB Service&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JMSService.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class JMSService implements BusinessService &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void doProcessing() &#123;</div><div class="line">      System.out.println(&quot;Processing task by invoking JMS Service&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建业务查询服务。</p>
<p>BusinessLookUp.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class BusinessLookUp &#123;</div><div class="line">   public BusinessService getBusinessService(String serviceType)&#123;</div><div class="line">      if(serviceType.equalsIgnoreCase(&quot;EJB&quot;))&#123;</div><div class="line">         return new EJBService();</div><div class="line">      &#125;else &#123;</div><div class="line">         return new JMSService();</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建业务代表。</p>
<p>BusinessDelegate.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class BusinessDelegate &#123;</div><div class="line">   private BusinessLookUp lookupService = new BusinessLookUp();</div><div class="line">   private BusinessService businessService;</div><div class="line">   private String serviceType;</div><div class="line"></div><div class="line">   public void setServiceType(String serviceType)&#123;</div><div class="line">      this.serviceType = serviceType;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void doTask()&#123;</div><div class="line">      businessService = lookupService.getBusinessService(serviceType);</div><div class="line">      businessService.doProcessing();		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>创建客户端。</p>
<p>Client.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">	</div><div class="line">   BusinessDelegate businessService;</div><div class="line"></div><div class="line">   public Client(BusinessDelegate businessService)&#123;</div><div class="line">      this.businessService  = businessService;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void doTask()&#123;		</div><div class="line">      businessService.doTask();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>使用 BusinessDelegate 和 Client 类来演示业务代表模式。</p>
<p>BusinessDelegatePatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class BusinessDelegatePatternDemo &#123;</div><div class="line">	</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">      BusinessDelegate businessDelegate = new BusinessDelegate();</div><div class="line">      businessDelegate.setServiceType(&quot;EJB&quot;);</div><div class="line"></div><div class="line">      Client client = new Client(businessDelegate);</div><div class="line">      client.doTask();</div><div class="line"></div><div class="line">      businessDelegate.setServiceType(&quot;JMS&quot;);</div><div class="line">      client.doTask();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 7</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Processing task by invoking EJB Service</div><div class="line">Processing task by invoking JMS Service</div></pre></td></tr></table></figure>
<h2 id="组合实体模式"><a href="#组合实体模式" class="headerlink" title="组合实体模式"></a>组合实体模式</h2><p>组合实体模式（Composite Entity Pattern）用在 EJB 持久化机制中。一个组合实体是一个 EJB 实体 bean，代表了对象的图解。当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean 管理的。以下是组合实体 bean 的参与者。<br><strong>组合实体（Composite Entity）</strong> - 它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期。<br><strong>粗粒度对象（Coarse-Grained Object）</strong> - 该对象包含依赖对象。它有自己的生命周期，也能管理依赖对象的生命周期。<br><strong>依赖对象（Dependent Object）</strong> - 依赖对象是一个持续生命周期依赖于粗粒度对象的对象。<br><strong>策略（Strategies）</strong> - 策略表示如何实现组合实体。<br><strong>实现</strong><br>我们将创建作为组合实体的 CompositeEntity 对象。CoarseGrainedObject 是一个包含依赖对象的类。<br>CompositeEntityPatternDemo，我们的演示类使用 Client 类来演示组合实体模式的用法。<br><img src="http://jet-han.oschina.io/img/设计模式/compositeentity_pattern_uml_diagram.jpg" alt="compositeentity_pattern" title="compositeentity_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建依赖对象。</p>
<p>DependentObject1.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class DependentObject1 &#123;</div><div class="line">	</div><div class="line">   private String data;</div><div class="line"></div><div class="line">   public void setData(String data)&#123;</div><div class="line">      this.data = data; </div><div class="line">   &#125; </div><div class="line"></div><div class="line">   public String getData()&#123;</div><div class="line">      return data;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DependentObject2.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class DependentObject2 &#123;</div><div class="line">	</div><div class="line">   private String data;</div><div class="line"></div><div class="line">   public void setData(String data)&#123;</div><div class="line">      this.data = data; </div><div class="line">   &#125; </div><div class="line"></div><div class="line">   public String getData()&#123;</div><div class="line">      return data;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建粗粒度对象。</p>
<p>CoarseGrainedObject.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class CoarseGrainedObject &#123;</div><div class="line">   DependentObject1 do1 = new DependentObject1();</div><div class="line">   DependentObject2 do2 = new DependentObject2();</div><div class="line"></div><div class="line">   public void setData(String data1, String data2)&#123;</div><div class="line">      do1.setData(data1);</div><div class="line">      do2.setData(data2);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String[] getData()&#123;</div><div class="line">      return new String[] &#123;do1.getData(),do2.getData()&#125;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建组合实体。</p>
<p>CompositeEntity.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class CompositeEntity &#123;</div><div class="line">   private CoarseGrainedObject cgo = new CoarseGrainedObject();</div><div class="line"></div><div class="line">   public void setData(String data1, String data2)&#123;</div><div class="line">      cgo.setData(data1, data2);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String[] getData()&#123;</div><div class="line">      return cgo.getData();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建使用组合实体的客户端类。</p>
<p>Client.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">   private CompositeEntity compositeEntity = new CompositeEntity();</div><div class="line"></div><div class="line">   public void printData()&#123;</div><div class="line">      for (int i = 0; i &lt; compositeEntity.getData().length; i++) &#123;</div><div class="line">         System.out.println(&quot;Data: &quot; + compositeEntity.getData()[i]);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setData(String data1, String data2)&#123;</div><div class="line">      compositeEntity.setData(data1, data2);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>使用 Client 来演示组合实体设计模式的用法。</p>
<p>CompositeEntityPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class CompositeEntityPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">       Client client = new Client();</div><div class="line">       client.setData(&quot;Test&quot;, &quot;Data&quot;);</div><div class="line">       client.printData();</div><div class="line">       client.setData(&quot;Second Test&quot;, &quot;Data1&quot;);</div><div class="line">       client.printData();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Data: Test</div><div class="line">Data: Data</div><div class="line">Data: Second Test</div><div class="line">Data: Data1</div></pre></td></tr></table></figure>
<h2 id="数据访问对象模式"><a href="#数据访问对象模式" class="headerlink" title="数据访问对象模式"></a>数据访问对象模式</h2><p>数据访问对象模式（Data Access Object Pattern）或 DAO 模式用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者。<br><strong>数据访问对象接口（Data Access Object Interface）</strong> - 该接口定义了在一个模型对象上要执行的标准操作。<br><strong>数据访问对象实体类（Data Access Object concrete class）</strong> - 该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。<br><strong>模型对象/数值对象（Model Object/Value Object）</strong> - 该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据。<br><strong>实现 </strong><br>我们将创建一个作为模型对象或数值对象的 Student 对象。StudentDao 是数据访问对象接口。StudentDaoImpl 是实现了数据访问对象接口的实体类。DaoPatternDemo，我们的演示类使用 StudentDao 来演示数据访问对象模式的用法。<br><img src="http://jet-han.oschina.io/img/设计模式/dao_pattern_uml_diagram.jpg" alt="dao_pattern" title="dao_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建数值对象。</p>
<p>Student.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class Student &#123;</div><div class="line">   private String name;</div><div class="line">   private int rollNo;</div><div class="line"></div><div class="line">   Student(String name, int rollNo)&#123;</div><div class="line">      this.name = name;</div><div class="line">      this.rollNo = rollNo;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getName() &#123;</div><div class="line">      return name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setName(String name) &#123;</div><div class="line">      this.name = name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public int getRollNo() &#123;</div><div class="line">      return rollNo;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setRollNo(int rollNo) &#123;</div><div class="line">      this.rollNo = rollNo;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建数据访问对象接口。</p>
<p>StudentDao.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public interface StudentDao &#123;</div><div class="line">   public List&lt;Student&gt; getAllStudents();</div><div class="line">   public Student getStudent(int rollNo);</div><div class="line">   public void updateStudent(Student student);</div><div class="line">   public void deleteStudent(Student student);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建实现了上述接口的实体类。</p>
<p>StudentDaoImpl.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class StudentDaoImpl implements StudentDao &#123;</div><div class="line">	</div><div class="line">   //列表是当作一个数据库</div><div class="line">   List&lt;Student&gt; students;</div><div class="line"></div><div class="line">   public StudentDaoImpl()&#123;</div><div class="line">      students = new ArrayList&lt;Student&gt;();</div><div class="line">      Student student1 = new Student(&quot;Robert&quot;,0);</div><div class="line">      Student student2 = new Student(&quot;John&quot;,1);</div><div class="line">      students.add(student1);</div><div class="line">      students.add(student2);		</div><div class="line">   &#125;</div><div class="line">   @Override</div><div class="line">   public void deleteStudent(Student student) &#123;</div><div class="line">      students.remove(student.getRollNo());</div><div class="line">      System.out.println(&quot;Student: Roll No &quot; + student.getRollNo() </div><div class="line">         +&quot;, deleted from database&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //从数据库中检索学生名单</div><div class="line">   @Override</div><div class="line">   public List&lt;Student&gt; getAllStudents() &#123;</div><div class="line">      return students;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public Student getStudent(int rollNo) &#123;</div><div class="line">      return students.get(rollNo);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void updateStudent(Student student) &#123;</div><div class="line">      students.get(student.getRollNo()).setName(student.getName());</div><div class="line">      System.out.println(&quot;Student: Roll No &quot; + student.getRollNo() </div><div class="line">         +&quot;, updated in the database&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 StudentDao 来演示数据访问对象模式的用法。</p>
<p>CompositeEntityPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class DaoPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      StudentDao studentDao = new StudentDaoImpl();</div><div class="line"></div><div class="line">      //输出所有的学生</div><div class="line">      for (Student student : studentDao.getAllStudents()) &#123;</div><div class="line">         System.out.println(&quot;Student: [RollNo : &quot;</div><div class="line">            +student.getRollNo()+&quot;, Name : &quot;+student.getName()+&quot; ]&quot;);</div><div class="line">      &#125;</div><div class="line"></div><div class="line"></div><div class="line">      //更新学生</div><div class="line">      Student student =studentDao.getAllStudents().get(0);</div><div class="line">      student.setName(&quot;Michael&quot;);</div><div class="line">      studentDao.updateStudent(student);</div><div class="line"></div><div class="line">      //获取学生</div><div class="line">      studentDao.getStudent(0);</div><div class="line">      System.out.println(&quot;Student: [RollNo : &quot;</div><div class="line">         +student.getRollNo()+&quot;, Name : &quot;+student.getName()+&quot; ]&quot;);		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Student: [RollNo : 0, Name : Robert ]</div><div class="line">Student: [RollNo : 1, Name : John ]</div><div class="line">Student: Roll No 0, updated in the database</div><div class="line">Student: [RollNo : 0, Name : Michael ]</div></pre></td></tr></table></figure>
<h2 id="前端控制器模式"><a href="#前端控制器模式" class="headerlink" title="前端控制器模式"></a>前端控制器模式</h2><p>前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。<br><strong>前端控制器（Front Controller）</strong> - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。<br><strong>调度器（Dispatcher）</strong> - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。<br><strong>视图（View）</strong> - 视图是为请求而创建的对象。<br><strong>实现 </strong><br>我们将创建 FrontController、Dispatcher 分别当作前端控制器和调度器。HomeView 和 StudentView 表示各种为前端控制器接收到的请求而创建的视图。<br>FrontControllerPatternDemo，我们的演示类使用 FrontController 来演示前端控制器设计模式。<br><img src="http://jet-han.oschina.io/img/设计模式/frontcontroller_pattern_uml_diagram.jpg" alt="frontcontroller_pattern" title="frontcontroller_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建视图。</p>
<p>HomeView.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class HomeView &#123;</div><div class="line">   public void show()&#123;</div><div class="line">      System.out.println(&quot;Displaying Home Page&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>StudentView.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class StudentView &#123;</div><div class="line">   public void show()&#123;</div><div class="line">      System.out.println(&quot;Displaying Student Page&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建调度器 Dispatcher。</p>
<p>Dispatcher.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Dispatcher &#123;</div><div class="line">   private StudentView studentView;</div><div class="line">   private HomeView homeView;</div><div class="line">   public Dispatcher()&#123;</div><div class="line">      studentView = new StudentView();</div><div class="line">      homeView = new HomeView();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void dispatch(String request)&#123;</div><div class="line">      if(request.equalsIgnoreCase(&quot;STUDENT&quot;))&#123;</div><div class="line">         studentView.show();</div><div class="line">      &#125;else&#123;</div><div class="line">         homeView.show();</div><div class="line">      &#125;	</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建前端控制器 FrontController。</p>
<p>Context.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class FrontController &#123;</div><div class="line">	</div><div class="line">   private Dispatcher dispatcher;</div><div class="line"></div><div class="line">   public FrontController()&#123;</div><div class="line">      dispatcher = new Dispatcher();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private boolean isAuthenticUser()&#123;</div><div class="line">      System.out.println(&quot;User is authenticated successfully.&quot;);</div><div class="line">      return true;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private void trackRequest(String request)&#123;</div><div class="line">      System.out.println(&quot;Page requested: &quot; + request);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void dispatchRequest(String request)&#123;</div><div class="line">      //记录每一个请求</div><div class="line">      trackRequest(request);</div><div class="line">      //对用户进行身份验证</div><div class="line">      if(isAuthenticUser())&#123;</div><div class="line">         dispatcher.dispatch(request);</div><div class="line">      &#125;	</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>使用 FrontController 来演示前端控制器设计模式。</p>
<p>FrontControllerPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class FrontControllerPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      FrontController frontController = new FrontController();</div><div class="line">      frontController.dispatchRequest(&quot;HOME&quot;);</div><div class="line">      frontController.dispatchRequest(&quot;STUDENT&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Page requested: HOME</div><div class="line">User is authenticated successfully.</div><div class="line">Displaying Home Page</div><div class="line">Page requested: STUDENT</div><div class="line">User is authenticated successfully.</div><div class="line">Displaying Student Page</div></pre></td></tr></table></figure>
<h2 id="拦截过滤器模式"><a href="#拦截过滤器模式" class="headerlink" title="拦截过滤器模式"></a>拦截过滤器模式</h2><p>拦截过滤器模式（Intercepting Filter Pattern）用于对应用程序的请求或响应做一些预处理/后处理。定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上。过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。<br><strong>过滤器（Filter）</strong> - 过滤器在请求处理程序执行请求之前或之后，执行某些任务。<br><strong>过滤器链（Filter Chain）</strong> - 过滤器链带有多个过滤器，并在 Target 上按照定义的顺序执行这些过滤器。<br><strong>Target </strong>- Target 对象是请求处理程序。<br><strong>过滤管理器（Filter Manager）</strong> - 过滤管理器管理过滤器和过滤器链。<br><strong>客户端（Client）</strong> - Client 是向 Target 对象发送请求的对象。<br><strong>实现</strong><br>我们将创建 FilterChain、FilterManager、Target、Client 作为表示实体的各种对象。AuthenticationFilter 和 DebugFilter 表示实体过滤器。<br>InterceptingFilterDemo，我们的演示类使用 Client 来演示拦截过滤器设计模式。<br><img src="http://jet-han.oschina.io/img/设计模式/interceptingfilter_pattern_uml_diagram.jpg" alt="interceptingfilter_pattern" title="interceptingfilter_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建过滤器接口 Filter。</p>
<p>Filter.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Filter &#123;</div><div class="line">   public void execute(String request);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实体过滤器。</p>
<p>AuthenticationFilter.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class AuthenticationFilter implements Filter &#123;</div><div class="line">   public void execute(String request)&#123;</div><div class="line">      System.out.println(&quot;Authenticating request: &quot; + request);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DebugFilter.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class DebugFilter implements Filter &#123;</div><div class="line">   public void execute(String request)&#123;</div><div class="line">      System.out.println(&quot;request log: &quot; + request);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>创建 Target。</p>
<p>Target.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class Target &#123;</div><div class="line">   public void execute(String request)&#123;</div><div class="line">      System.out.println(&quot;Executing request: &quot; + request);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建过滤器链。</p>
<p>FilterChain.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class FilterChain &#123;</div><div class="line">   private List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;();</div><div class="line">   private Target target;</div><div class="line"></div><div class="line">   public void addFilter(Filter filter)&#123;</div><div class="line">      filters.add(filter);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void execute(String request)&#123;</div><div class="line">      for (Filter filter : filters) &#123;</div><div class="line">         filter.execute(request);</div><div class="line">      &#125;</div><div class="line">      target.execute(request);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setTarget(Target target)&#123;</div><div class="line">      this.target = target;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>创建过滤管理器。</p>
<p>FilterManager.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class FilterManager &#123;</div><div class="line">   FilterChain filterChain;</div><div class="line"></div><div class="line">   public FilterManager(Target target)&#123;</div><div class="line">      filterChain = new FilterChain();</div><div class="line">      filterChain.setTarget(target);</div><div class="line">   &#125;</div><div class="line">   public void setFilter(Filter filter)&#123;</div><div class="line">      filterChain.addFilter(filter);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void filterRequest(String request)&#123;</div><div class="line">      filterChain.execute(request);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>创建客户端 Client。</p>
<p>Client.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">   FilterManager filterManager;</div><div class="line"></div><div class="line">   public void setFilterManager(FilterManager filterManager)&#123;</div><div class="line">      this.filterManager = filterManager;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void sendRequest(String request)&#123;</div><div class="line">      filterManager.filterRequest(request);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 7</strong></p>
<p>使用 Client 来演示拦截过滤器设计模式。</p>
<p>FrontControllerPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class InterceptingFilterDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      FilterManager filterManager = new FilterManager(new Target());</div><div class="line">      filterManager.setFilter(new AuthenticationFilter());</div><div class="line">      filterManager.setFilter(new DebugFilter());</div><div class="line"></div><div class="line">      Client client = new Client();</div><div class="line">      client.setFilterManager(filterManager);</div><div class="line">      client.sendRequest(&quot;HOME&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 8</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Authenticating request: HOME</div><div class="line">request log: HOME</div><div class="line">Executing request: HOME</div></pre></td></tr></table></figure>
<h2 id="服务定位器模式"><a href="#服务定位器模式" class="headerlink" title="服务定位器模式"></a>服务定位器模式</h2><p>服务定位器模式（Service Locator Pattern）用在我们想使用 JNDI 查询定位各种服务的时候。考虑到为某个服务查找 JNDI 的代价很高，服务定位器模式充分利用了缓存技术。在首次请求某个服务时，服务定位器在 JNDI 中查找服务，并缓存该服务对象。当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能。以下是这种设计模式的实体。<br><strong>服务（Service）</strong> - 实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到。<br><strong>Context / 初始的 Context</strong> - JNDI Context 带有对要查找的服务的引用。<br><strong>服务定位器（Service Locator）</strong> - 服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触。<br><strong>缓存（Cache）</strong> - 缓存存储服务的引用，以便复用它们。<br><strong>客户端（Client）</strong> - Client 是通过 ServiceLocator 调用服务的对象。<br><strong>实现</strong><br>我们将创建 ServiceLocator、InitialContext、Cache、Service 作为表示实体的各种对象。Service1 和 Service2 表示实体服务。<br>ServiceLocatorPatternDemo，我们的演示类在这里是作为一个客户端，将使用 ServiceLocator 来演示服务定位器设计模式。<br><img src="http://jet-han.oschina.io/img/设计模式/servicelocator_pattern_uml_diagram.jpg" alt="servicelocator_pattern" title="servicelocator_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建服务接口 Service。</p>
<p>Service.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface Service &#123;</div><div class="line">   public String getName();</div><div class="line">   public void execute();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建实体服务。</p>
<p>Service1.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Service1 implements Service &#123;</div><div class="line">   public void execute()&#123;</div><div class="line">      System.out.println(&quot;Executing Service1&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String getName() &#123;</div><div class="line">      return &quot;Service1&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Service2.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Service2 implements Service &#123;</div><div class="line">   public void execute()&#123;</div><div class="line">      System.out.println(&quot;Executing Service2&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String getName() &#123;</div><div class="line">      return &quot;Service2&quot;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>为 JNDI 查询创建 InitialContext。</p>
<p>InitialContext.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class InitialContext &#123;</div><div class="line">   public Object lookup(String jndiName)&#123;</div><div class="line">      if(jndiName.equalsIgnoreCase(&quot;SERVICE1&quot;))&#123;</div><div class="line">         System.out.println(&quot;Looking up and creating a new Service1 object&quot;);</div><div class="line">         return new Service1();</div><div class="line">      &#125;else if (jndiName.equalsIgnoreCase(&quot;SERVICE2&quot;))&#123;</div><div class="line">         System.out.println(&quot;Looking up and creating a new Service2 object&quot;);</div><div class="line">         return new Service2();</div><div class="line">      &#125;</div><div class="line">      return null;		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>创建缓存 Cache。</p>
<p>Cache.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class Cache &#123;</div><div class="line"></div><div class="line">   private List&lt;Service&gt; services;</div><div class="line"></div><div class="line">   public Cache()&#123;</div><div class="line">      services = new ArrayList&lt;Service&gt;();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public Service getService(String serviceName)&#123;</div><div class="line">      for (Service service : services) &#123;</div><div class="line">         if(service.getName().equalsIgnoreCase(serviceName))&#123;</div><div class="line">            System.out.println(&quot;Returning cached  &quot;+serviceName+&quot; object&quot;);</div><div class="line">            return service;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void addService(Service newService)&#123;</div><div class="line">      boolean exists = false;</div><div class="line">      for (Service service : services) &#123;</div><div class="line">         if(service.getName().equalsIgnoreCase(newService.getName()))&#123;</div><div class="line">            exists = true;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      if(!exists)&#123;</div><div class="line">         services.add(newService);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 5</strong></p>
<p>创建服务定位器。</p>
<p>ServiceLocator.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class ServiceLocator &#123;</div><div class="line">   private static Cache cache;</div><div class="line"></div><div class="line">   static &#123;</div><div class="line">      cache = new Cache();		</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public static Service getService(String jndiName)&#123;</div><div class="line"></div><div class="line">      Service service = cache.getService(jndiName);</div><div class="line"></div><div class="line">      if(service != null)&#123;</div><div class="line">         return service;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      InitialContext context = new InitialContext();</div><div class="line">      Service service1 = (Service)context.lookup(jndiName);</div><div class="line">      cache.addService(service1);</div><div class="line">      return service1;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 6</strong></p>
<p>使用 ServiceLocator 来演示服务定位器设计模式。</p>
<p>ServiceLocatorPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class ServiceLocatorPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      Service service = ServiceLocator.getService(&quot;Service1&quot;);</div><div class="line">      service.execute();</div><div class="line">      service = ServiceLocator.getService(&quot;Service2&quot;);</div><div class="line">      service.execute();</div><div class="line">      service = ServiceLocator.getService(&quot;Service1&quot;);</div><div class="line">      service.execute();</div><div class="line">      service = ServiceLocator.getService(&quot;Service2&quot;);</div><div class="line">      service.execute();		</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 7</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Looking up and creating a new Service1 object</div><div class="line">Executing Service1</div><div class="line">Looking up and creating a new Service2 object</div><div class="line">Executing Service2</div><div class="line">Returning cached  Service1 object</div><div class="line">Executing Service1</div><div class="line">Returning cached  Service2 object</div><div class="line">Executing Service2</div></pre></td></tr></table></figure>
<h2 id="传输对象模式"><a href="#传输对象模式" class="headerlink" title="传输对象模式"></a>传输对象模式</h2><p>传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。传输对象也被称为数值对象。传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输。它没有任何的行为。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。<br><strong>业务对象（Business Object）</strong> - 为传输对象填充数据的业务服务。<br><strong>传输对象（Transfer Object）</strong> - 简单的 POJO，只有设置/获取属性的方法。<br><strong>客户端（Client）</strong> - 客户端可以发送请求或者发送传输对象到业务对象。<br><strong>实现</strong><br>我们将创建一个作为业务对象的 StudentBO 和作为传输对象的 StudentVO，它们都代表了我们的实体。<br>TransferObjectPatternDemo，我们的演示类在这里是作为一个客户端，将使用 StudentBO 和 Student 来演示传输对象设计模式。<br><img src="http://jet-han.oschina.io/img/设计模式/transferobject_pattern_uml_diagram.jpg" alt="transferobject_pattern" title="transferobject_pattern"></p>
<p><strong>步骤 1</strong></p>
<p>创建传输对象。</p>
<p>StudentVO.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class StudentVO &#123;</div><div class="line">   private String name;</div><div class="line">   private int rollNo;</div><div class="line"></div><div class="line">   StudentVO(String name, int rollNo)&#123;</div><div class="line">      this.name = name;</div><div class="line">      this.rollNo = rollNo;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getName() &#123;</div><div class="line">      return name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setName(String name) &#123;</div><div class="line">      this.name = name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public int getRollNo() &#123;</div><div class="line">      return rollNo;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void setRollNo(int rollNo) &#123;</div><div class="line">      this.rollNo = rollNo;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 2</strong></p>
<p>创建业务对象。</p>
<p>StudentBO.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class StudentBO &#123;</div><div class="line">	</div><div class="line">   //列表是当作一个数据库</div><div class="line">   List&lt;StudentVO&gt; students;</div><div class="line"></div><div class="line">   public StudentBO()&#123;</div><div class="line">      students = new ArrayList&lt;StudentVO&gt;();</div><div class="line">      StudentVO student1 = new StudentVO(&quot;Robert&quot;,0);</div><div class="line">      StudentVO student2 = new StudentVO(&quot;John&quot;,1);</div><div class="line">      students.add(student1);</div><div class="line">      students.add(student2);		</div><div class="line">   &#125;</div><div class="line">   public void deleteStudent(StudentVO student) &#123;</div><div class="line">      students.remove(student.getRollNo());</div><div class="line">      System.out.println(&quot;Student: Roll No &quot; </div><div class="line">      + student.getRollNo() +&quot;, deleted from database&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //从数据库中检索学生名单</div><div class="line">   public List&lt;StudentVO&gt; getAllStudents() &#123;</div><div class="line">      return students;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public StudentVO getStudent(int rollNo) &#123;</div><div class="line">      return students.get(rollNo);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void updateStudent(StudentVO student) &#123;</div><div class="line">      students.get(student.getRollNo()).setName(student.getName());</div><div class="line">      System.out.println(&quot;Student: Roll No &quot; </div><div class="line">      + student.getRollNo() +&quot;, updated in the database&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 3</strong></p>
<p>使用 StudentBO 来演示传输对象设计模式。</p>
<p>TransferObjectPatternDemo.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class TransferObjectPatternDemo &#123;</div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">      StudentBO studentBusinessObject = new StudentBO();</div><div class="line"></div><div class="line">      //输出所有的学生</div><div class="line">      for (StudentVO student : studentBusinessObject.getAllStudents()) &#123;</div><div class="line">         System.out.println(&quot;Student: [RollNo : &quot;</div><div class="line">         +student.getRollNo()+&quot;, Name : &quot;+student.getName()+&quot; ]&quot;);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      //更新学生</div><div class="line">      StudentVO student =studentBusinessObject.getAllStudents().get(0);</div><div class="line">      student.setName(&quot;Michael&quot;);</div><div class="line">      studentBusinessObject.updateStudent(student);</div><div class="line"></div><div class="line">      //获取学生</div><div class="line">      studentBusinessObject.getStudent(0);</div><div class="line">      System.out.println(&quot;Student: [RollNo : &quot;</div><div class="line">      +student.getRollNo()+&quot;, Name : &quot;+student.getName()+&quot; ]&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤 4</strong></p>
<p>验证输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Student: [RollNo : 0, Name : Robert ]</div><div class="line">Student: [RollNo : 1, Name : John ]</div><div class="line">Student: Roll No 0, updated in the database</div><div class="line">Student: [RollNo : 0, Name : Michael ]</div></pre></td></tr></table></figure>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p>本章列出了设计模式相关的网站、书籍和文章。</p>
<p><strong>设计模式相关的网站</strong></p>
<p><a href="http://en.wikipedia.org/wiki/Design_pattern_(computer_science" target="_blank" rel="external"><font color="#0366d6">Wiki Page for Design Patterns</font></a>) - 以一种非常通用的方式检查设计模式。<br><a href="http://en.wikibooks.org/wiki/Java_Programming/Design_Patterns" target="_blank" rel="external"><font color="#0366d6">Java Programming/Design Patterns</font></a> - 一篇关于设计模式的好文章。<br><a href="http://java.sun.com/docs/books/tutorial/index.html" target="_blank" rel="external"><font color="#0366d6">The JavaTM Tutorials</font></a> - 该 Java 教程是为那些想用 Java 编程语言创建应用程序的编程人员提供的实用指南。<br><a href="http://java.sun.com/j2se/1.4.2/docs/index.html" target="_blank" rel="external"><font color="#0366d6">JavaTM 2 SDK, Standard Edition</font></a> - JavaTM 2 SDK, Standard Edition 的官网。<br><a href="http://exciton.cs.rice.edu/javaresources/DesignPatterns/" target="_blank" rel="external"><font color="#0366d6">Java DesignPatterns</font></a> - 关于设计模式的短文。</p>
<p><strong>Java 设计模式有用的书籍</strong><br>Java Design Patterns<br>Head First Design Patterns<br>Java Design Pattern Essentials<br>Design Patterns: Elements of Reusable Object-Oriented Software<br>Design Patterns in Java(TM)<br>Design Patterns Java Workbook </p>
<p><a href="http://www.runoob.com/design-pattern/design-pattern-tutorial.html" target="_blank" rel="external"><font color="#0366d6">原文地址</font></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;设计模式简介&lt;/strong&gt;&lt;br&gt;设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 &lt;/p&gt;
&lt;p&gt;设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。&lt;br&gt;
    
    </summary>
    
      <category term="design patterns" scheme="http://jet-han.oschina.io/categories/design-patterns/"/>
    
    
      <category term="Singleton Pattern" scheme="http://jet-han.oschina.io/tags/Singleton-Pattern/"/>
    
      <category term="Factory Pattern" scheme="http://jet-han.oschina.io/tags/Factory-Pattern/"/>
    
      <category term="Proxy Pattern" scheme="http://jet-han.oschina.io/tags/Proxy-Pattern/"/>
    
      <category term="MVC Pattern" scheme="http://jet-han.oschina.io/tags/MVC-Pattern/"/>
    
      <category term="Intercepting Filter Pattern" scheme="http://jet-han.oschina.io/tags/Intercepting-Filter-Pattern/"/>
    
      <category term="Iterator Pattern" scheme="http://jet-han.oschina.io/tags/Iterator-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之线程池ThreadPoolExecutor</title>
    <link href="http://jet-han.oschina.io/2017/08/06/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor/"/>
    <id>http://jet-han.oschina.io/2017/08/06/并发编程之线程池ThreadPoolExecutor/</id>
    <published>2017-08-06T05:32:02.000Z</published>
    <updated>2017-09-04T10:46:05.648Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/java.jpg" alt="java" title="java"></p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>当前越来越多的系统使用多线程来处理任务，但是为每一个任务创建线程并不是合理的方案，原因有2点：一是创建线程的开销很大，一个任务一个线程的方式会有性能上的损失；二是可能导致线程数量的膨胀，不但不易于线程的管理，还可能导致内存被消耗完，导致out of memory（OOM）,从而使系统崩溃。为了解决这个问题，线程池应运而生。线程池有两个作用：一个是限制线程的数量，不会导致线程的膨胀；二是线程复用，线程执行完一个人任务之后，可以接着执行下一个任务，减少了创建线程的开销。 </p>
<p>java中一个运用非常普遍的线程池是ThreadPoolExecutor。下面来探究下ThreadPoolExecutor的功能和实现原理。<br><a id="more"></a><br><strong>ThreadPoolExecutor的功能</strong></p>
<ol>
<li>自定义线程池的核心线程数和最大线程数。如果当前池中的线程数小于核心线程数，则直接为任务创建新线程来执行，如果前池中的线程数大于核心线程数，则把任务放入任务队列中，等待线程池中已有的线程去执行。如果任务队列满了，但是池中的线程数小于最大线程数，则创建新线程执行任务。如果任务队列满了，池中的线程数等于最大线程数，那么执行拒绝任务策略。</li>
<li>可配置拒绝任务策略，ThreadPoolExecutor自带了四种拒绝策略：丢弃当前将要加入队列的任务本身（DiscardPolicy），丢弃任务队列中最旧任务（DiscardOldestPolicy），抛出异常的方式（AbortPolicy），将任务交由调用者线程去执行（CallerRunsPolicy），除了自带的策略之外，用户还可以自定义策略。</li>
<li>线程声明周期管理。如果线程空闲时间超过了配置的时间keepAliveTime，则线程将被销毁。</li>
<li>配置线程工厂，用户可以自定义创建线程的工厂。</li>
<li>配置阻塞队列类型。</li>
<li>线程池生命周期管理。可以强制shutdown线程池，也可以优雅shutdown线程池。</li>
</ol>
<p>为了实现上面的配置管理。ThreadPoolExecutor提供了不同的创建线程池的构造方法，用户可以根据自身实际情况选择。</p>
<p><strong>ThreadPoolExecutor实现原理</strong></p>
<p> ThreadPoolExecutor的属性</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性名</th>
<th>属性说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>volatile int runState</td>
<td><strong>runState</strong>主要提供了生命周期的控制，下面是主要的状态：<br><strong>RUNNING：0。</strong>接收新任务以及处理队列中的任务<br><strong>SHUTDOWN：1。</strong>不再接收新任务，但是处理队列中的任务<br><strong>STOP：2。</strong>不再接收新任务，也不处理队列中的任务，同时中断正在执行的任务<br><strong>TERMINATED：3。</strong>跟STOP相同，同时所有的线程都终止了。</td>
</tr>
<tr>
<td>BlockingQueue<runnable> workQueue</runnable></td>
<td>任务队列</td>
</tr>
<tr>
<td>ReentrantLock mainLock</td>
<td>为poolSize, corePoolSize,maximumPoolSize, runState, and workers属性的set提供同步。</td>
</tr>
<tr>
<td>HashSet<worker> workers</worker></td>
<td>保存线程池中所有的工作线程，只有获得mainLock锁才能访问</td>
</tr>
<tr>
<td>volatile long  keepAliveTime</td>
<td>空闲线程的最大存活时间</td>
</tr>
<tr>
<td>volatile boolean allowCoreThreadTimeOut</td>
<td>核心线程是否也支持最大存活时间管理</td>
</tr>
<tr>
<td>volatile int corePoolSize</td>
<td>线程池核心线程数</td>
</tr>
<tr>
<td>volatile int   maximumPoolSize</td>
<td>线程池最大线程数</td>
</tr>
<tr>
<td>volatile int   poolSize</td>
<td>线程池当前线程数</td>
</tr>
<tr>
<td>int largestPoolSize</td>
<td>线程池峰值线程数</td>
</tr>
<tr>
<td>long completedTaskCount</td>
<td>线程池总共处理的任务数</td>
</tr>
<tr>
<td>volatile RejectedExecutionHandler handler</td>
<td>任务拒绝策略</td>
</tr>
<tr>
<td>volatile ThreadFactory threadFactory</td>
<td>创建线程工厂</td>
</tr>
</tbody>
</table>
</div>
<p>ThreadPoolExecutor的属性，基本上大部分都是构造函数中可配置的，也说明了ThreadPoolExecutor的灵活性。不过通过上面的表大家可能会有点疑惑：怎么没有保存Thread对象集合的属性？不要急，大家应该发现了里面有个HashSet<worker> workers属性。这个集合里Worker对象是ThreadPoolExecutor定义的一个内部类，它包含了thread对象。现在我们来看下Worker对象包含的属性。</worker></p>
<p><strong>Worker对象的属性</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性名称</th>
<th>属性说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>inal ReentrantLock runLock</td>
<td>这个锁的作用是保护取消worker线程的中断，而不是中断正在执行的任务。</td>
</tr>
<tr>
<td>Runnable firstTask</td>
<td>由于线程池创建现在的时候都是为某个任务创建，所以该属性就是记录该刚线程创建时执行的任务</td>
</tr>
<tr>
<td>long completedTasks</td>
<td>这个线程执行的任务数</td>
</tr>
<tr>
<td>Thread thread</td>
<td>本worker运行的线程</td>
</tr>
<tr>
<td>volatile boolean hasRun</td>
<td>本worker对象运行的线程是否执行过该worker的run方法。只有hasRun为true时worker的线程才能被中断。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>ThreadPoolExecutor的任务处理流程</strong></p>
<p>前面介绍了ThreadPoolExecutor的属性以及需要用到的内部类，素材有了，那么下面来看看是如何来把素材加工成成品的吧。在用户创建完线程池之后，需要把任务提交给线程池，线程池提供了submit和execute方法来提交任务，而submit方法最终还是调用的execute方法，它只是把任务封装成futuretask，以便获得任务的返回值。对于没有返回值的任务直接用execute提交就可以了，如果有返回值的任务，用submit提交更好。所以提交任务的核心还是execute方法。现在就来看看execute的实现代码：</p>
<pre><code>1.public void execute(Runnable command) {  
2.        if (command == null)  
3.            throw new NullPointerException();  
4.        if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) {  
5.            if (runState == RUNNING &amp;&amp; workQueue.offer(command)) {  
6.                if (runState != RUNNING || poolSize == 0)  
7.                    ensureQueuedTaskHandled(command);  
8.            }  
9.            else if (!addIfUnderMaximumPoolSize(command))  
10.                reject(command); // is shutdown or saturated  
11.        }  
12.    }  
</code></pre><p>这段代码的主要逻辑如下：</p>
<p>1.如果当选线程数大于等于核心线程数，则直接把任务放到任务队列里，等待已有的线程去执行它。如果当前选线程数小于核心线程数，则为该任务创建新的线程去执行它，这个的功能的实现方法是<code>addIfUnderCorePoolSize(command)</code>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private boolean addIfUnderCorePoolSize(Runnable firstTask) &#123;  </div><div class="line">   Thread t = null;  </div><div class="line">   final ReentrantLock mainLock = this.mainLock;  </div><div class="line">   mainLock.lock();  </div><div class="line">   try &#123;  </div><div class="line">      if (poolSize &lt; corePoolSize &amp;&amp; runState == RUNNING)  </div><div class="line">      t = addThread(firstTask);  </div><div class="line">   &#125; finally &#123;  </div><div class="line">   mainLock.unlock();  </div><div class="line">   &#125;  </div><div class="line">   return t != null;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现，这段源码是如果发现小于corePoolSize就会调用addThread()方法创建一个新的线程，并且调用线程的start()方法将线程运行起来。只有没有创建成功Thread才会返回false，也就是当当前的poolSize &gt; corePoolSize的时候，或线程池已经不是在running状态的时候才会出现。execute对poolSize和corePoolSize的比较只是粗略判断，而addIfUnderCorePoolSize（）内部是加锁后判定的，以得到更为准确的结果，而外部初步判定如果是大于了，就没有必要进入这段有锁的代码了。<br> 2.如果addIfUnderCorePoolSize返回false，说明没有为任务创建线程（原因可能是线程池不是RUNNING状态，或者poolsize大于corepoolsize了）。则需要把任务存放到任务队列中。<br> 3.在任务放到队列之前，先初步判断下此时线程池的状态。如果是running才接受新任务，否则addIfUnderMaximumPoolSize方法精确线程池状态。<br> 4.如果任务可以添加到任务队列，则判调用队列的offer方法，往队列末尾加入任务。由于队列是一个自定义的阻塞队列，可以是有界也可以是无界的。如果加入队列成功，还有先判断下runState != RUNNING || poolSize == 0。前面判断了状态之后为什么还要判断呢？这是因为有时间差，状态随时可以发生改变。记住了这一点在看这样一堆状态判断就不会难以理解了。好了，如果线程池不是RUNNING状态或线程池里没有线程了，则执行<code>ensureQueuedTaskHandled</code>方法处理任务如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">private void ensureQueuedTaskHandled(Runnable command) &#123;  </div><div class="line">        final ReentrantLock mainLock = this.mainLock;  </div><div class="line">        mainLock.lock();  </div><div class="line">        boolean reject = false;  </div><div class="line">        Thread t = null;  </div><div class="line">        try &#123;  </div><div class="line">            int state = runState;  </div><div class="line">            if (state != RUNNING &amp;&amp; workQueue.remove(command))  </div><div class="line">                reject = true;  </div><div class="line">            else if (state &lt; STOP &amp;&amp;  </div><div class="line">                     poolSize &lt; Math.max(corePoolSize, 1) &amp;&amp;  </div><div class="line">                     !workQueue.isEmpty())  </div><div class="line">                t = addThread(null);  </div><div class="line">        &#125; finally &#123;  </div><div class="line">            mainLock.unlock();  </div><div class="line">        &#125;  </div><div class="line">        if (reject)  </div><div class="line">            reject(command);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码是处理拒绝任务的。这里也会加锁来锁定当前的状态和工作队列。如果状态确实不等于running，则把任务从任务列表中移除并执行拒绝策略。如果任务remove失败，并且当前状态为running和shutdown状态，任务队列不为空，并且poolSize小于Math.max(corePoolSize, 1)。则调用addThread为线程池创建一个新线程。但是这个任务并没有直接给新线程执行。为什么要判断poolSize小于Math.max(corePoolSize, 1)，因为corePoolSize可以设置为0.当corePoolSize=0时，需要至少有1个线程去执行任务。前面的几个方法中出现了几次创建addThread的方法，现在来看看这个方法做了哪些事情：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">private Thread addThread(Runnable firstTask) &#123;  </div><div class="line">        Worker w = new Worker(firstTask);  </div><div class="line">        Thread t = threadFactory.newThread(w);  </div><div class="line">        boolean workerStarted = false;  </div><div class="line">        if (t != null) &#123;  </div><div class="line">            if (t.isAlive()) // precheck that t is startable  </div><div class="line">                throw new IllegalThreadStateException();  </div><div class="line">            w.thread = t;  </div><div class="line">            workers.add(w);  </div><div class="line">            int nt = ++poolSize;  </div><div class="line">            if (nt &gt; largestPoolSize)  </div><div class="line">                largestPoolSize = nt;  </div><div class="line">            try &#123;  </div><div class="line">                t.start();  </div><div class="line">                workerStarted = true;  </div><div class="line">            &#125;  </div><div class="line">            finally &#123;  </div><div class="line">                if (!workerStarted)  </div><div class="line">                    workers.remove(w);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        return t;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法的参数名firstTask可能比较难理解。这里详细说明一下：首先在线程池中，一个新线程的创建大多数情况都是为执行某个任务而创建的，这个任务不会加入任务队列，而是通过firstTask传给为他而建的新线程去执行。所以这个任务也就是这个线程执行的第一个任务。如果firstTask设为null，那么线程将去执行任务队列中的任务。下面来分析这个方法的功能，首先先创建一个worker对象，把firstTask初始化这个worker对象。然后通过线程工厂创建一个线程，并检查这个线程的状态，同时跟新线程池的峰值线程数的值。需要注意的是，这个线程不是属于某个具体任务的，而是属于这个worker的，即该线程不是执行某个任务的run，而是执行这个worker的run。最后把worker对象添加到worker队列里面。所以发到这里可以明白了ThreadPoolExecutor为什么没有thread的集合属性了。<br>5.第4点阐述了任务加入队列成功的情况，但是如果队列满了加入队列也可能失败。这时候会去尝试创建新线程来执行该任务。即执行addIfUnderMaximumPoolSize方法。这个方法与addIfUnderCorePoolSize基本一致，只是后者是拿poolSize跟corePoolSize比较，而前者是拿poolSize跟maximumPoolSize比较。如果addIfUnderMaximumPoolSize方法为任务创建线程失败，则执行拒绝策略来处理这个任务。<br>到目前为止，前面讲的5个步骤将了一个任务提交给线程池之后是如何处理的。但是细心的用户可能发现，里面缺失了非常重要的一个功能：任务被添加到任务队列之后是如何被线程池处理掉的？线程处理完它的首个任务之后是如何获取新任务的呢？线程池是不是有类似Timer一样的守护进程不断扫描线程队列和等待队列？还是利用某种锁机制，实现类似wait和notify实现的？ 别急。下面来揭开它的神秘面纱。<br>前面提到了ThreadPoolExecutor的内部类Worker，也在介绍addThread方法的时候提到了线程池的线程是和Worker对象绑定在一起的。所以现在来看看Worker类做了什么事情？通过代码发现Worker的定义也是一个Runnable。addthread方法中调用了这个Worker的start()方法，也就是线程的启动方法，其实也就是调用了Worker的run()方法。现在来看看worker的run方法做了什么事情：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public void run() &#123;  </div><div class="line">            try &#123;  </div><div class="line">                hasRun = true;  </div><div class="line">                Runnable task = firstTask;  </div><div class="line">                firstTask = null;  </div><div class="line">                while (task != null || (task = getTask()) != null) &#123;  </div><div class="line">                   runTask(task);  </div><div class="line">                   task = null;  </div><div class="line">               &#125;  </div><div class="line">            &#125; finally &#123;  </div><div class="line">                workerDone(this);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>woker的run方法主要是通过while循环不断调用getTask()方法去获取任务。然后执行runTask(task)方法来执行任务，最后调用workerDone()方法来执行一些清除操作。</p>
<p> runTask(task)其实做的事情很简单：它的核心就是调用任务的run方法来执行真正的用户任务，除此之外还执行了任务执行前后需要的一些操作，以及统计一下这个worker完成的任务数。这个方法不需要深究，代码也比较简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">private void runTask(Runnable task) &#123;  </div><div class="line">            final ReentrantLock runLock = this.runLock;  </div><div class="line">            runLock.lock();  </div><div class="line">            try &#123;  </div><div class="line">                if ((runState &gt;= STOP ||  </div><div class="line">                    (Thread.interrupted() &amp;&amp; runState &gt;= STOP)) &amp;&amp;  </div><div class="line">                    hasRun)  </div><div class="line">                    thread.interrupt();  </div><div class="line">                boolean ran = false;  </div><div class="line">                beforeExecute(thread, task);  </div><div class="line">                try &#123;  </div><div class="line">                    task.run();  </div><div class="line">                    ran = true;  </div><div class="line">                    afterExecute(task, null);  </div><div class="line">                    ++completedTasks;  </div><div class="line">                &#125; catch (RuntimeException ex) &#123;  </div><div class="line">                    if (!ran)  </div><div class="line">                        afterExecute(task, ex);  </div><div class="line">                    throw ex;  </div><div class="line">                &#125;  </div><div class="line">            &#125; finally &#123;  </div><div class="line">                runLock.unlock();  </div><div class="line">            &#125;  </div><div class="line"> &#125; </div><div class="line">``` </div><div class="line"> </div><div class="line"> worker的润方法真正的核心是如果不断获取任务的。所以这里必须认真解读下getTask()方法，下面是getTask()的代码：</div><div class="line"> </div><div class="line"> </div><div class="line">``` </div><div class="line">Runnable getTask() &#123;  </div><div class="line">        for (;;) &#123;  </div><div class="line">            try &#123;  </div><div class="line">                int state = runState;  </div><div class="line">                if (state &gt; SHUTDOWN)  </div><div class="line">                    return null;  </div><div class="line">                Runnable r;  </div><div class="line">                if (state == SHUTDOWN)  // Help drain queue  </div><div class="line">                    r = workQueue.poll();  </div><div class="line">                else if (poolSize &gt; corePoolSize || allowCoreThreadTimeOut)  </div><div class="line">                    r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);  </div><div class="line">                else  </div><div class="line">                    r = workQueue.take();  </div><div class="line">                if (r != null)  </div><div class="line">                    return r;  </div><div class="line">                if (workerCanExit()) &#123;  </div><div class="line">                    if (runState &gt;= SHUTDOWN) // Wake up others  </div><div class="line">                        interruptIdleWorkers();  </div><div class="line">                    return null;  </div><div class="line">                &#125;  </div><div class="line">                // Else retry  </div><div class="line">            &#125; catch (InterruptedException ie) &#123;  </div><div class="line">                // On interruption, re-check runState  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>你会发现getTask()方法是从workQueue队列中，也就是等待队列中获取一个任务出来并返回！如果没有获得任务，则通过 interruptIdleWorkers()方法去关闭空闲时间超过阈值的空闲线程。</p>
<p>至此，完整的ThreadPoolExecutor线程池处理任务的原理就解读完毕了。其他的一些诸如关闭线程池和获取线程池的状态和统计信息等的接口都比较简单，这里就不一一解释了。</p>
<h2 id="常见线程池"><a href="#常见线程池" class="headerlink" title="常见线程池"></a>常见线程池</h2><p><strong>1. newSingleThreadExecutor。</strong><br>只有一个线程的线程池，即corePoolSize和maximumPoolSize都等于1。<br><strong>2. newCachedThreadPool</strong><br>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。在newCachedThreadPool构造参数中，corePoolSize=0，maximumPoolSize=Integer.MAX_VALUE，即可与无限制的创建线程。但是它使用的是阻塞队列是SynchronousQueue。这个队列比较奇葩，虽然他是无界的，但是里面只能有一个元素。在添加一个任务的时候，必须要有一个线程正在等待一个任务。即通过这个阻塞队列，既可以保证任务能够马上得到线程去运行，同时又能重用已有的空闲线程。<br><strong>3. newFixedThreadPool</strong><br>线程数固定的线程池，即corePoolSize=maximumPoolSize。当线程数达到了corePoolSize时，不能创建新的线程了，所以新的任务只能放到任务队列中，因此这个线程池用的阻塞队列是无界队列LinkedBlockingQueue。<br><strong>4. ScheduledThreadPoolExecutor</strong><br>可以执行延迟固定时间的任务，也可以执行定时任务的线程池。ScheduledThreadPoolExecutor的底层不是基于ThreadPoolExecutor实现的，它有一个自己的实现类。</p>
<p>其实我们的要求很简单，希望线程池能跟连接池一样，能设置最小线程数、最大线程数，当最小数&lt;任务&lt;最大数时，应该分配新的线程处理；当任务&gt;最大数时，应该等待有空闲线程再处理该任务。<br>但线程池的设计思路是，任务应该放到Queue中，当Queue放不下时再考虑用新线程处理，如果Queue满且无法派生新线程，就拒绝该任务。设计导致“先放等执行”、“放不下再执行”、“拒绝不等待”。所以，根据不同的Queue参数，要提高吞吐量不能一味地增大maximumPoolSize。<br>当然，要达到我们的目标，必须对线程池进行一定的封装，幸运的是ThreadPoolExecutor中留了足够的自定义接口以帮助我们达到目标。我们封装的方式是：  </p>
<ol>
<li>以SynchronousQueue作为参数，使maximumPoolSize发挥作用，以防止线程被无限制的分配，同时可以通过提高maximumPoolSize来提高系统吞吐量  </li>
<li>自定义一个RejectedExecutionHandler，当线程数超过maximumPoolSize时进行处理，处理方式为隔一段时间检查线程池是否可以执行新Task，如果可以把拒绝的Task重新放入到线程池，检查的时间依赖keepAliveTime的大小。</li>
</ol>
<h2 id="线程池的两个核心队列"><a href="#线程池的两个核心队列" class="headerlink" title="线程池的两个核心队列"></a>线程池的两个核心队列</h2><ul>
<li>线程等待池，即线程队列BlockingQueue。 </li>
<li>任务处理池（PoolWorker），即正在工作的Thread列表（HashSet）。<br>线程池的核心参数： </li>
<li>核心池大小（corePoolSize），即固定大小，设定好之后，线程池的稳定峰值，达到这个值之后池的线程数大小不会释放。 </li>
<li>最大处理线程池数（maximumPoolSize），当线程池里面的线程数超过corePoolSize，小于maximumPoolSize时会动态创建与回收线程池里面的线程池资源。</li>
</ul>
<p>线程池的运行机制：</p>
<p>举个例子。假如有一个工厂，工厂里面有10个人，每个工人同时只能做一件事情。因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；当10个工人都有任务时，如果还来任务，就把任务进行排队等待。<br>如果说新任务数目增长的速度远远大于工作做任务的速度，那么此时工厂的主管可能就需要采取补救措施了，比如重新招4个工人进来；然后就将任务分配给这4个刚招进来的工人处理。<br>如果说这14个工人做任务的速度还是不够，此时工厂主管就要考虑不再接受新的任务或者抛弃前面的一些任务了。当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管就要考虑辞掉4个临时工了，只保持原来10个工人，比较额外的工人是需要花费的。<br>而这个例子中永远等待干活的10个工人机制就是workerQueue。这个栗子中的corePoolSize就是10，而maximumPoolSize就是14（10+4）。也就是说corePoolSize就是线程池的大小，maximumPoolSize在我看来就是一种线程池任务超过负荷的一种补救措施，即任务量突然过大时的一种补救措施。再看看下面图好好理解一下。工人永远在等待干活，就像workerQueue永远在循环干活一样，除非，整个线程池停止了。<br><img src="http://jet-han.oschina.io/img/并发编程之线程池ThreadPoolExecutor/thread1.png" alt="thread" title="thread"></p>
<p>线程池里面的线程的时序图如下图所示：<br><img src="http://jet-han.oschina.io/img/并发编程之线程池ThreadPoolExecutor/thread2.png" alt="thread" title="thread"></p>
<p>自定义线程池与ExecutorService<br>自定义线程池需要用到ThreadFactory，本节将通过创建一个线程的例子对ExecutorService及其参数进行详细讲解。<br><strong>1.认识ExecutorService家族 </strong><br>ExecutorService家族成员如下所示：<br><img src="http://jet-han.oschina.io/img/并发编程之线程池ThreadPoolExecutor/thread3.png" alt="thread" title="thread"></p>
<p>上图中主要元素说明如下：<br><strong>Executor：</strong>线程池的顶级接口，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。<br><strong>ExecutorService：</strong>真正线程池接口。这个接口继承了<code>Executor</code>接口，并声明了一些方法：<br><code>submit</code>、<code>invokeAll</code>、<code>invokeAny</code>以及<code>shutDown</code>等。<br><strong>ThreadPoolExecutor：</strong>ExecutorService的默认实现，继承了类AbstractExecutorService。<br><strong>ScheduledExecutorService：</strong>与Timer/TimerTask类似，解决那些需要任务重复执行的问题。<br><strong>ScheduledThreadPoolExecutor：</strong>继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。<br>Executors是个线程工厂类，方便我们快速地创建线程池。</p>
<p><strong>2.利用ThreadFactory创建一个线程</strong><br><code>Java.util.concurrent.ThreadFactory</code>提供了一个创建线程的工厂的接口。<br>ThreadFactory源码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface ThreadFactory&#123;</div><div class="line">  @override</div><div class="line">  public Thread newThread(Runnable r);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到上面的接口类中有一个<code>newThread()</code>的方法，为此我们自己手动定义一个线程工厂类，有木有激动啊，呵呵，下面我们就手动写一个自己的线程工厂类吧！  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class MyThreadFactory implements ThreadFactory&#123;</div><div class="line">  @Override</div><div class="line">  public Thread newThread(Runnable r)&#123;</div><div class="line">        return new Thread(r);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面已经创建好了我们自己的线程工厂类，但是啥都没有做，就是直接new了一个Thread就返回回去了，我们一般在创建线程的时候，都需要定义其线程的名字，因为我们在定义了线程的名字之后就能在出现问题的时候根据监视工具来查找错误的来源，所以我们来看下官方实现的<code>ThreadFactory</code>吧！<br>这个类在<code>java.util.concurrent.Executors</code>类中的静态类中<code>DefaultThreadFactory</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">*  The default thread factory</div><div class="line">*/static class DefaultThreadFactory implements ThreadFactory&#123;</div><div class="line">  private static final AtomicInteger poolNumber=new AtomicInteger(1);</div><div class="line">  private final ThreadGroup group;</div><div class="line">  private final AtomicInteger threadNumber=new AtomicInteger(1);</div><div class="line">  private final String namePrefix;</div><div class="line"></div><div class="line">  DefaultThreadFactory()&#123;</div><div class="line">    SecurityManager s=System.getSecurityManager();</div><div class="line">    group=(s!=null)?s.getThreadGroup():Thread.currentThread().getThreadGroup();</div><div class="line">    namePrefix=&quot;pool-&quot;+poolNumber.getAndIncrement()+&quot;-thread-&quot;;</div><div class="line">  &#125;</div><div class="line">  public Thread newThread(Runnable r)&#123;</div><div class="line">      Thread t=new Thread(group,r,namePrefix+threadNumber.getAndIncrement(),0);</div><div class="line">      if((t.isDaemon())</div><div class="line">          t.setDaemon(false);</div><div class="line">      if(t.getPriority()!=Thread.NORM_PRIORITY)</div><div class="line">          t.setPriority(Thread.NORM_PRIORITY);</div><div class="line">      return t;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>3.了解线程池的拒绝策略(RejectExecutionHandler)</strong><br>当调用<code>ThreadPoolExecuto</code>r的<code>execute</code>方法时，而此时线程池处于一个饱和的状态，并且任务队列也已经满了那么就需要做丢弃处理，<code>RejectExecutionHandler</code>就是这样的一个处理接口类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public interface RejectedExecutionHandler &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Method that may be invoked by a &#123;@link ThreadPoolExecutor&#125; when</div><div class="line">     * &#123;@link ThreadPoolExecutor#execute execute&#125; cannot accept a</div><div class="line">     * task.  This may occur when no more threads or queue slots are</div><div class="line">     * available because their bounds would be exceeded, or upon</div><div class="line">     * shutdown of the Executor.</div><div class="line">     *</div><div class="line">     * &lt;p&gt;In the absence of other alternatives, the method may throw</div><div class="line">     * an unchecked &#123;@link RejectedExecutionException&#125;, which will be</div><div class="line">     * propagated to the caller of &#123;@code execute&#125;.</div><div class="line">     *</div><div class="line">     * @param r the runnable task requested to be executed</div><div class="line">     * @param executor the executor attempting to execute this task</div><div class="line">     * @throws RejectedExecutionException if there is no remedy</div><div class="line">     */</div><div class="line">    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在JDK里面有4种拒绝策略，如下图所示：<br><img src="http://jet-han.oschina.io/img/并发编程之线程池ThreadPoolExecutor/thread4.png" alt="thread" title="thread"></p>
<ol>
<li><strong>AbortPolicy：</strong>一言不合就抛异常（默认使用策略）。</li>
<li><strong>CallerRunsPolicy：</strong>只用调用者所在线程来运行任务。</li>
<li><strong>DiscardOldestPolicy：</strong>丢弃队列里最近的一个任务，并执行当前任务。</li>
<li><strong>DiscardPolicy：</strong>不处理，直接丢弃。</li>
</ol>
<p>来看下源码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">AbortPolicy : 一言不合就抛异常的</div><div class="line">   /**</div><div class="line">     * A handler for rejected tasks that throws a</div><div class="line">     * &#123;@code RejectedExecutionException&#125;.</div><div class="line">     */</div><div class="line">    public static class AbortPolicy implements RejectedExecutionHandler &#123;</div><div class="line">        /**</div><div class="line">         * Creates an &#123;@code AbortPolicy&#125;.</div><div class="line">         */</div><div class="line">        public AbortPolicy() &#123; &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * Always throws RejectedExecutionException.</div><div class="line">         *</div><div class="line">         * @param r the runnable task requested to be executed</div><div class="line">         * @param e the executor attempting to execute this task</div><div class="line">         * @throws RejectedExecutionException always.</div><div class="line">         */</div><div class="line">        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</div><div class="line">            throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +</div><div class="line">                                                 &quot; rejected from &quot; +</div><div class="line">                                                 e.toString());</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>CallerRunsPolicy：调用者所在线程来运行任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * A handler for rejected tasks that runs the rejected task</div><div class="line"> * directly in the calling thread of the &#123;@code execute&#125; method,</div><div class="line"> * unless the executor has been shut down, in which case the task</div><div class="line"> * is discarded.</div><div class="line"> */</div><div class="line">public static class CallerRunsPolicy implements RejectedExecutionHandler &#123;</div><div class="line">    /**</div><div class="line">     * Creates a &#123;@code CallerRunsPolicy&#125;.</div><div class="line">     */</div><div class="line">    public CallerRunsPolicy() &#123; &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Executes task r in the caller&apos;s thread, unless the executor</div><div class="line">     * has been shut down, in which case the task is discarded.</div><div class="line">     *</div><div class="line">     * @param r the runnable task requested to be executed</div><div class="line">     * @param e the executor attempting to execute this task</div><div class="line">     */</div><div class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</div><div class="line">        if (!e.isShutdown()) &#123;</div><div class="line">            r.run();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DiscardOldestPolicy :丢弃队列里面最近的一个任务,并执行当前任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * A handler for rejected tasks that discards the oldest unhandled</div><div class="line"> * request and then retries &#123;@code execute&#125;, unless the executor</div><div class="line"> * is shut down, in which case the task is discarded.</div><div class="line"> */</div><div class="line">public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123;</div><div class="line">    /**</div><div class="line">     * Creates a &#123;@code DiscardOldestPolicy&#125; for the given executor.</div><div class="line">     */</div><div class="line">    public DiscardOldestPolicy() &#123; &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Obtains and ignores the next task that the executor</div><div class="line">     * would otherwise execute, if one is immediately available,</div><div class="line">     * and then retries execution of task r, unless the executor</div><div class="line">     * is shut down, in which case task r is instead discarded.</div><div class="line">     *</div><div class="line">     * @param r the runnable task requested to be executed</div><div class="line">     * @param e the executor attempting to execute this task</div><div class="line">     */</div><div class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</div><div class="line">        if (!e.isShutdown()) &#123;</div><div class="line">            e.getQueue().poll();</div><div class="line">            e.execute(r);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DiscardPolicy : 不处理，直接丢弃</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * A handler for rejected tasks that silently discards the</div><div class="line">     * rejected task.</div><div class="line">     */</div><div class="line">    public static class DiscardPolicy implements RejectedExecutionHandler &#123;</div><div class="line">        /**</div><div class="line">         * Creates a &#123;@code DiscardPolicy&#125;.</div><div class="line">         */</div><div class="line">        public DiscardPolicy() &#123; &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * Does nothing, which has the effect of discarding task r.</div><div class="line">         *</div><div class="line">         * @param r the runnable task requested to be executed</div><div class="line">         * @param e the executor attempting to execute this task</div><div class="line">         */</div><div class="line">        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>思考问题：<br>为什么有任务拒绝的情况发生呢：<br>这里先假设有一个前提：线程池里面有一个任务队列，用于缓存所有待处理的任务，正在处理的任务将从任务队列中移除。因此，在任务队列长度有限的情况下，就会出现现任务的拒绝情况，需要一种策略来处理发生这种已满无法加入的情况。另外，在线程池关闭的时候，也需要对任务加入队列操作进行额外的协调处理。  </p>
<p><strong>4.ThreadPoolExecutor详解</strong></p>
<p><code>ThreadPoolExecutor</code>类是线程池中最核心的一个类，因此如果要想透彻的了解Java线程池，必须先了解这个大BOSS，下面来看下其源码：</p>
<p>4种构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,TimeUnit unit,</div><div class="line">                      BlockingQueue&lt;Runnable&gt; workQueue) &#123;</div><div class="line">    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,Executors.defaultThreadFactory(), defaultHandler);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,long keepAliveTime,TimeUnit unit,</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory) &#123;</div><div class="line">    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,threadFactory, defaultHandler);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,long keepAliveTime,TimeUnit unit,</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123;</div><div class="line">    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,</div><div class="line">                         BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory,RejectedExecutionHandler handler) &#123;</div><div class="line">    if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0)</div><div class="line">        throw new IllegalArgumentException();</div><div class="line">    if (workQueue == null || threadFactory == null || handler == null)</div><div class="line">        throw new NullPointerException();</div><div class="line">    this.corePoolSize = corePoolSize;</div><div class="line">    this.maximumPoolSize = maximumPoolSize;</div><div class="line">    this.workQueue = workQueue;</div><div class="line">    this.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class="line">    this.threadFactory = threadFactory;</div><div class="line">    this.handler = handler;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过源码我们清楚的看到，最终构造函数调用了最后一个构造函数，后面的那个构造函数才是真正的构造函数，接下来研究一下参数。</p>
<ul>
<li>int corePoolSize：核心池大小，这个参数跟后面讲的线程池原理有很大的关系。在创建了线程池之后，默认情况下，线程池中并没有任何线程，而是等待所有的任务到来之时才进行创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法 ，从这个两个方法的名字可以知道是预创建线程的意思，即在没有任务来临之前先创建好corePoolSize个线程或者一个线程。默认情况下，在创建好线程池之后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数量达到corePoolSize后，就会把达到的任务放到缓存队列中去。 </li>
<li>int maximumPoolSize：线程池最大线程数量，这是个非常重要的参数，它表示在线程池中最多能创建线程的数量；在corePoolSize和maximumPoolSize的线程数会被自动释放，而小于corePoolSize的则不会。 </li>
<li>long keepAliveTime：表示线程没有执行任务时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会生效,直到线程池数量不大于corePoolSize，即只有当线程池数量大于corePoolSize数量，超出这个数量的线程一旦到达keepAliveTime就会终止。但是如果调用了allowCoreThreadTimeout(boolean)方法，即使线程池的线程数量不大于corePoolSize，线程也会在keepAliveTime之后就终止，知道线程池的数量为0为止。 </li>
<li>TimeUnit unit：参数keepAliveTime的时间单位，一个时间单位枚举类。 </li>
<li>BlockingQueue workQueue：一个阻塞队列，用来存储等待执行任务的队列，这个参数选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列就是（ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue；）。 </li>
<li>ThreadFactory ThreadFactory：线程工厂，主要用来创建线程；可以是一个自定义的线程工厂，默认就是Executors.defaultThreadFactory()。用来在线程池中创建线程。 </li>
<li>RejectedExecutionHandler handler：表示当拒绝处理任务时的策略，也是可以自定义的，默认是我们前面的4种取值： </li>
</ul>
<ul>
<li>ThreadPoolExecutor.AbortPolicy（默认的，一言不合即抛异常的） </li>
<li>ThreadPoolExecutor.DiscardPolicy（一言不合就丢弃任务） </li>
<li>ThreadPoolExecutor.DiscardOldestPolicy（一言不合就把最近的任务给抛弃，然后执行当前任务） </li>
<li>ThreadPoolExecutor.CallerRunsPolicy（由调用者所在线程来执行任务）<br>所以想自定义线程池就可以从上面的几个参数入手。接下来具体看下代码,了解一下实现原理：<br> // 默认异常处理机制<br> private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();<br> //任务缓存队列，用来存放等待执行的任务<br> private final BlockingQueue<runnable> workQueue;<br> //线程池的主要状态锁，对线程状态（比如线程大小、runState等）的改变都需要这个锁<br> private final ReentrantLock mainLock = new ReentrantLock();<br> //用来存放工作集<br> private final HashSet<worker> workers = new HashSet<worker>();<br> //volatile 可变变量关键字，写的时候用mainLock做锁，读的时候无锁，高性能<br> private volatile long keepAliveTime;<br> //是否允许核心线程超时<br> private volatile boolean allowCoreThreadTimeOut;<br> //核心线程数量<br> private volatile int corePoolSize;<br> //线程最大线程数量<br> private volatile int maximumPoolSize;<br> //任务拒绝策略<br> private volatile RejectedExcutionHandler handler;<br>结合之前的知识，大概就能猜出里面是怎么实现的了，具体可以参考一下JDK的源代码，这样我们就能做到了解原理又会用了。</worker></worker></runnable></li>
</ul>
<p><strong>5.自定义实现一个简单的Web请求连接池</strong><br>我们来自定义一个简单的Web请求线程池。模仿Web服务的需求场景说明如下：  </p>
<ul>
<li>服务器可容纳的最小请求数是多少。   </li>
<li>可以动态扩充的请求数大小是多少。   </li>
<li>多久回收多余线程数即请求数。   </li>
<li>用户访问量打了怎么处理。   </li>
<li>线程队列机制采取有优先级的排队的执行机制。<br>根据上面的场景，看下这个线程池如何编写？ </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class MyExecutors extends Executors&#123;</div><div class="line">    //利用默认线程工厂和PriorityBlockingQueue队列机制，当然了，我们还可以自定义ThreadFactory和继承queue进行自定义扩展</div><div class="line">   public static ExecutorService newMyWebThreadPool(int minSpareThreads,int maxThreads,int maxIdleTime)&#123;</div><div class="line">    return new ThreadPoolExecutor(minSpareThread,maxThreads,maxIdleTime,TimeUnit.MILLISECONDS，</div><div class="line">          new PriorityBlockingQueue&lt;Runnable&gt;());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>6.线程池在工作中的错误使用</strong><br>(1)分不清楚线程是单例还是多对象。<br>(2)线程池数量设置很大。<br>(3)注意死锁问题  </p>
<p><strong>连接池（org.apache.commons.dbcp.BasicDataSource）</strong><br>在使用org.apache.commons.dbcp.BasicDataSource的时候，因为之前采用了默认配置，所以当访问量大时，通过JMX观察到很多Tomcat线程都阻塞在BasicDataSource使用的Apache ObjectPool的锁上，直接原因当时是因为BasicDataSource连接池的最大连接数设置的太小，默认的BasicDataSource配置，仅使用8个最大连接。<br>我还观察到一个问题，当较长的时间不访问系统，比如2天，DB上的Mysql会断掉所以的连接，导致连接池中缓存的连接不能用。为了解决这些问题，我们充分研究了BasicDataSource，发现了一些优化的点：    </p>
<ul>
<li>Mysql默认支持100个链接，所以每个连接池的配置要根据集群中的机器数进行，如有2台服务器，可每个设置为60  </li>
<li>initialSize：参数是一直打开的连接数  </li>
<li>minEvictableIdleTimeMillis：该参数设置每个连接的空闲时间，超过这个时间连接将被关闭  </li>
<li>timeBetweenEvictionRunsMillis：后台线程的运行周期，用来检测过期连接  </li>
<li>maxActive：最大能分配的连接数  </li>
<li>maxIdle：最大空闲数，当连接使用完毕后发现连接数大于maxIdle，连接将被直接关闭。只有initialSize &lt; x &lt; maxIdle的连接将被定期检测是否超期。这个参数主要用来在峰值访问时提高吞吐量。  </li>
<li>initialSize是如何保持的？经过研究代码发现，BasicDataSource会关闭所有超期的连接，然后再打开initialSize数量的连接，这个特性与minEvictableIdleTimeMillis、timeBetweenEvictionRunsMillis一起保证了所有超期的initialSize连接都会被重新连接，从而避免了Mysql长时间无动作会断掉连接的问题。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;ThreadPoolExecutor&quot;&gt;&lt;a href=&quot;#ThreadPoolExecutor&quot; class=&quot;headerlink&quot; title=&quot;ThreadPoolExecutor&quot;&gt;&lt;/a&gt;ThreadPoolExecutor&lt;/h2&gt;&lt;p&gt;当前越来越多的系统使用多线程来处理任务，但是为每一个任务创建线程并不是合理的方案，原因有2点：一是创建线程的开销很大，一个任务一个线程的方式会有性能上的损失；二是可能导致线程数量的膨胀，不但不易于线程的管理，还可能导致内存被消耗完，导致out of memory（OOM）,从而使系统崩溃。为了解决这个问题，线程池应运而生。线程池有两个作用：一个是限制线程的数量，不会导致线程的膨胀；二是线程复用，线程执行完一个人任务之后，可以接着执行下一个任务，减少了创建线程的开销。 &lt;/p&gt;
&lt;p&gt;java中一个运用非常普遍的线程池是ThreadPoolExecutor。下面来探究下ThreadPoolExecutor的功能和实现原理。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://jet-han.oschina.io/categories/java/"/>
    
    
      <category term="java" scheme="http://jet-han.oschina.io/tags/java/"/>
    
      <category term="thread pool" scheme="http://jet-han.oschina.io/tags/thread-pool/"/>
    
  </entry>
  
  <entry>
    <title>线程的实现方式</title>
    <link href="http://jet-han.oschina.io/2017/08/05/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>http://jet-han.oschina.io/2017/08/05/线程的实现方式/</id>
    <published>2017-08-05T08:32:32.000Z</published>
    <updated>2017-08-13T01:45:26.098Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/java.jpg" alt="java" title="java"></p>
<h2 id="线程实现方式"><a href="#线程实现方式" class="headerlink" title="线程实现方式"></a>线程实现方式</h2><ol>
<li>继承java.lang.Thread类  </li>
<li>实现java.lang.Runnable接口</li>
</ol>
<p><strong>区别：</strong>第一种是继承，第二种是实现<br><strong>好处：</strong>  在实际开发中通常以实现Runnable接口为主，因为实现Runnable接口相比继承Thread类可以避免继承的局限，一个类可以继承多个接口，适合于资源的共享<br><a id="more"></a><br>示例1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">1.class ThreadTest extends Thread&#123;  </div><div class="line">2.  public void run()&#123; </div><div class="line">3.     private int tickets = 100;  </div><div class="line">4.    while(true)&#123;  </div><div class="line">5.      if(ticket &gt; 0)&#123;  </div><div class="line">6.        System.out.println(Thread.currentThread().getName() +  </div><div class="line">7.          &quot;is saling ticket&quot; + ticket--);  </div><div class="line">8.      &#125;else&#123;  </div><div class="line">9.        break;  </div><div class="line">10.      &#125;  </div><div class="line">11.    &#125;  </div><div class="line">12.  &#125;  </div><div class="line">13.&#125;  </div><div class="line"></div><div class="line">#main测试类: </div><div class="line">1.public class ThreadDome1&#123;  </div><div class="line">2.  public static void main(String[] args)&#123;  </div><div class="line">3.    ThreadTest t = new ThreadTest();  </div><div class="line">4.    t.start();  </div><div class="line">5.    t.start();  </div><div class="line">6.    t.start();  </div><div class="line">7.    t.start();  </div><div class="line">8.  &#125;  </div><div class="line">9.&#125;</div></pre></td></tr></table></figure></p>
<p>【说明】一个线程对象只能启动一个线程，无论你调用多少遍start()方法，结果只有一个线程。</p>
<p>示例2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">1.public class ThreadDemo1&#123;  </div><div class="line">2.  public static void main(String[] args)&#123;  </div><div class="line">3.    new ThreadTest().start();  </div><div class="line">4.    new ThreadTest().start();  </div><div class="line">5.    new ThreadTest().start();  </div><div class="line">6.    new ThreadTest().start();  </div><div class="line">7.  &#125;  </div><div class="line">8.&#125;  </div><div class="line"></div><div class="line">1.class ThreadTest extends Thread&#123;  </div><div class="line">2.  public void run()&#123; </div><div class="line">3.     private int tickets = 100;  </div><div class="line">4.    while(true)&#123;  </div><div class="line">5.      if(ticket &gt; 0)&#123;  </div><div class="line">6.        System.out.println(Thread.currentThread().getName() +   </div><div class="line">7.           &quot; is saling ticket&quot; + ticket--);  </div><div class="line">8.      &#125;else&#123;  </div><div class="line">9.        break;  </div><div class="line">10.      &#125;  </div><div class="line">11.    &#125;  </div><div class="line">12.  &#125;  </div><div class="line">13.&#125;</div></pre></td></tr></table></figure></p>
<p>【说明】创建了四个ThreadTest对象，就等于创建了四个资源，每个资源都有100张票，每个线程都在独自处理各自的资源。</p>
<p>示例4：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">1.public class ThreadDemo1&#123;  </div><div class="line">2.  public static void main(String[] args)&#123;  </div><div class="line">3.    ThreadTest t = new ThreadTest();  </div><div class="line">4.    new Thread(t).start();  </div><div class="line">5.    new Thread(t).start();  </div><div class="line">6.    new Thread(t).start();  </div><div class="line">7.    new Thread(t).start();  </div><div class="line">8.  &#125;  </div><div class="line">9.&#125;  </div><div class="line"></div><div class="line">1.class ThreadTest implements Runnable&#123;   </div><div class="line">2.  public void run()&#123; </div><div class="line">3.     private int tickets = 100; //局部变量，如果是成员变量，则所有线程则共享它，会出现问题 </div><div class="line">4.    while(true)&#123;  </div><div class="line">5.      if(tickets &gt; 0)&#123;  </div><div class="line">6.        System.out.println(Thread.currentThread().getName() +  </div><div class="line">7.          &quot; is saling ticket &quot; + tickets--);  </div><div class="line">8.      &#125;  </div><div class="line">9.    &#125;  </div><div class="line">10.  &#125;  </div><div class="line">11.&#125;</div></pre></td></tr></table></figure>
<p>【注意】创建了四个线程，每个线程调用的是同一个ThreadTest对象中的run()方法，访问的是同一个对象中的变量（tickets）的实例<br>　如果一个变量是成员变量，那么多个线程对同一个对象的成员变量进行操作时，它们对该成员变量是彼此影响的，也就是说一个线程对成员变量的改变会影响到另一个线程。<br>　如果一个变量是局部变量，那么每个线程都会有一个该局部变量的拷贝（即便是同一个对象中的方法的局部变量，也会对每一个线程有一个拷贝），一个线程对该局部变量的改变不会影响到其他线程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;线程实现方式&quot;&gt;&lt;a href=&quot;#线程实现方式&quot; class=&quot;headerlink&quot; title=&quot;线程实现方式&quot;&gt;&lt;/a&gt;线程实现方式&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;继承java.lang.Thread类  &lt;/li&gt;
&lt;li&gt;实现java.lang.Runnable接口&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;区别：&lt;/strong&gt;第一种是继承，第二种是实现&lt;br&gt;&lt;strong&gt;好处：&lt;/strong&gt;  在实际开发中通常以实现Runnable接口为主，因为实现Runnable接口相比继承Thread类可以避免继承的局限，一个类可以继承多个接口，适合于资源的共享&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://jet-han.oschina.io/categories/java/"/>
    
    
      <category term="java" scheme="http://jet-han.oschina.io/tags/java/"/>
    
      <category term="thread" scheme="http://jet-han.oschina.io/tags/thread/"/>
    
      <category term="runnable" scheme="http://jet-han.oschina.io/tags/runnable/"/>
    
  </entry>
  
  <entry>
    <title>jvm调优</title>
    <link href="http://jet-han.oschina.io/2017/08/05/jvm%E8%B0%83%E4%BC%98/"/>
    <id>http://jet-han.oschina.io/2017/08/05/jvm调优/</id>
    <published>2017-08-05T08:05:44.000Z</published>
    <updated>2017-09-05T02:34:05.902Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/java.jpg" alt="java" title="java"></p>
<h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p>1.根据Java虚拟机规范，JVM将内存划分为：<br><strong>New（年轻代）<br>Tenured（年老代）<br>永久代（Perm）</strong><br><a id="more"></a><br><img src="http://jet-han.oschina.io/img/jvm内存模型/jvm2.gif" alt="jvm" title="jvm"><br>  其中New和Tenured属于堆内存，堆内存会从JVM启动参数（-Xmx:3G）指定的内存中分配，Perm不属于堆内存，有虚拟机直接分配，但可以通过-XX:PermSize -XX:MaxPermSize 等参数调整其大小。<br><img src="http://jet-han.oschina.io/img/jvm内存模型/jvm4.jpg" alt="jvm" title="jvm"></p>
<p><strong>年轻代（New）：</strong>年轻代用来存放JVM刚分配的Java对象<br><strong>年老代（Tenured)：</strong>年轻代中经过垃圾回收没有回收掉的对象将被Copy到年老代<br><strong>永久代（Perm）：</strong>永久代存放Class、Method元信息，其大小跟项目的规模、类、方法的量有关，一般设置为128M就足够，设置原则是预留30%的空间。</p>
<p>New又分为几个部分：<br><strong>Eden：</strong>Eden用来存放JVM刚分配的对象<br><strong>Survivor1</strong><br><strong>Survivro2：</strong>两个Survivor空间一样大，当Eden中的对象经过垃圾回收没有被回收掉时，会在两个Survivor之间来回Copy，当满足某个条件，比如Copy次数，就会被Copy到Tenured。显然，Survivor只是增加了对象在年轻代中的逗留时间，增加了被垃圾回收的可能性。</p>
<p><strong>各代如何设置比例</strong><br><strong>堆大小设置</strong><br>JVM 中最大堆大小有三方面限制：相关操作系统的数据模型（32-bt还是64-bit）限制；系统的可用虚拟内存限制；系统的可用物理内存限制。32位系统下，一般限制在1.5G~2G；64为操作系统对内存无限制。我在Windows Server 2003 系统，3.5G物理内存，JDK5.0下测试，最大可设置为1478m。<br><strong>典型设置：</strong><br>- java -Xmx3550m -Xms3550m -Xmn2g -Xss128k<br>- -Xmx3550m：设置JVM最大可用内存为3550M。<br>- -Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。<br>- -Xmn2g：设置年轻代大小为2G。整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。<br>- -Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。<br>- java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0<br>- -XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5<br>- -XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6<br>- -XX:MaxPermSize=16m:设置持久代大小为16m。<br>- -XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。 </p>
<p>如果程序确实需要大量的线程，现有的设置不能达到要求，那么可以通过修改MaxProcessMemory，JVMMemory，ThreadStackSize这三个因素，来增加能创建的线程数：<br>a. MaxProcessMemory 使用64位JVM<br>    经测试在，64位jvm下生成的线程数不受上述公式的制约，值为63260，这个数值应该足够用了，<br>    测试数据如下, (指令|能启动的线程数量)</p>
<p>java -Xms512M -Xmx2G -cp . TestNativeOutOfMemoryError  | 63389<br>java -Xms512M -Xmx8G -cp . TestNativeOutOfMemoryError  | 63260<br>java -Xms512M -Xmx16G -cp . TestNativeOutOfMemoryError  | 63385<br>java -Xms512M -Xmx32G -cp . TestNativeOutOfMemoryError  | 63380<br>java -Xms512M -Xmx64G -cp . TestNativeOutOfMemoryError  |63387</p>
<p>b. JVMMemory   减少JVMMemory的分配(即减少xms/xmx的大小)<br>c. ThreadStackSize  减小单个线程的栈大小 (-Xss)</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>垃圾回收算法可以分为三类，都基于标记-清除（复制）算法：<br><strong>Serial算法（单线程）<br>并行算法<br>并发算法</strong><br>JVM会根据机器的硬件配置对每个内存代选择适合的回收算法，比如，如果机器多于1个核，会对年轻代选择并行算法，关于选择细节请参考JVM调优文档。 </p>
<p>稍微解释下的是，并行算法是用多线程进行垃圾回收，回收期间会暂停程序的执行，而并发算法，也是多线程回收，但期间不停止应用执行。所以，并发算法适用于交互性高的一些程序。经过观察，并发算法会减少年轻代的大小，其实就是使用了一个大的年老代，这反过来跟并行算法相比吞吐量相对较低。  </p>
<p><strong>还有一个问题是，垃圾回收动作何时执行？</strong></p>
<ul>
<li>当年轻代内存满时，会引发一次普通GC，该GC仅回收年轻代。需要强调的时，年轻代满是指Eden代满，Survivor满不会引发GC</li>
<li>当年老代满时会引发Full GC，Full GC将会同时回收年轻代、年老代</li>
<li>当永久代满时也会引发Full GC，会导致Class、Method元信息的卸载<br>另一个问题是，何时会抛出OutOfMemoryException，并不是内存被耗空的时候才抛出</li>
<li>JVM98%的时间都花费在内存回收</li>
<li>每次回收的内存小于2%<br>满足这两个条件将触发OutOfMemoryException，这将会留给系统一个微小的间隙以做一些Down之前的操作，比如手动打印Heap Dump。</li>
</ul>
<h2 id="内存泄漏及解决方法"><a href="#内存泄漏及解决方法" class="headerlink" title="内存泄漏及解决方法"></a>内存泄漏及解决方法</h2><p><img src="http://jet-han.oschina.io/img/jvm内存模型/jvm.jpeg" alt="jvm" title="jvm"><br><img src="http://jet-han.oschina.io/img/jvm内存模型/jvm内存溢出.png" alt="jvm" title="jvm"><br>1.系统崩溃前的一些现象：</p>
<ul>
<li>每次垃圾回收的时间越来越长，由之前的10ms延长到50ms左右，FullGC的时间也有之前的0.5s延长到4、5s</li>
<li>FullGC的次数越来越多，最频繁时隔不到1分钟就进行一次FullGC</li>
<li>年老代的内存越来越大并且每次FullGC后年老代没有内存被释放<br>之后系统会无法响应新的请求，逐渐到达OutOfMemoryError的临界值。</li>
</ul>
<p>2.生成堆的dump文件<br> 通过JMX的MBean生成当前的Heap信息，大小为一个3G（整个堆的大小）的hprof文件，如果没有启动JMX可以通过Java的jmap命令来生成该文件。<br> <img src="http://jet-han.oschina.io/img/jvm内存模型/jmap.png" alt="jvm" title="jvm"></p>
<p>3.分析dump文件<br> 下面要考虑的是如何打开这个3G的堆信息文件，显然一般的Window系统没有这么大的内存，必须借助高配置的Linux。当然我们可以借助X-Window把Linux上的图形导入到Window。我们考虑用下面几种工具打开该文件：</p>
<ul>
<li>Visual VM  </li>
<li>IBM HeapAnalyzer  </li>
<li>JDK 自带的Hprof工具  </li>
</ul>
<p>使用这些工具时为了确保加载速度，建议设置最大内存为6G。使用后发现，这些工具都无法直观地观察到内存泄漏，Visual VM虽能观察到对象大小，但看不到调用堆栈；HeapAnalyzer虽然能看到调用堆栈，却无法正确打开一个3G的文件。因此，我们又选用了Eclipse专门的静态内存分析工具：Mat。</p>
<p>4.分析内存泄漏<br> 通过Mat我们能清楚地看到，哪些对象被怀疑为内存泄漏，哪些对象占的空间最大及对象的调用关系。针对本案，在ThreadLocal中有很多的JbpmContext实例，经过调查是JBPM的Context没有关闭所致。<br> 另，通过Mat或JMX我们还可以分析线程状态，可以观察到线程被阻塞在哪个对象上，从而判断系统的瓶颈。  </p>
<p>5.回归问题<br>   Q：<strong>为什么崩溃前垃圾回收的时间越来越长？</strong><br>   A:根据内存模型和垃圾回收算法，垃圾回收分两部分：内存标记、清除（复制），标记部分只要内存大小固定时间是不变的，变的是复制部分，因为每次垃圾回收都有一些回收不掉的内存，所以增加了复制量，导致时间延长。所以，垃圾回收的时间也可以作为判断内存泄漏的依据<br>   Q：<strong>为什么Full GC的次数越来越多？</strong><br>   A：因此内存的积累，逐渐耗尽了年老代的内存，导致新对象分配没有更多的空间，从而导致频繁的垃圾回收<br>   Q:<strong>为什么年老代占用的内存越来越大？</strong><br>   A:因为年轻代的内存无法被回收，越来越多地被Copy到年老代  </p>
<h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><p> 除了上述内存泄漏外，我们还发现CPU长期不足3%，系统吞吐量不够，针对8core×16G、64bit的Linux服务器来说，是严重的资源浪费。<br> 在CPU负载不足的同时，偶尔会有用户反映请求的时间过长，我们意识到必须对程序及JVM进行调优。从以下几个方面进行：  </p>
<ul>
<li>线程池：解决用户响应时间长的问题  </li>
<li>连接池  </li>
<li>JVM启动参数：调整各代的内存比例和垃圾回收算法，提高吞吐量  </li>
<li>程序算法：改进程序逻辑算法提高性能</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;JVM内存模型&quot;&gt;&lt;a href=&quot;#JVM内存模型&quot; class=&quot;headerlink&quot; title=&quot;JVM内存模型&quot;&gt;&lt;/a&gt;JVM内存模型&lt;/h2&gt;&lt;p&gt;1.根据Java虚拟机规范，JVM将内存划分为：&lt;br&gt;&lt;strong&gt;New（年轻代）&lt;br&gt;Tenured（年老代）&lt;br&gt;永久代（Perm）&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://jet-han.oschina.io/categories/java/"/>
    
    
      <category term="java" scheme="http://jet-han.oschina.io/tags/java/"/>
    
      <category term="jvm" scheme="http://jet-han.oschina.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>web.xml加载顺序</title>
    <link href="http://jet-han.oschina.io/2017/08/05/web-xml%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/"/>
    <id>http://jet-han.oschina.io/2017/08/05/web-xml加载顺序/</id>
    <published>2017-08-05T06:42:06.000Z</published>
    <updated>2017-08-13T01:45:26.093Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/java.jpg" alt="java" title="java"></p>
<p><strong>web.xml 的加载顺序:</strong><br>ServletContext-&gt; context-param -&gt;listener -&gt; filter -&gt; servlet，而同个类型之间的实际程序调用的时候的顺序是根据对应的 mapping 的顺序进行调用的。ServletContext即Servlet上下文对象，该对象表示当前的web应用环境信息，一个Web应用只会创建一个ServletContext对象。</p>
<p>Web容器启动的时候，它会为每个Web应用程序都创建一个对应的ServletContext对象，它代表当前的web应用。<br>[注意]由于一个Web应用中的所有Servlet共享一个ServletContext对象，所以多个Servlet通过ServletContext对象实现数据共享，ServletContext对象通常称为Context域对象。<br><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;web.xml 的加载顺序:&lt;/strong&gt;&lt;br&gt;ServletContext-&amp;gt; context-param -&amp;gt;listener -&amp;gt; filter -&amp;gt; servlet，而同个类型之间的实际程序调用的时候的顺序是根据对应的 mapping 的顺序进行调用的。ServletContext即Servlet上下文对象，该对象表示当前的web应用环境信息，一个Web应用只会创建一个ServletContext对象。&lt;/p&gt;
&lt;p&gt;Web容器启动的时候，它会为每个Web应用程序都创建一个对应的ServletContext对象，它代表当前的web应用。&lt;br&gt;[注意]由于一个Web应用中的所有Servlet共享一个ServletContext对象，所以多个Servlet通过ServletContext对象实现数据共享，ServletContext对象通常称为Context域对象。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://jet-han.oschina.io/categories/java/"/>
    
    
      <category term="java" scheme="http://jet-han.oschina.io/tags/java/"/>
    
      <category term="web" scheme="http://jet-han.oschina.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>sping之IOC，AOP</title>
    <link href="http://jet-han.oschina.io/2017/08/05/sping%E4%B9%8BIOC%EF%BC%8CAOP/"/>
    <id>http://jet-han.oschina.io/2017/08/05/sping之IOC，AOP/</id>
    <published>2017-08-05T06:34:04.000Z</published>
    <updated>2017-08-13T01:45:26.091Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/spring.jpg" alt="spring" title="spring"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Spring AOP和IOC个人理解<br><strong>IOC inversion of control 控制反转</strong><br>将new对象的权力由调用者转移到spring容器（即xml文件），Struts2与Spring整合（scope=”prototype”）由spring来维护struts的生命周期，在启动web容器时spring容器创建action实例对象，又分两种方式：<br>第一种xml方式 需要set方法为被调用的属性赋值，xml中需要<code>ref</code>注入被调要的对象。<br>第二种注解方式 不需要set方法为被调用属性赋值，但需要在action层service层dao层的类上对应写上<br><code>@Controller,@Service,@Repository</code>通过在属性上加上<code>@Resource(name=&quot;&quot;)</code>来为属性赋值，这一步相当于xml方式的<code>ref</code>。<br>事务管理器<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;txManager&quot;class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt; </div><div class="line">&lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;&gt;&lt;/property&gt;  </div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>相当于切面需要注入<code>sessionFactory</code></p>
<p><strong>AOP Aspect Oriented Programming 面向切面编程</strong><br>通过代理的方式在需要的时候通过切入点给指定位置的程序添加逻辑代码或功能。声明事务处理分为两种方式：<br><strong>第一种xml方式:</strong> 需要在xml中配置事务的通知<code>&lt;tx:advice&gt;</code>里面放增删改查等方法的<code>isolation=&quot;DEFAULT&quot;        propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot;&lt;/tx:advice&gt;）</code><br>用切面关联通知，然后再用通知关联切入点<code>&lt;aop:config&gt;</code>（即事务操作业务层）切入地点是所有service 包及其子包下类的所有方法。<br><strong>第二种注解方式:</strong> 使用注解的方式配置声明式事务处理，在Service层类中，<code>@Transcational</code>(事务处理的)     <code>&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;</code><br>不需要关联通知也不需要通知关联切入点</p>
<h2 id="spring的基本框架主要包含六大模块：DAO、ORM、AOP、JEE、WEB、CORE"><a href="#spring的基本框架主要包含六大模块：DAO、ORM、AOP、JEE、WEB、CORE" class="headerlink" title="spring的基本框架主要包含六大模块：DAO、ORM、AOP、JEE、WEB、CORE"></a>spring的基本框架主要包含六大模块：DAO、ORM、AOP、JEE、WEB、CORE</h2><p><img src="http://jet-han.oschina.io/img/icons/spring-structure.png" alt="spring" title="spring"></p>
<p><strong>Spring DAO：</strong>Spring提供了对JDBC的操作支持：JdbcTemplate模板工具类 。<br><strong>Spring ORM：</strong>Spring可以与ORM框架整合。例如Spring整合Hibernate框架，其中Spring还提供  HibernateDaoSupport工具类，简化了Hibernate的操作 。<br><strong>Spring WEB：</strong>Spring提供了对Struts、Springmvc的支持，支持WEB开发。与此同时Spring自身也提供了基于MVC的解决方案 。<br><strong>Spring  AOP：</strong>Spring提供面向切面的编程，可以给某一层提供事务管理，例如在Service层添加事物控制 。<br><strong>Spring   JEE：</strong>J2EE开发规范的支持，例如EJB 。<br><strong>8Spring Core：</strong>提供IOC容器对象的创建和处理依赖对象关系 。  </p>
<h2 id="Spring下IOC容器和DI-依赖注入Dependency-injection"><a href="#Spring下IOC容器和DI-依赖注入Dependency-injection" class="headerlink" title="Spring下IOC容器和DI(依赖注入Dependency injection)"></a>Spring下IOC容器和DI(依赖注入Dependency injection)</h2><p>　　<strong>IOC容器：</strong>就是具有依赖注入功能的容器，是可以创建对象的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。通常new一个实例，控制权由程序员控制，而”控制反转”是指new实例工作不由程序员来做而是交给Spring容器来做。。在Spring中BeanFactory是IOC容器的实际代表者。<br>　　<strong>DI(依赖注入Dependency injection) ：</strong>在容器创建对象后，处理对象的依赖关系。<br>依赖注入spring的注入方式： </p>
<p><strong>set注入方式<br>静态工厂注入方式<br>构造方法注入方式<br>基于注解的方式 </strong><br>1、 set注入方式：<br>控制层代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private OrderServiceImp orderService;</div><div class="line">    public void setOrderService(OrderServiceImp orderService) &#123;</div><div class="line">       this.orderService = orderService;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Spring配置XML文件：其中配置声明OrderAction类存在属性orderService。程式运行时候，会将已经实例化的orderService对象调用setOrderService方式注入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;bean name=&quot;orderAction&quot; class=&quot;com.pec.action.OrderAction&quot;&gt;</div><div class="line">        &lt;property name=&quot;orderService&quot; ref=&quot;orderService&quot;&gt;&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line">&lt;bean name=&quot;orderService&quot; class=&quot;com.pec.service.imp.OrderServiceImp&quot;&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>2、 构造器注入方式：<br>控制层代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private OrderServiceImp orderService;</div><div class="line">    public OrderAction(OrderServiceImp orderService) &#123;</div><div class="line">        this.orderService = orderService;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>Spring配置XML文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;bean name=&quot;orderAction&quot; class=&quot;com.pec.action.OrderAction&quot;&gt;</div><div class="line">      &lt;constructor-arg ref=&quot;orderService&quot;&gt;&lt;/constructor-arg&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line">&lt;bean name=&quot;orderService&quot; class=&quot;com.pec.service.imp.OrderServiceImp&quot;&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>3、基于注解的方式 （推荐使用，比较便捷少配置）<br>控制层代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@Autowired   //@Resourceprivate OrderServiceImp orderService;</div></pre></td></tr></table></figure></p>
<p>服务层代码：</p>
<pre><code>    @Service(&quot;orderService&quot;)
    public class OrderServiceImp implements IOrderService {

    @Autowired
    private JavaOrderMDaoImp javaOrderMDao;

    @Autowired
    private JavaOrderDDaoImp javaOrderDDao;

    @Override
    public List&lt;JavaOrderMList&gt; findOrderM(OrderSearch search) {
        return javaOrderMDao.findJavaOrderM(search);
    }

    @Override
    public List&lt;JavaOrderDList&gt; findOrderD(OrderSearch search) {
        return javaOrderDDao.findJavaOrderD(search);
    }

}
</code></pre><p> DAO层代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Repository(&quot;javaOrderMDao&quot;)</div><div class="line">public class JavaOrderMDaoImp extends BaseHibernateDAO&lt;JavaOrderM, Serializable&gt; implements IJavaOrderMDao &#123;...&#125;</div><div class="line">@Repository(&quot;javaOrderDDao&quot;)</div><div class="line">public class JavaOrderDDaoImp extendsBaseHibernateDAO&lt;JavaOrderD, Serializable&gt; implements IJavaOrderDDao &#123;...&#125;</div></pre></td></tr></table></figure></p>
<p>【注意点】<br>⑴ 持久层DAO层注解Repository中规定了名称，在Service层中声明名称必须一致。<br>⑵ 服务层Service层注解Service中规定了名称，在控制层中声明的名称必须一致。<br>⑶ 注解方式注入依赖注解：</p>
<p><strong>@Component </strong>        把对象加入ioc容器，对象引用名称是类名，第一个字母小写<br><strong>@Component(“name”)</strong> 把指定名称的对象，加入ioc容器<br><strong>@Repository</strong>        主要用于标识加入容器的对象是一个持久层的组件(类)<br><strong>@Service</strong>           主要用于标识加入容器的对象是一个业务逻辑层的组件<br><strong>@Controller </strong>       主要用于标识加入容器的对象是一个控制层的组件<br><strong>@Resource </strong>         注入属性(DI), 会从容器中找对象注入到@Resource修饰的对象上<br><strong>@Autowired </strong>        注入属性(DI), 会从容器中找对象注入到@Autowired修饰的对象上</p>
<p><strong>开启注解</strong><br><code>&lt;mvc:annotation-driven/&gt;</code><br><strong>静态资源由WEB服务器默认的Servlet来处理    ，必须和<mvc:annotation-driven>一起</mvc:annotation-driven></strong><br><code>&lt;mvc:default-servlet-handler/&gt;</code><br><strong>包扫描路径</strong><br><code>&lt;context:component-scan base-package=&quot;com.fh.controller&quot; /&gt;</code></p>
<p>注解可以简化配置，提升开发效率，但是也不利于后期维护。</p>
<ol>
<li>@Autowired与@Resource都可以用来装配bean. 都可以写在字段上,或写在setter方法上。   </li>
<li><p>@Autowired默认按类型装配（这个注解是属业spring的），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@Autowired() @Qualifier(&quot;baseDao&quot;)     </div><div class="line">private BaseDao baseDao;</div></pre></td></tr></table></figure>
</li>
<li><p>@Resource（这个注解属于J2EE的），默认安照名称进行装配，名称可以通过name属性进行指定，<br>如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。 当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@Resource(name=&quot;baseDao&quot;)     </div><div class="line">private BaseDao baseDao;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>我喜欢用 @Resource注解在字段上，且这个注解是属于J2EE的，减少了与spring的耦合。最重要的这样代码看起就比较优雅。  </p>
<h2 id="Spring面向切面编程-AOP-和事务管理配置"><a href="#Spring面向切面编程-AOP-和事务管理配置" class="headerlink" title="Spring面向切面编程(AOP)和事务管理配置"></a>Spring面向切面编程(AOP)和事务管理配置</h2><p>AOP就是纵向的编程，如业务1和业务2都需要一个共同的操作，与其往每个业务中都添加同样的代码，不如写一遍代码，让两个业务共同使用这段代码。在日常有订单管理、商品管理、资金管理、库存管理等业务，都会需要到类似日志记录、事务控制、权限控制、性能统计、异常处理及事务处理等。AOP把所有共有代码全部抽取出来，放置到某个地方集中管理，然后在具体运行时，再由容器动态织入这些共有代码。<br><img src="http://jet-han.oschina.io/img/icons/aop.png" alt="spring" title="spring"></p>
<p>AOP涉及名称：<br><strong>切面（Aspect）：</strong>其实就是共有功能的实现。如日志切面、权限切面、事务切面等。在实际应用中通常是一个存放共有功能实现的普通Java类，之所以能被AOP容器识别成切面，是在配置中指定的。<br><strong>通知（Advice）：</strong>是切面的具体实现。以目标方法为参照点，根据放置的地方不同，可分为前置通知（Before）、后置通知（AfterReturning）、异常通知（AfterThrowing）、最终通知（After）与环绕通知（Around）5种。在实际应用中通常是切面类中的一个方法，具体属于哪类通知，同样是在配置中指定的。<br><strong>连接点（Joinpoint）：</strong>就是程序在运行过程中能够插入切面的地点。例如，方法调用、异常抛出或字段修改等，但Spring只支持方法级的连接点。<br><strong>切入点（Pointcut）：</strong>用于定义通知应该切入到哪些连接点上。不同的通知通常需要切入到不同的连接点上，这种精准的匹配是由切入点的正则表达式来定义的。<br><strong>目标对象（Target）：</strong>就是那些即将切入切面的对象，也就是那些被通知的对象。这些对象中已经只剩下干干净净的核心业务逻辑代码了，所有的共有功能代码等待AOP容器的切入。<br><strong>代理对象（Proxy）：</strong>将通知应用到目标对象之后被动态创建的对象。可以简单地理解为，代理对象的功能等于目标对象的核心业务逻辑功能加上共有功能。代理对象对于使用者而言是透明的，是程序运行过程中的产物。<br><strong>织入（Weaving）：</strong>将切面应用到目标对象从而创建一个新的代理对象的过程。这个过程可以发生在编译期、类装载期及运行期，当然不同的发生点有着不同的前提条件。譬如发生在编译期的话，就要求有一个支持这种AOP实现的特殊编译器；发生在类装载期，就要求有一个支持AOP实现的特殊类装载器；只有发生在运行期，则可直接通过Java语言的反射机制与动态代理机制来动态实现。<br> Spring配置文件中关于事务配置总是由三个组成部分，分别是DataSource、TransactionManager和代理机制这三部分，无论哪种配置方式，一般变化的只是代理机制这部分。<br>  DataSource、TransactionManager这两部分只是会根据数据访问方式有所变化，比如使用hibernate进行数据访问时，DataSource实际为SessionFactory，TransactionManager的实现为HibernateTransactionManager。<br><img src="http://jet-han.oschina.io/img/icons/spring.gif" alt="spring" title="spring"><br>根据代理机制的不同，总结了五种Spring事务的配置方式，配置文件如下：<br>第一种方式：每个Bean都有一个代理  </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-2.5.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd&quot;&gt;

&lt;bean id=&quot;sessionFactory&quot;  
        class=&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&gt;  
    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot; /&gt;  
    &lt;property name=&quot;configurationClass&quot; value=&quot;org.hibernate.cfg.AnnotationConfiguration&quot; /&gt;
&lt;/bean&gt;  

&lt;!-- 定义事务管理器（声明式的事务） --&gt;  
&lt;bean id=&quot;transactionManager&quot;
    class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;
&lt;/bean&gt;

&lt;!-- 配置DAO --&gt;
&lt;bean id=&quot;userDaoTarget&quot; class=&quot;com.bluesky.spring.dao.UserDaoImpl&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userDao&quot;  
    class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&gt;  
       &lt;!-- 配置事务管理器 --&gt;  
       &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot; /&gt;     
    &lt;property name=&quot;target&quot; ref=&quot;userDaoTarget&quot; /&gt;  
     &lt;property name=&quot;proxyInterfaces&quot; value=&quot;com.bluesky.spring.dao.GeneratorDao&quot; /&gt;
    &lt;!-- 配置事务属性 --&gt;  
    &lt;property name=&quot;transactionAttributes&quot;&gt;  
        &lt;props&gt;  
            &lt;prop key=&quot;*&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;/props&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;  
&lt;/beans&gt;
</code></pre><p>第二种方式：所有Bean共享一个代理基类</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-2.5.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd&quot;&gt;

&lt;bean id=&quot;sessionFactory&quot;  
        class=&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&gt;  
    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot; /&gt;  
    &lt;property name=&quot;configurationClass&quot; value=&quot;org.hibernate.cfg.AnnotationConfiguration&quot; /&gt;
&lt;/bean&gt;  

&lt;!-- 定义事务管理器（声明式的事务） --&gt;  
&lt;bean id=&quot;transactionManager&quot;
    class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;transactionBase&quot;  
        class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;  
        lazy-init=&quot;true&quot; abstract=&quot;true&quot;&gt;  
    &lt;!-- 配置事务管理器 --&gt;  
    &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot; /&gt;  
    &lt;!-- 配置事务属性 --&gt;  
    &lt;property name=&quot;transactionAttributes&quot;&gt;  
        &lt;props&gt;  
            &lt;prop key=&quot;*&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt;  
        &lt;/props&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;    

&lt;!-- 配置DAO --&gt;
&lt;bean id=&quot;userDaoTarget&quot; class=&quot;com.bluesky.spring.dao.UserDaoImpl&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userDao&quot; parent=&quot;transactionBase&quot; &gt;  
    &lt;property name=&quot;target&quot; ref=&quot;userDaoTarget&quot; /&gt;   
&lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>第三种方式：使用拦截器</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-2.5.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd&quot;&gt;

&lt;bean id=&quot;sessionFactory&quot;  
        class=&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&gt;  
    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot; /&gt;  
    &lt;property name=&quot;configurationClass&quot; value=&quot;org.hibernate.cfg.AnnotationConfiguration&quot; /&gt;
&lt;/bean&gt;  

&lt;!-- 定义事务管理器（声明式的事务） --&gt;  
&lt;bean id=&quot;transactionManager&quot;
    class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;
&lt;/bean&gt; 

&lt;bean id=&quot;transactionInterceptor&quot;  
    class=&quot;org.springframework.transaction.interceptor.TransactionInterceptor&quot;&gt;  
    &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot; /&gt;  
    &lt;!-- 配置事务属性 --&gt;  
    &lt;property name=&quot;transactionAttributes&quot;&gt;  
        &lt;props&gt;  
            &lt;prop key=&quot;*&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt;  
        &lt;/props&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;

&lt;bean class=&quot;org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator&quot;&gt;  
    &lt;property name=&quot;beanNames&quot;&gt;  
        &lt;list&gt;  
            &lt;value&gt;*Dao&lt;/value&gt;
        &lt;/list&gt;  
    &lt;/property&gt;  
    &lt;property name=&quot;interceptorNames&quot;&gt;  
        &lt;list&gt;  
            &lt;value&gt;transactionInterceptor&lt;/value&gt;  
        &lt;/list&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;  

&lt;!-- 配置DAO --&gt;
&lt;bean id=&quot;userDao&quot; class=&quot;com.bluesky.spring.dao.UserDaoImpl&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;
&lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>第四种方式：使用tx标签配置的拦截器</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-2.5.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd
       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&quot;&gt;

&lt;context:annotation-config /&gt;
&lt;context:component-scan base-package=&quot;com.bluesky&quot; /&gt;

&lt;bean id=&quot;sessionFactory&quot;  
        class=&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&gt;  
    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot; /&gt;  
    &lt;property name=&quot;configurationClass&quot; value=&quot;org.hibernate.cfg.AnnotationConfiguration&quot; /&gt;
&lt;/bean&gt;  

&lt;!-- 定义事务管理器（声明式的事务） --&gt;  
&lt;bean id=&quot;transactionManager&quot;
    class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;
&lt;/bean&gt;

&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; /&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;

&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;interceptorPointCuts&quot;
        expression=&quot;execution(* com.bluesky.spring.dao.*.*(..))&quot; /&gt;
    &lt;aop:advisor advice-ref=&quot;txAdvice&quot;
        pointcut-ref=&quot;interceptorPointCuts&quot; /&gt;        
&lt;/aop:config&gt;      
&lt;/beans&gt;
</code></pre><p>第五种方式：全注解</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-2.5.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd
       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&quot;&gt;

&lt;context:annotation-config /&gt;
&lt;context:component-scan base-package=&quot;com.bluesky&quot; /&gt;

&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;

&lt;bean id=&quot;sessionFactory&quot;  
        class=&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&gt;  
    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot; /&gt;  
    &lt;property name=&quot;configurationClass&quot; value=&quot;org.hibernate.cfg.AnnotationConfiguration&quot; /&gt;
&lt;/bean&gt;  

&lt;!-- 定义事务管理器（声明式的事务） --&gt;  
&lt;bean id=&quot;transactionManager&quot;
    class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;
&lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>此时在DAO上需加上@Transactional注解，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.bluesky.spring.dao;</div><div class="line"></div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">import org.hibernate.SessionFactory;</div><div class="line">import org.springframework.beans.factory.annotation.Autowired;</div><div class="line">import org.springframework.orm.hibernate3.support.HibernateDaoSupport;</div><div class="line">import org.springframework.stereotype.Component;</div><div class="line"></div><div class="line">import com.bluesky.spring.domain.User;</div><div class="line"></div><div class="line">@Transactional</div><div class="line">@Component(&quot;userDao&quot;)</div><div class="line">public class UserDaoImpl extends HibernateDaoSupport implements UserDao &#123;</div><div class="line"></div><div class="line">    public List&lt;User&gt; listUsers() &#123;</div><div class="line">        return this.getSession().createQuery(&quot;from User&quot;).list();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/spring.jpg&quot; alt=&quot;spring&quot; title=&quot;spring&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Spring AOP和IOC个人理解&lt;br&gt;&lt;strong&gt;IOC inversion of control 控制反转&lt;/strong&gt;&lt;br&gt;将new对象的权力由调用者转移到spring容器（即xml文件），Struts2与Spring整合（scope=”prototype”）由spring来维护struts的生命周期，在启动web容器时spring容器创建action实例对象，又分两种方式：&lt;br&gt;第一种xml方式 需要set方法为被调用的属性赋值，xml中需要&lt;code&gt;ref&lt;/code&gt;注入被调要的对象。&lt;br&gt;第二种注解方式 不需要set方法为被调用属性赋值，但需要在action层service层dao层的类上对应写上&lt;br&gt;&lt;code&gt;@Controller,@Service,@Repository&lt;/code&gt;通过在属性上加上&lt;code&gt;@Resource(name=&amp;quot;&amp;quot;)&lt;/code&gt;来为属性赋值，这一步相当于xml方式的&lt;code&gt;ref&lt;/code&gt;。&lt;br&gt;事务管理器&lt;br&gt;
    
    </summary>
    
      <category term="spring" scheme="http://jet-han.oschina.io/categories/spring/"/>
    
    
      <category term="spring" scheme="http://jet-han.oschina.io/tags/spring/"/>
    
      <category term="IOC" scheme="http://jet-han.oschina.io/tags/IOC/"/>
    
      <category term="AOP" scheme="http://jet-han.oschina.io/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>spring事务的传播属性和隔离级别</title>
    <link href="http://jet-han.oschina.io/2017/08/05/spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://jet-han.oschina.io/2017/08/05/spring事务的传播属性和隔离级别/</id>
    <published>2017-08-05T04:03:28.000Z</published>
    <updated>2017-08-13T01:45:26.091Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/spring.jpg" alt="spring" title="spring"></p>
<h2 id="spring事务传播属性"><a href="#spring事务传播属性" class="headerlink" title="spring事务传播属性"></a>spring事务传播属性</h2><p><strong>Propagation（事务的传播属性） ：</strong>key属性确定代理应该给哪个方法增加事务行为。这样的属性最重要的部份是传播行为。有以下选项可供使用：<br><strong>PROPAGATION_REQUIRED</strong>—支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。<br><strong>PROPAGATION_SUPPORTS</strong>—支持当前事务，如果当前没有事务，就以非事务方式执行。<br><strong>PROPAGATION_MANDATORY</strong>—支持当前事务，如果当前没有事务，就抛出异常。<br><strong>PROPAGATION_REQUIRES_NEW</strong>—新建事务，如果当前存在事务，把当前事务挂起。<br><strong>PROPAGATION_NOT_SUPPORTED</strong>—以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br><strong>PROPAGATION_NEVER</strong>—以非事务方式执行，如果当前存在事务，则抛出异常。<br><a id="more"></a></p>
<ol>
<li>PROPAGATION_REQUIRED<br>加入当前正要执行的事务不在另外一个事务里，那么就起一个新的事务<br>比如说，ServiceB.methodB的事务级别定义为PROPAGATION_REQUIRED, 那么由于执行ServiceA.methodA的时候，<br>ServiceA.methodA已经起了事务，这时调用ServiceB.methodB，ServiceB.methodB看到自己已经运行在ServiceA.methodA<br>的事务内部，就不再起新的事务。而假如ServiceA.methodA运行的时候发现自己没有在事务中，他就会为自己分配一个事务。<br>这样，在ServiceA.methodA或者在ServiceB.methodB内的任何地方出现异常，事务都会被回滚。即使ServiceB.methodB的事务已经被<br>提交，但是ServiceA.methodA在接下来fail要回滚，ServiceB.methodB也要回滚</li>
<li>PROPAGATION_SUPPORTS<br>如果当前在事务中，即以事务的形式运行，如果当前不再一个事务中，那么就以非事务的形式运行</li>
<li>PROPAGATION_MANDATORY<br>必须在一个事务中运行。也就是说，他只能被一个父事务调用。否则，他就要抛出异常</li>
<li>PROPAGATION_REQUIRES_NEW<br>这个就比较绕口了。 比如我们设计ServiceA.methodA的事务级别为PROPAGATION_REQUIRED，ServiceB.methodB的事务级别为PROPAGATION_REQUIRES_NEW，<br>那么当执行到ServiceB.methodB的时候，ServiceA.methodA所在的事务就会挂起，ServiceB.methodB会起一个新的事务，等待ServiceB.methodB的事务完成以后，<br>他才继续执行。他与PROPAGATION_REQUIRED 的事务区别在于事务的回滚程度了。因为ServiceB.methodB是新起一个事务，那么就是存在<br>两个不同的事务。如果ServiceB.methodB已经提交，那么ServiceA.methodA失败回滚，ServiceB.methodB是不会回滚的。如果ServiceB.methodB失败回滚，<br>如果他抛出的异常被ServiceA.methodA捕获，ServiceA.methodA事务仍然可能提交。</li>
<li>PROPAGATION_NOT_SUPPORTED<br>当前不支持事务。比如ServiceA.methodA的事务级别是PROPAGATION_REQUIRED ，而ServiceB.methodB的事务级别是PROPAGATION_NOT_SUPPORTED ，<br>那么当执行到ServiceB.methodB时，ServiceA.methodA的事务挂起，而他以非事务的状态运行完，再继续ServiceA.methodA的事务。</li>
<li>PROPAGATION_NEVER<br>不能在事务中运行。假设ServiceA.methodA的事务级别是PROPAGATION_REQUIRED， 而ServiceB.methodB的事务级别是PROPAGATION_NEVER ，<br>那么ServiceB.methodB就要抛出异常了。</li>
<li>PROPAGATION_NESTED<br>理解Nested的关键是savepoint。他与PROPAGATION_REQUIRES_NEW的区别是，PROPAGATION_REQUIRES_NEW另起一个事务，将会与他的父事务相互独立，<br>而Nested的事务和他的父事务是相依的，他的提交是要等和他的父事务一块提交的。也就是说，如果父事务最后回滚，他也要回滚的。<br>而Nested事务的好处是他有一个savepoint。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ServiceA &#123;</div><div class="line">/**</div><div class="line">* 事务属性配置为 PROPAGATION_REQUIRED</div><div class="line">*/</div><div class="line">void methodA() &#123;</div><div class="line">try &#123;</div><div class="line">//savepoint</div><div class="line">ServiceB.methodB(); //PROPAGATION_NESTED 级别</div><div class="line">&#125; catch (SomeException) &#123;</div><div class="line">// 执行其他业务, 如 ServiceC.methodC();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说ServiceB.methodB失败回滚，那么ServiceA.methodA也会回滚到savepoint点上，ServiceA.methodA可以选择另外一个分支，比如<br>ServiceC.methodC，继续执行，来尝试完成自己的事务。<br>但是这个事务并没有在EJB标准中定义。</p>
<h2 id="Spring事务的隔离级别"><a href="#Spring事务的隔离级别" class="headerlink" title="Spring事务的隔离级别"></a>Spring事务的隔离级别</h2><ol>
<li><strong>ISOLATION_DEFAULT：</strong> 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.<br>  另外四个与JDBC的隔离级别相对应  </li>
<li><strong>ISOLATION_READ_UNCOMMITTED：</strong> 这是事务最低的隔离级别，它充许令外一个事务可以看到这个事务未提交的数据。<br>  这种隔离级别会产生脏读，不可重复读和幻像读。</li>
<li><strong>ISOLATION_READ_COMMITTED：</strong> 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据</li>
<li><strong>ISOLATION_REPEATABLE_READ：</strong> 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。<br>  它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。</li>
<li><strong>ISOLATION_SERIALIZABLE:</strong> 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。</li>
</ol>
<p><strong>事务的四个特性</strong>  </p>
<ol>
<li><strong>原子性（Atomicity）</strong><br>　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</li>
<li><strong>一致性（Consistency）</strong><br>　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。<br>　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</li>
<li><strong>隔离性（Isolation）</strong><br>　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。<br>　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。<br>　　关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。</li>
<li><strong>持久性（Durability）</strong><br>　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。<br>　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。<br>　　以上介绍完事务的四大特性(简称ACID)，现在重点来说明下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题：  <ol>
<li><strong>脏读:</strong> 指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据， 那么另外一<br>个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。  </li>
<li><strong>不可重复读:</strong> 指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。<br>那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据<br>可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。  </li>
<li><strong>幻觉读:</strong> 指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及<br>到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，<br>以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</li>
</ol>
</li>
</ol>
<p>除了防止脏读，不可重复读外，还避免了幻像读，需要设置事务隔离级别</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/spring.jpg&quot; alt=&quot;spring&quot; title=&quot;spring&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;spring事务传播属性&quot;&gt;&lt;a href=&quot;#spring事务传播属性&quot; class=&quot;headerlink&quot; title=&quot;spring事务传播属性&quot;&gt;&lt;/a&gt;spring事务传播属性&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Propagation（事务的传播属性） ：&lt;/strong&gt;key属性确定代理应该给哪个方法增加事务行为。这样的属性最重要的部份是传播行为。有以下选项可供使用：&lt;br&gt;&lt;strong&gt;PROPAGATION_REQUIRED&lt;/strong&gt;—支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。&lt;br&gt;&lt;strong&gt;PROPAGATION_SUPPORTS&lt;/strong&gt;—支持当前事务，如果当前没有事务，就以非事务方式执行。&lt;br&gt;&lt;strong&gt;PROPAGATION_MANDATORY&lt;/strong&gt;—支持当前事务，如果当前没有事务，就抛出异常。&lt;br&gt;&lt;strong&gt;PROPAGATION_REQUIRES_NEW&lt;/strong&gt;—新建事务，如果当前存在事务，把当前事务挂起。&lt;br&gt;&lt;strong&gt;PROPAGATION_NOT_SUPPORTED&lt;/strong&gt;—以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。&lt;br&gt;&lt;strong&gt;PROPAGATION_NEVER&lt;/strong&gt;—以非事务方式执行，如果当前存在事务，则抛出异常。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://jet-han.oschina.io/categories/java/"/>
    
    
      <category term="spring" scheme="http://jet-han.oschina.io/tags/spring/"/>
    
      <category term="事务传播属性" scheme="http://jet-han.oschina.io/tags/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7/"/>
    
      <category term="隔离级别" scheme="http://jet-han.oschina.io/tags/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>乐观锁与悲观锁及应用举例</title>
    <link href="http://jet-han.oschina.io/2017/08/05/%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%E5%8F%8A%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B/"/>
    <id>http://jet-han.oschina.io/2017/08/05/乐观锁与悲观锁及应用举例/</id>
    <published>2017-08-05T03:53:43.000Z</published>
    <updated>2017-08-13T01:45:26.093Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/mysql.jpg" alt="mysql" title="mysql"></p>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>   正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）的修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。<br>  以常用的mysql InnoDB存储引擎为例：加入商品表items表中有一个字段status，status=1表示该商品未被下单，status=2表示该商品已经被下单，那么我们对每个商品下单前必须确保此商品的status=1。假设有一件商品，其id为10000；如果不使用锁，那么操作方法如下:<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//查出商品状态</div><div class="line">select status from items where id=10000;</div><div class="line">//根据商品信息生成订单</div><div class="line">insert into orders(id,item_id) values(null,10000);</div><div class="line">//修改商品状态为2</div><div class="line">update Items set status=2 where id=10000;</div></pre></td></tr></table></figure>
<p><strong>上述场景在高并发环境下可能出现问题：</strong><br>前面已经提到只有商品的status=1是才能对它进行下单操作，上面第一步操作中，查询出来的商品status为1。但是当我们执行第三步update操作的时候，有可能出现其他人先一步对商品下单把Item的status修改为2了，但是我们并不知道数据已经被修改了，这样就可能造成同一个商品被下单2次，使得数据不一致。所以说这种方式是不安全的。<br>使用悲观锁来实现：在上面的场景中，商品信息从查询出来到修改，中间有一个处理订单的过程，使用悲观锁的原理就是，当我们在查询出items信息后就把当前的数据锁定，直到我们修改完毕后再解锁。那么在这个过程中，因为items被锁定了，就不会出现有第三者来对其进行修改了。<br>注：要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。我们可以使用命令设置MySQL为非autocommit模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">set autocommit=0;</div><div class="line">设置完autocommit后，我们就可以执行我们的正常业务了。具体如下：</div><div class="line">//开始事务</div><div class="line">begin;/begin work;/start transaction; (三者选一就可以)</div><div class="line">//查询出商品信息</div><div class="line">select status from items where id=10000 for update;</div><div class="line">//根据商品信息生成订单</div><div class="line">insert into orders (id,item_id) values (null,10000);</div><div class="line">//修改商品status为2</div><div class="line">update items set status=2 where id=10000;</div><div class="line">//提交事务</div><div class="line">commit;/commit work;</div></pre></td></tr></table></figure></p>
<p>注：上面的begin/commit为事务的开始和结束，因为在前一步我们关闭了mysql的autocommit，所以需要手动控制事务的提交，在这里就不细表了。<br>上面的第一步我们执行了一次查询操作：select status from items where id=10000 for update;与普通查询不一样的是，我们使用了select…for update的方式，这样就通过数据库实现了悲观锁。此时在items表中，id为10000的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。<br>注：需要注意的是，在事务中，只有SELECT … FOR UPDATE 或LOCK IN SHARE MODE 同一笔数据时会等待其它事务结束后才执行，一般SELECT … 则不受此影响。拿上面的实例来说，当我执行select status from items where id=10000 for update;后。我在另外的事务中如果再次执行select status from items where id=10000 for update;则第二个事务会一直等待第一个事务的提交，此时第二个查询处于阻塞的状态，但是如果我是在第二个事务中执行select status from items where id=10000;则能正常查询出数据，不会受第一个事务的影响。<br>上面我们提到，使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认Row-Level Lock，所以只有明确地指定主键，MySQL 才会执行Row lock (只锁住被选取的数据) ，否则MySQL 将会执行Table Lock (将整个数据表单给锁住)。除了主键外，使用索引也会影响数据库的锁定级别。<br>悲观锁并不是适用于任何场景，它也有它存在的一些不足，因为悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。如果加锁的时间过长，其他用户长时间无法访问，影响了程序的并发访问性，同时这样对数据库性能开销影响也很大，特别是对长事务而言，这样的开销往往无法承受。</p>
<h2 id="乐观锁（-Optimistic-Locking-）"><a href="#乐观锁（-Optimistic-Locking-）" class="headerlink" title="乐观锁（ Optimistic Locking ）"></a>乐观锁（ Optimistic Locking ）</h2><p>相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。那么我们如何实现乐观锁呢，一般来说有以下2种方式：  </p>
<ol>
<li><p>使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值+1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。<br>如果更新操作顺序执行，则数据的版本（version）依次递增，不会产生冲突。但是如果发生有不同的业务操作对同一版本的数据进行修改，那么，先提交的操作（图中B）会把数据version更新为2，当A在B之后提交更新时发现数据的version已经被修改了，那么A的更新操作会失败。</p>
</li>
<li><p>乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似（其实不用新加字段，用需要修改的字段作为条件进行修改操作即可），也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。<br>以mysql InnoDB存储引擎为例，还是拿之前的例子商品表items表中有一个字段status，status=1表示该商品未被下单，status=2表示该商品已经被下单，那么我们对每个商品下单前必须确保此商品的status=1。假设有一件商品，其id为10000；<br>下单操作包括3步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//查询出商品信息</div><div class="line">select (status,version) from items where id=#&#123;id&#125;</div><div class="line">//根据商品信息生成订单</div><div class="line">//修改商品status为2</div><div class="line">update items set status=2,version=version+1 where id=#&#123;id&#125; and version=#&#123;version&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>为了使用乐观锁，我们需要首先修改items表，增加一个version字段，数据默认version可设为1；<br>其实我们周围的很多产品都有乐观锁的使用，比如我们经常使用的分布式存储引擎Tair，Tair中存储的每个数据都有版本号，版本号在每次更新后都会递增，相应的，在Tair put接口中也有此version参数，这个参数是为了解决并发更新同一个数据而设置的，这其实就是乐观锁；<br>很多情况下，更新数据是先get，修改get回来的数据，然后put回系统。如果有多个客户端get到同一份数据，都对其修改并保存，那么先保存的修改就会被后到达的修改覆盖，从而导致数据一致性问题,在大部分情况下应用能够接受，但在少量特殊情况下，这个是我们不希望发生的。<br>比如系统中有一个值”1”, 现在A和B客户端同时都取到了这个值。之后A和B客户端都想改动这个值，假设A要改成12，B要改成13，如果不加控制的话，无论A和B谁先更新成功，它的更新都会被后到的更新覆盖。Tair引入的乐观锁机制避免了这样的问题。刚刚的例子中，假设A和B同时取到数据，当时版本号是10，A先更新，更新成功后，值为12，版本为11。当B更新的时候，由于其基于的版本号是10，此时服务器会拒绝更新，返回version error，从而避免A的更新被覆盖。B可以选择get新版本的value，然后在其基础上修改，也可以选择强行更新。<br>当然了，乐观锁也是要精心挑选的，主要的目的就是避免锁的失败率过高又要规避ABA问题。关于锁力度太大导致接口操作失败率过高。<br>商品库存扣减时，尤其是在秒杀、聚划算这种高并发的场景下，若采用version号作为乐观锁，则每次只有一个事务能更新成功，业务感知上就是大量操作失败。<br>若挑选以库存数作为乐观锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">update item </div><div class="line">set </div><div class="line">    quantity=quantity-#sub_quantity# </div><div class="line">where </div><div class="line">    item_id = #id# </div><div class="line">    and quantity-#sub_quantity# &gt; 0</div></pre></td></tr></table></figure></p>
<p>通过挑选乐观锁，可以减小锁力度，从而提升吞吐<br>乐观锁需要灵活运用,现在互联网高并发的架构中，受到fail-fast思路的影响，悲观锁已经非常少见了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/mysql.jpg&quot; alt=&quot;mysql&quot; title=&quot;mysql&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;悲观锁&quot;&gt;&lt;a href=&quot;#悲观锁&quot; class=&quot;headerlink&quot; title=&quot;悲观锁&quot;&gt;&lt;/a&gt;悲观锁&lt;/h2&gt;&lt;p&gt;   正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）的修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。&lt;br&gt;  以常用的mysql InnoDB存储引擎为例：加入商品表items表中有一个字段status，status=1表示该商品未被下单，status=2表示该商品已经被下单，那么我们对每个商品下单前必须确保此商品的status=1。假设有一件商品，其id为10000；如果不使用锁，那么操作方法如下:&lt;br&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://jet-han.oschina.io/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://jet-han.oschina.io/tags/mysql/"/>
    
      <category term="乐观锁" scheme="http://jet-han.oschina.io/tags/%E4%B9%90%E8%A7%82%E9%94%81/"/>
    
      <category term="悲观锁" scheme="http://jet-han.oschina.io/tags/%E6%82%B2%E8%A7%82%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>mysql事务隔离级别</title>
    <link href="http://jet-han.oschina.io/2017/08/04/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://jet-han.oschina.io/2017/08/04/mysql事务隔离级别/</id>
    <published>2017-08-04T03:58:09.000Z</published>
    <updated>2017-09-08T05:49:38.874Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/mysql.jpg" alt="mysql" title="mysql"></p>
<h1 id="mysql事务隔离级别"><a href="#mysql事务隔离级别" class="headerlink" title="mysql事务隔离级别"></a>mysql事务隔离级别</h1><h2 id="第1级别：Read-Uncommitted-读取未提交内容"><a href="#第1级别：Read-Uncommitted-读取未提交内容" class="headerlink" title="第1级别：Read Uncommitted(读取未提交内容)"></a>第1级别：Read Uncommitted(读取未提交内容)</h2><p>1.所有事务都可以看到其他未提交事务的执行结果<br>2.本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少<br>3.该级别引发的问题是——脏读(Dirty Read)：读取到了未提交的数据<br><a id="more"></a></p>
<pre><code>#首先，修改隔离级别
set tx_isolation=&#39;READ-UNCOMMITTED&#39;;  
select @@tx_isolation; 
| @@tx_isolation |
| READ-UNCOMMITTED |
#事务A：启动一个事务  
start transaction;  
select * from tx;  
| id   | num  |  
|    1 |    1 |  
|    2 |    2 |  
|    3 |    3 |  

#事务B：也启动一个事务(那么两个事务交叉了)  
#在事务B中执行更新语句，且不提交
start transaction;   
update tx set num=10 where id=1;  
select * from tx;
| id   | num  |  
|    1 |   10 |  
|    2 |    2 |  
|    3 |    3 | 

#事务A：那么这时候事务A能看到这个更新了的数据吗?  
select * from tx;  
| id   | num  |  
|    1 |   10 |   ---&gt;可以看到！说明我们读到了事务B还没有提交的数据  
|    2 |    2 |  
|    3 |    3 |  

#事务B：事务B回滚,仍然未提交  
rollback;  
select * from tx;  
| id   | num  |  
|    1 |    1 |  
|    2 |    2 |  
|    3 |    3 |  

#事务A：在事务A里面看到的也是B没有提交的数据
select * from tx;  
| id   | num  |  
|    1 |    1 |      ---&gt;脏读意味着我在这个事务中(A中)，事务B虽然没有提交，但它任何一条数据变化，我都可以看到！  
|    2 |    2 |  
|    3 |    3 |  
</code></pre><h2 id="第2级别：Read-Committed-读取提交内容"><a href="#第2级别：Read-Committed-读取提交内容" class="headerlink" title="第2级别：Read Committed(读取提交内容)"></a>第2级别：Read Committed(读取提交内容)</h2><p>1.这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）<br>2.它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变<br>3.这种隔离级别出现的问题是——不可重复读(Nonrepeatable Read)：不可重复读意味着我们在同一个事务中执行完全相同的select语句时可能看到不一样的结果。<br> ——&gt;导致这种情况的原因可能有：<br> (1)有一个交叉的事务有新的commit，导致了数据的改变;<br> (2)一个数据库被多个实例操作时,同一事务的其他实例在该实例处理其间可能会有新的commit</p>
<pre><code>  #首先修改隔离级别
  set tx_isolation=&#39;read-committed&#39;;  
  select @@tx_isolation;  
  | @@tx_isolation |  
  | READ-COMMITTED |  

  #事务A：启动一个事务
  start transaction;  
  select * from tx;  
  | id   | num  |  
  |    1 |    1 |  
  |    2 |    2 |  
  |    3 |    3 |  

  #事务B：也启动一个事务(那么两个事务交叉了)
  #在这事务中更新数据，且未提交
  start transaction;  
  update tx set num=10 where id=1;  
  select * from tx; 
  | id   | num  |  
  |    1 |   10 |  
  |    2 |    2 |  
  |    3 |    3 |  

  #事务A：这个时候我们在事务A中能看到数据的变化吗?
  select * from tx;
  | id   | num  |  
  |    1 |    1 |---&gt;并不能看到！  
  |    2 |    2 |                 
  |    3 |    3 |     
  |——&gt;相同的select语句，结果却不一样

  #事务B：如果提交了事务B呢?           
  commit;                          

  #事务A:                           
  select * from tx;  
  | id   | num  |  
  |    1 |   10 |---&gt;因为事务B已经提交了，所以在A中我们看到了数据变化  
  |    2 |    2 |  
  |    3 |    3 |  
</code></pre><h2 id="第3级别：Repeatable-Read-可重读"><a href="#第3级别：Repeatable-Read-可重读" class="headerlink" title="第3级别：Repeatable Read(可重读)"></a>第3级别：Repeatable Read(可重读)</h2><p>1.这是MySQL的默认事务隔离级别<br>2.它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行<br>3.此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行<br>4.InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题  </p>
<pre><code>    #首先，更改隔离级别  
    set tx_isolation=&#39;repeatable-read&#39;;  
    select @@tx_isolation;  
    | @@tx_isolation  |
    +------+------+
    | REPEATABLE-READ |
    +------+------+

    #事务A：启动一个事务
    start transaction;  
    select * from tx;  
    | id   | num  |
    +------+------+
    |    1 |    1 |
    |    2 |    2 |
    |    3 |    3 |
    +------+------+

    #事务B：开启一个新事务(那么这两个事务交叉了)
    #在事务B中更新数据，并提交
    start transaction;  
    update tx set num=10 where id=1;  
    select * from tx;  
    +------+------+  
    | id   | num  |  
    +------+------+  
    |    1 |   10 |  
    |    2 |    2 |  
    |    3 |    3 |  
    +------+------+  
    commit;  

    #事务A：这时候即使事务B已经提交了,但A能不能看到数据变化？
    select * from tx;+------+------+  
    | id   | num  |  
    +------+------+  
    |    1 |    1 | ---&gt;还是看不到的！(这个级别2不一样，也说明级别3解决了不可重复读问题)  
    |    2 |    2 |  
    |    3 |    3 |  
    +------+------+  

    #事务A：只有当事务A也提交了，它才能够看到数据变化
    commit;select * from tx;  
    +------+------+  
    | id   | num  |  
    +------+------+  
    |    1 |   10 |  
    |    2 |    2 |  
    |    3 |    3 |  
    +------+------+  
</code></pre><h2 id="第4级别：Serializable-可串行化"><a href="#第4级别：Serializable-可串行化" class="headerlink" title="第4级别：Serializable(可串行化)"></a>第4级别：Serializable(可串行化)</h2><p>1.这是最高的隔离级别<br>2.它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁。<br>3.在这个级别，可能导致大量的超时现象和锁竞争</p>
<pre><code>    #首先修改隔离界别
    set tx_isolation=&#39;serializable&#39;;  
    select @@tx_isolation;  
    +----------------+  
    | @@tx_isolation |  
    +----------------+  
    | SERIALIZABLE   |  
    +----------------+  

    #事务A：开启一个新事务  
    start transaction;  

    #事务B：在A没有commit之前，这个交叉事务是不能更改数据的  
    start transaction;  
    insert tx values(&#39;4&#39;,&#39;4&#39;);  
    ERROR 1205 (HY000): Lock wait timeout exceeded;   
    try restarting transactionupdate tx set num=10 where id=1;ERROR 1205 (HY000): Lock wait timeout exceeded;   
    try restarting transaction  
</code></pre><p><img src="http://jet-han.oschina.io/img/mysql事务隔离级别/transaction.jpg" alt="transaction" title="transaction"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/mysql.jpg&quot; alt=&quot;mysql&quot; title=&quot;mysql&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;mysql事务隔离级别&quot;&gt;&lt;a href=&quot;#mysql事务隔离级别&quot; class=&quot;headerlink&quot; title=&quot;mysql事务隔离级别&quot;&gt;&lt;/a&gt;mysql事务隔离级别&lt;/h1&gt;&lt;h2 id=&quot;第1级别：Read-Uncommitted-读取未提交内容&quot;&gt;&lt;a href=&quot;#第1级别：Read-Uncommitted-读取未提交内容&quot; class=&quot;headerlink&quot; title=&quot;第1级别：Read Uncommitted(读取未提交内容)&quot;&gt;&lt;/a&gt;第1级别：Read Uncommitted(读取未提交内容)&lt;/h2&gt;&lt;p&gt;1.所有事务都可以看到其他未提交事务的执行结果&lt;br&gt;2.本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少&lt;br&gt;3.该级别引发的问题是——脏读(Dirty Read)：读取到了未提交的数据&lt;br&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://jet-han.oschina.io/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://jet-han.oschina.io/tags/mysql/"/>
    
      <category term="事务隔离级别" scheme="http://jet-han.oschina.io/tags/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>equals、==和hashCode</title>
    <link href="http://jet-han.oschina.io/2017/08/01/equals%E3%80%81-%E5%92%8ChashCode/"/>
    <id>http://jet-han.oschina.io/2017/08/01/equals、-和hashCode/</id>
    <published>2017-08-01T15:47:35.000Z</published>
    <updated>2017-08-13T01:45:26.059Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/java.jpg" alt="java" title="java"></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><strong>equals：</strong>是否同一个对象实例。注意，是“实例”。比如String s = new String(“test”);  s.equals(s), 这就是同一个对象实例的比较；</p>
<p><strong>等号(==)：</strong>对比对象实例的内存地址（也即对象实例的ID），来判断是否是同一对象实例；又可以说是判断对象实例是否物理相等；</p>
<p><strong>Hashcode：</strong>我觉得可以这样理解：并不是对象的内存地址，而是利用hash算法，对对象实例的一种描述符（或者说对象存储位置的hash算法映射）——对象实例的哈希码。</p>
<p>==比较的是对象的地址<br>String重写的equals比较的是字符串的内容值<br>String重写的hashCode已经不是对象内存地址的hash码，是根据内容产生的，因为a、b是两个完全不同的对象，也满足这条规律“equals相等的两个对象，hashCode也相等”。<br>System.identityHashCode是未被重写的获取对象内存地址hash码的函数，new出来的String对象的内存地址是不一样的，所以hash值也不一样<br><a id="more"></a></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">  public static void main(String[] args) &#123;</div><div class="line">     String a=new String(&quot;foo&quot;);</div><div class="line">     String b=new String(&quot;foo&quot;);</div><div class="line"></div><div class="line">     String c=&quot;hello&quot;;</div><div class="line">     String d=&quot;hello&quot;;</div><div class="line"></div><div class="line">     System.out.println(&quot;memory address hashcode a:&quot;+System.identityHashCode(a));</div><div class="line">     System.out.println(&quot;memory address hashcode a:&quot;+System.identityHashCode(b));</div><div class="line">     System.out.println(&quot;String hashcode a:        &quot;+a.hashCode());</div><div class="line">     System.out.println(&quot;String hashcode a:        &quot;+b.hashCode());</div><div class="line">     System.out.println(&quot;a==b:                     &quot;+(a==b));</div><div class="line">     System.out.println(&quot;a.equals(b):              &quot;+a.equals(b));</div><div class="line"></div><div class="line">     System.out.println(&quot;&quot;);</div><div class="line"></div><div class="line">     System.out.println(&quot;memory address hashcode c:&quot;+System.identityHashCode(c));</div><div class="line">     System.out.println(&quot;memory address hashcode d:&quot;+System.identityHashCode(d));</div><div class="line">     System.out.println(&quot;String hashcode c:        &quot;+c.hashCode());</div><div class="line">     System.out.println(&quot;String hashcode d:        &quot;+d.hashCode());</div><div class="line">     System.out.println(&quot;c==d:                     &quot;+(c==d));</div><div class="line">     System.out.println(&quot;c.equals(d):              &quot;+c.equals(d));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>结果：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">memory address hashcode a:8222510</div><div class="line">memory address hashcode a:18581223</div><div class="line">String hashcode a:        101574</div><div class="line">String hashcode a:        101574</div><div class="line">a==b:                     false</div><div class="line">a.equals(b):              true</div><div class="line">memory address hashcode c:3526198</div><div class="line">memory address hashcode d:3526198</div><div class="line">String hashcode c:        99162322</div><div class="line">String hashcode d:        99162322</div><div class="line">c==d:                     true</div><div class="line">c.equals(d):              true</div></pre></td></tr></table></figure></p>
<h2 id="从Java集合的常用需求为什么需要使用Hashcode"><a href="#从Java集合的常用需求为什么需要使用Hashcode" class="headerlink" title="从Java集合的常用需求为什么需要使用Hashcode"></a>从Java集合的常用需求为什么需要使用Hashcode</h2><p>Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？这就是 Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。</p>
<p>于是，Java采用了哈希表的原理。哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。可以这样简单理解，hashCode方法实际上返回的就是对象存储位置的映像。</p>
<p>这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就能定位到它应该放置的bucket存储位置。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就表示发生冲突了，散列表对于冲突有具体的解决办法，但最终还会将新元素保存在适当的位置。这样一来，实际调用equals方法的次数就大大降低了，几乎只需要一两次。</p>
<p>简单归纳，hashmap的深入理解：</p>
<p>HashMap的数据结构是基于<font color="#c00">数组和链表</font>的。（以数组存储元素，如有hash相同的元素，在数组结构中，创建链表结构，再把hash相同的元素放到链表的下一个节点）</p>
<p>hashMap的结构类似这样<br>  元素0—&gt;[hashCode=0, key.value=x1的数据]<br>  元素1—&gt;[hashCode=1, key.value=y1的数据]<br>  。。。。。。<br>  元素n—&gt;[hashCode=n, key.value=z1的数据]</p>
<p>假设没有hashCode=1的元素加入，但是有两个hashCode=0的数据，它的结构就变成这样<br>  元素0—&gt;[hashCode=0, key.value=x1的数据].next—&gt;[hashCode=0, key.value=x2的数据]<br>  元素1—&gt;[null]<br>  ……<br>  元素n—&gt;[hashCode=n, key.value=z1的数据]</p>
<p>put和get都首先会调用hashcode方法，去查找相关的key，当有冲突时，再调用equals（这也是为什么刚开始就重温hashcode和equals的原因）！<br>HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。</p>
<p>当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。</p>
<p><strong>HashMap的工作原理</strong><br>HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。</p>
<p>当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。</p>
<h2 id="重写-equals-的时候必须重写-hashCode"><a href="#重写-equals-的时候必须重写-hashCode" class="headerlink" title="重写 equals 的时候必须重写 hashCode"></a>重写 equals 的时候必须重写 hashCode</h2><p>SUN官方的文档中规定”如果重定义equals方法，就必须重定义hashCode方法,以便用户可以将对象插入到散列(哈希)表中” </p>
<p>那么 SUN 公司是出于什么考虑做了这个规定呢？ </p>
<p>在集合框架中的HashSet，HashTable和HashMap都使用哈希表的形式存储数据，而hashCode计算出来的哈希码便是它们的身份证。哈希码的存在便可以： </p>
<p>快速定位对象，提高哈希表集合的性能。<br>只有当哈希表中对象的索引即hashCode和对象的属性即equals同时相等时，才能够判断两个对象相等。<br>从上面可以看出，哈希码主要是为哈希表服务的，其实如果不需要使用哈希表，也可以不重写hashCode。但是SUN公司应该是出于对程序扩展性的考虑（万一以后需要将对象放入哈希表集合中），才会规定重写equals的同时需要重写hashCode，以避免后续开发不必要的麻烦。  </p>
<p><strong>重写equals的注意事项</strong>  </p>
<p>Java语言规范要求equals需要具有如下的特性： </p>
<p><strong>自反性：</strong>对于任何非空引用 x，x.equals() 应该返回 true。<br><strong>对称性：</strong>对于任何引用 x 和 y，当且仅当 y.equals(x) 返回 true，x.equals(y) 也应该返回 true。<br><strong>传递性：</strong>对于任何引用 x、y 和 z，如果 x.equals(y)返回 true，y.equals(z) 也应返回同样的结果。<br><strong>一致性：</strong>如果 x 和 y 引用的对象没有发生变化，反复调用 x.equals(y) 应该返回同样的结果。<br>对于任意非空引用 x，x.equals(null) 应该返回 false。<br>在对象比较时，我们应该如何编写出一个符合特性的 equals 方法呢，《Core Java》中提出了如下建议：</p>
<p>显式参数命名为 otherObject，稍后将它转换成另一个叫做 other 的变量。<br>检测 this 与 otherObject 是否引用同一个对象： </p>
<p>if (this == otherObject) return true;<br>计算这个等式可以避免一个个比较类中的域，实现优化。</p>
<p>检测 otherObject 是否为 null，如果为 null，返回 false。进行非空校验是十分重要的。</p>
<p>比较 this 与 otherObject 是否属于同一个类。</p>
<p>如果每个子类都重写了 equals，使用 getClass 检验：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (getClass() != otherObject.getClass()) </div><div class="line">    return false;</div></pre></td></tr></table></figure></p>
<p>如果所有子类都使用同一个 equals，就用 instanceof 检验：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (!(otherObject instanceof ClassName))</div><div class="line">    return false;</div></pre></td></tr></table></figure></p>
<p>将 otherObject 转换为相应的类型变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ClassName other = (ClassName) otherObject;</div></pre></td></tr></table></figure></p>
<p>现在可以对所有需要比较的域进行比较了。</p>
<p>基本类型使用 == 比较<br>对象使用 equals 比较<br>数组类型的域可以使用静态方法 Arrays.equals检测相应数组元素是否相等<br>如果所有域匹配，则返回 true<br>注意：子类重写父类 equals 方法时，必须完全覆盖父类方法，不能因为类型错误或者其他原因定义了一个完全无关的方法。可以使用 @Override 注解对覆盖父类的方法进行标记，这样编译器便会检测到覆盖过程中的错误。</p>
<p><strong>重写 hashCode 的注意事项</strong><br>散列码（hash code）是由对象导出的一个整型值。散列码没有规律，在不同的对象中通过不同的算法生成，Java中生成 hashCode 的策略为（以下说明均摘自 Java API 8）：</p>
<p><strong>String 类的 hashCode 根据其字符串内容，使用算法计算后返回哈希码。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Returns a hash code for this string. The hash code for a String object is computed as s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</div></pre></td></tr></table></figure></p>
<p><strong>Integer 类返回的哈希码为其包含的整数数值。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Returns: a hash code value for this object, equal to the primitive int value represented by this Integer object.</div></pre></td></tr></table></figure></p>
<p><strong>Object 类的 hashCode 返回对象的内存地址经过处理后的数值。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Returns a hash code value for the object. This method is supported for the benefit of hash tables such as those provided by HashMap.</div></pre></td></tr></table></figure></p>
<p>在自己的类中想要重写 hashCode 的话一般怎么做呢？建议合理地组合实例域的散列码，让各个不同对象产生的散列码更加均匀。例如我们现在有一个 Cat 对象，它有 name、size 和 color 三个不同域，那么可以重写 hashCode 方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Cat &#123;</div><div class="line">    ......</div><div class="line">    public int hashCode() &#123;</div><div class="line">        //hashCode是可以返回负值的</div><div class="line">        return 6 * name.hashCode()</div><div class="line">            + 8 * new Double(size).hashCode()</div><div class="line">            + 10 * color.hashCode();</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然还有更好的做法，我们可以直接调用静态方法 Objects.hash 并提供多个参数。这个方法会对各个参数调用 Object.hashCode，并组合返回的散列码。故以上的方法可以缩写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public int hashCode() &#123;</div><div class="line">    return Objects.hash(name, size, color);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>【注意】 <font color="#c00">equals与hashCode的定义必须一致，两个对象equals为true，就必须有相同的hashCode。</font>例如：如果定义的equals比较的是小猫的 name，那么hashCode就需要散列该 name，而不是小猫的 color 或 size。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;equals：&lt;/strong&gt;是否同一个对象实例。注意，是“实例”。比如String s = new String(“test”);  s.equals(s), 这就是同一个对象实例的比较；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;等号(==)：&lt;/strong&gt;对比对象实例的内存地址（也即对象实例的ID），来判断是否是同一对象实例；又可以说是判断对象实例是否物理相等；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hashcode：&lt;/strong&gt;我觉得可以这样理解：并不是对象的内存地址，而是利用hash算法，对对象实例的一种描述符（或者说对象存储位置的hash算法映射）——对象实例的哈希码。&lt;/p&gt;
&lt;p&gt;==比较的是对象的地址&lt;br&gt;String重写的equals比较的是字符串的内容值&lt;br&gt;String重写的hashCode已经不是对象内存地址的hash码，是根据内容产生的，因为a、b是两个完全不同的对象，也满足这条规律“equals相等的两个对象，hashCode也相等”。&lt;br&gt;System.identityHashCode是未被重写的获取对象内存地址hash码的函数，new出来的String对象的内存地址是不一样的，所以hash值也不一样&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://jet-han.oschina.io/categories/java/"/>
    
    
      <category term="java" scheme="http://jet-han.oschina.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>HashMap工作原理</title>
    <link href="http://jet-han.oschina.io/2017/07/28/HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://jet-han.oschina.io/2017/07/28/HashMap工作原理/</id>
    <published>2017-07-28T08:05:02.000Z</published>
    <updated>2017-09-06T10:38:49.022Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/java.jpg" alt="java" title="java"></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>HashMap的工作原理是近年来常见的Java面试题。几乎每个Java程序员都知道HashMap，都知道哪里要用HashMap，知道Hashtable和HashMap之间的区别，那么为何这道面试题如此特殊呢？是因为这道题考察的深度很深。这题经常出现在高级或中高级面试中。投资银行更喜欢问这个问题，甚至会要求你实现HashMap来考察你的编程能力。ConcurrentHashMap和其它同步集合的引入让这道题变得更加复杂。让我们开始探索的旅程吧！<br><a id="more"></a></p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><strong>“你用过HashMap吗？” “什么是HashMap？你为什么用到它？”</strong></p>
<p>几乎每个人都会回答“是的”，然后回答HashMap的一些特性，譬如HashMap可以接受null键值和值，而Hashtable则不能；HashMap是非synchronized;HashMap很快；以及HashMap储存的是键值对等等。这显示出你已经用过HashMap，而且对它相当的熟悉。但是面试官来个急转直下，从此刻开始问出一些刁钻的问题，关于HashMap的更多基础的细节。面试官可能会问出下面的问题：</p>
<p><strong>“你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？”</strong><br>你也许会回答“我没有详查标准的Java API，你可以看看Java源代码或者Open JDK。”“我可以用Google找到答案。”</p>
<p>但一些面试者可能可以给出答案，“HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用<code>get(key)</code>从HashMap中获取对象。当我们给<code>put()</code>方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry。这一点有助于理解获取对象的逻辑。如果你没有意识到这一点，或者错误的认为仅仅只在bucket中存储值的话，你将不会回答如何从HashMap中获取对象的逻辑。这个答案相当的正确，也显示出面试者确实知道hashing以及HashMap的工作原理。但是这仅仅是故事的开始，当面试官加入一些Java程序员每天要碰到的实际场景的时候，错误的答案频现。下个问题可能是关于HashMap中的碰撞探测(collision detection)以及碰撞的解决方法：</p>
<p>“当两个对象的hashcode相同会发生什么？” 从这里开始，真正的困惑开始了，一些面试者会回答因为hashcode相同，所以两个对象是相等的，HashMap将会抛出异常，或者不会存储它们。然后面试官可能会提醒他们有equals()和hashCode()两个方法，并告诉他们两个对象就算hashcode相同，但是它们可能并不相等。一些面试者可能就此放弃，而另外一些还能继续挺进，他们回答“因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。”这个答案非常的合理，虽然有很多种处理碰撞的方法，这种方法是最简单的，也正是HashMap的处理方法。但故事还没有完结，面试官会继续问：</p>
<p>“如果两个键的hashcode相同，你如何获取值对象？” 面试者会回答：当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。面试官提醒他如果有两个值对象储存在同一个bucket，他给出答案:将会遍历链表直到找到值对象。面试官会问因为你并没有值对象去比较，你是如何确定确定找到值对象的？除非面试者直到HashMap在链表中存储的是键值对，否则他们不可能回答出这一题。</p>
<p>其中一些记得这个重要知识点的面试者会说，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。完美的答案！</p>
<p>许多情况下，面试者会在这个环节中出错，因为他们混淆了<code>hashCode()</code>和<code>equals()</code>方法。因为在此之前hashCode()屡屡出现，而equals()方法仅仅在获取值对象的时候才出现。一些优秀的开发者会指出使用不可变的、声明作final的对象，并且采用合适的<code>equals()</code>和<code>hashCode()</code>方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。</p>
<p>如果你认为到这里已经完结了，那么听到下面这个问题的时候，你会大吃一惊。“如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？”除非你真正知道HashMap的工作原理，否则你将回答不出这道题。默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。</p>
<p>如果你能够回答这道问题，下面的问题来了：“你了解重新调整HashMap大小存在什么问题吗？”你可能回答不上来，这时面试官会提醒你当多线程的情况下，可能产生条件竞争(race condition)。</p>
<p>当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？：）</p>
<p>为什么<code>String</code>, <code>Interger</code>这样的<code>wrapper</code>类适合作为键？ String, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且<code>String</code>最为常用。因为String是不可变的，也是final的，而且已经重写了<code>equals()</code>和<code>hashCode()</code>方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算<code>hashCode()</code>，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。<br>我们可以使用自定义的对象作为键吗？ 这是前一个问题的延伸。当然你可能使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。<br>我们可以使用CocurrentHashMap来代替Hashtable吗？这是另外一个很热门的面试题，因为ConcurrentHashMap越来越多人用了。我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。看看这篇博客查看Hashtable和ConcurrentHashMap的区别。<br>我个人很喜欢这个问题，因为这个问题的深度和广度，也不直接的涉及到不同的概念。让我们再来看看这些问题设计哪些知识点：</p>
<p>hashing的概念<br>HashMap中解决碰撞的方法<br><code>equals()</code>和<code>hashCode()</code>的应用，以及它们在HashMap中的重要性<br>不可变对象的好处<br>HashMap多线程的条件竞争<br>重新调整HashMap的大小</p>
<p><strong>HashMap的工作原理</strong><br>HashMap基于hashing原理，我们通过<code>put()</code>和<code>get()</code>方法储存和获取对象。当我们将键值对传递给<code>put()</code>方法时，它调用键对象的<code>hashCode()</code>方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的<code>equals()</code>方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。</p>
<p>当两个不同的键对象的<code>hashcode</code>相同时会发生什么？ 它们会储存在同一个<code>bucket位置的链表中。键对象的</code>equals()<code>方法用来找到键值对</code>。</p>
<p>因为HashMap的好处非常多，我曾经在电子商务的应用中使用HashMap作为缓存。因为金融领域非常多的运用Java，也出于性能的考虑，我们会经常用到<code>HashMap</code>和<code>ConcurrentHashMap</code>。</p>
<p>简单归纳，hashmap的深入理解：</p>
<p>HashMap的数据结构是基于<font color="#c00">数组和链表</font>的。（以数组存储元素，如有hash相同的元素，在数组结构中，创建链表结构，再把hash相同的元素放到链表的下一个节点）</p>
<p>hashMap的结构类似这样<br>  元素0—&gt;[hashCode=0, key.value=x1的数据]<br>  元素1—&gt;[hashCode=1, key.value=y1的数据]<br>  。。。。。。<br>  元素n—&gt;[hashCode=n, key.value=z1的数据]  </p>
<p>假设没有hashCode=1的元素加入，但是有两个hashCode=0的数据，它的结构就变成这样<br>  元素0—&gt;[hashCode=0, key.value=x1的数据].next—&gt;[hashCode=0, key.value=x2的数据]<br>  元素1—&gt;[null]<br>  ……<br>  元素n—&gt;[hashCode=n, key.value=z1的数据]  </p>
<p><code>put</code>和<code>get</code>都首先会调用<code>hashcode</code>方法，去查找相关的<code>key</code>，当有冲突时，再调用<code>equals</code>（这也是为什么刚开始就重温<code>hashcode</code>和<code>equals</code>的原因）！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;HashMap的工作原理是近年来常见的Java面试题。几乎每个Java程序员都知道HashMap，都知道哪里要用HashMap，知道Hashtable和HashMap之间的区别，那么为何这道面试题如此特殊呢？是因为这道题考察的深度很深。这题经常出现在高级或中高级面试中。投资银行更喜欢问这个问题，甚至会要求你实现HashMap来考察你的编程能力。ConcurrentHashMap和其它同步集合的引入让这道题变得更加复杂。让我们开始探索的旅程吧！&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://jet-han.oschina.io/categories/java/"/>
    
    
      <category term="hashmap" scheme="http://jet-han.oschina.io/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>多线程之volatile</title>
    <link href="http://jet-han.oschina.io/2017/07/28/volatile%E7%94%A8%E6%B3%95/"/>
    <id>http://jet-han.oschina.io/2017/07/28/volatile用法/</id>
    <published>2017-07-28T07:39:33.000Z</published>
    <updated>2017-09-06T07:34:21.367Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/java.jpg" alt="java" title="java"></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>volatile这个关键字可能很多朋友都听说过，或许也都用过。在Java 5之前，它是一个备受争议的关键字，因为在程序中使用它往往会导致出人意料的结果。在Java 5之后，volatile关键字才得以重获生机。</p>
<p>volatile关键字虽然从字面上理解起来比较简单，但是要用好不是一件容易的事情。由于volatile关键字是与Java的内存模型有关的，因此在讲述volatile关键之前，我们先来了解一下与内存模型相关的概念和知识，然后分析了volatile关键字的实现原理，最后给出了几个使用volatile关键字的场景。</p>
<p>在Java中除了long和double类型的基本类型变量的赋值和读取操作外都是原子操作，也就是说，对于变量值的简单读取操作没有必要进行同步。</p>
<p>count++不是原子操作，是3个原子操作组合<br>1.读取主存中的count值，赋值给一个局部成员变量tmp<br>2.tmp+1<br>3.将tmp赋值给count<br><a id="more"></a></p>
<h2 id="long和double的赋值操作"><a href="#long和double的赋值操作" class="headerlink" title="long和double的赋值操作"></a>long和double的赋值操作</h2><p>Java中的原子操作包括：<br>1）除long和double之外的基本类型的<strong>赋值和读取操作</strong><br>2）所有引用reference的<strong>赋值操作</strong><br>3）java.concurrent.Atomic.* 包中所有类的一切操作。</p>
<p>long和double占用的字节数都是8，也就是64bits。在32位操作系统上对64位的数据的读写要分两步完成，每一步取32位数据。这样对double和long的赋值操作就会有问题：如果有两个线程同时写一个变量内存，一个进程写低32位，而另一个写高32位，这样将导致获取的64位数据是失效的数据。因此需要使用volatile关键字来防止此类现象。volatile本身不保证获取和设置操作的原子性，仅仅保持修改的可见性。但是java的内存模型保证声明为volatile的long和double变量的get和set操作是原子的。</p>
<p>在当前的Java内存模型下，线程可以把变量保存在本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。 </p>
<p>要解决这个问题，只需要像在本程序中的这样，把该变量声明为volatile（不稳定的）即可，这就指示JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。一般说来，多任务环境下各任务间共享的标志都应该加volatile修饰。 </p>
<p>Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。 </p>
<p>Java语言规范中指出：为了获得最佳速度，允许线程保存共享成员变量的私有拷贝，而且只当线程进入或者离开同步代码块时才与共享成员变量的原始值对比。 </p>
<p>这样当多个线程同时与某个对象交互时，就必须要注意到要让线程及时的得到共享成员变量的变化。 </p>
<p>而volatile关键字就是提示VM：对于这个成员变量不能保存它的私有拷贝，而应直接与共享成员变量交互。 </p>
<p>使用建议：在两个或者更多的线程访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，不必使用。 </p>
<p>由于使用volatile屏蔽掉了VM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>public class UnatomicLong implements Runnable {
    private static long test = 0;

    private final long val;

    public UnatomicLong(long val) {
        this.val = val;
    }

    @Override
    public void run() {
        while (!Thread.interrupted()) {
            test = val; //两个线程都试图将自己的私有变量val赋值给类私有静态变量test
        }
    }

    public static void main(String[] args) {
        Thread t1 = new Thread(new UnatomicLong(-1));
        Thread t2 = new Thread(new UnatomicLong(0));

        System.out.println(Long.toBinaryString(-1));
        System.out.println(pad(Long.toBinaryString(0), 64));

        t1.start();
        t2.start();

        long val;
        while ((val = test) == -1 || val == 0) { 
       //如果静态成员test的值是-1或0，说明两个线程操作没有交叉
        }

        System.out.println(pad(Long.toBinaryString(val), 64));
        System.out.println(val);

        t1.interrupt();
        t2.interrupt();
    }

    // prepend 0s to the string to make it the target length
    private static String pad(String s, int targetLength) {
        int n = targetLength - s.length();
        for (int x = 0; x &lt; n; x++) {
            s = &quot;0&quot; + s;
        }
        return s;
    }
}
</code></pre><p>运行发现程序在while循环时进入了死循环，这是因为使用的JVM是64bits。在64位JVM中double和long的赋值操作是原子操作。<br>在eclipse中修改jre为一个32bit的JVM地址，则会有如下运行结果：<br>1111111111111111111111111111111111111111111111111111111111111111<br>0000000000000000000000000000000000000000000000000000000000000000<br>0000000000000000000000000000000011111111111111111111111111111111<br>//很明显test的值被破坏了<br>4294967295</p>
<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。</p>
<p>也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：</p>
<pre><code>    i = i + 1;
</code></pre><p>当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p>
<p>这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p>
<p>比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？</p>
<p>可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p>
<p>最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p>
<p>也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p>
<p><strong>为了解决缓存不一致性问题，通常来说有以下2种解决方法(硬件层面)：</strong></p>
<p>1) 通过在总线加LOCK#锁的方式</p>
<p>2) 通过缓存一致性协议</p>
<p>在早期的CPU当中，是通过在<strong>总线上加LOCK#锁</strong>的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p>
<p>但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</p>
<p>所以就出现了<strong>缓存一致性协议</strong>。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
<p><img src="http://jet-han.oschina.io/img/volatile/cpu.jpg" alt="java" title="java"></p>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p>在并发编程中，我们通常会遇到以下三个问题：<strong>原子性问题，可见性问题，有序性问题</strong>。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>一个很经典的例子就是银行账户转账问题：</p>
<p>比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p>
<p>试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p>
<p>所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p>
<p>同样地反映到并发编程中会出现什么结果呢？</p>
<p>举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？</p>
<pre><code>i = 9;
</code></pre><p>假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。</p>
<p>那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>举个简单的例子，看下面这段代码：</p>
<pre><code>  //线程1执行的代码
  int i = 0;
  i = 10;

  //线程2执行的代码
  j = i;
</code></pre><p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p>
<p>此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p>
<p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p>
<pre><code>  int i = 0;              
  boolean flag = false;
  i = 1;                //语句1  
  flag = true;          //语句2
</code></pre><p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p>
<p>下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>
<p>比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p>
<p>但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p>
<pre><code>  int a = 10;    //语句1
  int r = 2;    //语句2
  a = a + 3;    //语句3
  r = a*a;     //语句4
</code></pre><p>这段代码有4个语句，那么可能的一个执行顺序是：语句2  语句1   语句3  语句4</p>
<p>那么可不可能是这个执行顺序呢： 语句2   语句1    语句4   语句3</p>
<p>不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p>
<p>虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p>
<pre><code>  //线程1:
  context = loadContext();   //语句1
  inited = true;             //语句2

  //线程2:
  while(!inited ){
    sleep()
  }
  doSomethingwithconfig(context);
</code></pre><p>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p>
<p>从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p>
<p><strong>要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</strong></p>
<h2 id="内存模型-1"><a href="#内存模型-1" class="headerlink" title="内存模型"></a>内存模型</h2><p>在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。</p>
<p>在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</p>
<p>Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>
<p>举个简单的例子：在java中，执行下面这个语句：</p>
<pre><code>  i  = 10;
</code></pre><p>执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p>
<p>那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p>
<p><strong>原子性</strong></p>
<p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p>
<p>上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p>
<p>请分析以下哪些操作是原子性操作：</p>
<pre><code>  x = 10;         //语句1，原子操作
  y = x;         //语句2，非原子操作
  x++;           //语句3，非原子操作
  x = x + 1;     //语句4，非原子操作
</code></pre><p>咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>
<p>语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p>
<p>语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p>
<p>同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>
<p>所以上面4个语句只有语句1的操作具备原子性。</p>
<p><strong>只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</strong></p>
<p>不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。如<a href="http://jet-han.oschina.io/2017/07/28/volatile%E7%94%A8%E6%B3%95/#long和double的赋值操作">long和double</a>但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p>
<p>从上面可以看出<strong>Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</strong></p>
<p><strong>可见性</strong></p>
<p>对于可见性，Java提供了volatile关键字来保证可见性。</p>
<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<p><strong>有序性</strong></p>
<p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>
<p>另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>
<p>下面就来具体介绍下happens-before原则（先行发生原则）：</p>
<p>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作<br>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作<br>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作<br>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C<br>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作<br>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生<br>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行<br>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始<br>这8条原则摘自《深入理解Java虚拟机》。</p>
<p>这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p>
<p>下面我们来解释一下前4条规则：</p>
<p>对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</p>
<p>第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果处于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</p>
<p>第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p>
<p>第四条规则实际上就是体现happens-before原则具备传递性。</p>
<h2 id="深入剖析"><a href="#深入剖析" class="headerlink" title="深入剖析"></a>深入剖析</h2><p>在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。</p>
<p><strong>volatile关键字的两层语义</strong></p>
<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<p>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>
<p>2）禁止进行指令重排序。</p>
<p>先看一段代码，假如线程1先执行，线程2后执行：</p>
<pre><code>  //线程1
  boolean stop = false;
  while(!stop){
      doSomething();
  }

  //线程2
  stop = true;
</code></pre><p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>
<p>下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>
<p>那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>
<p>但是用volatile修饰之后就变得不一样了：</p>
<p>**第一：使用volatile关键字会强制将修改的值立即写入主存；   </p>
<p>**第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；  </p>
<p><strong>第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</strong></p>
<p>那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>
<p>那么线程1读取到的就是最新的正确的值。</p>
<p><strong>volatile保证原子性吗？</strong></p>
<p>从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？</p>
<p>下面看一个例子：</p>
<pre><code>  public class Test {
      public volatile int inc = 0;

      public void increase() {
          inc++;
      }

      public static void main(String[] args) {
          final Test test = new Test();
          for(int i=0;i&lt;10;i++){
              new Thread(){
                  public void run() {
                      for(int j=0;j&lt;1000;j++)
                          test.increase();
                  };
              }.start();
          }

          while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完
              Thread.yield();
          System.out.println(test.inc);
      }
  }
</code></pre><p>大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>
<p>(但是这里有个坑，如果在单核cpu下执行这段代码，运行结果同样是每次都是10000，所以本地测试时小心哈，不过一般情况下也不会，我的开发环境在虚拟机下，所以设置的处理器数量为1，改大了后正常)</p>
<p>可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>
<p>这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>
<p>在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>
<p>假如某个时刻变量inc的值为10，</p>
<p>线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>
<p>然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>
<p>然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>
<p>那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>
<p><strong>解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</strong></p>
<p>根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p>
<p>把上面的代码改成以下任何一种都可以达到效果：</p>
<p><strong>采用synchronized：</strong></p>
<pre><code>public class Test {
    public  int inc = 0;

    public synchronized void increase() {
        inc++;
    }

    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&lt;1000;j++)
                        test.increase();
                };
            }.start();
        }

        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
</code></pre><p><strong>采用Lock：</strong></p>
<pre><code>public class Test {
    public  int inc = 0;
    Lock lock = new ReentrantLock();

    public  void increase() {
        lock.lock();
        try {
            inc++;
        } finally{
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&lt;1000;j++)
                        test.increase();
                };
            }.start();
        }

        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
</code></pre><p><strong>采用AtomicInteger：</strong></p>
<pre><code>public class Test {
    public  AtomicInteger inc = new AtomicInteger();

    public  void increase() {
        inc.getAndIncrement();
    }

    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i&lt;10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j&lt;1000;j++)
                        test.increase();
                };
            }.start();
        }

        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
</code></pre><p>在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>
<p><strong>volatile能保证有序性吗？</strong></p>
<p>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p>
<p>volatile关键字禁止指令重排序有两层意思：</p>
<p>1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>
<p>2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p>
<p>可能上面说的比较绕，举个简单的例子：</p>
<pre><code>  //x、y为非volatile变量
  //flag为volatile变量

  x = 2;        //语句1
  y = 0;        //语句2
  flag = true;  //语句3
  x = 4;         //语句4
  y = -1;       //语句5
</code></pre><p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会将语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p>
<p>并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p>
<p>那么我们回到前面举的一个例子：</p>
<pre><code>  //线程1:
  context = loadContext();   //语句1
  inited = true;             //语句2

  //线程2:
  while(!inited ){
    sleep()
  }
  doSomethingwithconfig(context);
</code></pre><p>前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么就可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>
<p>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>
<p><strong>volatile的原理和实现机制</strong></p>
<p>前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p>
<p>下面这段话摘自《深入理解Java虚拟机》：</p>
<p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>
<p>lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>
<p>1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p>
<p>2）它会强制将对缓存的修改操作立即写入主存；</p>
<p>3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>
<p>1）对变量的写操作不依赖于当前值</p>
<p>2）该变量没有包含在具有其他变量的不变式中</p>
<p>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>
<p>事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p>
<p>下面列举几个Java中使用volatile的几个场景。</p>
<p><strong>状态标记量</strong>  </p>
<pre><code>volatile boolean flag = false;

while(!flag){
    doSomething();
}

public void setFlag() {
    flag = true;
}
</code></pre><p><strong>double check</strong></p>
<pre><code>class Singleton{
    private volatile static Singleton instance = null;

    private Singleton() {

    }

    public static Singleton getInstance() {
        if(instance==null) {
            synchronized (Singleton.class) {
                if(instance==null)
                    instance = new Singleton();
            }
        }
        return instance;
    }
}
</code></pre><p><a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="external">原文链接</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;volatile这个关键字可能很多朋友都听说过，或许也都用过。在Java 5之前，它是一个备受争议的关键字，因为在程序中使用它往往会导致出人意料的结果。在Java 5之后，volatile关键字才得以重获生机。&lt;/p&gt;
&lt;p&gt;volatile关键字虽然从字面上理解起来比较简单，但是要用好不是一件容易的事情。由于volatile关键字是与Java的内存模型有关的，因此在讲述volatile关键之前，我们先来了解一下与内存模型相关的概念和知识，然后分析了volatile关键字的实现原理，最后给出了几个使用volatile关键字的场景。&lt;/p&gt;
&lt;p&gt;在Java中除了long和double类型的基本类型变量的赋值和读取操作外都是原子操作，也就是说，对于变量值的简单读取操作没有必要进行同步。&lt;/p&gt;
&lt;p&gt;count++不是原子操作，是3个原子操作组合&lt;br&gt;1.读取主存中的count值，赋值给一个局部成员变量tmp&lt;br&gt;2.tmp+1&lt;br&gt;3.将tmp赋值给count&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://jet-han.oschina.io/categories/java/"/>
    
    
      <category term="volatile" scheme="http://jet-han.oschina.io/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>java常量池</title>
    <link href="http://jet-han.oschina.io/2017/07/28/java%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
    <id>http://jet-han.oschina.io/2017/07/28/java常量池/</id>
    <published>2017-07-28T04:36:43.000Z</published>
    <updated>2017-08-13T01:45:26.063Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/java.jpg" alt="java" title="java"></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>接上一篇文章继续探索string类牵带出的常量池</p>
<h2 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h2><p><strong>程序计数器：</strong><br>1.在IDE上编译的Java代码运行时都会被转译成字节码。程序计数器的就是给编译好的字节码添加行号，这样这些字节码就以程序计数器的编号来作为调度时候的标识了。</p>
<p>2.在程序运行时，诸如循环，跳转，异常处理这些功能都必须依赖于字节码来完。</p>
<p>我的理解：字节码是二进制文件，所以识别起来很难，代表一个功能的字节码数量巨大。如果在编译的时候就将其在程序计数器上进行编号，则后期调用的时候就可以按照程序员在IDE上用高级语言编译时候的顺序进行分条执行了。<br><a id="more"></a><br><strong>栈：</strong><br>栈不灵活，但是很严格，是安全的，易于管理。因为只要上面的引用没有销毁，下面引用就一定还在，在大部分程序中，都是先定义的变量、引用先进栈，后定义的后进栈，同时，区块内部的变量、引用在进入区块时压栈，区块结束时出栈，理解了这种机制，我们就可以很方便地理解各种编程语言的作用域的概念了，同时这也是栈的优点——错误的引用逻辑在编译时就可以被发现，主要存放引用和基本数据类型。包括：<br>&ensp;&ensp;&ensp;<strong>1.本地方法栈：</strong>是jvm调用操作系统方法所使用的栈。</p>
<p>&ensp;&ensp;&ensp;<strong>2.虚拟机栈：</strong>是jvm执行java代码所使用的栈。</p>
<p><strong>方法区：</strong>存放了一些常量、静态变量、类信息等，可以理解成class文件在内存中的存放位置。</p>
<p><strong>虚拟机堆：</strong><br>堆很灵活，但是不安全。对于对象，我们要动态地创建、销毁，不能说后创建的对象没有销毁，先前创建的对象就不能销毁，那样的话我们的程序就寸步难行，所以Java中用堆来存储对象。而一旦堆中的对象被销毁，我们继续引用这个对象的话，就会出现著名的 NullPointerException，这就是堆的缺点——错误的引用逻辑只有在运行时才会被发现。主要用来存放 new 出来的对象实例。</p>
<p><strong>Java中的常量池：</strong>，实际上分为两种形态：静态常量池和运行时常量池。</p>
<p>&ensp;&ensp;&ensp;<strong>1.静态常量池：</strong>，即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。</p>
<p>&ensp;&ensp;&ensp;<strong>2.运行时常量池：</strong>，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。</p>
<p>接下来我们引用一些网络上流行的常量池例子，然后借以讲解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">String s1 = &quot;Hello&quot;;  </div><div class="line">String s2 = &quot;Hello&quot;;  </div><div class="line">String s3 = &quot;Hel&quot; + &quot;lo&quot;;  </div><div class="line">String s4 = &quot;Hel&quot; + new String(&quot;lo&quot;);  </div><div class="line">String s5 = new String(&quot;Hello&quot;);  </div><div class="line">String s6 = s5.intern();  </div><div class="line">String s7 = &quot;H&quot;;  </div><div class="line">String s8 = &quot;ello&quot;;  </div><div class="line">String s9 = s7 + s8;  </div><div class="line">            </div><div class="line">System.out.println(s1 == s2);  // true  </div><div class="line">System.out.println(s1 == s3);  // true  </div><div class="line">System.out.println(s1 == s4);  // false  </div><div class="line">System.out.println(s1 == s9);  // false  </div><div class="line">System.out.println(s4 == s5);  // false  </div><div class="line">System.out.println(s1 == s6);  // true</div></pre></td></tr></table></figure></p>
<p> 在上节中提到，在java 中，直接使用==操作符，比较的是两个字符串的引用地址，并不是比较内容，比较内容请用equals()方法。</p>
<p>s1 == s2这个非常好理解，s1、s2在赋值时，均使用的字符串字面量，说白话点，就是直接把字符串写死，在编译期间，这种字面量会直接放入class文件的常量池中，从而实现复用，载入运行时常量池后，s1、s2指向的是同一个内存地址，所以相等。</p>
<p>s1 == s3这个地方有个坑，s3虽然是动态拼接出来的字符串，但是所有参与拼接的部分都是已知的字面量，在编译期间，这种拼接会被优化，编译器直接帮你拼好，因此String s3 = “Hel” + “lo”;在class文件中被优化成String s3 = “Hello”;，所以s1 == s3成立。</p>
<p>s1 == s4当然不相等，s4虽然也是拼接出来的，但new String(“lo”)这部分不是已知字面量，是一个不可预料的部分，编译器不会优化，必须等到运行时才可以确定结果，结合字符串不变定理，鬼知道s4被分配到哪去了，所以地址肯定不同。配上一张简图理清思路：</p>
<p><img src="http://jet-han.oschina.io/img/java常量池/string1.jpg" alt="java字符串不变" title="java字符串不变"></p>
<p>s1 == s9也不相等，道理差不多，虽然s7、s8在赋值的时候使用的字符串字面量，但是拼接成s9的时候，s7、s8作为两个变量，都是不可预料的，编译器毕竟是编译器，不可能当解释器用，所以不做优化，等到运行时，s7、s8拼接成的新字符串，在堆中地址不确定，不可能与方法区常量池中的s1地址相同。</p>
<p><img src="http://jet-han.oschina.io/img/java常量池/string2.png" alt="jvm常量池，堆，栈内存分布" title="jvm常量池，堆，栈内存分布"></p>
<p>s4 == s5已经不用解释了，绝对不相等，二者都在堆中，但地址不同。</p>
<p>s1 == s6这两个相等完全归功于intern方法，s5在堆中，内容为Hello ，intern方法会尝试将Hello字符串添加到常量池中，并返回其在常量池中的地址，因为常量池中已经有了Hello字符串，所以intern方法直接返回地址；而s1在编译期就已经指向常量池了，因此s1和s6指向同一地址，相等。</p>
<p>至此，我们可以得出三个非常重要的结论：</p>
<p>&ensp;&ensp;&ensp;<strong>必须要关注编译期的行为，才能更好的理解常量池。</strong></p>
<p>&ensp;&ensp;&ensp;<strong>运行时常量池中的常量，基本来源于各个class文件中的常量池。</strong></p>
<p>&ensp;&ensp;&ensp;<strong>程序运行时，除非手动向常量池中添加常量(比如调用intern方法)，否则jvm不会自动添加常量到常量池。</strong></p>
<p>以上所讲仅涉及字符串常量池，实际上还有整型常量池、浮点型常量池等等，但都大同小异，只不过数值类型的常量池不可以手动添加常量，程序启动时常量池中的常量就已经确定了，比如整型常量池中的常量范围：-128~127，只有这个范围的数字可以用到常量池。</p>
<p>说了这么多理论，接下来让我们触摸一下真正的常量池。</p>
<p>前文提到过，class文件中存在一个静态常量池，这个常量池是由编译器生成的，用来存储java源文件中的字面量(本文仅仅关注字面量)，假设我们有如下java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String s = &quot;hi&quot;;</div></pre></td></tr></table></figure></p>
<p>为了方便起见，就这么简单，没错！将代码编译成class文件后，用UE打开二进制格式的class文件。如图：</p>
<p><img src="http://jet-han.oschina.io/img/java常量池/string3.png" alt="二进制格式的class文件" title="二进制格式的class文件"></p>
<p>在命令行我们通过javap工具来查看一个class文件的字节码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javap -v test</div></pre></td></tr></table></figure></p>
<p>如图所示：</p>
<p><img src="http://jet-han.oschina.io/img/java常量池/string4.png" alt="二进制格式的class文件" title="二进制格式的class文件"></p>
<p>简单讲解一下class文件的结构，开头的4个字节是class文件魔数，用来标识这是一个class文件，说白话点就是文件头，既：CA FE BA BE。</p>
<p>紧接着4个字节是java的版本号，这里的版本号是34，因为笔者是用jdk8编译的，版本号的高低和jdk版本的高低相对应，高版本可以兼容低版本，但低版本无法执行高版本。所以，如果哪天读者想知道别人的class文件是用什么jdk版本编译的，就可以看这4个字节，对应关系如下：</p>
<p>jdk1.4 对应48 （00 30）,<br>jdk1.5 对应49,（00 31）,<br>jdk1.6 对应50,（00 32）,<br>jdk1.7 对应51,（00 33）,<br>jdk1.8 对应52,（00 34）, </p>
<p>接下来就是常量池入口，入口处用2个字节标识常量池常量数量，本例中数值为00 13，翻译成十进制是19，也就是有18个常量，其中第0个常量是特殊值，所以只有18个常量。</p>
<p>常量池中存放了各种类型的常量，他们都有自己的类型，并且都有自己的存储规范，本文只关注字符串常量  </p>
<p>01 00 02 68 69 ，其中01代表的是“utf-8编码的字符串”，00 02代表的是这个字符串的长度是2个字节，68 69这2个字节代表的就是这个字符串的内容，因为是<a href="http://www.ascii.net.cn/" target="_blank" rel="external"><font color="#0366d6">ascii码</font></a>，每个字节对应一个字符，翻译过来就是hi</p>
<p>接下来再说说运行时常量池，由于运行时常量池在方法区中，我们可以通过jvm参数：-XX:PermSize、-XX:MaxPermSize来设置方法区大小，从而间接限制常量池大小。</p>
<p>假设jvm启动参数为：-XX:PermSize＝2M -XX:MaxPermSize＝2M，然后运行如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//保持引用，防止自动垃圾回收</div><div class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line">        </div><div class="line">int i = 0;</div><div class="line">        </div><div class="line">while(true)&#123;</div><div class="line">    //通过intern方法向常量池中手动添加常量</div><div class="line">    list.add(String.valueOf(i++).intern());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>程序立刻会抛出：Exception in thread “main” java.lang.outOfMemoryError: PermGen space异常。PermGen space正是方法区，足以说明常量池在方法区中。</p>
<p>在jdk8中，移除了方法区，转而用Metaspace区域替代，所以我们需要使用新的jvm参数：-XX:MaxMetaspaceSize=2M，依然运行如上代码，抛出：java.lang.OutOfMemoryError: Metaspace异常。同理说明运行时常量池是划分在Metaspace区域中。具体关于Metaspace区域的知识，请读者自行搜索。</p>
<p>本文所有代码均在jdk7、jdk8下测试通过，其他版本jdk可能会略有差异，请读者自行探索。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;接上一篇文章继续探索string类牵带出的常量池&lt;/p&gt;
&lt;h2 id=&quot;jvm&quot;&gt;&lt;a href=&quot;#jvm&quot; class=&quot;headerlink&quot; title=&quot;jvm&quot;&gt;&lt;/a&gt;jvm&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;程序计数器：&lt;/strong&gt;&lt;br&gt;1.在IDE上编译的Java代码运行时都会被转译成字节码。程序计数器的就是给编译好的字节码添加行号，这样这些字节码就以程序计数器的编号来作为调度时候的标识了。&lt;/p&gt;
&lt;p&gt;2.在程序运行时，诸如循环，跳转，异常处理这些功能都必须依赖于字节码来完。&lt;/p&gt;
&lt;p&gt;我的理解：字节码是二进制文件，所以识别起来很难，代表一个功能的字节码数量巨大。如果在编译的时候就将其在程序计数器上进行编号，则后期调用的时候就可以按照程序员在IDE上用高级语言编译时候的顺序进行分条执行了。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://jet-han.oschina.io/categories/java/"/>
    
    
      <category term="常量池" scheme="http://jet-han.oschina.io/tags/%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>string比较之‘’equals‘’和‘’==‘’</title>
    <link href="http://jet-han.oschina.io/2017/07/28/string%E6%AF%94%E8%BE%83%E4%B9%8B%E2%80%98%E2%80%99equals%E2%80%98%E2%80%99%E5%92%8C%E2%80%98%E2%80%99==%E2%80%98%E2%80%99/"/>
    <id>http://jet-han.oschina.io/2017/07/28/string比较之‘’equals‘’和‘’==‘’/</id>
    <published>2017-07-28T03:06:56.000Z</published>
    <updated>2017-08-13T01:45:26.093Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/java.jpg" alt="java" title="java"></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>最近我发现了一个事情，那就是在面试笔试中，好多公司都喜欢在String字符串上出问题，涉及到方方面面的知识，包括其中的一些常用方法。在此，我总结下关于String类中的equals方法，以备应对以后的笔试面试。</p>
<h2 id="equals和”-”"><a href="#equals和”-”" class="headerlink" title="equals和”==”"></a>equals和”==”</h2><p>string是一个final class，两种声明方法 :<br>1.通过new关键字，创建一个新对象，分配一块新的、独立的内存堆<br>String s1 = new String(“Hello”);<br>2.直接赋值，创建一个”Hello”字符串放入字符串常量池里面,s2只是这个字符串的引用.<br>String s2 = “Hello”;</p>
<p>这里s2属于字符串字面量，下一节会详细介绍</p>
<p>在java 中，string重写了equals和hashCode方法，都是以字符串内容复写的，直接使用”==”操作符，比较的是两个字符串的引用是否指向同一个对象，并不是比较内容，”equals”方法比较的是字符串内容，所以如果”==”返回true则”equals”一定为true,反之则不然。<br><a id="more"></a><br>下面来看具体例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">String s1 = new String(&quot;Hello&quot;);</div><div class="line">String s2 = new String(&quot;Hello&quot;);</div><div class="line">System.out.println(s1 == s2);// false</div><div class="line">System.out.println(s1.equals(s2)); //true</div><div class="line"></div><div class="line">String s3 = new String(&quot;Hello&quot;);</div><div class="line">String s4 = s3;</div><div class="line">System.out.println(s3 == s4);// true</div><div class="line">System.out.println(s3.equals(s4));// true</div><div class="line"></div><div class="line">String s5 = &quot;Hello&quot;;</div><div class="line">String s6 = &quot;Hello&quot;;</div><div class="line">System.out.println(s5 == s6);// true</div><div class="line">System.out.println(s5.equals(s6));// true</div><div class="line"></div><div class="line">String s7 = &quot;Hello&quot;;</div><div class="line">String s8 = new String(&quot;Hello&quot;);</div><div class="line">System.out.println(s7 == s8);// false，</div><div class="line">System.out.println(s7.equals(s8));// true</div><div class="line"></div><div class="line">String s9 = s3.intern();</div><div class="line">System.out.println(s7 == s9);// true，</div><div class="line">System.out.println(s7.equals(s9));// true</div></pre></td></tr></table></figure></p>
<p>intern方法会尝试将Hello字符串添加到常量池中，并返回其在常量池中的地址，因为常量池中已经有了Hello字符串，所以intern方法直接返回地址；而s7在编译期就已经指向常量池了，因此s7和s9指向同一地址，相等。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>假设有一个类，它有一个记录消息的方法，这个方法记录用户传来的消息(假设消息内容可能较大，并且重复率较高)，并且把消息按接收顺序记录在一个列表中。我想有些朋友会这样设计：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class Messages &#123;</div><div class="line"></div><div class="line">ArrayList messages = new ArrayList();</div><div class="line"></div><div class="line">public void record(String msg) &#123;</div><div class="line">messages.add(msg);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public List getMessages() &#123;</div><div class="line">return messages;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种设计方案好吗？假设我们重复的发送给record()方法同一个消息(消息来自不同的用户，所以可以视每个消息为一个new String(“…”))，并且消息内容较大，那么这个设计将会大大浪费内存空间，因为消息列表中记录的都是新创建的、独立的String对象，虽然它们的内容都相同。那么怎么样可以对其进行优化呢，其实很简单，请看如下优化后的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class Messages &#123;</div><div class="line"></div><div class="line">ArrayList messages = new ArrayList();</div><div class="line"></div><div class="line">public void record(String msg) &#123;</div><div class="line">messages.add(msg.intern());</div><div class="line">&#125;</div><div class="line"></div><div class="line">public List getMessages() &#123;</div><div class="line">return messages;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正如你所看到的，原先record()方法中的messages.add(msg);代码段变成了messages.add(msg.intern());，仅仅对msg参数调用了intern()方法，这样将对重复的消息进行共享机制，从而降低了内存消耗，提高了性能。</p>
<p>自己写一个类MyString，里边有一个char[ ]  value，实现里边的equalsString方法，要求可以比较两个MyString类的对象。相等返回0，大于返回1，小于返回-1，若比较的不是MyString类型的对象，则返回-100。</p>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">package cn.ywq.test;  </div><div class="line">  </div><div class="line">class MyString &#123;  </div><div class="line">      </div><div class="line">    char[] value;  </div><div class="line">    public MyString(char[] value) &#123;  </div><div class="line">        this.value=value;  //通过构造方法将字符传入  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">      </div><div class="line">    public int equalsString(Object obj) &#123;  </div><div class="line">        if(this==obj)&#123;  </div><div class="line">            return 0;  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        //若该对象是MyString类型的  </div><div class="line">        if(obj instanceof MyString)&#123;  </div><div class="line">            MyString string =(MyString) obj;  </div><div class="line">            int n=this.value.length;  </div><div class="line">            if (n&gt;string.value.length) &#123;  //先判断长度的关系  </div><div class="line">                return 1;  </div><div class="line">            &#125;else if(n&lt;string.value.length)&#123;  </div><div class="line">                return -1;  </div><div class="line">            &#125;else&#123;   //若长度相等  </div><div class="line">                 char v1[] = this.value;  </div><div class="line">                 char v2[] = string.value;  </div><div class="line">                    int i = 0;  </div><div class="line">                    while (n-- != 0) &#123;  //按照数组的每一位进行比较  </div><div class="line">                        if (v1[i] &gt; v2[i])&#123;  </div><div class="line">                            return 1;  </div><div class="line">                        &#125;else if(v1[i] &lt; v2[i])&#123;  </div><div class="line">                            return -1;  </div><div class="line">                        &#125;  </div><div class="line">                                  </div><div class="line">                        i++;  </div><div class="line">                    &#125;  </div><div class="line">                    return 0;  //若while循环正常结束，则说明相等，返回0  </div><div class="line">  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        return -100;  //若传入的不是MyString类型的对象  </div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;  </div><div class="line">#测试代码：</div><div class="line">package cn.ywq.test;  </div><div class="line">  </div><div class="line">public class Test &#123;  </div><div class="line">  public static void main(String[] args) &#123;  </div><div class="line">       char[] value=&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;&#125;;  </div><div class="line">       char[] value2=&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;&#125;;  </div><div class="line">       char[] value3=&#123;&apos;c&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;&#125;;  </div><div class="line">       char[] value4=&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&#125;;  </div><div class="line">          </div><div class="line">       MyString myString = new MyString(value);  </div><div class="line">       MyString s=new MyString(value4);  </div><div class="line">       int i = myString.equalsString(s);   </div><div class="line">       System.out.println(i);  </div><div class="line">   &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/java.jpg&quot; alt=&quot;java&quot; title=&quot;java&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;最近我发现了一个事情，那就是在面试笔试中，好多公司都喜欢在String字符串上出问题，涉及到方方面面的知识，包括其中的一些常用方法。在此，我总结下关于String类中的equals方法，以备应对以后的笔试面试。&lt;/p&gt;
&lt;h2 id=&quot;equals和”-”&quot;&gt;&lt;a href=&quot;#equals和”-”&quot; class=&quot;headerlink&quot; title=&quot;equals和”==”&quot;&gt;&lt;/a&gt;equals和”==”&lt;/h2&gt;&lt;p&gt;string是一个final class，两种声明方法 :&lt;br&gt;1.通过new关键字，创建一个新对象，分配一块新的、独立的内存堆&lt;br&gt;String s1 = new String(“Hello”);&lt;br&gt;2.直接赋值，创建一个”Hello”字符串放入字符串常量池里面,s2只是这个字符串的引用.&lt;br&gt;String s2 = “Hello”;&lt;/p&gt;
&lt;p&gt;这里s2属于字符串字面量，下一节会详细介绍&lt;/p&gt;
&lt;p&gt;在java 中，string重写了equals和hashCode方法，都是以字符串内容复写的，直接使用”==”操作符，比较的是两个字符串的引用是否指向同一个对象，并不是比较内容，”equals”方法比较的是字符串内容，所以如果”==”返回true则”equals”一定为true,反之则不然。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://jet-han.oschina.io/categories/java/"/>
    
    
      <category term="string" scheme="http://jet-han.oschina.io/tags/string/"/>
    
      <category term="==" scheme="http://jet-han.oschina.io/tags//"/>
    
      <category term="equals" scheme="http://jet-han.oschina.io/tags/equals/"/>
    
  </entry>
  
  <entry>
    <title>Spring单例模式与线程安全</title>
    <link href="http://jet-han.oschina.io/2017/07/26/Spring%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>http://jet-han.oschina.io/2017/07/26/Spring单例模式与线程安全/</id>
    <published>2017-07-26T10:06:49.000Z</published>
    <updated>2017-08-13T01:45:26.058Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/spring.jpg" alt="spring" title="spring"></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Spring框架里的bean，或者说组件，获取实例的时候都是默认的单例模式，这是在多线程开发的时候要尤其注意的地方。<br><a id="more"></a> </p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式的意思就是只有一个实例。单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。<br>当多用户同时请求一个服务时，容器会给每一个请求分配一个线程，这是多个线程会并发执行该请求多对应的业务逻辑（成员方法），此时就要注意了，如果该处理逻辑中有对该单列状态的修改（体现为该单列的成员属性），则必须考虑线程同步问题<br>同步机制的比较　　ThreadLocal和线程同步机制相比有什么优势呢？ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。 </p>
<p>　　在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。 </p>
<p>　　而ThreadLocal则从另一个角度来解决多线程的并发访问。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。 </p>
<p>　　由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换。但JDK 5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用<br>　概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。 </p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p> Spring使用ThreadLocal解决线程安全问题 </p>
<p>　　我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean（如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等）中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。 </p>
<p>　　一般的Web应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回响应所经过的所有程序调用都同属于一个线程<br>ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。<br>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 或者说:一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。 　线程安全问题都是由全局变量及静态变量引起的。<br>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。<br>1） 常量始终是线程安全的，因为只存在读操作。<br>2）每次调用方法前都新建一个实例是线程安全的，因为不会访问共享的资源。<br>3）局部变量是线程安全的。因为每执行一个方法，都会在独立的空间创建局部变量，它不是共享的资源。局部变量包括方法的参数变量和方法内变量。<br>有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象  ，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。<br>无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象  .不能保存数据，是不变类，是线程安全的。<br>有状态对象:<br>无状态的Bean适合用不变模式，技术就是单例模式，这样可以共享实例，提高性能。有状态的Bean，多线程环境下不安全，那么适合用Prototype原型模式。Prototype: 每次对bean的请求都会创建一个新的bean实例。<br>Struts2默认的实现是Prototype模式。也就是每个请求都新生成一个Action实例，所以不存在线程安全问题。需要注意的是，如果由Spring管理action的生命周期， scope要配成prototype作用域。</p>
<h2 id="线程安全案例"><a href="#线程安全案例" class="headerlink" title="线程安全案例"></a>线程安全案例</h2><p>SimpleDateFormat(下面简称sdf)类内部有一个Calendar对象引用,它用来储存和这个sdf相关的日期信息,例如sdf.parse(dateStr), sdf.format(date) 诸如此类的方法参数传入的日期相关String, Date等等, 都是交友Calendar引用来储存的.这样就会导致一个问题,如果你的sdf是个static的, 那么多个thread 之间就会共享这个sdf, 同时也是共享这个Calendar引用, 并且, 观察 sdf.parse() 方法,你会发现有如下的调用:</p>
<pre><code>Date parse() {
  calendar.clear(); // 清理calendar
  ... // 执行一些操作, 设置 calendar 的日期什么的
  calendar.getTime(); // 获取calendar的时间
}
</code></pre><p>这里会导致的问题就是, 如果 线程A 调用了 sdf.parse(), 并且进行了 calendar.clear()后还未执行calendar.getTime()的时候,线程B又调用了sdf.parse(), 这时候线程B也执行了sdf.clear()方法, 这样就导致线程A的的calendar数据被清空了(实际上A,B的同时被清空了). 又或者当 A 执行了calendar.clear() 后被挂起, 这时候B 开始调用sdf.parse()并顺利i结束, 这样 A 的 calendar内存储的的date 变成了后来B设置的calendar的date<br>这个问题背后隐藏着一个更为重要的问题—无状态：无状态方法的好处之一，就是它在各种环境下，都可以安全的调用。衡量一个方法是否是有状态的，就看它是否改动了其它的东西，比如全局变量，比如实例的字段。format方法在运行过程中改动了SimpleDateFormat的calendar字段，所以，它是有状态的。</p>
<p> 这也同时提醒我们在开发和设计系统的时候注意下一下三点:</p>
<p>1.自己写公用类的时候，要对多线程调用情况下的后果在注释里进行明确说明<br>2.对线程环境下，对每一个共享的可变变量都要注意其线程安全性<br>3.我们的类和方法在做设计的时候，要尽量设计成无状态的 </p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p> <strong>需要的时候创建新实例：</strong></p>
<p>说明：在需要用到SimpleDateFormat 的地方新建一个实例，不管什么时候，将有线程安全问题的对象由共享变为局部私有都能避免多线程问题，不过也加重了创建对象的负担。在一般情况下，这样其实对性能影响比不是很明显的。</p>
<p> <strong>使用同步：同步SimpleDateFormat对象</strong>     </p>
<pre><code>public class DateSyncUtil {

   private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
   public static String formatDate(Date date)throws ParseException{
   synchronized(sdf){
   return sdf.format(date);
    }  
   }
   public static Date parse(String strDate) throws ParseException{
   synchronized(sdf){
   return sdf.parse(strDate);
    }
   } 
}
</code></pre><p>说明：当线程较多时，当一个线程调用该方法时，其他想要调用此方法的线程就要block，多线程并发量大的时候会对性能有一定的影响。</p>
<p><strong>使用ThreadLocal：</strong>  　</p>
<pre><code>public class ConcurrentDateUtil {

    private static ThreadLocal&lt;DateFormat&gt; threadLocal = new ThreadLocal&lt;DateFormat&gt;() {
        @Override
        protected DateFormat initialValue() {
            return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        }
    };

    public static Date parse(String dateStr) throws ParseException {
        return threadLocal.get().parse(dateStr);
    }

    public static String format(Date date) {
        return threadLocal.get().format(date);
    }
}
</code></pre><p>或</p>
<pre><code>public class ThreadLocalDateUtil {
    private static final String date_format = &quot;yyyy-MM-dd HH:mm:ss&quot;;
    private static ThreadLocal&lt;DateFormat&gt; threadLocal = new ThreadLocal&lt;DateFormat&gt;(); 

    public static DateFormat getDateFormat()   
    {  
        DateFormat df = threadLocal.get();  
        if(df==null){  
            df = new SimpleDateFormat(date_format);  
            threadLocal.set(df);  
        }  
        return df;  
    }  

    public static String formatDate(Date date) throws ParseException {
        return getDateFormat().format(date);
    }

    public static Date parse(String strDate) throws ParseException {
        return getDateFormat().parse(strDate);
    }   
}
</code></pre><p>说明：使用ThreadLocal, 也是将共享变量变为独享，线程独享肯定能比方法独享在并发环境中能减少不少创建对象的开销。如果对性能要求比较高的情况下，一般推荐使用这种方法。</p>
<p> <strong> 抛弃JDK，使用其他类库中的时间格式化类：</strong></p>
<p>1.使用Apache commons 里的FastDateFormat，宣称是既快又线程安全的SimpleDateFormat, 可惜它只能对日期进行format, 不能对日期串进行解析。</p>
<p>2.使用Joda-Time类库来处理时间相关问题</p>
<p>做一个简单的压力测试，方法一最慢，方法三最快，但是就算是最慢的方法一性能也不差，一般系统方法一和方法二就可以满足，所以说在这个点很难成为你系统的瓶颈所在。从简单的角度来说，建议使用方法一或者方法。    如果在必要的时候，追求那么一点性能提升的话，可以考虑用方法三，用ThreadLocal做缓存。<br>Joda-Time类库对时间处理方式比较完美，建议使用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/spring.jpg&quot; alt=&quot;spring&quot; title=&quot;spring&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;Spring框架里的bean，或者说组件，获取实例的时候都是默认的单例模式，这是在多线程开发的时候要尤其注意的地方。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://jet-han.oschina.io/categories/java/"/>
    
    
      <category term="spring" scheme="http://jet-han.oschina.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>spring scope prototype与singleton</title>
    <link href="http://jet-han.oschina.io/2017/07/26/spring-scope-prototype%E4%B8%8Esingleton%E5%8C%BA%E5%88%AB/"/>
    <id>http://jet-han.oschina.io/2017/07/26/spring-scope-prototype与singleton区别/</id>
    <published>2017-07-26T10:06:11.000Z</published>
    <updated>2017-08-13T01:45:26.091Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/spring.jpg" alt="spring" title="spring"></p>
<h2 id="singleton作用域"><a href="#singleton作用域" class="headerlink" title="singleton作用域"></a>singleton作用域</h2><p>　　当一个bean的作用域设置为singleton, 那么Spring IOC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。换言之，当把一个bean定义设置为singleton作用域时，Spring IOC容器只会创建该bean定义的唯一实例。这个单一实例会被存储到单例缓存（singleton cache）中，并且所有针对该bean的后续请求和引用都将返回被缓存的对象实例。<br>     这里要注意的是singleton作用域和GOF设计模式中的单例是完全不同的，单例设计模式表示一个ClassLoader中只有一个class存在，而这里的singleton则表示一个容器对应一个bean，也就是说当一个bean被标识为singleton时候，spring的IOC容器中只会存在一个该bean。<br> <a id="more"></a></p>
<h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>　　prototype作用域部署的bean，每一次请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）都会产生一个新的bean实例，相当与一个new的操作，对于prototype作用域的bean，有一点非常重要，那就是Spring不能对一个prototype bean的整个生命周期负责，容器在初始化、配置、装饰或者是装配完一个prototype实例后，将它交给客户端，随后就对该prototype实例不闻不问了。<br>      不管何种作用域，容器都会调用所有对象的初始化生命周期回调方法，而对prototype而言，任何配置好的析构生命周期回调方法都将不会被调用。清除prototype作用域的对象并释放任何prototype bean所持有的昂贵资源，都是客户端代码的职责。（让Spring容器释放被singleton作用域bean占用资源的一种可行方式是，通过使用bean的后置处理器，该处理器持有要被清除的bean的引用。）<br>    scope=”prototype”没写的问题,项目中对一个表的增删该操作是用一个action，这个actionadd,update,delete,save这些方法， 添加和修改是共用一个页面，当页面得到id时代表进行的修改操作，反之是添加操作。因为在配置spring的bean是忘了写scope=”prototype” 所以每次添加时都显示最后一次访问过的记录,scope=”prototype” 会在该类型的对象被请求 时创建一个新的action对象。如果没有配置scope=prototype则添加的时候不会新建一个action，他任然会保留上次访问的过记录的信息 webwork的Action不是线程安全的，要求在多线程环境下必须是一个线程对应一个独立的实例，不能使用singleton。所以，我们在Spring配置Webwork Action Bean时，需要加上属性scope=”prototype”或singleton=”false”。<br>     singleton模式指的是对某个对象的完全共享，包括代码空间和数据空间，说白了，如果一个类是singleton的，假如这个类有成员变量，那么这个成员变量的值是各个线程共享的（有点类似于static的样子了），当线程A往给变量赋了一个值以后，线程B就能读出这个值。<br>      因此，对于前台Action，肯定不能使用singleton的模式，必须是一个线程请求对应一个独立的实例。推而广之，只要是带数据成员变量的类，为了防止多个线程混用数据，就不能使用singleton。对于我们用到的Service、Dao，之所以用了singleton，就是因为他们没有用到数据成员变量，如果谁的Service需要数据成员变量，请设置singleton=false。 有状态的bean都使用Prototype作用域，而对无状态的bean则应该使用singleton作用域。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/spring.jpg&quot; alt=&quot;spring&quot; title=&quot;spring&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;singleton作用域&quot;&gt;&lt;a href=&quot;#singleton作用域&quot; class=&quot;headerlink&quot; title=&quot;singleton作用域&quot;&gt;&lt;/a&gt;singleton作用域&lt;/h2&gt;&lt;p&gt;　　当一个bean的作用域设置为singleton, 那么Spring IOC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。换言之，当把一个bean定义设置为singleton作用域时，Spring IOC容器只会创建该bean定义的唯一实例。这个单一实例会被存储到单例缓存（singleton cache）中，并且所有针对该bean的后续请求和引用都将返回被缓存的对象实例。&lt;br&gt;     这里要注意的是singleton作用域和GOF设计模式中的单例是完全不同的，单例设计模式表示一个ClassLoader中只有一个class存在，而这里的singleton则表示一个容器对应一个bean，也就是说当一个bean被标识为singleton时候，spring的IOC容器中只会存在一个该bean。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://jet-han.oschina.io/categories/java/"/>
    
    
      <category term="spring" scheme="http://jet-han.oschina.io/tags/spring/"/>
    
      <category term="scope" scheme="http://jet-han.oschina.io/tags/scope/"/>
    
  </entry>
  
  <entry>
    <title>jvm内存模型</title>
    <link href="http://jet-han.oschina.io/2017/07/20/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://jet-han.oschina.io/2017/07/20/jvm内存模型/</id>
    <published>2017-07-20T06:44:40.000Z</published>
    <updated>2017-08-13T01:45:26.065Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/java.jpg" alt="jvm" title="jvm"></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>JVM定义了若干个程序执行期间使用的数据区域。这个区域里的一些数据在JVM启动的时候创建，在JVM退出的时候销毁。而其他的数据依赖于每一个线程，在线程创建时创建，在线程退出时销毁。<br><a id="more"></a><br><img src="http://jet-han.oschina.io/img/jvm内存模型/jvm.png" alt="jvm" title="jvm"></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。<br>由于Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。<br>如果线程正在执行的是一个Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie 方法，这个计数器值则为空（Undefined）。<br>此内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>线程私有，它的生命周期与线程相同。虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。<br>动画是由一帧一帧图片连续切换结果的结果而产生的，其实虚拟机的运行和动画也类似，每个在虚拟机中运行的程序也是由许多的帧的切换产生的结果，只是这些帧里面存放的是方法的局部变量，操作数栈，动态链接，方法返回地址和一些额外的附加信息组成。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>对于执行引擎来说，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法。执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。<br>局部变量表<br>局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译成Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的最大局部变量表的容量。<br>局部变量表的容量以变量槽（Slot）为最小单位，32位虚拟机中一个Slot可以存放一个32位以内的数据类型（boolean、byte、char、short、int、float、reference和returnAddress八种）。<br>reference类型虚拟机规范没有明确说明它的长度，但一般来说，虚拟机实现至少都应当能从此引用中直接或者间接地查找到对象在Java堆中的起始地址索引和方法区中的对象类型数据。<br>returnAddress类型是为字节码指令jsr、jsr_w和ret服务的，它指向了一条字节码指令的地址。<br>虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果是实例方法（非static），那么局部变量表的第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中通过this访问。<br> Slot是可以重用的，当Slot中的变量超出了作用域，那么下一次分配Slot的时候，将会覆盖原来的数据。Slot对对象的引用会影响GC（要是被引用，将不会被回收）。<br> 系统不会为局部变量赋予初始值（实例变量和类变量都会被赋予初始值）。也就是说不存在类变量那样的准备阶段。</p>
<h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><p>和局部变量区一样，操作数栈也是被组织成一个以字长为单位的数组。但是和前者不同的是，它不是通过索引来访问，而是通过标准的栈操作——压栈和出栈—来访问的。比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。<br>虚拟机在操作数栈中存储数据的方式和在局部变量区中是一样的：如int、long、float、double、reference和returnType的存储。对于byte、short以及char类型的值在压入到操作数栈之前，也会被转换为int。<br>虚拟机把操作数栈作为它的工作区——大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。比如，iadd指令就要从操作数栈中弹出两个整数，执行加法运算，其结果又压回到操作数栈中，看看下面的示例，它演示了虚拟机是如何把两个int类型的局部变量相加，再把结果保存到第三个局部变量的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">begin  </div><div class="line">iload_0    // push the int in local variable 0 ontothe stack  </div><div class="line">iload_1    //push the int in local variable 1 onto the stack  </div><div class="line">iadd       // pop two ints, add them, push result  </div><div class="line">istore_2   // pop int, store into local variable 2  </div><div class="line">end</div></pre></td></tr></table></figure></p>
<p>在这个字节码序列里，前两个指令iload_0和iload_1将存储在局部变量中索引为0和1的整数压入操作数栈中，其后iadd指令从操作数栈中弹出那两个整数相加，再将结果压入操作数栈。第四条指令istore_2则从操作数栈中弹出结果，并把它存储到局部变量区索引为2的位置。下图详细表述了这个过程中局部变量和操作数栈的状态变化，图中没有使用的局部变量区和操作数栈区域以空白表示。</p>
<p><img src="http://jet-han.oschina.io/img/jvm内存模型/stack1.png" alt="stack" title="stack"></p>
<h2 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h2><p>虚拟机运行的时候,运行时常量池会保存大量的符号引用，这些符号引用可以看成是每个方法的间接引用。如果代表栈帧A的方法想调用代表栈帧B的方法，那么这个虚拟机的方法调用指令就会以B方法的符号引用作为参数，但是因为符号引用并不是直接指向代表B方法的内存位置，所以在调用之前还必须要将符号引用转换为直接引用，然后通过直接引用才可以访问到真正的方法。<br>如果符号引用是在类加载阶段或者第一次使用的时候转化为直接应用，那么这种转换成为静态解析，如果是在运行期间转换为直接引用，那么这种转换就成为动态连接。</p>
<h2 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h2><p>方法的返回分为两种情况，一种是正常退出，退出后会根据方法的定义来决定是否要传返回值给上层的调用者，一种是异常导致的方法结束，这种情况是不会传返回值给上层的调用方法。<br>不过无论是那种方式的方法结束，在退出当前方法时都会跳转到当前方法被调用的位置，如果方法是正常退出的，则调用者的PC计数器的值就可以作为返回地址,，果是因为异常退出的，则是需要通过异常处理表来确定。<br>方法的的一次调用就对应着栈帧在虚拟机栈中的一次入栈出栈操作，因此方法退出时可能做的事情包括：恢复上层方法的局部变量表以及操作数栈，如果有返回值的话，就把返回值压入到调用者栈帧的操作数栈中，还会把PC计数器的值调整为方法调用入口的下一条指令。<br><img src="http://jet-han.oschina.io/img/jvm内存模型/stack2.png" alt="stack" title="stack"><br>异常<br>在Java 虚拟机规范中，对虚拟机栈规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的Java 虚拟机都可动态扩展，只不过Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError 异常。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈（Native MethodStacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。<br>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。但是随着JIT 编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。<br>堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”。<br>堆的大小可以通过-Xms(最小值)和-Xmx(最大值)参数设置，-Xms为JVM启动时申请的最小内存，默认为操作系统物理内存的1/64但小于1G，-Xmx为JVM可申请的最大内存，默认为物理内存的1/4但小于1G，默认当空余堆内存小于40%时，JVM会增大Heap到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列；当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小，可通过XX:MaxHeapFreeRation=来指定这个比列，对于运行系统，为避免在运行时频繁调整Heap的大小，通常-Xms与-Xmx的值设成一样。</p>
<p>如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；<br>新生代：程序新创建的对象都是从新生代分配内存，新生代由Eden Space和两块相同大小的Survivor Space(通常又称S0和S1或From和To)构成，可通过-Xmn参数来指定新生代的大小，也可以通过-XX:SurvivorRation来调整Eden Space及SurvivorSpace的大小。<br>老年代：用于存放经过多次新生代GC仍然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代，主要有两种情况：1、大对象，可通过启动参数设置-XX:PretenureSizeThreshold=1024(单位为字节，默认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。2、大的数组对象，且数组中无引用外部对象。<br>老年代所占的内存大小为-Xmx对应的值减去-Xmn对应的值。</p>
<p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区在一个jvm实例的内部，类型信息被存储在一个称为方法区的内存逻辑区中。类型信息是由类加载器在类加载时从类文件中提取出来的。类(静态)变量也存储在方法区中。<br>简单说方法区用来存储类型的元数据信息，一个.class文件是类被java虚拟机使用之前的表现形式，一旦这个类要被使用，java虚拟机就会对其进行装载、连接（验证、准备、解析）和初始化。而装载（后的结果就是由.class文件转变为方法区中的一段特定的数据结构。这个数据结构会存储如下信息：</p>
<p><strong>类型信息</strong><br>      这个类型的全限定名<br>      这个类型的直接超类的全限定名<br>      这个类型是类类型还是接口类型<br>      这个类型的访问修饰符<br>      任何直接超接口的全限定名的有序列表 </p>
<p><strong>字段信息</strong><br>      字段名<br>      字段类型<br>      字段的修饰符  </p>
<p><strong>方法信息</strong><br>      方法名<br>      方法返回类型<br>      方法参数的数量和类型（按照顺序）<br>      方法的修饰符</p>
<p><strong>其他信息</strong><br>      除了常量以外的所有类（静态）变量<br>      一个指向ClassLoader的指针<br>      一个指向Class对象的指针<br>      常量池（常量数据以及对其他类型的符号引用）  </p>
<p>JVM为每个已加载的类型都维护一个常量池。常量池就是这个类型用到的常量的一个有序集合，包括实际的常量(string,integer,和floating point常量)和对类型，域和方法的符号引用。池中的数据项象数组项一样，是通过索引访问的。</p>
<p>每个类的这些元数据，无论是在构建这个类的实例还是调用这个类某个对象的方法，都会访问方法区的这些元数据。<br>构建一个对象时，JVM会在堆中给对象分配空间，这些空间用来存储当前对象实例属性以及其父类的实例属性（而这些属性信息都是从方法区获得），注意，这里并不是仅仅为当前对象的实例属性分配空间，还需要给父类的实例属性分配，到此其实我们就可以回答第一个问题了，即实例化父类的某个子类时，JVM也会同时构建父类的一个对象。从另外一个角度也可以印证这个问题：调用当前类的构造方法时，首先会调用其父类的构造方法直到Object，而构造方法的调用意味着实例的创建，所以子类实例化时，父类肯定也会被实例化。<br>类变量被类的所有实例共享，即使没有类实例时你也可以访问它。这些变量只与类相关，所以在方法区中，它们成为类数据在逻辑上的一部分。在JVM使用一个类之前，它必须在方法区中为每个non-final类变量分配空间。</p>
<p>方法区主要有以下几个特点：<br>1、方法区是线程安全的。由于所有的线程都共享方法区，所以，方法区里的数据访问必须被设计成线程安全的。例如，假如同时有两个线程都企图访问方法区中的同一个类，而这个类还没有被装入JVM，那么只允许一个线程去装载它，而其它线程必须等待<br>2、方法区的大小不必是固定的，JVM可根据应用需要动态调整。同时，方法区也不一定是连续的，方法区可以在一个堆(甚至是JVM自己的堆)中自由分配。<br>3、方法区也可被垃圾收集，当某个类不在被使用(不可触及)时，JVM将卸载这个类，进行垃圾收集</p>
<p>可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。<br>对于习惯在HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（PermanentGeneration），本质上两者并不等价，仅仅是因为HotSpot 虚拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。<br>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。<br>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>特征</th>
<th>作用</th>
<th>配置参数</th>
<th>异常</th>
</tr>
</thead>
<tbody>
<tr>
<td>程序计数器</td>
<td>占用内存小，线程私有，生命周期与线程相同</td>
<td>大致为字节码行号指示器</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>虚拟机栈</td>
<td>线程私有，生命周期与线程相同，使用连续的内存空间</td>
<td>Java 方法执行的内存模型，存储局部变量表、操作栈、动态链接、方法出口等信息</td>
<td>-Xss</td>
<td>StackOverflowError OutOfMemoryError</td>
</tr>
<tr>
<td>java堆</td>
<td>线程共享，生命周期与虚拟机相同，可以不使用连续的内存地址</td>
<td>保存对象实例，所有对象实例（包括数组）都要在堆上分配</td>
<td>-Xms<br>-Xsx<br>-Xmn</td>
<td>OutOfMemoryError</td>
</tr>
<tr>
<td>方法区</td>
<td>线程共享，生命周期与虚拟机相同，可以不使用连续的内存地址</td>
<td>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</td>
<td>-XX:PermSize:<br>16M<br>-XX:MaxPermSize<br>64M</td>
<td>OutOfMemoryError</td>
</tr>
<tr>
<td>运行时常量池</td>
<td>方法区的一部分，具有动态性</td>
<td>存放字面量及符号引用</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError 异常出现，所以我们放到这里一起讲解。<br>在JDK 1.4 中新加入了NIO（NewInput/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O 方式，它可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java 堆里面的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java 堆和Native 堆中来回复制数据。</p>
<h2 id="堆与栈的对比"><a href="#堆与栈的对比" class="headerlink" title="堆与栈的对比"></a>堆与栈的对比</h2><p>经常有人把Java 内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。<br>堆很灵活，但是不安全。对于对象，我们要动态地创建、销毁，不能说后创建的对象没有销毁，先前创建的对象就不能销毁，那样的话我们的程序就寸步难行，所以Java中用堆来存储对象。而一旦堆中的对象被销毁，我们继续引用这个对象的话，就会出现著名的 NullPointerException，这就是堆的缺点——<font color="#e07878">错误的引用逻辑只有在运行时才会被发现</font>。<br>栈不灵活，但是很严格，是安全的，易于管理。因为只要上面的引用没有销毁，下面引用就一定还在，在大部分程序中，都是先定义的变量、引用先进栈，后定义的后进栈，同时，区块内部的变量、引用在进入区块时压栈，区块结束时出栈，理解了这种机制，我们就可以很方便地理解各种编程语言的作用域的概念了，同时这也是栈的优点——<font color="#e07878">错误的引用逻辑在编译时就可以被发现</font>。  </p>
<p><font color="#e07878">栈—主要存放引用和基本数据类型</font>。  </p>
<p><font color="#e07878">堆—用来存放 new 出来的对象实例</font>。</p>
<h2 id="内存溢出和内存泄漏"><a href="#内存溢出和内存泄漏" class="headerlink" title="内存溢出和内存泄漏"></a>内存溢出和内存泄漏</h2><p>内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer，但给它存了long才能存下的数，那就是内存溢出。<br>内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。<br>memory leak会最终会导致out ofmemory。</p>
<p>Java 堆内存的OutOfMemoryError异常是实际应用中最常见的内存溢出异常情况。出现Java 堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heapspace”。<br>要解决这个区域的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump 出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。<br>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots 引用链的信息，就可以比较准确地定位出泄漏代码的位置。<br>如果不存在泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx 与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p>
<h2 id="内存分配过程"><a href="#内存分配过程" class="headerlink" title="内存分配过程"></a>内存分配过程</h2><p>1、JVM 会试图为相关Java对象在Eden Space中初始化一块内存区域。<br>2、当Eden空间足够时，内存申请结束；否则到下一步。<br>3、JVM 试图释放在Eden中所有不活跃的对象（这属于1或更高级的垃圾回收）。释放后若Eden空间仍然不足以放入新对象，则试图将部分Eden中活跃对象放入Survivor区。<br>4、Survivor区被用来作为Eden及Old的中间交换区域，当Old区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区。<br>5、当Old区空间不够时，JVM 会在Old区进行完全的垃圾收集（0级）。<br>6、完全垃圾收集后，若Survivor及Old区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现“outofmemory”错误。</p>
<h2 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h2><p><img src="http://jet-han.oschina.io/img/jvm内存模型/jvm3.gif" alt="jvm" title="jvm"><br>对象访问在Java 语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及Java 栈、Java 堆、方法区这三个最重要内存区域之间的关联关系，如下面的这句代码：</p>
<p>Object obj = newObject();</p>
<p>假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java 栈的本地变量表中，作为一个reference 类型数据出现。而“new Object()”这部分的语义将会反映到Java 堆中，形成一块存储了Object 类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java 堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。<br>由于reference 类型在Java 虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java 堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。<br>如果使用句柄访问方式，Java 堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/java.jpg&quot; alt=&quot;jvm&quot; title=&quot;jvm&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;JVM定义了若干个程序执行期间使用的数据区域。这个区域里的一些数据在JVM启动的时候创建，在JVM退出的时候销毁。而其他的数据依赖于每一个线程，在线程创建时创建，在线程退出时销毁。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://jet-han.oschina.io/categories/java/"/>
    
    
      <category term="jvm" scheme="http://jet-han.oschina.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>nginx安装与使用</title>
    <link href="http://jet-han.oschina.io/2017/07/17/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://jet-han.oschina.io/2017/07/17/nginx安装与使用/</id>
    <published>2017-07-17T07:53:11.000Z</published>
    <updated>2017-09-08T08:07:10.228Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/nginx.jpg" alt="nginx" title="nginx"></p>
<h2 id="nginx安装"><a href="#nginx安装" class="headerlink" title="nginx安装"></a>nginx安装</h2><p>第一步，在<code>/etc/yum.repos.d/</code>目录下创建一个源配置文件<code>nginx.repo</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /etc/yum.repos.d/  </div><div class="line">vim nginx.repo</div></pre></td></tr></table></figure>
<p>填写如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[nginx]</div><div class="line">name=nginx repo  </div><div class="line">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/  </div><div class="line">gpgcheck=0  </div><div class="line">enabled=1</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>保存，则会产生一个<code>/etc/yum.repos.d/nginx.repo</code>文件。</p>
<p>下面直接执行如下指令即可自动安装好Nginx：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install nginx</div></pre></td></tr></table></figure>
<p>安装完成，下面直接就可以启动Nginx了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/init.d/nginx start</div></pre></td></tr></table></figure>
<p>我是用：服务启动并设置开机启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">service nginx start</div><div class="line">chkconfig nginx on --level 35</div><div class="line"></div><div class="line">#指定配置文件启动</div><div class="line">/usr/sbin/nginx -c /etc/nginx/nginx.conf</div></pre></td></tr></table></figure>
<p>启动成功如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[op@bogon init.d]$ ps aux | grep nginx</div><div class="line">root     19210  0.0  0.0  46348  1192 ?        Ss   14:57   0:00 nginx: master process /usr/sbin/nginx -c /etc/nginx/nginx.conf</div><div class="line">nginx    19211  0.0  0.0  46740  1968 ?        S    14:57   0:00 nginx: worker process                   </div><div class="line">nginx    19212  0.0  0.0  46740  1936 ?        S    14:57   0:00 nginx: worker process                   </div><div class="line">nginx    19214  0.0  0.0  46740  1968 ?        S    14:57   0:00 nginx: worker process                   </div><div class="line">nginx    19215  0.0  0.0  46740  1968 ?        S    14:57   0:00 nginx: worker process                   </div><div class="line">nginx    19216  0.0  0.0  46740  1936 ?        S    14:57   0:00 nginx: worker process                   </div><div class="line">nginx    19217  0.0  0.0  46740  1936 ?        S    14:57   0:00 nginx: worker process                   </div><div class="line">op       19219  0.0  0.0 103328   872 pts/0    S+   14:58   0:00 grep nginx</div></pre></td></tr></table></figure>
<p>常用命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">sudo nginx #启动nginx</div><div class="line">nginx -s reload|reopen|stop|quit  #重新加载配置|重启|停止|退出 nginx</div><div class="line">nginx -t   #测试配置是否有语法错误</div><div class="line"></div><div class="line">nginx [-?hvVtq] [-s signal] [-c filename] [-p prefix] [-g directives]</div><div class="line"></div><div class="line">-?,-h           : 打开帮助信息</div><div class="line">-v              : 显示版本信息并退出</div><div class="line">-V              : 显示版本和配置选项信息，然后退出</div><div class="line">-t              : 检测配置文件是否有语法错误，然后退出</div><div class="line">-q              : 在检测配置文件期间屏蔽非错误信息</div><div class="line">-s signal       : 给一个 nginx 主进程发送信号：stop（停止）, quit（退出）, reopen（重启）, reload（重新加载配置文件）</div><div class="line">-p prefix       : 设置前缀路径（默认是：/usr/local/Cellar/nginx/1.2.6/）</div><div class="line">-c filename     : 设置配置文件（默认是：/usr/local/etc/nginx/nginx.conf）</div><div class="line">-g directives   : 设置配置文件外的全局指令</div></pre></td></tr></table></figure>
<h2 id="nginx-配置"><a href="#nginx-配置" class="headerlink" title="nginx 配置"></a>nginx 配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line">user nginx;</div><div class="line">#启动进程,通常设置成和cpu的数量相等</div><div class="line">worker_processes  4;</div><div class="line"></div><div class="line">#全局错误日志及PID文件</div><div class="line">#error_log  /data/nginx/logs/error.log  warn;</div><div class="line">#error_log  /data/nginx/logs/error.log  notice;</div><div class="line">#error_log  /data/nginx/logs/error.log  info;</div><div class="line"></div><div class="line">#pid        /data/nginx/pid/nginx.pid;</div><div class="line"></div><div class="line">#工作模式及连接数上限</div><div class="line">events &#123;</div><div class="line">   #epoll是多路复用IO(I/O Multiplexing)中的一种方式,</div><div class="line">    #仅用于linux2.6以上内核,可以大大提高nginx的性能</div><div class="line">    use  epoll;</div><div class="line"></div><div class="line">    #单个后台worker process进程的最大并发链接数</div><div class="line">    worker_connections  1024;</div><div class="line"></div><div class="line">    # 并发总数是 worker_processes 和 worker_connections 的乘积</div><div class="line">    # 即 max_clients = worker_processes * worker_connections</div><div class="line">    # 在设置了反向代理的情况下，max_clients = worker_processes * worker_connections / 4  为什么</div><div class="line">    # 为什么上面反向代理要除以4，应该说是一个经验值</div><div class="line">    # 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 = 32000</div><div class="line">    # worker_connections 值的设置跟物理内存大小有关</div><div class="line">    # 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数</div><div class="line">    # 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右</div><div class="line">    # 我们来看看360M内存的VPS可以打开的文件句柄数是多少：</div><div class="line">    # $ cat /proc/sys/fs/file-max</div><div class="line">    # 输出 34336</div><div class="line">    # 32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内</div><div class="line">    # 所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置</div><div class="line">    # 使得并发总数小于操作系统可以打开的最大文件数目</div><div class="line">    # 其实质也就是根据主机的物理CPU和内存进行配置</div><div class="line">    # 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。</div><div class="line">    # ulimit -SHn 65535</div><div class="line">&#125;</div><div class="line"></div><div class="line">http &#123;</div><div class="line">    #设定mime类型,类型由mime.type文件定义</div><div class="line">    include    mime.types;</div><div class="line">    default_type  application/octet-stream;</div><div class="line">    #设定日志格式</div><div class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</div><div class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</div><div class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</div><div class="line">    access_log  logs/access.log  main;</div><div class="line"></div><div class="line">    #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，</div><div class="line">    #对于普通应用，必须设为 on,</div><div class="line">    #如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，</div><div class="line">    #以平衡磁盘与网络I/O处理速度，降低系统的uptime.</div><div class="line">    sendfile    on;</div><div class="line">    #tcp_nopush    on;</div><div class="line"></div><div class="line">    #连接超时时间</div><div class="line">    #keepalive_timeout  0;</div><div class="line">    keepalive_timeout  65;</div><div class="line">    tcp_nodelay    on;</div><div class="line"></div><div class="line">    #开启gzip压缩</div><div class="line">    gzip  on;</div><div class="line">    gzip_disable &quot;MSIE [1-6].&quot;;</div><div class="line"></div><div class="line">    #设定请求缓冲</div><div class="line">    client_header_buffer_size    128k;</div><div class="line">    large_client_header_buffers  4 128k;</div><div class="line"></div><div class="line">    #设定虚拟主机配置</div><div class="line">    server &#123;</div><div class="line">        #侦听80端口</div><div class="line">        listen    80;</div><div class="line">        #定义使用 www.nginx.cn访问</div><div class="line">        server_name  www.nginx.cn;</div><div class="line"></div><div class="line">        #定义服务器的默认网站根目录位置</div><div class="line">        root html;</div><div class="line"></div><div class="line">        #设定本虚拟主机的访问日志</div><div class="line">        access_log  logs/nginx.access.log  main;</div><div class="line"></div><div class="line">        #默认请求</div><div class="line">        location / &#123;</div><div class="line"></div><div class="line">            #定义首页索引文件的名称</div><div class="line">            index index.php index.html index.htm;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        # 定义错误提示页面</div><div class="line">        error_page  500 502 503 504 /50x.html;</div><div class="line">        location = /50x.html &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        #静态文件，nginx自己处理</div><div class="line">        location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123;</div><div class="line">            #过期30天，静态文件不怎么更新，过期可以设大一点，</div><div class="line">            #如果频繁更新，则可以设置得小一点。</div><div class="line">            expires 30d;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.</div><div class="line">        location ~ .php$ &#123;</div><div class="line">            fastcgi_pass 127.0.0.1:9000;</div><div class="line">            fastcgi_index index.php;</div><div class="line">            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</div><div class="line">            include fastcgi_params;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        #禁止访问 .htxxx 文件</div><div class="line">            location ~ /.ht &#123;</div><div class="line">            deny all;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>nginx <code>502</code>错误,而通过服务器地址:原始端口号(8080)可以访问<br>查看<code>/var/log/nginx/error.log</code><br>显示为 <code>failed (13: Permission denied)</code><br>命令行临时关闭selinux确认是否由此设置引起的 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ getenforce    #查看selinux状态</div><div class="line">$ setenforce 0</div></pre></td></tr></table></figure>
<p>然后测试是否可以访问如果可以则证明是<code>selinux</code>的问题，于是先关掉s<code>elinux</code></p>
<p><strong>nginx拒绝或允许指定IP,是使用模块HTTP访问控制模块（HTTP Access）.</strong></p>
<p>控制规则按照声明的顺序进行检查，首条匹配IP的访问规则将被启用。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">  deny    192.168.1.1;</div><div class="line">  allow   192.168.1.0/24;</div><div class="line">  allow   10.1.1.0/16;</div><div class="line">  deny    all;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的例子中仅允许<code>192.168.1.0/24</code>和<code>10.1.1.0/16</code>网络段访问这个<code>location</code>字段，但<code>192.168.1.1</code>是个例外。<br>注意规则的匹配顺序，如果你使用过apache你可能会认为你可以随意控制规则的顺序并且他们能够正常的工作，但实际上不行。</p>
<p>下面的这个例子将拒绝掉所有的连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">  #这里将永远输出403错误。</div><div class="line">  deny all;</div><div class="line">  #这些指令不会被启用，因为到达的连接在第一条已经被拒绝</div><div class="line">  deny    192.168.1.1;</div><div class="line">  allow   192.168.1.0/24;</div><div class="line">  allow   10.1.1.0/1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/nginx.jpg&quot; alt=&quot;nginx&quot; title=&quot;nginx&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;nginx安装&quot;&gt;&lt;a href=&quot;#nginx安装&quot; class=&quot;headerlink&quot; title=&quot;nginx安装&quot;&gt;&lt;/a&gt;nginx安装&lt;/h2&gt;&lt;p&gt;第一步，在&lt;code&gt;/etc/yum.repos.d/&lt;/code&gt;目录下创建一个源配置文件&lt;code&gt;nginx.repo&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;cd /etc/yum.repos.d/  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;vim nginx.repo&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;填写如下内容：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[nginx]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;name=nginx repo  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;baseurl=http://nginx.org/packages/centos/$releasever/$basearch/  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;gpgcheck=0  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;enabled=1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="nginx" scheme="http://jet-han.oschina.io/categories/nginx/"/>
    
    
      <category term="linux" scheme="http://jet-han.oschina.io/tags/linux/"/>
    
      <category term="nginx" scheme="http://jet-han.oschina.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>solr安装与使用</title>
    <link href="http://jet-han.oschina.io/2017/07/16/solr%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://jet-han.oschina.io/2017/07/16/solr安装与使用/</id>
    <published>2017-07-16T09:11:01.000Z</published>
    <updated>2017-09-08T08:07:23.284Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://jet-han.oschina.io/img/icons/bigdata.jpg" alt="bigdata" title="bigdata"></p>
<h2 id="solr-tomcat单节点"><a href="#solr-tomcat单节点" class="headerlink" title="solr+tomcat单节点"></a>solr+tomcat单节点</h2><p>Solr6部署在Tomcat8环境下</p>
<p><a href="http://archive.apache.org/dist/lucene/solr/6.0.0/" target="_blank" rel="external">solr下载</a></p>
<p>在之前版本的Solr安装包中，存在solr.war文件，但是Solr6已经没有这个war包了，它已经被解压到了.\solr-6.0.0\server\solr-webapp文件夹下，将该文件夹复制到.\apache-tomcat-8.5.5\webapps下，并将其重命名为solr。   </p>
<p>日志处理：将Solr安装包中<code>.\solr-6.0.0\server\lib\ext</code>内的5个jar包复制到<code>.\apache-tomcat-8.5.5\webapps\solr\WEB-INF\lib</code>下。将<code>.\solr-6.0.0\server\resources</code>下的<code>log4j.properties</code>文件复制到<code>.\apache-tomcat-8.5.5\webapps\solr\WEB-INF\classes</code>中，这里的<code>classes</code>目录需要自己新建。<code>log4j.properties</code>文件中有一行<code>log4j.appender.file.File=${solr.log}/solr.log</code>指定log文件的存放路径，可以指定到特定的目录。<br><a id="more"></a><br>配置<code>solr_home</code>：在磁盘任意位置新建目录，取名<code>solr_home</code>,把<code>.\solr-6.0.0\server\solr</code>下的整个solr文件夹复制到<code>solr_home</code>，编辑<code>.\apache-tomcat-8.5.5\webapps\solr\WEB-INF</code>下的<code>web.xml</code>文件。<br>将<code>web.xml</code>文件注释去掉，<code>&lt;env-entry-value&gt;</code>中填刚才新建的<code>solr_home</code>路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;env-entry&gt;</div><div class="line">   &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt;</div><div class="line">   &lt;env-entry-value&gt;/home/jet/workspace/github/bigdata/solr/solr_home&lt;/env-entry-value&gt;</div><div class="line">   &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;</div><div class="line">&lt;/env-entry&gt;</div></pre></td></tr></table></figure>
<p>这个<code>solr_home</code>里面的内容是复制<code>.\solr-6.0.0\server\solr\</code>下的内容，然后在该目录下新建文件夹<code>core0</code>，把 <code>.\solr-6.0.0\server\solr\configsets\basic_configs\</code>下的所有文件复制进来。 </p>
<p>运行的话，直接双击<code>startup.sh</code></p>
<p>访问<code>http://localhost:8080/solr/index.html</code>，可以看到<code>solr</code>管理界面，但是我们的sore还是空的，需要手动创建。在管理界面，点击<code>No cores available</code>选项，在弹出的窗口刚才新建的文件夹的名字。<br><code>Add core</code><br>这样，最简单的Solr就搭建完成了。</p>
<p>【注意事项】<br>solr6以上必须要求jdk1.8以上版本，不然访问会报404,而且tomcat日志不会报任何错误信息<br>且访问路径是<code>localhost:8080/solr/index.html</code></p>
<h2 id="solrcloud6"><a href="#solrcloud6" class="headerlink" title="solrcloud6"></a>solrcloud6</h2><h3 id="配置hosts"><a href="#配置hosts" class="headerlink" title="配置hosts"></a>配置hosts</h3><p>192.168.40.200 jet.solr.com<br>192.168.40.2 hadoop02.hadoop.com<br>192.168.40.3 hadoop03.hadoop.com</p>
<h3 id="关闭防火墙-可以只执行第二步：推荐"><a href="#关闭防火墙-可以只执行第二步：推荐" class="headerlink" title="关闭防火墙(可以只执行第二步：推荐)"></a>关闭防火墙(可以只执行第二步：推荐)</h3><p>1) 永久关闭防火墙: <code>vi /etc/selinux/config</code>，将其中的SELinux设置：<code>SELINUX=disabled</code></p>
<p>2) 关闭防火墙 : <code>systemctl disable firewalld.service</code> #禁用</p>
<p>3) 关闭packagekit: <code>vi /etc/yum/pluginconf.d/langpacks.conf</code>，将<code>enabled</code>设为 <code>0</code></p>
<h3 id="配置tomcat（各个solr节点一样）"><a href="#配置tomcat（各个solr节点一样）" class="headerlink" title="配置tomcat（各个solr节点一样）"></a>配置tomcat（各个solr节点一样）</h3><p><strong>启动与关闭</strong></p>
<p><strong>启动：</strong>到bin目录下<code>./startup.sh</code></p>
<p><strong>验证：</strong><code>http://192.168.40.200:8080</code></p>
<p><strong>关闭：</strong>到bin目录下<code>./shutdown.sh</code></p>
<h3 id="配置zookeeper（各个zookeeper节点上面）"><a href="#配置zookeeper（各个zookeeper节点上面）" class="headerlink" title="配置zookeeper（各个zookeeper节点上面）"></a>配置zookeeper（各个zookeeper节点上面）</h3><p><strong>(1)  解压</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zxvf zookeeper-3.4.10.tar.gz</div></pre></td></tr></table></figure>
<p><strong>(2)创建data和logs目录</strong></p>
<p>创建目录并赋于写权限</p>
<p>指定<code>zookeeper</code>的数据存放目录<code>/hadoop/zookeeper/data</code>和日志目录<code>/hadoop/zookeeper/logs</code></p>
<p><strong>(3)拷贝zookeeper</strong><br>配制文件<code>zoo_sample.cfg</code>，文件在<code>conf</code>目录下</p>
<p>拷贝<code>zookeeper</code>配制文件<code>zoo_sample.cfg</code>并重命名<code>zoo.cfg</code></p>
<p><strong>(4)  修改zoo.cfg</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#</div><div class="line">#</div><div class="line"># Licensed to the Apache Software Foundation (ASF) under one</div><div class="line"># or more contributor license agreements.  See the NOTICE file</div><div class="line"># distributed with this work for additional information</div><div class="line"># regarding copyright ownership.  The ASF licenses this file</div><div class="line"># to you under the Apache License, Version 2.0 (the</div><div class="line"># &quot;License&quot;); you may not use this file except in compliance</div><div class="line"># with the License.  You may obtain a copy of the License at</div><div class="line">#</div><div class="line">#   http://www.apache.org/licenses/LICENSE-2.0</div><div class="line">#</div><div class="line"># Unless required by applicable law or agreed to in writing,</div><div class="line"># software distributed under the License is distributed on an</div><div class="line"># &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</div><div class="line"># KIND, either express or implied.  See the License for the</div><div class="line"># specific language governing permissions and limitations</div><div class="line"># under the License.</div><div class="line">#</div><div class="line">#</div><div class="line">#</div><div class="line"></div><div class="line">clientPort=2181</div><div class="line">initLimit=10</div><div class="line">autopurge.purgeInterval=24</div><div class="line">syncLimit=5</div><div class="line">tickTime=3000</div><div class="line">dataDir=/hadoop/zookeeper/data #上面创建的数据目录</div><div class="line">dataLogDir=/hadoop/zookeeper/logs #上面创建的日志目录</div><div class="line">autopurge.snapRetainCount=30</div><div class="line">server.1=hadoop02.hadoop.com:2888:3888</div><div class="line">server.2=hadoop03.hadoop.com:2888:3888</div></pre></td></tr></table></figure>
<p><strong>(5)进入data</strong><br>文件夹建立对应的myid文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /hadoop/zookeeper/data/myid</div></pre></td></tr></table></figure>
<p><strong>(6)拷贝zookeeper</strong></p>
<p>文件夹到其他机器,进行相同配置</p>
<h3 id="配置solr（各个solr节点一样）"><a href="#配置solr（各个solr节点一样）" class="headerlink" title="配置solr（各个solr节点一样）"></a>配置solr（各个solr节点一样）</h3><p><a href="#solr-tomcat单节点">和上面单节点一样</a></p>
<h3 id="配置solr服务"><a href="#配置solr服务" class="headerlink" title="配置solr服务"></a>配置solr服务</h3><p><strong>(1) 在solr下，上传相关信息至zookeeper</strong></p>
<p>在<code>/home/jet/workspace/github/bigdata/solr/solr-6.0.0/server/scripts/cloud-scripts</code>目录下执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./zkcli.sh -zkhost 192.168.40.2:2181,192.168.40.3:2181 -cmd upconfig -confdir /home/jet/workspace/github/bigdata/solr/solr_home/core0/conf -confname solrconfig.xml</div></pre></td></tr></table></figure>
<p><strong>(2) 每一台solr和zookeeper关联</strong></p>
<p>修改每一台solr的tomcat 的 bin目录下catalina.sh文件中加入DzkHost指定zookeeper服务器地址：</p>
<p>在JAVA_OPTS添加zookeepre地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">JAVA_OPTS=&quot;-DzkHost=192.168.40.2:2181,192.168.40.3:2181&quot;</div></pre></td></tr></table></figure>
<p><strong>(3) 启动每一台solr服务器</strong><br>进入对应tomcat bin目录启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sh startup.sh</div></pre></td></tr></table></figure>
<p><strong>(4) 查看tomcat日志</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tail -fn 100 catalina.out</div></pre></td></tr></table></figure>
<p>如下信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">10035261 INFO  (zkCallback-4-thread-34-processing-n:192.168.40.200:8080_solr-EventThread) [   ] o.a.s.c.c.ConnectionManager Watcher org.apache.solr.common.cloud.ConnectionManager@6edf2d5f name:ZooKeeperConnection Watcher:192.168.40.2:2181,192.168.40.3:2181 got event WatchedEvent state:SyncConnected type:None path:null path:null type:None</div></pre></td></tr></table></figure>
<p><strong>(5) 修改solr启动端口（各个节点的配置一样）</strong></p>
<p>在solrhome下，有一个solr.xml文件，修改其中的内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$&#123;host:192.168.40.200&#125;</div><div class="line"></div><div class="line">$&#123;jetty.port:8080&#125;</div></pre></td></tr></table></figure>
<p>然后访问地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://192.168.40.200:8080/solr/index.html#/</div></pre></td></tr></table></figure>
<p>如下<br><img src="http://jet-han.oschina.io/img/ambari/solr.png" alt="solr" title="solr"></p>
<h2 id="solr全文检索原理"><a href="#solr全文检索原理" class="headerlink" title="solr全文检索原理"></a>solr全文检索原理</h2><p><a href="http://www.cnblogs.com/guochunguang/articles/3641008.html" target="_blank" rel="external">solr全文检索实现原理</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://jet-han.oschina.io/img/icons/bigdata.jpg&quot; alt=&quot;bigdata&quot; title=&quot;bigdata&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;solr-tomcat单节点&quot;&gt;&lt;a href=&quot;#solr-tomcat单节点&quot; class=&quot;headerlink&quot; title=&quot;solr+tomcat单节点&quot;&gt;&lt;/a&gt;solr+tomcat单节点&lt;/h2&gt;&lt;p&gt;Solr6部署在Tomcat8环境下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://archive.apache.org/dist/lucene/solr/6.0.0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;solr下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在之前版本的Solr安装包中，存在solr.war文件，但是Solr6已经没有这个war包了，它已经被解压到了.\solr-6.0.0\server\solr-webapp文件夹下，将该文件夹复制到.\apache-tomcat-8.5.5\webapps下，并将其重命名为solr。   &lt;/p&gt;
&lt;p&gt;日志处理：将Solr安装包中&lt;code&gt;.\solr-6.0.0\server\lib\ext&lt;/code&gt;内的5个jar包复制到&lt;code&gt;.\apache-tomcat-8.5.5\webapps\solr\WEB-INF\lib&lt;/code&gt;下。将&lt;code&gt;.\solr-6.0.0\server\resources&lt;/code&gt;下的&lt;code&gt;log4j.properties&lt;/code&gt;文件复制到&lt;code&gt;.\apache-tomcat-8.5.5\webapps\solr\WEB-INF\classes&lt;/code&gt;中，这里的&lt;code&gt;classes&lt;/code&gt;目录需要自己新建。&lt;code&gt;log4j.properties&lt;/code&gt;文件中有一行&lt;code&gt;log4j.appender.file.File=${solr.log}/solr.log&lt;/code&gt;指定log文件的存放路径，可以指定到特定的目录。&lt;br&gt;
    
    </summary>
    
      <category term="bigdata" scheme="http://jet-han.oschina.io/categories/bigdata/"/>
    
    
      <category term="solr" scheme="http://jet-han.oschina.io/tags/solr/"/>
    
      <category term="bigdata" scheme="http://jet-han.oschina.io/tags/bigdata/"/>
    
      <category term="搜索引擎" scheme="http://jet-han.oschina.io/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
</feed>
